<!DOCTYPE html><html lang="zh-CN" data-theme="light"> <head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>FreeRTOS | 会飞的鱼</title><meta name="author" content="6+1"><meta name="copyright" content="6+1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="单片机操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="FreeRTOS">
<meta property="og:url" content="http://example.com/2023/11/18/FreeRTOS/index.html">
<meta property="og:site_name" content="会飞的鱼">
<meta property="og:description" content="单片机操作系统">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/num11.webp">
<meta property="article:published_time" content="2023-11-18T13:15:31.000Z">
<meta property="article:modified_time" content="2023-12-10T12:42:07.611Z">
<meta property="article:author" content="6+1">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/num11.webp"><link rel="shortcut icon" href="/img/tubiao.webp"><link rel="canonical" href="http://example.com/2023/11/18/FreeRTOS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FreeRTOS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-10 20:42:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/TX1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-MBEfenggechangyongtubiao-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-MBEfenggechangyongtubiao-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlecidai">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingyuan-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-aixin"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/num11.webp')"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="会飞的鱼"><span class="site-name">会飞的鱼</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-MBEfenggechangyongtubiao-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-MBEfenggechangyongtubiao-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlecidai">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingyuan-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-aixin"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FreeRTOS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表</span><time class="post-meta-date-created" datetime="2023-11-18T13:15:31.000Z" title="发表 2023-11-18 21:15:31">2023-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新</span><time class="post-meta-date-updated" datetime="2023-12-10T12:42:07.611Z" title="更新 2023-12-10 20:42:07">2023-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/FreeRTOS/">FreeRTOS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数:</span><span class="word-count">4.6w</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><code>注</code>：<strong>此教程代码笔记基于硬件家园，开发板是STM32ZET6。参考代码，请注意板子引脚</strong></p>
<hr>
<h1 id="系统简介与移植"><a href="#系统简介与移植" class="headerlink" title="系统简介与移植"></a>系统简介与移植</h1><h2 id="FreeRTOS简介"><a href="#FreeRTOS简介" class="headerlink" title="FreeRTOS简介"></a>FreeRTOS简介</h2><h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统是为了区别于通用的计算机操作系统，人们把嵌入到对象体系中，为实现对象体系智能化控制的计算机操作系统，称作嵌入式计算机操作系统，简称嵌入式操作系统。</p>
<p>嵌入式操作系统分类：</p>
<blockquote>
<p>① 按对外部事件的响应能力来分类，嵌入式操作系统分实时操作系统和分时操作系统。如果操作系统能及时的响应外部事件请求，并能控制所有实时设备和实时任务协调运行，且能在一个规定的时间内完成对事件的处理，那么这种系统就称为实时操作系统。如果操作系统按时间片轮转完成各个任务，任务没有优先级，这种系统就称为分时操作系统。</p>
<p>② 按时间的严格程度来分，实时操作系统又分为强实时操作系统和弱实时操作系统。系统必须在极其严格的时间内完成的任务叫做硬实时操作系统，比如飞机系统；如果不是很严格的话就是弱实时操作系统，比如信息采集系统。</p>
</blockquote>
<h3 id="FreeRTOS实时操作系统"><a href="#FreeRTOS实时操作系统" class="headerlink" title="FreeRTOS实时操作系统"></a>FreeRTOS实时操作系统</h3><p>FreeRTOS是一款开源免费的实时操作系统，商业使用的话不需要用户公开源代码，也不存在任何版权问题，是当前小型嵌入式操作系统市场使用率最高的。</p>
<p>FreeRTOS 的移植比较简单，只需要用户添加需要的源码文件，不需要做任何的底层工作，再添加几个宏定义即可，详情可以看第四节的手动移植FreeRTOS 操作系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_%201.webp" alt=""></p>
<h3 id="为什么选择FreeRTOS操作系统"><a href="#为什么选择FreeRTOS操作系统" class="headerlink" title="为什么选择FreeRTOS操作系统"></a>为什么选择FreeRTOS操作系统</h3><blockquote>
<p>①  开源免费；</p>
<p>②  简单易学；</p>
<p>③ 在RTOS中占有率最高；</p>
<p>④ FreeRTOS被移植到了很多不同的微处理器，比如STM32，极为方便；</p>
<p>⑤ 许多半导体厂商产品的SDK采用FreeRTOS，比如WIFI与蓝牙模块；</p>
<p>⑥ 许多软件厂商使用FreeRTOS作为本公司软件的操作系统，比如TouchGFX；</p>
</blockquote>
<h3 id="FreeRTOS特点"><a href="#FreeRTOS特点" class="headerlink" title="FreeRTOS特点"></a>FreeRTOS特点</h3><blockquote>
<p> ① 支持抢占式调度，合作式调度和时间片调度；</p>
<p>② 支持 35 种系统架构；</p>
<p>③ 设计的简单易用，典型的内核使用大小在 4k-9k；</p>
<p>④ 移植非常简单，代码主要用 C 编写；</p>
<p>⑤ 支持消息队列、二值信号量、计数信号量、递归信号量和互斥信号量、事件通知，可用于任务与任务间的消息传递和同步，任务与中断间的消息传递和同步；</p>
<p>⑥ 提供丰富的，配置好的工程例子；</p>
<p>⑦ 多个任务可以分配相同优先级，即支持时间片调度；</p>
<p>⑧  高效的软件定时器；</p>
<p>⑨ 强大的跟踪执行函数；</p>
<p>⑩ 任务优先级数量不限；</p>
<p>⑩① 任务的数量不限；</p>
<p>⑩② 开源免费  </p>
</blockquote>
<h2 id="裸机系统与多任务系统"><a href="#裸机系统与多任务系统" class="headerlink" title="裸机系统与多任务系统"></a>裸机系统与多任务系统</h2><h3 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h3><p>裸机编程时，先初始化相关的硬件，然后让主程序在一个死循环里面不断的循环，顺序地处理各种事件。 对于紧急事件，采用中断功能进行快速响应。</p>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//功能函数1</span></span><br><span class="line">        <span class="built_in">Fun_1</span>();</span><br><span class="line">        <span class="comment">//功能函数2</span></span><br><span class="line">        <span class="built_in">Fun_2</span>();</span><br><span class="line">        。。。        </span><br><span class="line">        <span class="comment">//功能函数n</span></span><br><span class="line">        <span class="built_in">Fun_n</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//中断函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>建议：</strong>对于工业与消费级产品，大部分采用裸机系统。采用硬件家园主推的面向对象编程思维和模块化编程技术，规范程序架构，采用结构体封装外设，程序方便阅读、修改与移植，提高开发效率的同时，降低维护程序的难度。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_2%20.webp" alt=""></p>
<h4 id="多任务系统"><a href="#多任务系统" class="headerlink" title="多任务系统"></a>多任务系统</h4><p>相比于裸机系统，多任务系统的事件处理是在任务中完成的，对于紧急事件，同样采用中断功能进行快速响应。</p>
<p>多任务系统通常包含多个任务，彼此独立，方便编程。 同时，任务具有优先级，高优先级任务可以打断低优先级任务，系统的实时性进一步得到提高。</p>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FreeRTOS初始化</span></span><br><span class="line">    <span class="built_in">FreeRTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FreeRTOS启动，开始任务调度，不再返回</span></span><br><span class="line">    <span class="built_in">FreeRTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//中断函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>引入操作系统后，在编程时不需要精心设计程序执行流，任务间不存在干扰，编程反而变得简单了。 </p>
<p>当然，系统需要占用一定的RAM与FLASH资源，如今的单片机，RAM与FLASH越来越大，为采用操作系统编程提供了便利。</p>
<h4 id="裸机系统与多任务系统对比"><a href="#裸机系统与多任务系统对比" class="headerlink" title="裸机系统与多任务系统对比"></a>裸机系统与多任务系统对比</h4><p>裸机系统与多任务系统各自具有优势，在各自的领域都具有应用价值，不能简单的说孰优孰劣，掌握后，根据产品功能合理选择。</p>
<p>裸机系统：工业产品与消费级用的非常多，特别是低端的单片机，必须采用裸机系统，采用模块化技术，编程也可以很方便</p>
<p>多任务系统：适合单片机高端，功能复杂的产品，多任务管理，编程简单很多。</p>
<p>两者对比：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_3.webp" alt="图片"></p>
<h2 id="初学FreeRTOS准备工作"><a href="#初学FreeRTOS准备工作" class="headerlink" title="初学FreeRTOS准备工作"></a>初学FreeRTOS准备工作</h2><p>搭建开发环境</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_4.webp" alt=""></p>
<p>下载安装STM32CubeMX和Keil</p>
<h2 id="手动移植FreeRTOS"><a href="#手动移植FreeRTOS" class="headerlink" title="手动移植FreeRTOS"></a>手动移植FreeRTOS</h2><p><strong>第一步：</strong>官网下载或qq群下载FreeRTOS源码</p>
<p>官网网址：<a target="_blank" rel="noopener" href="https://www.freertos.org">https://www.freertos.org</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_18.webp" alt="图片"></p>
<p><strong>第二步：</strong>准备基础工程 - 使用HAL05 - LED流水灯，延时时钟基准由SysTick改到TIM2，删除主循环内的代码</p>
<p><strong>原因：</strong>FreeRTOS操作系统使用SysTick作为基准时钟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_5.webp" alt="图片"></p>
<p><strong>第三步：</strong>将FreeROS源码添加至工程中，设置头文件路径，编译工程</p>
<p>① 将FreeRTOS源码复制到工程中， 另外，将portable与RVDS文件夹多余的文件删除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_6.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_7.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_8.webp" alt="图片"></p>
<p>② Keil工程新建2个Groups - FreeRTOS/Source与FreeRTOS/Port，同时添加相应的文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_9.webp" alt="图片"></p>
<p>③ 添加头文件路径</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_10.webp" alt="图片"></p>
<p>④ 编译工程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_11.webp" alt="图片"></p>
<p><strong>第四步：</strong>将FreeRTOSConfig.h文件(位于Demo - CORTEX_STM32F103_Keil工程中)添加至工程的MyApplication文件内， 方便打开与修改，同时添加至MyApplication文件组内，再次编译</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_12.webp" alt="图片"></p>
<p><strong>第五步：</strong>修改FreeRTOSConfig.h文件，是stm32f1xx_it.c文件，编译ok</p>
<p>① 修改FreeRTOSConfig.h文件，并编译</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_13.webp" alt="图片"></p>
<p>② 注释掉stm32f1xx_it.c文件的SVC，PendSV，Systick中断函数，编译ok</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_14.webp" alt="图片"></p>
<p><strong>第六步：</strong>工程添加MyTask.c文件，里面预先写好了3个任务，同时MyApplicatin.h头文件添加FreeRTOS与MyTask的头文件，编译ok</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_15.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_16.webp" alt="图片"></p>
<p>第七步：在main.c文件调用任务创建函数与系统调度函数，编译ok。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_17.webp" alt="图片"></p>
<p>第八步：将程序下载至STM32物联网实战板，正常运行。</p>
<p>LED1 - 间隔100ms 闪烁</p>
<p>LED2 - 间隔500ms 闪烁</p>
<p>LED3 - 间隔1000ms闪烁</p>
<p><strong>至此，手动移植完成。</strong></p>
<h2 id="STM32CubeMX生成FreeRTOS"><a href="#STM32CubeMX生成FreeRTOS" class="headerlink" title="STM32CubeMX生成FreeRTOS"></a>STM32CubeMX生成FreeRTOS</h2><p><strong>第二步：</strong>准备基础工程 - 使用HAL05 - LED流水灯，延时时钟基准由<code>SysTick</code>改到<code>TIM2</code></p>
<p><strong>原因：</strong>FreeRTOS操作系统使用<code>SysTick</code>作为基准时钟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_5.webp" alt="图片"></p>
<p><strong>第三步：</strong>左侧选择Middleware选项卡，点击FERRRTOS，Interface选择CMSIS_V1，配置参数默认即可。</p>
<p>说明：</p>
<p>Disable   - 禁用FreeRTOS</p>
<p>CMSIS_V1 - CMSIS-RTOS版本为V1.02，一般选择这个</p>
<p>CMSIS_V2 - CMSIS-RTOS版本为V2.00，兼容更多的CPU架构，但代码量更大</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_20.webp" alt="图片"></p>
<p><strong>第四步：</strong>选择Tasks and Queue，修改默认任务<code>defaultTask</code>(双击进入编辑任务界面)，并额外添加LED2与LED3任务。</p>
<p>说明：</p>
<p>编辑任务时，软件要求不同位置不能使用同样的名称，因为任务名称设定为LED1_Task,任务函数设定为LED1</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_21.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_22.webp" alt="图片"></p>
<p><strong>第四步：</strong>保存工程，并生产代码，删除主循环内的代码，编译<code>keil</code>工程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_23.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_24.webp" alt="图片"></p>
<p><strong>第五步：</strong>打开<code>freertos.c</code>文件，在LED1、LED2、LED3函数内添加代码，编译ok</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_25.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_26.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_27.webp" alt="图片"></p>
<p><strong>第六步：</strong>将程序下载至STM32物联网实战板，正常运行。</p>
<p>LED1 - 间隔100ms 闪烁</p>
<p>LED2 - 间隔500ms 闪烁</p>
<p>LED3 - 间隔1000ms闪烁</p>
<hr>
<h1 id="启动流程、编码风格与调试方法"><a href="#启动流程、编码风格与调试方法" class="headerlink" title="启动流程、编码风格与调试方法"></a>启动流程、编码风格与调试方法</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>RTOS主要有两种比较流行的启动方式，下面会通过伪代码讲解两种启动方式的区别，然后看看STM32cubeMX集成的FreeRTOS采用哪种启动方式。</p>
<p>方法一：在main函数中将硬件初始化、RTOS系统初始化，同时创建所有任务，再启动RTOS调度器。</p>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTOS初始化</span></span><br><span class="line">    <span class="built_in">RTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//创建任务n</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//RTOS启动，开始任务调度，不再返回</span></span><br><span class="line">   <span class="built_in">RTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法二：在main函数中将硬件初始化、RTOS系统初始化，只创建一个启动任务，再启动RTOS调度器。 之后，在启动任务中创建各种应用任务，当所有任务创建完成，启动任务把自己删除。</p>
<p><strong>伪代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTOS初始化</span></span><br><span class="line">    <span class="built_in">RTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(AppTaskCreate);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//RTOS启动，开始任务调度，不再返回</span></span><br><span class="line">   <span class="built_in">RTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始任务，在里面创建各种应用任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppTaskCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//创建任务n</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建完应用任务，删除自身，释放内存</span></span><br><span class="line">   <span class="built_in">RTOS_TaskDelate</span>(AppTaskCreate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>STM32cubeMX集成的FreeRTOS如下图，采用的是第一种启动方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_1.webp" alt="image-20231119203004873"></p>
<h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>如下图，FreeRTOS使用的数据类型虽然都是标准C的数据类型，但都进行了重定义，取了个新名字。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_2.webp" alt="image-20231119203315563"></p>
<p>需要注意的是，<code>char</code>数据类型可以通过keil指定了有符号或者无符号，默认为无符号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_3.webp" alt="image-20231119203434375"></p>
<h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>在FreeRTOS中，定义变量时，把变量的类型作为前缀，方便用户通过变量即可知道变量的类型。  </p>
<p><code>char</code>变量的前缀是<code>c</code>，<code>short</code>变量的前缀是<code>s</code>，<code>long</code>变量的前缀是<code>l</code>，其它比如结构体、任务句柄等是<code>x</code>； </p>
<p>如果是无符号类型的，前缀再加<code>u</code>;</p>
<p>如果是指针变量，前缀再加<code>p</code>。</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>   cTemp</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>    ucTemp</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*   pucTemp</span><br></pre></td></tr></table></figure>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>函数名包含了函数返回值的类型、函数所在的文件名以及函数的功能，如果是私有的函数，还会加<code>prv</code>前缀。   这种命名方式方便寻找函数定义并了解函数作用，值得借鉴。</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">x <span class="title">TaskCreate</span><span class="params">()</span> <span class="comment">//函数的返回值为任务句柄，在Task.c中定义，作用是创建任务；</span></span></span><br><span class="line"><span class="function">v <span class="title">TaskPrioritySet</span><span class="params">()</span> <span class="comment">//函数的返回值为void，在Task.c中定义，作用是设置优先级；</span></span></span><br></pre></td></tr></table></figure>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>在FreeRTOS中，宏用大写字母表示，并配有小写字母作为前缀， 前缀用于指示该宏在哪个头文件定义。</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">portMAX_DELAY,  <span class="comment">//位于portable.h；</span></span><br><span class="line">configUSE_PREEMPTION, <span class="comment">//位于FreeRTOSConfig.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，有几个通用的宏定义贯穿FreeRTOS的整个代码，都是表示0与1的宏，如下：</span></span><br><span class="line">pdTRUE    <span class="number">1</span></span><br><span class="line">pdFALSE   <span class="number">0</span></span><br><span class="line">pdPASS    <span class="number">1</span></span><br><span class="line">pdFAIL     <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><p>本节为大家介绍FreeRTOS的调试方法，主要是获取任务的执行情况，通过串口打印出来，方便后续的系统配置与优化工程，非常实用。</p>
<p>1、串口打印调试说明</p>
<p>为了了解任务的运行状态、任务栈的使用情况以及各个任务的 CPU 使用率，需要用到官方提供的两个函数 <code>vTaskList</code>和 <code>vTaskGetRunTimeStats</code>。</p>
<p>用户可以通过这两个函数获得任务信息，然后通过串口将其打印出来，当然，也可以通过任何其它方式将其显示出来。后续课程统一采用串口打印的方式显示任务信息。</p>
<p>2、定时器</p>
<p>为了获取 FreeRTOS 的任务信息，需要创建一个定时器，这个定时器的时间基准精度要高于系统时钟节拍，达到系统时钟节拍的10 ~ 20倍，这样得到的任务信息才准确。</p>
<p><strong>Note：</strong></p>
<blockquote>
<p>① <code>这种调试方式仅限调试、测试，实际项目中不要使用，因为这种测试方式比较影响系统实时性</code></p>
<p>② FreeRTOS 的系统内核没有对计数时间做溢出保护。 比如定时器周期为50us，最大支持计数时间：2^32 * 50us / 3600s =59.6 分钟。运行时间超过了 59.6 分钟将不准确。</p>
</blockquote>
<p>3、具体实现</p>
<p>学习FreeRTOS操作系统的目的是利用多任务功能更好的管理产品外设，因此调试代码将在STM32物联网实战项目HAL裸机开发整合代码工程上启用FreeRTOS操作系统，因为最后一讲包含了全部外设驱动函数，方便后续的调用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_4.webp" alt="图片"></p>
<p>①、处理工程代码 - 删除裸机框架的代码(main.c，MyInit.c,callback.c与System.c文件)，系统运行指示灯关闭；</p>
<p>②、STM32CubeMX配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_5.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_6.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_7.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_8.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_9.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_10.webp" alt="图片"></p>
<p>③、完善keil工程代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_11.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_12.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_13.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_14.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_15.webp" alt="图片"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<p> 开启定时器3，去main函数里写定时器的回调函数。我忘记写回调函数一直显示不出来运行状态。</p>
</blockquote>
<hr>
<h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="系统配置说明"><a href="#系统配置说明" class="headerlink" title="系统配置说明"></a>系统配置说明</h2><p>实际应用FreeRTOS的时候，我们需要根据产品需求配置FreeRTOS，满足产品需求的同时，发挥FreeRTOS的最佳性能。</p>
<p>FreeRTOS的系统配置文件为<code>FreeRTOSConfig.h</code>，在此配置文件中可完成FreeRTOS的裁剪与配置。 <strong>初学的话，有个大概了解即可，随着后续的深入学习，再熟练设置每个配置选项。</strong></p>
<p><code>FreeRTOSConfig.h</code> 根据正在构建的应用程序定制 FreeRTOS 内核。因此，它特定于应用程序，而不是 FreeRTOS，并且应该位于应用程序目录中，而不是位于 FreeRTOS 内核源代码目录中。</p>
<p>另外，大部分配置选项在FreeRTOS.h文件中都有默认的配置，在应用时，把需要的配置选项放在<code>FreeRTOSConfig.h</code>文件即可。</p>
<p>关于系统配置，官网也有详细介绍</p>
<p>网址：<a target="_blank" rel="noopener" href="http://www.freertos.org/a00110.html">http://www.freertos.org/a00110.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_1.webp" alt="image-20231119221626682"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_2.webp" alt="image-20231119221646921"></p>
<h2 id="“Config”开始的宏-内核配置"><a href="#“Config”开始的宏-内核配置" class="headerlink" title="“Config”开始的宏 - 内核配置"></a>“Config”开始的宏 - 内核配置</h2><p>STM32cubeMX中的配置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_3.webp" alt="image-20231119221723257"></p>
<p><strong>configUSE_PREEMPTION</strong></p>
<blockquote>
<ul>
<li>配置为 1 </li>
</ul>
<p>使能抢占式调度器</p>
<ul>
<li>配置为 0 </li>
</ul>
<p>使能合作式调度器</p>
</blockquote>
<p><strong>configUSE_PORT_OPTIMISED_TASK_SELECTION</strong></p>
<blockquote>
<p> 此配置用于优化优先级列表中要执行的最高优先级任务的算法。对 CM 内核的移植文件，默认已经在文件 <code>portmacro.h</code> 文件中使能。</p>
<ul>
<li><p>通用方式—-配置为 0： </p>
<p>   所有平台的移植文件都可以配置为 0，因为这是通用方式。 </p>
<p>   纯 C 编写，比专用方式效率低。</p>
<p>   可用的优先级数量不限制。</p>
</li>
<li><p>专用方式—-配置为 1： </p>
<p>  部分平台支持。</p>
<p>  这些平台架构有专用的汇编指令，比如 CLZ（Count Leading Zeros）指令，通过这些指令可以加快算法执行速度。 </p>
<p>  比通用方式高效。</p>
<p>  有最大优先级数限制，通常限制为 32 个。</p>
</li>
</ul>
</blockquote>
<p><strong>configUSE_TICKLESS_IDLE</strong></p>
<blockquote>
<p>此配置用于使能 <code>tickless</code>低功耗模式</p>
<ul>
<li><p>配置为 1</p>
<p>  使能 <code>tickless</code>低功耗模式</p>
</li>
<li><p>配置为 0</p>
<p>  禁能 <code>tickless</code>低功耗模式</p>
</li>
</ul>
</blockquote>
<p><strong>configCPU_CLOCK_HZ</strong></p>
<blockquote>
<p>此参数用于定义 CPU 的主频，单位 Hz</p>
</blockquote>
<p><strong>configTICK_RATE_HZ</strong></p>
<blockquote>
<p>此参数用于定义系统时钟节拍数，单位 Hz，一般取 1000Hz 即可。本教程配套的例子也全部采用这个时钟节拍数。过高的的系统时钟节拍将使得 FreeRTOS 内核运行占用过多的时间，增加系统负荷</p>
</blockquote>
<p><strong>configMAX_PRIORITIES</strong></p>
<blockquote>
<p>此参数用于定义可供用户使用的最大任务优先级数，如果这个定义的是 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5，对于这一点，初学者要特别的注意。 </p>
</blockquote>
<p><strong>configMINIMAL_STACK_SIZE</strong></p>
<blockquote>
<p>此参数用于定义空闲任务的栈空间大小，单位字，即 4 字节。</p>
</blockquote>
<p><strong>configTOTAL_HEAP_SIZE</strong></p>
<blockquote>
<p>定义堆大小，FreeRTOS 内核，用户动态内存申请，任务栈，任务创建，信号量创建，消息队列创建等都需要用这个空间。</p>
</blockquote>
<p><strong>configMAX_TASK_NAME_LEN</strong></p>
<blockquote>
<p>定义任务名最大的字符数，末尾的结束符 ‘\0’也要计算在内。</p>
</blockquote>
<p><strong>configUSE_16_BIT_TICKS</strong></p>
<blockquote>
<p>系统时钟节拍计数使用 <code>TickType_t</code>数据类型定义的。</p>
<p>如果用户使能了宏定义 <code>configUSE_16_BIT_TICKS</code>，那么 <code>TickType_t</code>定义的就是 16 位无符号数，如 果没有使能，那么 <code>TickType_t</code>定义的就是 32 位无符号数。对于 32 位架构的处理器，一定要禁止此宏定义，即设置此宏定义数值为 0 即可。而 16 位无符号数类型主要用于 8 位和 16 位架构的处理器。</p>
</blockquote>
<p><strong>configIDLE_SHOULD_YIELD</strong></p>
<blockquote>
<p>此参数用于使能与空闲任务同优先级的任务，只有满足以下两个条件时，此参数才有效果：</p>
<ol>
<li><p>使能抢占式调度器。</p>
</li>
<li><p>有创建与空闲任务同优先级的任务。</p>
</li>
</ol>
<p>配置为 1，就可以使能此特性了，实际应用中不建议用户使用此功能，将其配置为 0 即可。</p>
</blockquote>
<p><strong>configUSE_TASK_NOTIFICATIONS</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能任务间直接的消息传递，包含信号量，事件标志组和消息邮箱。 </p>
</li>
<li><p>配置为 0</p>
<p>  禁能此特性。</p>
</li>
</ul>
</blockquote>
<p><strong>configUSE_MUTEXES</strong></p>
<blockquote>
<ul>
<li>配置为 1</li>
</ul>
<p>​    使能互斥信号量</p>
<ul>
<li>配置为 0</li>
</ul>
<p>​    禁能互斥信号量</p>
</blockquote>
<p><strong>configUSE_RECURSIVE_MUTEXES</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能递归互斥信号量</p>
</li>
<li><p>配置为 0</p>
<p>  禁能递归互斥信号量</p>
</li>
</ul>
</blockquote>
<p><strong>configUSE_COUNTING_SEMAPHORES</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能计数信号量</p>
</li>
<li><p>配置为 0</p>
<p>  禁能计数信号量</p>
</li>
</ul>
</blockquote>
<p><strong>configQUEUE_REGISTRY_SIZE</strong></p>
<blockquote>
<p>通过此定义来设置可以注册的信号量和消息队列个数。队列注册有两个目的，这两个目的都与内核调试有关：</p>
<p>注册队列的时候，可以给队列起一个名字，当使用调试组件的时候，通过名字可以很容易的区分不同队列</p>
<p>通过队列的相关信息，调试器可以很容易定位队列和信号量，能够定位信号量是因为 FreeRTOS 信号量也是基于队列实现的。当然，如果用户没有使用内核方面的调试器，这个宏定义是没有意义的。</p>
</blockquote>
<p><strong>configUSE_QUEUE_SETS</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能消息队列</p>
</li>
<li><p>配置为 0</p>
<p>  禁能消息队列。</p>
</li>
</ul>
</blockquote>
<p><strong>configUSE_TIME_SLICING</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能时间片调度。</p>
</li>
<li><p>配置为 0</p>
<p>  禁能时间片调度。</p>
</li>
</ul>
<pre><code>用户没有配置此选项如果用户没有配置此选项

默认在` FreeRTOS.h` 文件中已经配置为 1，即使能时间片调度。
</code></pre></blockquote>
<h2 id="“Config”开始的宏-其他配置"><a href="#“Config”开始的宏-其他配置" class="headerlink" title="“Config”开始的宏 - 其他配置"></a>“Config”开始的宏 - 其他配置</h2><p>STM32cubeMX中的配置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_4.webp" alt="image-20231119221804305"></p>
<p>钩子函数配置：</p>
<p>钩子函数的主要功能是用于函数的扩展，用户可以根据自己的需要往里面添加相关的测试函数。</p>
<p><strong>configUSE_IDLE_HOOK</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能空闲任务的钩子函数</p>
</li>
<li><p>配置为 0</p>
</li>
</ul>
<p>禁能空闲任务钩子函数</p>
</blockquote>
<p><strong>configUSE_MALLOC_FAILED_HOOK</strong></p>
<blockquote>
<p>当创建任务，信号量或者消息队列时，FreeRTOS 通过函数 <code>pvPortMalloc</code>()申请动态内存。</p>
<ul>
<li><p>配置为 1</p>
<p>  使能动态内存申请失败时的钩子函数</p>
</li>
<li><p>配置为 0</p>
<p>  禁能动态内存申请失败时的钩子函数</p>
</li>
</ul>
</blockquote>
<p> <strong>configUSE_TICK_HOOK</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能滴答定时器中断里面执行的钩子函数</p>
</li>
<li><p>配置为 0</p>
<p>  禁能滴答定时器中断里面执行的钩子函数</p>
</li>
</ul>
</blockquote>
<p> <strong>configCHECK_FOR_STACK_OVERFLOW</strong></p>
<blockquote>
<p>FreeRTOS 的栈溢出检测支持两种方法，为了方便描述，我们这里将其称之为方法一和方法二。</p>
<ul>
<li><p>配置为 2</p>
<p>  栈溢出检测使用方法二。</p>
</li>
<li><p>配置为 1</p>
<p>  栈溢出检测使用方法一。</p>
</li>
<li><p>配置为 0</p>
<p>  禁止栈溢出检测。</p>
</li>
</ul>
</blockquote>
<p>任务运行信息获取配置：</p>
<p><strong>configGENERATE_RUN_TIME_STATS</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能任务运行状态参数统计。</p>
</li>
<li><p>配置为 0</p>
<p>  禁止此特性。 </p>
</li>
</ul>
</blockquote>
<p><strong>configUSE_TRACE_FACILITY</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能此配置将添加额外的结构体成员和函数，以此来协助可视化和跟踪</p>
</li>
<li><p>配置为 0</p>
<p>  禁止此特性。 </p>
</li>
</ul>
</blockquote>
<p> <strong>configUSE_STATS_FORMATTING_FUNCTIONS</strong></p>
<blockquote>
<p>用户配置宏定义 <code>configUSE_TRACE_FACILITY</code>和 <code>configUSE_STATS_FORMATTING_FUNCTIONS</code>都为 1 的时候，将使能函数 <code>vTaskList</code>() 和 <code>vTaskGetRunTimeStats</code>()</p>
<p>如果两者中任何一个为 0，那么这两个函数都将被禁能。</p>
</blockquote>
<p>合作式任务配置：</p>
<p><strong>configUSE_CO_ROUTINES</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能合作式调度相关函数。</p>
</li>
<li><p>配置为 0</p>
<p>  禁能合作式调度相关函数。</p>
</li>
</ul>
</blockquote>
<p><strong>configMAX_CO_ROUTINE_PRIORITIES</strong></p>
<blockquote>
<p>此参数用于定义可供用户使用的最大的合作式任务优先级数，如果这个定义的是 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5，对于这一点，初学者要特别的注意。</p>
</blockquote>
<p>软件定时器配置：</p>
<p> <strong>configUSE_TIMERS</strong></p>
<blockquote>
<ul>
<li><p>配置为 1</p>
<p>  使能软件定时器。</p>
</li>
<li><p>配置为 0</p>
<p>  失能软件定时器</p>
</li>
</ul>
</blockquote>
<p> <strong>configTIMER_TASK_PRIORITY</strong></p>
<blockquote>
<p> 配置软件定时器任务的优先级。</p>
</blockquote>
<p> <strong>configTIMER_QUEUE_LENGTH</strong></p>
<blockquote>
<p>配置软件定时器命令队列的长度。</p>
</blockquote>
<p><strong>configTIMER_TASK_STACK_DEPTH</strong></p>
<blockquote>
<p>配置软件定时器任务的栈空间大小</p>
</blockquote>
<p><code>断言配置</code></p>
<p>STM32cubeMX生成的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_5.webp" alt="image-20231119221818493"></p>
<p>后续可以根据需要进行修改。</p>
<p>中断相关：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_6.webp" alt="image-20231119221837209"></p>
<p><code>configLIBRARY_LOWEST_INTERRUPT_PRIORITY</code>：</p>
<p>配置中断最低优先级，通常为15(因为STM32的抢占式优先级最多设置为4bit，优先级最低只能设置为15)，此参数用于配置<code>SysTick</code>与<code>PendSV</code>。</p>
<p><code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>：</p>
<p>配置系统可管理的最高优先级，此参数用于配置BASEPRI寄存器。 如果设置为5，则优先级数值为0,1,2,3,4的中断是不受FreeRTOS管理的，不可被屏蔽，也不能调用FreeRTOS中的API接口函数，而中断优先级在5-15的中断受系统FreeRTOS管理，可以被屏蔽</p>
<h2 id="“INCLUDE-”开始的宏"><a href="#“INCLUDE-”开始的宏" class="headerlink" title="“INCLUDE_”开始的宏"></a>“INCLUDE_”开始的宏</h2><p>以“INCLUDE”开头的宏允许您的应用程序将未使用的实时内核组件从您的工程中移除， 这可节约嵌入式应用程序所需的任何 ROM 或 RAM。</p>
<p>每个宏都采用以下形式：</p>
<p><code>INCLUDE_FunctionName</code></p>
<p>其中 <code>FunctionName</code> 表示可以选择性地排除的 API 函数（或函数集）。</p>
<p>要包含 API 函数，请将宏设置为 1，要排除该函数，请将宏设置为 0。</p>
<p>例如：</p>
<p>要包含 <code>vTaskDelete</code>() API 函数，请使用：</p>
<p><code>#define INCLUDE_vTaskDelete 1</code></p>
<p>要从构建中排除 <code>vTaskDelete</code>()，请使用：</p>
<p><code>#define INCLUDE_vTaskDelete 0</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_7.webp" alt="图片"></p>
<p>STM32cubeMX中的配置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_8.webp" alt="图片"></p>
<hr>
<h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="任务概念"><a href="#任务概念" class="headerlink" title="任务概念"></a>任务概念</h2><h3 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h3><p>从系统的角度看，任务是竞争系统资源的最小运行单元。</p>
<p>FreeRTOS是一个支持多任务的操作系统，在FreeRTOS中，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其他任务运行。</p>
<p>每个任务在自己的环境中运行，在任何时刻，只有一个任务得到运行，FreeRTOS调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观上看，所有的任务都在同时进行。</p>
<p>在FreeRTOS中，每个任务都有自己的栈空间(一段连续的内存)，用于保存任务运行环境。任务越多，需要的栈空间就越大，而一个系统能运行多少个任务，取决于系统可用的内存。</p>
<p>任务通常会运行在一个死循环中，不会退出，如果不需要某个任务，可以调用FreeRTOS中的删除任务API函数将任务删除，释放系统资源。</p>
<h3 id="任务状态的概念"><a href="#任务状态的概念" class="headerlink" title="任务状态的概念"></a>任务状态的概念</h3><p>FreeRTOS系统中的任务有四种状态：</p>
<p><strong>Running—运行态</strong></p>
<p>当任务处于实际运行时被称之为运行态，即 CPU 的使用权被这个任务占用。</p>
<p><strong>Ready—就绪态</strong></p>
<p>处于就绪态的任务是指那些能够运行（没有被阻塞和挂起），但是当前没有运行的任务，因为同优先级或更高优先级的任务正在运行。</p>
<p><strong>Blocked—阻塞态</strong></p>
<p>由于等待信号量，消息队列，事件标志组等而处于的状态被称之为阻塞态，另外任务调用延迟函数也会处于阻塞态。</p>
<p><strong>Suspended—挂起态</strong></p>
<p>类似阻塞态，通过调用函数 vTaskSuspend()对指定任务进行挂起，挂起后这个任务将不被执行，只有调用函数 xTaskResume()才可以将这个任务从挂起态恢复。</p>
<h3 id="任务状态的切换"><a href="#任务状态的切换" class="headerlink" title="任务状态的切换"></a>任务状态的切换</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/640" alt="图片"></p>
<h2 id="系统启动与空闲任务"><a href="#系统启动与空闲任务" class="headerlink" title="系统启动与空闲任务"></a>系统启动与空闲任务</h2><h3 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h3><p>使用如下函数启动 FreeRTOS调度： </p>
<p><code>vTaskStartScheduler();</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/7e93203d7ea3edc486397d8740765a49.png" alt="图片"></p>
<p>启动函数介绍：</p>
<p>函数原型：</p>
<p><code>void vTaskStartScheduler( void );</code></p>
<p>函数描述：函数 <code>vTaskStartScheduler</code>用于启动 FreeRTOS 调度器，即启动 FreeRTOS 的多任务执行。</p>
<p>使用这个函数要注意以下几个问题：</p>
<blockquote>
<ol>
<li><p>空闲任务和可选的定时器任务是在调用这个函数后自动创建的。</p>
</li>
<li><p>正常情况下这个函数是不会返回的。如果有返回，极有可能是用于定时器任务或者空闲任务的内存空间不足造成创建失败，此时需要加大FreeRTOS可管理的内存空间。</p>
</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120224.png" alt="图片"></p>
<p>2、空闲任务</p>
<p>空闲任务是FreeRTOS系统中没有其它任务运行时自动进入的系统任务，不需要用户创建，启用调度器时，调度器会自动创建空闲任务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120351.png" alt="图片"></p>
<p>空闲任务的作用：</p>
<blockquote>
<p>① 执行删除任务时，系统并不会立即释放任务的内存空间，只会将任务添加到结束列表中，真正的系统资源回收工作在空闲任务中完成。</p>
<p>②可以在空闲任务中实现低功耗功能，后续会详细讲解。</p>
</blockquote>
<h2 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h2><p>创建任务的方式：</p>
<p>① 静态创建任务，<code>xTaskCreateStatic()</code>，需要自行定义任务栈空间与任务控制块，一般不采用，不作介绍。</p>
<p>②动态创建任务，<code>xTaskCreate()</code>，系统动态分配任务栈空间与任务控制块，应用采用此方式。</p>
<p>动态创建任务函数详解：</p>
<p><strong>函数原型：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120517.webp" alt="图片"></p>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xTaskCreate</code>用于实现 FreeRTOS 操作系统的任务创建，并且还可以自定义任务栈的大小。</p>
<blockquote>
<p> 第 一 个参数填创建任务的函数名</p>
<p> 第 二 个参数是任务名，这个参数主要用于调试的时候方便看是哪个任务</p>
<p> 第 三 个参数是任务栈大小，单位 word，也就是 4 字节</p>
<p> 第 四 个参数是创建的任务函数的形参</p>
<p> 第 五 个参数是定义任务优先级</p>
<p> 第 六 个参数是任务句柄，用于区分不同的任务</p>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120716.webp" alt="图片"></p>
<p><strong>STM32cubeMX创建方法：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120912.webp" alt="图片"></p>
<p>方法详解：</p>
<p>① 首先利用宏定义定义任务参数结构体变量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121607.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121701.webp" alt="图片"></p>
<p>#name：将name转化为字符串，等效于”name”</p>
<p><code>os_thread_def__name</code>:将name以字符串方式拼接，等效于”<code>os_thread_def_name</code>“</p>
<p>① 调用动态创建函数创建任务，形参为上面的结构体地址</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121733.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121858.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121925.webp" alt="图片"></p>
<h2 id="任务删除"><a href="#任务删除" class="headerlink" title="任务删除"></a>任务删除</h2><p>删除任务函数详解：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;  <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskDelete</code>用于实现 FreeRTOS 操作系统的任务删除。 </p>
<p> 第 1 个参数填要删除任务的句柄</p>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p>
<p><code>#define INCLUDE_vTaskDelete 1</code></p>
<p>② 如果用往此函数里面填的任务 ID 是 NULL，即数值 0 的话，那么删除的就是当前正在执行的任务，此任务被删除后，FreeRTOS 会切换到任务就绪列表里面下一个要执行的最高优先级任务。</p>
<p>③ 在 FreeRTOS 中，创建任务所需的内存需要在空闲任务中释放，如果用户在 FreeRTOS 中调用了这个函数的话，一定要让空闲任务有执行的机会，否则这块内存是无法释放的。另外，创建的这个任务在使用中申请了动态内存，这个内存不会因为此任务被删除而删除，这一点要注意，一定要在删除前将此内存释放。</p>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121955.webp" alt="图片"></p>
<h2 id="任务挂起"><a href="#任务挂起" class="headerlink" title="任务挂起"></a>任务挂起</h2><p>挂起任务函数详解：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend)</span>; <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskSuspend</code>用于实现 FreeRTOS 操作系统的任务挂起。 </p>
<p> 第 1 个参数填要挂起任务的句柄</p>
<p>使用这个函数要注意以下问题：</p>
<p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p>
<p><code>#define INCLUDE_vTaskSuspend 1</code></p>
<p>② 如果用往此函数里面填的任务 ID 是 <code>NULL</code>，即数值 0 的话，那么挂起的就是当前正在执行的任务，此任务被挂起后，FreeRTOS 会切换到任务就绪列表里面下一个要执行的高优先级任务。</p>
<p>③ 多次调用此函数的话，只需调用一次 <code>vTaskResume</code>即可将任务从挂起态恢复。</p>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122008.webp" alt="图片"></p>
<h2 id="任务恢复-普通方式与中断方式"><a href="#任务恢复-普通方式与中断方式" class="headerlink" title="任务恢复(普通方式与中断方式)"></a>任务恢复(普通方式与中断方式)</h2><p>普通方式恢复任务函数详解：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">( TaskHandle_t xTaskToResume)</span>;<span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskResume</code>用于实现 FreeRTOS 操作系统的任务恢复</p>
<p> 第 1 个参数填要恢复任务的句柄</p>
<p>使用这个函数要注意以下问题：</p>
<p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p>
<p><code>#define INCLUDE_vTaskSuspend 1</code></p>
<p>② 多次调用函数 <code>vTaskSuspend</code>的话，只需调用一次 <code>vTaskResume</code>即可将任务从挂起态恢复。</p>
<p>③ 此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的<code>xTaskResumeFromISR</code>()，以后缀 <code>FromISR</code>结尾。</p>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122026.webp" alt="图片"></p>
<p>中断方式恢复任务函数详解：</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">vTaskResumeFromISR</span><span class="params">( TaskHandle_t xTaskToResume)</span>; <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskResumeFromISR</code>用于实现 FreeRTOS 操作系统的任务恢复。</p>
<p> 第 1 个参数填要恢复任务的句柄</p>
<p>使用这个函数要注意以下问题：</p>
<p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code>配置文件中配置如下宏定义为 1</p>
<p><code>#define INCLUDE_xResumeFromISR 1</code></p>
<p>② 多次调用函数 <code>vTaskSuspend</code>的话，只需调用一次 <code>vTaskResumeFromISR</code>即可将任务从挂起态恢复。</p>
<p>③ 如果用户打算采用这个函数实现中断与任务的同步，要注意一种情况，如果此函数的调用优先于函数<code>vTaskSuspend</code>被调用，那么此次同步会丢失，这种情况下建议使用信号量来实现同步。</p>
<ol>
<li>此函数是用于中断服务程序中调用的，故不可以在任务中使用此函数，任务中使用的是 <code>vTaskResume</code>。</li>
</ol>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122030.webp" alt="图片"></p>
<h2 id="任务管理编程"><a href="#任务管理编程" class="headerlink" title="任务管理编程"></a>任务管理编程</h2><p>1、STM32cubeMX初始化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122034.webp" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122039.webp" alt="图片"></p>
<p>说明：按键任务手动创建。</p>
<p>2、文件结构如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122043.webp" alt="图片"></p>
<p>3、程序功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122048.webp" alt="图片"></p>
<p>4、按键结构体</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122051.webp" alt="图片"></p>
<p>5、按键检测函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122055.webp" alt="图片"></p>
<p>6、创建按键任务</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122059.webp" alt="图片"></p>
<p>7、按键任务执行函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122104.webp" alt="图片"></p>
<hr>
<h1 id="任务调度与任务栈"><a href="#任务调度与任务栈" class="headerlink" title="任务调度与任务栈"></a>任务调度与任务栈</h1><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>简单的说，调度器就是使用相关的调度算法来决定当前需要执行的任务。</p>
<p>FreeRTOS 操作系统支持三种调度方式：抢占式调度，时间片调度和合作式调度。</p>
<p>1.合作式调度</p>
<p>合作式调度器提供了一种单任务的的系统结构：</p>
<blockquote>
<ul>
<li>当任务需要运行的时候，被添加到等待队列</li>
<li>任务在特定的时刻被调度运行（以周期性或者单次方式）</li>
<li>任务运行直到完成(高优先级任务不可抢占CPU)，然后由调度器选择下一个任务</li>
</ul>
</blockquote>
<p>优点：调度简单，系统占用资源少(单任务结构，运行时高优先级任务不会抢占CPU，不需要给每个任务分配独立的栈空间)</p>
<p>缺点：系统实时性不够好</p>
<p>Note：</p>
<blockquote>
<p>单片机资源越来越丰富，加上合作式调度器的系统实时性不够好，合作式调度已经很少用了，FreeRTOS在新的版本中已不再更新，简单了解即可</p>
</blockquote>
<p>2.抢占式调度</p>
<p>抢占式调度器提供了一种多任务的的系统结构，高优先级任务可以抢占低优先级任务的CPU使用权，使得系统实时性非常好。</p>
<p>使用抢占式调度器时，根据任务重要程度合理分配优先级，CPU会优先执行就绪列表中优先级最高的任务。</p>
<p>下面图片： 任务1优先级 &lt; 任务2优先级 &lt; 任务3优先级</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free5_1.webp" alt=""></p>
<p>3.时间片调度</p>
<p>时间片调度针对同优先级的任务，调度算法给同优先级的任务分配一个专门的列表，用于记录当前就绪的任务，并为每个任务分配一个时间片。</p>
<p>下面图片： 任务1优先级 = 任务2优先级 = 任务3优先级 = 任务4优先级</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/2.webp" alt=""></p>
<h2 id="抢占式调度编程测试"><a href="#抢占式调度编程测试" class="headerlink" title="抢占式调度编程测试"></a>抢占式调度编程测试</h2><p>实验方法:</p>
<p>创建3个任务,情况如下：</p>
<p>任务1： 优先级低，阻塞，打印信息</p>
<p>任务2： 优先级中，运行时不阻塞，不挂起，闪灯</p>
<p>任务3： 优先级高，阻塞，打印信息</p>
<p>实验分析:</p>
<p>因为任务2一直运行，不释放CPU，使得低优先级的任务1无法获得CPU使用权，而任务3优先高，可以抢占CPU获得运行。</p>
<p>实验现象:</p>
<p>任务2指示灯闪烁，任务3打印信息输出。</p>
<p><strong>Note：</strong></p>
<blockquote>
<p>可以将任务2的优先级设置为最高，观察实验现象。</p>
</blockquote>
<h2 id="时间片调度编程测试"><a href="#时间片调度编程测试" class="headerlink" title="时间片调度编程测试"></a>时间片调度编程测试</h2><p>实验方法:</p>
<p>创建3个相同优先级的任务，打印信息，延时10ms，灯闪烁。 另外，方便测试，FreeRTOS的Tick设置为20，也就是每50ms进行一次系统调度。</p>
<p>实验分析:</p>
<p>3个任务优先级相同，按时间片调度，调度时间为50ms，因此每个任务可以连续执行5次。</p>
<p>实验现象:</p>
<p>3个任务循环打印5次，闪5次灯。</p>
<p><strong>Note：</strong></p>
<blockquote>
<p>可以禁止时间片调度，观察实验现象。</p>
</blockquote>
<h2 id="任务栈大小确认"><a href="#任务栈大小确认" class="headerlink" title="任务栈大小确认"></a>任务栈大小确认</h2><p>在FreeRTOS的应用设计中，每个任务都需要独立的栈空间，而且每个任务需要的栈大小也是不同的。将如下的几个选项简单的累加就可以得到一个粗略的栈大小：</p>
<p>1、函数</p>
<blockquote>
<p>  ① 局部变量</p>
<p>   ② 函数形参 (针对函数嵌套)</p>
<p>   ③ 函数返回地址 (针对函数嵌套)</p>
<p>   ④ 函数内部的状态保存</p>
</blockquote>
<p>2、任务切换</p>
<p>3、发生中断</p>
<p>实际应用中将这些都加起来是一件非常麻烦的工作，上面这些栈空间加起来的总和只是栈的最小需求，实际分配的栈大小可以在最小栈需求的基础上乘以一个安全系数，一般取 1.5-2。</p>
<p>上面的计算是我们用户可以确定的栈大小，项目应用中还存在无法确定的栈大小，比如调用printf函数就很难确定实际的栈消耗。又比如通过函数指针实现函数的间接调用，因为函数指针不是固定的指向一个函数进行调用，而是根据不同的程序设计可以指向不同的函数，使得栈大小的计算变得比较麻烦。</p>
<p>另外还要注意一点，建议不要编写递归代码，因为我们不知道递归的层数，栈的大小也是不好确定的。</p>
<p><strong>建议：</strong></p>
<blockquote>
<p>可以事先给任务分配一个大的栈空间，然后通过第二讲介绍的调试方法打印任务栈的使用情况，运行一段时间就会有个大概的范围了，再乘以安全系数，即可得到需要使用的栈空间。</p>
</blockquote>
<p>如下图：Test1-3使用的栈空间：(128-106)=22 words， 乘以安全系数，分配33 words即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/3.webp" alt=""></p>
<h2 id="任务栈溢出与检测"><a href="#任务栈溢出与检测" class="headerlink" title="任务栈溢出与检测"></a>任务栈溢出与检测</h2><h3 id="任务栈溢出"><a href="#任务栈溢出" class="headerlink" title="任务栈溢出"></a>任务栈溢出</h3><p>上节讲解了如何确定任务栈的大小，那什么又是栈溢出呢？简单的说就是用户分配的栈空间不够用了，溢出了。</p>
<p>下面我们举一个简单的实例，栈生长方向从高地址向低地址生长（M4 和 M3 是这种方式）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/4.webp" alt=""></p>
<blockquote>
<p>① 上图标识 1 的位置是 RTOS 的某个任务调用了函数 test()前的 SP 栈指针位置</p>
<p>② 上图标识 2 的位置是调用了函数 test 需要保存返回地址到栈空间。这一步不是必须的，对于 M3和 M4 内核是先将其保存到 LR 寄存器中，如果 LR 寄存器中有保存上一级函数的返回地址，需要将 LR 寄存器中的内容先入栈</p>
<p>③ 上图标识 3 的位置是局部变量 <code>int i</code> 和 <code>int array</code>[10]占用的栈空间，但申请了栈空间后已经越界了。这个就是所谓的栈溢出了。如果用户在函数 <code>test</code>中通过数组 <code>array</code>修改了这部分越界区的数据且这部分越界的栈空间暂时没有用到或者数据不是很重要，情况还不算严重，但是如果存储的是关键数据，会直接导致系统崩溃</p>
<p>④ 上图标识 4 的位置是局部变量申请了栈空间后，栈指针向下偏移（返回地址+变量 i+10 个数组元素）*4 =48 个字节</p>
<p>⑤ 上图标识 5 的位置可能是其它任务的栈空间，也可能是全局变量或者其它用途的存储区，如果 test函数在使用中还有用到栈的地方就会从这里申请，这部分越界的空间暂时没有用到或者数据不是很重要，情况还不算严重，但是如果存储的是关键数据，会直接导致系统崩溃</p>
</blockquote>
<h3 id="FreerRTOS栈溢出检测机制"><a href="#FreerRTOS栈溢出检测机制" class="headerlink" title="FreerRTOS栈溢出检测机制"></a>FreerRTOS栈溢出检测机制</h3><p>FreeRTOS 提供了两种栈溢出检测机制，这两种检测都是在任务切换时才会进行：</p>
<p>方法一：</p>
<p>在任务切换时检测任务栈指针是否过界了，如果过界了，在任务切换的时候会触发栈溢出钩子函数(钩子函数的主要作用就是对原有函数的功能进行扩展，用户可以根据自己的需要往里面添加相关的测试代码)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t xTask, <span class="type">signed</span> <span class="type">char</span> *pcTaskName )</span>;</span><br></pre></td></tr></table></figure>
<p>用户可以在钩子函数里面做一些处理。这种方法不能保证所有的栈溢出都能检测到。比如任务在执行的过程中出现过栈溢出。任务切换前栈指针又恢复到了正常水平，这种情况在任务切换的时候是检测不到的。又比如任务栈溢出后，把这部分栈区的数据修改了，这部分栈区的数据不重要或者暂时没有用到还好，但如果是重要数据被修改将直接导致系统进入硬件异常，这种情况下，栈溢出检测功能也是检测不到的。</p>
<p>使用方法一需要用户在 <code>FreeRTOSConfig.h</code>文件中配置如下宏定义：</p>
<p><code>#define configCHECK_FOR_STACK_OVERFLOW 1</code></p>
<p>方法二：</p>
<p>任务创建的时候将任务栈所有数据初始化为 0xa5，任务切换时进行任务栈检测的时候会检测末尾的 16 个字节是否都是 0xa5，通过这种方式来检测任务栈是否溢出了。相比方法一，这种方法的速 度稍慢些，但是这样就有效地避免了方法一里面的部分情况。不过依然不能保证所有的栈溢出都能检测到，比如任务栈末尾的 16 个字节没有用到，即没有被修改，但是任务栈已经溢出了，这种情况是检测不到的。另外任务栈溢出后，任务栈末尾的 16 个字节没有修改，但是溢出部分的栈区数据被修改了，这部分栈区的数据不重要或者暂时没有用到还好，但如果是重要数据被修改将直接导致系统进入硬件异常，这种情况下，栈溢出检测功能也是检测不到的。</p>
<p>使用方法二需要用户在 <code>FreeRTOSConfig.h</code> 文件中配置如下宏定义：</p>
<p><code>#define configCHECK_FOR_STACK_OVERFLOW  2</code></p>
<h2 id="栈溢出编程测试"><a href="#栈溢出编程测试" class="headerlink" title="栈溢出编程测试"></a>栈溢出编程测试</h2><p>实验方法:</p>
<p>本实验就是在任务KEY_Task中申请过大的数组，模拟栈溢出的情况，检测到按键1按下时，对数组赋值，模拟产生系统硬件错误。  检测溢出后触发钩子函数，将发生栈溢出的任务打印出来。</p>
<p>实验现象:</p>
<p>串口打印KEY任务发生栈溢出，按下KEY1，系统产生硬件错误。</p>
<p><strong>Note：</strong></p>
<blockquote>
<p>FreerRTOS栈溢出检测机制的2种方法都试试。</p>
<p><code>#define configCHECK_FOR_STACK_OVERFLOW 1</code></p>
<p><code>#define configCHECK_FOR_STACK_OVERFLOW 2</code></p>
</blockquote>
<hr>
<h1 id="任务与中断优先级，临界保护"><a href="#任务与中断优先级，临界保护" class="headerlink" title="任务与中断优先级，临界保护"></a>任务与中断优先级，临界保护</h1><h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p> 1.NVIC基础知识<strong>(回顾)</strong></p>
<blockquote>
<p>NVIC 即嵌套向量中断控制器(Nested Vectored Interrupt Controller)。STM32 的中有一个强大而方便的 NVIC，它是属于 CM4 内核的器件。NVIC 是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。但是各个芯片厂商在设计芯片的时候会对 CM4 内核里面的 NVIC 进行裁剪，把不需要的部分去掉，所以说 STM32 的 NVIC 是 CM4 的 NVIC 的一个子集</p>
<p>STM32 中有两个优先级的概念: 抢占式优先级和响应优先级，响应优先级也称子优先级，每个中断源都需要被指定这两种优先级。<br>具有高抢占式优先级的中断可以在具有低抢占式优先级的中断处理过程中被响应，即中断嵌套，或者说高抢占式优先级的中断可以嵌套在低抢占式优先级的中断中。<br>当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个:如果他们的抢占式优先级和响应优先级都相硬件家园等，则根据他们在中断表中的排位顺序决定先处理哪一个</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_1.webp" alt=""></p>
<p>2.FreeRTOS配置NVIC</p>
<p><strong>Note：</strong></p>
<blockquote>
<p><code>官方强烈建议将中断优先级分组设置为4，即抢占优先级可配置范围是0-15，数值越小，抢占优先级越高。</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_2.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_3.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_4.webp" alt=""></p>
<p>3、<code>SVC</code>，<code>PendSV</code>与<code>Systick</code>中断</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_5.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_6.webp" alt=""></p>
<p>SVC 中断：</p>
<blockquote>
<p>在 FreeRTOS 的移植文件 <code>ports.c</code> 中有用到 <code>SVC</code>中断的 0 号系统服务，即 <code>SVC</code>0。此中断在 FreeRTOS中仅执行一次，用于启动第一个要执行的任务。另外，由于 FreeRTOS 没有配置 SVC 的中断优先级，默认没有配置的情况下，<code>SVC 中断的优先级就是最高的 0</code>。</p>
</blockquote>
<p><code>PendSV</code>与<code>Systick</code>中断：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_7.webp" alt=""></p>
<p>4、不受FreeTOS管理的中断</p>
<blockquote>
<p>FreeRTOS 内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件，得不到及时执行的话，后果是可想而知的。</p>
<p>针对这种情况，FreeRTOS 就专门做了一种新的开关中断实现机制。关闭中断时仅关闭受 FreeRTOS管理的中断，不受 FreeRTOS 管理的中断不关闭，这些不受管理的中断都是高优先级的中断，用户可以在这些中断里面加入需要实时响应的程序。</p>
<p>FreeRTOS 能够实现这种功能的奥秘就在于 FreeRTOS 开关中断使用的是寄存器 <code>basepri</code>：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_8.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_9.webp" alt=""></p>
<p>5、STM32CubeMX配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_10.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_11.webp" alt=""></p>
<h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>1、任务优先级说明</p>
<blockquote>
<p>① FreeRTOS 中任务的最高优先级是通过 <code>FreeRTOSConfig.h</code> 文件中的 <code>configMAX_PRIORITIES</code>进行配置的，用户实际可以使用的优先级范围是 <code>0</code>到 <code>configMAX_PRIORITIES – 1</code>。比如我们配置此宏定义为 <code>5</code>，那么用户可以使用的优先级号是 <strong>0,1,2,3,4</strong>，<code>不包含 5</code>，对于这一点，初学者要特别的注意。</p>
<p>② <code>用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0</code>。</p>
<p>③ 建议用户配置宏定义 <code>configMAX_PRIORITIES</code> 的最大值不要超过 32，即用户任务可以使用的优先级范围是0到31。因为对于CM内核的移植文件，用户任务的优先级不是大于等于32的话，<code>portmacro.h</code>文件中的宏定义<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>会优化优先级列表中要执行的最高优先级任务的获取算法（对于 CM 内核的移植文件，此宏定义默认是使能的，当然，用户也可以在<code>FreeRTOSConfig.h</code> 文件中进行配置）。</p>
<p>④ 如果用户在 <code>FreeRTOSConfig.h</code> 文件中配置宏定义 <code>configUSE_TIME_SLICING</code>为 1，或者没有配置此宏定义，时间片调度都是使能的。另外，只要芯片资源允许，可以配置任意多个同优先级任务。</p>
<p>⑤ <code>FreeRTOS 中处于运行状态的任务永远是当前能够运行的最高优先级任务。</code></p>
</blockquote>
<p>2、任务优先级分配方案</p>
<p>对于初学者，有时候会纠结任务优先级设置为多少合适，因为任务优先级设置多少是没有标准的。对于这个问题，这里为大家推荐一个标准，任务优先级设置推荐方式如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_12.webp" alt=""></p>
<blockquote>
<p>① <code>IRQ 任务</code>：IRQ 任务是指通过中断服务程序进行触发的任务，此类任务应该设置为所有任务里面<code>优先级最高</code>的。</p>
<p>② <code>高优先级后台任务</code>：比如按键检测，触摸检测，USB 消息处理，串口消息处理等，都可以归为这一类任务。</p>
<p>③ <code>低优先级的时间片调度任务</code>：比如 emWin 的界面显示，LED 数码管的显示等不需要实时执行的都可以归为这一类任务。实际应用中用户不必拘泥于将这些任务都设置为优先级 1 的同优先级任务，可以设置多个优先级，<code>只需注意这类任务不需要高实时性</code>。</p>
<p>④ <code>空闲任务</code>：空闲任务是系统任务。</p>
<p>⑤ <code>特别注意</code>：<code>IRQ 任务和高优先级任务必须设置为阻塞式</code>（调用消息等待或者延迟等函数即可），只有这样，高优先级任务才会释放 CPU 的使用权，,从而低优先级任务才有机会得到执行。</p>
</blockquote>
<p>3、中断优先级和任务优先级区别</p>
<blockquote>
<p>部分初学者也容易在这两个概念上面出现问题。简单的说，这两个之间没有任何关系，不管中断的优先级是多少，中断的优先级永远高于任何任务的优先级，即任务在执行的过程中，中断来了就开始执行中断服务程序。</p>
<p>另外对于 <code>STM32</code>，<code>中断优先级的数值越小，优先级越高</code>。而 <code>FreeRTOS</code>的任务优先级是，<code>任务优先级数值越小，任务优先级越低</code>。</p>
</blockquote>
<p>4、任务优先级修改与获取</p>
<p>优先级获取：</p>
<p><strong>函数原型：</strong></p>
<p><code>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</code>/<em> 任务句柄 </em>/</p>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskPriorityGet</code>用于获取 FreeRTOS 任务优先级。</p>
<p>第 1 个参数是任务句柄，用于区分不同的任务。</p>
<p>使用这个函数要注意以下问题：</p>
<ol>
<li>使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</li>
</ol>
<p><code>#define INCLUDE_vTaskPriorityGet  1</code></p>
<ol>
<li>如果第二个参数里面填的是 NULL，即数值 0 的话，那么获取的优先级就是当前正在执行的任务</li>
</ol>
<p>优先级修改：</p>
<p><strong>函数原型：</strong></p>
<p><code>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )</code>;  给任务配置的新优先级 </p>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vTaskPrioritySet</code>用于实现 FreeRTOS 任务优先级的修改。 </p>
<p> 第 1 个参数是任务句柄，用于区分不同的任务。 </p>
<p> 第 2 个参数是给任务配置的新优先级。</p>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p>
<p><code>#define INCLUDE_vTaskPrioritySet  1</code></p>
<p>② 如果第一个参数里面填的是 NULL，即数值 0 的话，那么配置的就是当前正在执行的任务</p>
<p>③ 如果被修改的任务的优先级，修改后高于正在执行的任务，将执行任务切换，切换到修改好的高优先级任务。</p>
<p>④ 第二个参数数值不可大于等于 <code>FreeRTOSConfig.h</code> 文件中的宏定义：<code>#define configMAX_PRIORITIES 配置的数值</code>。</p>
</blockquote>
<h2 id="开关中断与临界段函数"><a href="#开关中断与临界段函数" class="headerlink" title="开关中断与临界段函数"></a>开关中断与临界段函数</h2><p>1、临界段概念</p>
<p>代码的临界段也称为临界区，一旦这部分代码开始执行，则不允许中断打断。为确保临界段代码的执行不被中断，在进入临界段之前须关中断，而临界段代码执行完毕后，要立即开中断。</p>
<p>进入临界段前操作寄存器 <code>basepri</code>关闭了所有小于等于宏定义 <code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>所定义的中断优先级，这样临界段代码就不会被中断干扰到，而且实现任务切换功能的 <code>PendSV</code>中断和滴答定时器中断是最低优先级中断，所以此任务在执行临界段代码期间是不会被其它高优先级任务打断的。退出临界段时重新操作 <code>basepri</code>寄存器，即打开被关闭的中断（这里我们不考虑不受 FreeRTOS 管理的更高优先级中断）</p>
<p>除了 FreeRTOS 操作系统源码所带的临界段以外，用户写应用的时候也有临界段的问题，比如以下两种：</p>
<ul>
<li><p>读取或者修改变量（特别是用于任务间通信的全局变量）的代码，一般来说这是最常见的临界代码。</p>
</li>
<li><p>调用公共函数的代码，特别是不可重入的函数，如果多个任务都访问这个函数，结果是可想而知的。总之，对于临界段要做到执行时间越短越好，否则会影响系统的实时性。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_13.webp" alt=""></p>
<p>2、开关中断函数</p>
<p>FreeRTOS 提供了一组开关中断函数，比较简单。</p>
<p>具体实现如下：</p>
<p><code>#define taskDISABLE_INTERRUPTS()  portDISABLE_INTERRUPTS()</code></p>
<p><code>#define taskENABLE_INTERRUPTS()   portENABLE_INTERRUPTS()</code></p>
<p>进一步跟踪宏定义的实现如下：</p>
<p><code>#define portDISABLE_INTERRUPTS()  vPortRaiseBASEPRI()</code></p>
<p><code>#define portENABLE_INTERRUPTS()   vPortSetBASEPRI( 0 )</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_14.webp" alt=""></p>
<p><strong>Note：</strong></p>
<blockquote>
<p><code>这两个函数不建议使用，因为不支持嵌套。</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_15.webp" alt=""></p>
<p>3、任务代码临界段处理函数</p>
<p>任务代码进入和退出临界段的函数如下：</p>
<p><code>#define taskENTER_CRITICAL()  portENTER_CRITICAL()</code></p>
<p><code>#define taskEXIT_CRITICAL()    portEXIT_CRITICAL()</code></p>
<p>源码实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_16.webp" alt=""></p>
<p>通过上面两个函数 <code>vPortEnterCritical</code>和 <code>vPortExitCritical</code>可以看出，进入临界段和退出临界段是通过函数调用开关中断函数<code>portENABLE_INTERRUPTS</code>和 <code>portDISABLE_INTERRUPTS</code>实现的。<code>细心的读者还会发现上面的这两个函数都对变量 uxCriticalNesting 进行了操作。这个变量比较重要，用于临界段的嵌套计数。</code></p>
<p><strong>Note</strong></p>
<blockquote>
<p><code>临界段处理函数必须成对使用。</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_17.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_18.webp" alt=""></p>
<p>4、中断代码临界段处理函数</p>
<p>中断代码进入和退出临界段的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR()  portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )</span></span><br></pre></td></tr></table></figure>
<p>源码实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_19.webp" alt=""></p>
<p>通过上面的源码可以看出，中断服务程序里面的临界段代码的开关中断也是通过寄存器 <code>basepri</code>实现的。初学的同学也许会问，这里怎么没有中断嵌套计数了呢？是的，这里换了另外一种实现方法，通过保存和恢复寄存器 <code>basepri</code>的数值就可以实现嵌套使用。</p>
<p><strong>Note：
</strong></p>
<blockquote>
<p><code>临界段处理函数必须成对使用。</code></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_20.webp" alt=""></p>
<h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_1.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_2.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_3.webp" alt=""></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line">    <span class="comment">//KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span>(KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//测试任务代码临界段</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;更改前的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">vTaskPrioritySet</span>(<span class="literal">NULL</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;更改后的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进入代码临界段\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">taskENTER_CRITICAL</span>();  <span class="comment">//进入代码临界段</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;延时5s，尽管KEY任务的优先级最低，但由于进入了临界段，任务不会切换，LED灯应该停止闪烁5s\n&quot;</span>);</span><br><span class="line">		<span class="built_in">HAL_Delay</span>(<span class="number">5000</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="built_in">taskEXIT_CRITICAL</span>();   <span class="comment">//退出代码临界段</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;退出代码临界段\r\n&quot;</span>);</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line">		<span class="built_in">vTaskPrioritySet</span>(<span class="literal">NULL</span>,<span class="number">5</span>); <span class="comment">// 优先级更改移动到退出临界段之后</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;当前的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//KEY2处理</span></span><br><span class="line">		<span class="keyword">if</span>(KEY.KeyCode == KEY2)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//KEY3处理</span></span><br><span class="line">		<span class="keyword">if</span>(KEY.KeyCode == KEY3)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//KEY4处理</span></span><br><span class="line">		<span class="keyword">if</span>(KEY.KeyCode == KEY4)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//阻塞延时20ms</span></span><br><span class="line">		<span class="built_in">osDelay</span>(<span class="number">20</span>);		</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote>
<p>我使用的定时器是TIM2作为freertos的延时时钟基准，需要把TIM2的优先级调高，不然会卡死在HAL_Delay导致退不出来代码临界段！</p>
</blockquote>
<hr>
<h1 id="调度锁，中断锁，任务锁"><a href="#调度锁，中断锁，任务锁" class="headerlink" title="调度锁，中断锁，任务锁"></a>调度锁，中断锁，任务锁</h1><h2 id="调度锁、中断锁，任务锁"><a href="#调度锁、中断锁，任务锁" class="headerlink" title="调度锁、中断锁，任务锁"></a>调度锁、中断锁，任务锁</h2><h3 id="调度锁"><a href="#调度锁" class="headerlink" title="调度锁"></a>调度锁</h3><p>调度锁就是 RTOS 提供的调度器开关函数，如果某个任务调用了调度锁开关函数，处于调度锁开和调度锁关之间的代码在执行期间是不会被高优先级的任务抢占的，即任务调度被禁止。这一点要跟临界段的作用区分开，调度锁只是禁止了任务调度，并没有关闭任何中断，中断还是正常执行的。而临界段进行了开关中断操作。</p>
<h3 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h3><p>中断锁就是 RTOS 提供的开关中断函数，FreeRTOS 没有专门的中断锁函数，使用上一讲里面介绍的中断服务程序临界段处理函数就可以实现同样效果。</p>
<h3 id="任务锁"><a href="#任务锁" class="headerlink" title="任务锁"></a>任务锁</h3><p>简单的说，为了防止当前任务的执行被其它高优先级的任务打断而提供的锁机制就是任务锁。FreeRTOS 也没有专门的任务锁函数，但是使用 FreeRTOS 现有的功能有两种实现方法：</p>
<blockquote>
<ul>
<li>利用调度锁关闭任务切换</li>
<li>利用 FreeRTOS 的任务代码临界段处理函数关闭 <code>PendSV</code>中断和 <code>Systick</code>中断，进而关闭任务切换。</li>
</ul>
</blockquote>
<h2 id="调度锁在线编程测试"><a href="#调度锁在线编程测试" class="headerlink" title="调度锁在线编程测试"></a>调度锁在线编程测试</h2><p>1、调度锁开启函数</p>
<p>调度锁开启函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>①. 调度锁函数只是禁止了任务调度，并没有关闭任何中断。</p>
<p>②. 调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>一定要成对使用。</p>
<p>③. 切不可在调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>之间调用任何会引起任务切换的 API，比如 <code>vTaskDelayUntil</code>、<code>vTaskDelay</code>、<code>xQueueSend</code>等。</p>
</blockquote>
<p>调度锁关闭函数   <code>BaseType_t vTaskResumeAll(void)</code></p>
<p>调度锁关闭后，如果需要任务切换，此函数返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>①. 调度锁函数只是禁止了任务调度，并没有关闭任何中断。</p>
<p>②. 调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>一定要成对使用。</p>
<p>③. 切不可在调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>之间调用任何会引起任务切换的 API，比如 <code>vTaskDelayUntil</code>、<code>vTaskDelay</code>、<code>xQueueSend</code>等。</p>
</blockquote>
<p>2、应用方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free7_1.webp" alt=""></p>
<p>3、调度锁在线编程测试</p>
<p>实验方法：</p>
<p>创建2个任务，情况如下：</p>
<p>任务1：优先级低，启用调度锁，调度锁开关之间使用HAL_Delay延时5s，退出调度锁后，使用HAL_Delay继续延时2s</p>
<p>任务2：优先级高，指示灯100ms快闪</p>
<p>实验分析：任务2本应该间隔100ms连续快闪，由于低优先级的任务一调用了调度锁开关函数，而且延时了5s，延时期间关闭了任务切换，在此期间，任务2不运行，结果就是任务2的指示灯间隔5s快闪10次。</p>
<hr>
<h1 id="时间管理-系统节拍，延时函数"><a href="#时间管理-系统节拍，延时函数" class="headerlink" title="时间管理(系统节拍，延时函数)"></a>时间管理(系统节拍，延时函数)</h1><h2 id="系统节拍"><a href="#系统节拍" class="headerlink" title="系统节拍"></a>系统节拍</h2><p>FreeRTOS实时操作系统需要一个时钟节拍，以供系统处理诸如延时、超时、软件定时器等与时间相关的事件。</p>
<p>时钟节拍是周期性定时中断，这个中断可以看做是系统心跳。中断时间间隔取决于不同的应用，一般是 1ms – 100ms。时钟的节拍中断使得内核可以将任务延迟若干个时钟节拍，以及当任务等待事件发生时，提供等待超时等依据。时钟节拍率越快，系统响应越快，系统的额外开销也越大。</p>
<p>对于 Cortex-M3 内核的 STM32F103 ，教程配套的例子都是用滴答定时器来实现系统时钟节拍的。</p>
<p>滴答定时器 Systick</p>
<p>SysTick 定时器位于 NVIC 中，用于产生 SysTick 异常（异常号：15），滴答定时器是一个 24 位的递减计数器，支持中断。使用比较简单，专门用于给操作系统提供时钟节拍。</p>
<p>FreeRTOS 的系统时钟节拍可以在配置文件 <code>FreeRTOSConfig.h</code> 里面设置：</p>
<p><code>#define configTICK_RATE_HZ ( ( TickType_t ) 1000 )</code></p>
<p>如上所示的宏定义配置表示系统时钟节拍是 1KHz，即 1ms。</p>
<h2 id="延时相关函数"><a href="#延时相关函数" class="headerlink" title="延时相关函数"></a>延时相关函数</h2><p>1、作用</p>
<p>FreeRTOS 中的时间延迟函数主要有以下两个作用：</p>
<p>为周期性执行的任务提供延迟。</p>
<p> 对于抢占式调度器，让高优先级任务可以通过时间延迟函数释放 CPU 使用权，从而让低优先级任务可以得到执行。</p>
<p>2、相关函数</p>
<p>FreeRTOS 时间相关的函数主要有以下 4 个： </p>
<p> <code>vTaskDelay ()</code></p>
<p><code>vTaskDelayUntil ()</code></p>
<p><code>xTaskGetTickCount()</code></p>
<p> <code>xTaskGetTickCountFromISR()</code></p>
<p>下面我们对这 4 个函数依次进行说明：</p>
<p><strong>① 函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(  <span class="type">const</span> TickType_t xTicksToDelay )</span>; </span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong>函数 <code>vTaskDelay</code>用于任务的延迟。 属于相对延时，指每次延时都是从执行函数<code>vTaskDelay</code>()开始，直到延时指定的时间（参数：滴答值）结束。 </p>
<p> 参数 <code>xTicksToDelay</code>用于设置延迟的时钟节拍个数，范围 <code>1- 0xFFFFFFFF</code>。</p>
<p>延迟时间的最大值在<code>portmacro.h</code> 文件里面有定义：</p>
<p><code>typedef uint32_t TickType_t;</code></p>
<p><code>#define portMAX_DELAY ( TickType_t )</code> 0xffffffffUL</p>
<p>即延迟时间的范围是：1- 0xFFFFFFFF</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_1.webp" alt=""></p>
<p><strong>② 函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( </span></span><br><span class="line"><span class="params">    TickType_t *pxPreviousWakeTime, </span></span><br><span class="line"><span class="params">    <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong>函数 <code>vTaskDelayUntil</code>用于周期性延迟。 属于绝对延时，指间隔指定的时间（参数：滴答值），执行一次调用<code>vTaskDelayUntil</code>()函数的任务。</p>
<p> 第 1 个参数，存储任务最后一次解除阻塞的时间</p>
<p> 第 2 个参数，周期性延迟时间。</p>
<p>使用这个函数要注意以下问题：</p>
<ol>
<li>使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为1</li>
</ol>
<p><code>#define INCLUDE_vTaskDelayUntil 1</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_4.webp" alt=""></p>
<p><strong>③ 函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> TickType_t <span class="title function_">xTaskGetTickCount</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_2.webp" alt=""></p>
<p><strong>函数描述：</strong>函数 <code>xTaskGetTickCount</code>用于获取系统当前运行的时钟节拍数。</p>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数用于在任务代码里面调用，如果在中断服务程序里面调用的话，需要使用函数<code>xTaskGetTickCountFromISR</code>，这两个函数切不可混用。</p>
</blockquote>
<p><strong>④ 函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> TickType_t <span class="title function_">xTaskGetTickCountFromISR</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_3.webp" alt=""></p>
<p><strong>函数描述：</strong>函数 <code>xTaskGetTickCountFromISR</code>用于获取系统当前运行的时钟节拍数。</p>
<p>使用这个函数要注意以下问题：</p>
<p>1.此函数用于在中断服务程序里面调用，如果在任务里面调用的话，需要使用函数 <code>xTaskGetTickCount</code>，这两个函数切不可混用。</p>
<h2 id="对延时与绝对延时的区别与编程测试"><a href="#对延时与绝对延时的区别与编程测试" class="headerlink" title="对延时与绝对延时的区别与编程测试"></a>对延时与绝对延时的区别与编程测试</h2><p>1、问题：周期性去处理某一件事情。你会通过什么方式去实现？</p>
<p>比如：间隔10ms去采集传感器的数据，然后通过一种算法计算出一个结果，最后通过串口发送出去。对于裸机编程，首先想到的是：利用定时器，定时10ms中断，在中断里面处理。但中断函数适合处理简单数据，要求快进快出，不适合算法、通信等需要长时间占用CPU的处理。对计时精度要求比较高的地方适合定时器，像本节说的周期性采集传感器数据，要求不适合很高，那么就引入本文说的绝对延时。</p>
<blockquote>
<p>相对延时：指每次延时都是从执行函数vTaskDelay()开始，直到延时指定的时间（参数：滴答值）结束。</p>
<p>绝对延时：指间隔指定的时间（参数：滴答值），执行一次调用vTaskDelayUntil()函数的任务。</p>
</blockquote>
<p>3、通过编程测试相对延时和绝对延时的区别</p>
<p>创建2个任务，情况如下：</p>
<p>任务1：HAL_Delay延时50ms，模拟传感器采集数据与被中断或高优先级任务打断的时间，printf打印任务运行次数，再通过<code>vTaskDelay</code>相对延时200ms；</p>
<p>任务2：HAL_Delay延时50ms，模拟传感器采集数据与被中断或高优先级任务打断的时间，printf打印任务运行次数，再通过<code>vTaskDelayUntil</code>就绝对延时200ms；</p>
<p>实验分析：</p>
<p>任务1由于采用相对延时，printf间隔250ms(50ms+200ms)打印信息</p>
<p>任务2由于采用绝对延时，printf间隔200ms(50ms+150ms)打印信息</p>
<p><strong>疑问：</strong>为什么采用绝对延时，printf间隔为50ms+<strong>150ms</strong>。  </p>
<p><strong>解答：</strong>任务执行时，先花50ms执行模拟采集数据与被中断或高优先级任务打断的时间， 接着，调用<code>vTaskDelayUntil</code>, 此函数会根据第 1 个实参(存储任务最后一次解除阻塞的时间)与当前系统时间计算出模拟采集数据与被中断或高优先级任务打断的50ms时间，此时只延时200ms-50ms=150ms，以确保任务周期性执行，所以<code>vTaskDelayUntil</code>实际只阻塞了150ms。</p>
<p>&lt;串口打印信息&gt;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree8_1.webp" alt="image-20231130200641421"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><code>注</code>：把宏定义修改成1 <code>#define INCLUDE_vTaskDelayUntil 1</code> 不然使用不了函数，前面有说。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">osThreadDef</span>(LED1, LED1_Task, osPriorityBelowNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED1Handle = <span class="built_in">osThreadCreate</span>(<span class="built_in">osThread</span>(LED1), <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">osThreadDef</span>(LED2, LED2_Task, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED2Handle = <span class="built_in">osThreadCreate</span>(<span class="built_in">osThread</span>(LED2), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED1_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED1_Task */</span></span><br><span class="line">  <span class="type">uint16_t</span> Task1_Cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//模拟传感器采集数据与被中断或高优先级任务打断的时间</span></span><br><span class="line">		<span class="built_in">HAL_Delay</span>(<span class="number">50</span>);</span><br><span class="line">		LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line">		<span class="comment">//打印任务运行次数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;任务一执行次数：%u\r\n&quot;</span>,++Task1_Cnt);</span><br><span class="line">		<span class="comment">//相对延时200ms</span></span><br><span class="line">		<span class="built_in">osDelay</span>(<span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED1_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED2_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED2_Task */</span></span><br><span class="line"> portTickType PreviousWakeTime;</span><br><span class="line">  <span class="type">uint16_t</span> Task2_Cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//获取当前系统时间</span></span><br><span class="line">	PreviousWakeTime = <span class="built_in">xTaskGetTickCount</span>();</span><br><span class="line">	<span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//模拟传感器采集数据与被中断或高优先级任务打断的时间</span></span><br><span class="line">		<span class="built_in">HAL_Delay</span>(<span class="number">50</span>);</span><br><span class="line">	  LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line">		<span class="comment">//打印任务运行次数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;任务二执行次数：%u\r\n&quot;</span>,++Task2_Cnt);</span><br><span class="line">		<span class="comment">//绝对延时200ms</span></span><br><span class="line">		<span class="built_in">osDelayUntil</span>(&amp;PreviousWakeTime,<span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED2_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="链表-数据结构"><a href="#链表-数据结构" class="headerlink" title="链表(数据结构)"></a>链表(数据结构)</h1><h2 id="链表简述"><a href="#链表简述" class="headerlink" title="链表简述"></a>链表简述</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针</strong>链接次序实现的。链表由一系列节点（链表中每一个元素称为节点）组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p>
<p>链表作为C语言的一种基础数据结构，在平时写程序中用得并不多，但在操作系统中使用得非常多。如果需要读懂FreeRTOS系统的源码，必须弄懂链表，如果只是应用FreeRTOS系统，简要了解即可。</p>
<p>如下图：链表好比一个圆形的晾衣架，晾衣架上有很多钩子，钩子首尾相连；链表也是，链表由节点组成，节点与节点之间也是首尾相连。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_1.webp" alt=""></p>
<p>晾衣架的钩子本身不能代表很多东西，但钩子却可以挂载很多东西；同样，链表也类似，链表的节点本身不能储存很多内容，但节点跟晾衣架的钩子一样，可以挂载很多数据。</p>
<p>另外，链表分为单向链表与双向链表，单向链表很少用，用得较多的是双向链表。</p>
<h2 id="单向链表与双向链表"><a href="#单向链表与双向链表" class="headerlink" title="单向链表与双向链表"></a>单向链表与双向链表</h2><p>1、单向链表</p>
<p>单向链表如下图，该链表中共有n个节点，前一个节点都有一个指针指向后一个节点，首尾相连，组成一个圈。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_2.webp" alt=""></p>
<p>2、双链链表</p>
<p>双向链表如下图，该链表中共有n个节点，前一个节点都有两个指针分别指向前后节点，首尾相连，组成一个圈。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_3.webp" alt=""></p>
<p>3、链表与数组的差异</p>
<p>链表是通过节点把离散的数据(比如操作系统中任务)链接成一个表，通过对节点的插入与删除操作实现对数据的储存。 而数组是通过开辟一段连续的内存来储存数据，这是数组与链表的最大区别。</p>
<h2 id="FreeRTOS中链表实现代码"><a href="#FreeRTOS中链表实现代码" class="headerlink" title="FreeRTOS中链表实现代码"></a>FreeRTOS中链表实现代码</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对应C语言中的链表与节点。</p>
<p>1、列表项定义</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_4.webp" alt=""></p>
<p>列表项结构体参数含义如下：</p>
<blockquote>
<ul>
<li>用于检测列表数据是否完整</li>
<li>辅助值(比如用于任务的优先级)，用于帮助节点进行顺序排列</li>
<li>指向下一个节点的指针</li>
<li>指向上一个节点的指针</li>
<li>指向拥有该节点的内核对象，通常是TCB(任务控制块/任务句柄)</li>
<li>指向该节点所在的链表</li>
<li>用于检测列表数据是否完整</li>
</ul>
</blockquote>
<p>2、列表定义</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_5.webp" alt=""></p>
<p>列表结构体参数含义如下：</p>
<blockquote>
<ul>
<li>用于检测列表数据是否完整</li>
<li>链表节点计数器，用于记录该链表下有多少个节点，根节点除外</li>
<li>链表节点索引指针，用于遍历节点</li>
<li>链表最后一个节点。 链表是一个圈，首尾相连的，首就是尾，尾也是首。 从字面理解就是链表的最后一个节点，其实也是链表的第一个节点，称之为生产者。 该生产者的数据类型是一个精简的节点，具体如下图。</li>
<li>用于检测列表数据是否完整</li>
</ul>
</blockquote>
<p>节点(列表项)精简定义：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_6.webp" alt=""></p>
<h2 id="链表与节点初始化函数"><a href="#链表与节点初始化函数" class="headerlink" title="链表与节点初始化函数"></a>链表与节点初始化函数</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对C语言中的链表与节点。</p>
<p>1、列表项初始化函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_7.webp" alt=""></p>
<p>说明：</p>
<p>列表项初始化，只需将<code>pvContainer</code>初始化为NULL即可，表示该节点还没有插入到任何链表。 初始化后如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_8.webp" alt=""></p>
<p>2、列表初始化函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_9.webp" alt=""></p>
<p>说明：</p>
<p>列表初始化，主要初始化索引指针，链表计数值，与内部精简列表项。初始化后如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_10.webp" alt=""></p>
<h2 id="链表操作函数-尾部插入、升序插入、移除"><a href="#链表操作函数-尾部插入、升序插入、移除" class="headerlink" title="链表操作函数(尾部插入、升序插入、移除)"></a>链表操作函数(尾部插入、升序插入、移除)</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对应C语言中的链表与节点。</p>
<p>1、将节点插入链表尾部</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_11.webp" alt=""></p>
<p>分析如下：</p>
<blockquote>
<ul>
<li>将新节点的<code>pxNext</code>指向根节点内的精简节点；</li>
<li>将新节点的<code>pxPrevious</code>指向之前的最后一个节点；</li>
<li>将之前最后一个节点的<code>pxNext</code>指向新节点；</li>
<li>将根节点内的精简节点<code>pxPrevious</code>指向新节点；</li>
<li>新节点的<code>pvContaner</code>指向链表；</li>
<li>链表的节点计数值加1</li>
</ul>
</blockquote>
<p>尾部插入详情如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_12.webp" alt=""></p>
<p>2、将节点按照升序插入链表</p>
<p>说明：如果两个节点的辅助值相同，则新节点在旧节点的后面插入。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_13.webp" alt=""></p>
<p>分析如下：</p>
<blockquote>
<ul>
<li>查找插入位置；</li>
<li>调整指向关系</li>
<li>新节点的pvContaner指向链表；</li>
<li>链表的节点计数值加1</li>
</ul>
</blockquote>
<p>升序插入详情如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_14.webp" alt=""></p>
<p>3、移除节点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_15.webp" alt=""></p>
<p>分析如下：</p>
<blockquote>
<ul>
<li>通过节点获取链表；</li>
<li>调整指向关系</li>
<li>调整链表的索引指针</li>
<li>将删除节点的<code>pvContainer</code>指向NULL；</li>
<li>链表的节点计数值减1</li>
<li>返回链表的节点计数值</li>
</ul>
</blockquote>
<p>移除详情如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_16.webp" alt=""></p>
<h2 id="链表编程测试"><a href="#链表编程测试" class="headerlink" title="链表编程测试"></a>链表编程测试</h2><p><strong>说明：</strong>软件模拟仿真</p>
<p>1、只创建1个任务，在任务中进行链表测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_17.webp" alt=""></p>
<p>2、列表与列表项定义</p>
<p>说明：watch中查看变量值，需要定义为全局变量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_18.webp" alt=""></p>
<p>3、任务1代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_19.webp" alt=""></p>
<p>4、设置为模拟仿真，避免仿真错误，删除硬件相关的初始化代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_20.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_21.webp" alt=""></p>
<p>5、增加断点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_22.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_23.webp" alt=""></p>
<p>6、开始仿真，并在watch添加列表与列表项</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_24.webp" alt=""></p>
<p>7、全速仿真至任务1，再按F10单步执行，同时查看watch窗口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_25.webp" alt=""></p>
<p>8、验证OK。</p>
<hr>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h2><p>1、消息队列的基本概念</p>
<p>消息队列简称队列，是一种常用于任务间通信的数据结构。</p>
<p>如下图：消息队列可以在任务与任务间、中断与任务间传递消息，实现任务接收来自其它任务或中断的不固定长度的消息。</p>
<p> &lt;队列用于任务与任务间&gt;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_1.webp" alt=""></p>
<p>&lt;队列用于任务与中断间&gt;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_2.webp" alt=""></p>
<p>相比于裸机的全局数组，使用消息队列有如下优势：</p>
<blockquote>
<ul>
<li>消息队列具有超时机制，可以让 FreeRTOS 内核有效地管理任务</li>
<li>使用消息队列可以防止多任务的访问冲突</li>
<li>使用消息队列可以有效地解决中断服务程序与任务之间消息传递的问题，使用全局数组的话，任务得不断去监测标志位以获取数据</li>
<li>消息队列具有FIFO与LIFO储存机制，方便处理数据</li>
</ul>
</blockquote>
<p>2、消息队列的通信机制</p>
<p>消息队列是一种<code>异步</code>的通信方式。</p>
<p>任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务将被阻塞。用户可以指定阻塞的任务时间 <code>xTicksToWait</code>，在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过指定的阻塞时间，即使队列中没有有效数据，任务也会自动从阻塞态转为就绪态。</p>
<p>通过消息队列服务，任务或中断服务可以将一条或多条消息放入消息队列中。同样，一个或多个任务可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常是将先进入消息队列的消息先传给任务，也就是说，任务先得到的是最先进入消息队列的消息，即先进先出原则(<code>FIFO</code>)，FreeRTOS的队列也支持后进先出原则(<code>LIFO</code>)。</p>
<p>3、FreeRTOS中消息队列特性</p>
<blockquote>
<ul>
<li>消息支持先进先出方式排队，支持异步读写工作方式</li>
<li>读写队列均支持超时机制</li>
<li>消息支持后进先出方式排队，向队首发送消息(LIFO)</li>
<li>可以允许不同长度(不超过队列节点最大值)的任意类型消息</li>
<li>一个任务能够从任意一个消息队列接收和发送消息</li>
<li>多个任务能够从同一个消息队列接收和发送消息</li>
<li>当队列使用结束后，可以通过删除队列函数进行删除</li>
</ul>
</blockquote>
<p>4、消息队列运作流程图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_3.webp" alt=""></p>
<p>5、消息队列应用场景</p>
<p>消息队列可用于发送不定长消息的场合。</p>
<p>队列是FreeRTOS 主要的任务间通信方式，可以在任务与任务间、中断和任务间传送信息，发送到队列的消息是通过<strong>复制方式</strong>实现的，这意味着队列存储的数据是原始数据，而不是原始数据的引用。</p>
<h2 id="消息队列常用API函数"><a href="#消息队列常用API函数" class="headerlink" title="消息队列常用API函数"></a>消息队列常用API函数</h2><p>消息队列全部API函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_4.webp" alt=""></p>
<p>使用消息队列的典型流程如下：</p>
<blockquote>
<ul>
<li>创建消息队列</li>
<li>发送消息队列</li>
<li>读取消息队列</li>
<li>删除消息队列</li>
</ul>
</blockquote>
<p>常用API函数如下：</p>
<blockquote>
<ul>
<li><code>xQueueCreate</code>()</li>
<li><code>xQueueSend</code>() 与 <code>xQueueSendFromISR</code>()</li>
<li><code>xQueueReceive</code>()</li>
<li><code>vQueueDelete</code>()</li>
</ul>
</blockquote>
<h2 id="消息队列创建与删除"><a href="#消息队列创建与删除" class="headerlink" title="消息队列创建与删除"></a>消息队列创建与删除</h2><p>1、消息队列控制块(句柄)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_5.webp" alt=""></p>
<p>说明：句柄中的各个成员，稍微了解即可，Keil工程中有详细注释</p>
<p>2、队列创建</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreate</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxQueueLength, <span class="comment">//队列长度，即消息个数   </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxItemSize )</span></span>; <span class="comment">//类目大小，即消息大小，单位字节</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xQueueCreate</code>用于创建消息队列</p>
<p> 第 1 个参数是消息队列支持的消息个数</p>
<p> 第 2 个参数是每个消息的大小，单位字节</p>
<p> 返回值，如果创建成功会返回消息队列的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此消息队列提供所需的空间会返回 NULL</p>
<p><strong>队列创建示意图：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_6.webp" alt=""></p>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_7.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_8.webp" alt=""></p>
<p>3、队列删除</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vQueueDelete</span><span class="params">( QueueHandle_t xQueue)</span></span>; <span class="comment">//队列句柄 </span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vQueueDelete</code>用于删除消息队列</p>
<p> 第 1 个参数是需要删除的消息队列句柄</p>
<p>说明：</p>
<p>消息队列删除后，系统会清空此队列的全部消息，且不能再次使用此队列。     </p>
<h2 id="任务中消息队列发送"><a href="#任务中消息队列发送" class="headerlink" title="任务中消息队列发送"></a>任务中消息队列发送</h2><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( </span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">/* 要传递数据地址 */</span> </span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait` <span class="comment">/* 等待消息队列有空间的最大等待时间 */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xQueueSend</code>用于任务中消息发送。 </p>
<blockquote>
<ul>
<li>第 1 个参数是消息队列句柄</li>
<li>第 2 个参数要传递数据地址，每次发送都是将消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大 小复制到消息队列空间中</li>
<li>第 3 个参数是当消息队列已经满时，等待消息队列有空间时的最大等待时间，单位系统时钟节拍</li>
<li>返回值，如果消息成功发送返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code></li>
</ul>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。</p>
<p> 此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xQueueSendFromISR</code>。</p>
<p>如果消息队列已经满且第三个参数为 0，那么此函数会立即返回。</p>
<p> 如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第三个参数配置为 <code>portMAX_DELAY</code>，那么此发送函数会永久等待直到消息队列有空间可以使用。</p>
<p> 消息队列还有两个函数 <code>xQueueSendToBack</code>和 <code>xQueueSendToFront</code>，函数 <code>xQueueSendToBack</code>实现的是 FIFO 方式的存取，函数 <code>xQueueSendToFront</code>实现的是 LIFO 方式的读写。我们这里说的函数 <code>xQueueSend</code>等效于 <code>xQueueSendToBack</code>，即实现的是 FIFO 方式的存取。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_9.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_10.webp" alt=""></p>
<h2 id="中断中消息队列发送"><a href="#中断中消息队列发送" class="headerlink" title="中断中消息队列发送"></a>中断中消息队列发送</h2><p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span> <span class="params">( </span></span><br><span class="line"><span class="params">	QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,  <span class="comment">/* 要传递数据地址 */</span> </span></span><br><span class="line"><span class="params">    BaseType_t * pxHigherPriorityTaskWoken <span class="comment">/* 高优先级任务是否被唤醒的状态保存 */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xQueueSendFromISR</code>用于中断服务程序中消息发送。 </p>
<blockquote>
<p>第 1 个参数是消息队列句柄。 </p>
<p>第 2 个参数要传递数据地址，每次发送都是将消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大 小复制到消息队列空间中。</p>
<p> 第 3 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p>
<p> 返回值，如果消息成功发送返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。正因为这个原因，用户在创建消息队列时单个消息大小不可太大，因为一定程度上面会增加中断服务程序的执行时间。</p>
</li>
<li><p>此函数是用于中断服务程序中调用的，故不可以在任务代码中调用此函数，任务代码中使用的是<code>xQueueSend</code>。</p>
</li>
<li><p>消息队列还有两个函数 <code>xQueueSendToBackFromISR</code>和 <code>xQueueSendToFrontFromISR</code>，函数<code>xQueueSendToBackFromISR</code>实现的是 FIFO 方式的存取，函数 <code>xQueueSendToFrontFromISR</code>实现的是 <code>LIFO</code>方式的读写。我们这里说的函数 <code>xQueueSendFromISR</code>等效于<code>xQueueSendToBackFromISR</code>，即实现的是 <code>FIFO</code>方式的存取。</p>
</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_11.webp" alt=""></p>
<h2 id="消息队列接收"><a href="#消息队列接收" class="headerlink" title="消息队列接收"></a>消息队列接收</h2><p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xQueueReceive</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">	QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * pvBuffer, <span class="comment">/* 接收消息队列数据的缓冲地址 */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    TickType_t xTicksToWait <span class="comment">/* 等待消息队列有数据的最大等待时间 */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong>函数 <code>xQueueReceive</code>用于接收消息队列中的数据。 </p>
<blockquote>
<p>第 1 个参数是消息队列句柄。 </p>
<p>第 2 个参数是从消息队列中复制出数据后所储存的缓冲地址，缓冲区空间要大于等于消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大小，否则取出的数据无法全部存储到缓冲区，从而造成内存溢出。</p>
<p>第 3 个参数是消息队列为空时，等待消息队列有数据的最大等待时间，单位系统时钟节拍。 </p>
<p>返回值，如果接到到消息返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xQueueReceiveFromISR</code>。</p>
<p>如果消息队列为空且第三个参数为 0，那么此函数会立即返回。</p>
<p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第三个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到消息队列有数据。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_12.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_13.webp" alt=""></p>
<h2 id="消息队列应用编程-任务与任务"><a href="#消息队列应用编程-任务与任务" class="headerlink" title="消息队列应用编程 - 任务与任务"></a>消息队列应用编程 - 任务与任务</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree10_1.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_14.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_15.webp" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义队列变量</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t xQueue1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> QueueHandle_t xQueue2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">xQueue1 = <span class="built_in">xQueueCreate</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (xQueue1 == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列1失败\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列1成功\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xQueue2 = <span class="built_in">xQueueCreate</span>(<span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (xQueue2 == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列2失败\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列2成功\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulReceiveBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(xQueue1, &amp;ucRec_Data, ulReceiveBlockTime) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列1的数据：%u\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收消息队列1的数据超时！！！\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue2_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue2_Receive_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> ucRec_Data[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(xQueue2, ucRec_Data, portMAX_DELAY) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列2的字符串: %s\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue2_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>];</span><br><span class="line">  <span class="type">uint32_t</span> ucSend_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulSendBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue1, &amp;ucSend_Data, ulSendBlockTime) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列1发送数据：%u\r\n&quot;</span>, ucSend_Data);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列1发送数据出现超时！！！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      ucSend_Data += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue2, <span class="string">&quot;MCU1111111\r\n&quot;</span>, <span class="number">0</span>) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列2发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;MCU1111111&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列2发送字符串出现超时!!!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue2, <span class="string">&quot;yjjy1111111\r\n&quot;</span>, <span class="number">0</span>) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列2发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;yjjy1111111&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列2发送字符串出现超时!!!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="消息队列应用编程-中断与任务"><a href="#消息队列应用编程-中断与任务" class="headerlink" title="消息队列应用编程 - 中断与任务"></a>消息队列应用编程 - 中断与任务</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree10_2.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_16.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_17.webp" alt=""></p>
<ul>
<li>串口回调函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>	ucUART3_Rec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(huart-&gt;Instance == huart3.Instance)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//测试用</span></span><br><span class="line">		LED.<span class="built_in">LED_Flip</span>(LED3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列1发送数据		</span></span><br><span class="line">		<span class="built_in">xQueueSendFromISR</span>(myQueue01Handle, ucUART3_Rec_Data, &amp;xHigherPriorityTaskWoken);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果有高优先级任务就绪，执行一次任务切换</span></span><br><span class="line">		<span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//继续通过串口3中断接收10个字符</span></span><br><span class="line">		<span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>消息队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>	ucUART3_Rec_Data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> ucRec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">//通过串口3中断接收10个字符</span></span><br><span class="line">	<span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">	<span class="keyword">for</span>(;;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">xQueueReceive</span>(myQueue01Handle, ucRec_Data, portMAX_DELAY) == pdPASS)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列1的数据：%s\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h1><h2 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p>
<p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p>
<p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p>
<p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p>
<p>信号量是一个非负正数，<code>二值信号量</code>与<code>互斥信号量</code>取值范围为0-1，<code>计数信号量</code>取值范围是0-N(N&gt;1)</p>
<p><strong>0：</strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</p>
<p><strong>正数：</strong>表示有一个或多个信号量供获取</p>
<p>2、信号量的分类</p>
<blockquote>
<p>二值信号量(重点讲解同步应用)</p>
<p>计数信号量(重点讲解资源管理)</p>
<p>互斥信号量(重点讲解互斥访问)</p>
<p>递归互斥信号量(简要了解即可)</p>
</blockquote>
<h2 id="二值信号量的定义与应用"><a href="#二值信号量的定义与应用" class="headerlink" title="二值信号量的定义与应用"></a>二值信号量的定义与应用</h2><p>1、二值信号量的定义</p>
<p>当信号量被获取了，信号量值变为0；当信号量被释放了，信号量值变为1。 把这种取值只有0与1两种状态的信号量称之为二值信号量。</p>
<p>创建二值信号量时，系统会为创建的二值信号量分配内存，二值信号量创建完成后的示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_1.webp" alt=""></p>
<p>从上图可以看出，二值信号量是一种长度为1，消息大小为0的特殊消息队列。 </p>
<p>因为这个队列只有空或满两种状态，而且消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p>
<p>2、二值信号量的应用</p>
<p>在嵌入式操作系统中，二值信号量是任务与任务或任务与中断间同步的重要手段。</p>
<p>Note：</p>
<p><strong>二值信号量也可以用于临界资源的访问，但不建议，因为存在任务优先级翻转问题，这个将在下一讲的互斥信号量(具有优先级继承机制)中进行详细讲解。</strong></p>
<p><strong>任务与任务中同步的应用场景:</strong></p>
<p>假设有一个温湿度传感器，每1s采集一次数据，那么让它在液晶屏中显示数据，这个周期也是1s，如果液晶屏刷新的周期是100ms，那么此时的温湿度数据还没更新，液晶屏根本无须刷新，只需要在1s后温湿度数据更新时刷新即可，否则CPU就是白白做了多次的无效数据更新操作，造成 CPU 资源浪费。如果液晶屏刷新的周期是 10s，那么温湿度的数据都变化了10次，液晶屏才来更新数据，那么这个产品测得的结果就是不准确的，所以还是需要同步协调工作，在温湿度采集完毕之后进行液晶屏数据的刷新，这样得到的结果才是最准确的，并且不会浪费 CPU 的资源。</p>
<p><strong>任务与中断中同步的应用场景:</strong></p>
<p>在串口接收中，我们不知道什么时候有数据发送过来，但如果设置一个任务专门时刻查询是否有数据到来，将会浪费CPU资源，所以在这种情况下使用二值信号量是很好的办法：当没有数据到来时，任务进入阻塞态，不参与任务的调度;等到数据到来了，释放一个二值信号量，任务就立即从阻塞态中解除，进入就绪态，然后在运行时处理数据，这样系统的资源就会得到很好的利用。</p>
<h2 id="二值信号量的运作机制"><a href="#二值信号量的运作机制" class="headerlink" title="二值信号量的运作机制"></a>二值信号量的运作机制</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_2.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<ul>
<li><p>创建 2 个任务 Task1 和 Task2。 </p>
</li>
<li><p>创建二值信号量默认的初始值是 0，也就是没有可用资源。</p>
</li>
</ul>
<p><strong>运行过程描述如下：</strong></p>
<p>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，但是由于创建二值信号的初始值是 0，没有信号量可以用，任务 Task1 将由运行态转到阻塞状态。运行的过程中，任务 Task2 通过函数 <code>xSemaphoreGive</code>释放信号量，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态，实现Task1与Task2的同步功能。</p>
<p><strong>上面就是一个简单的 FreeRTOS 任务间二值信号量的同步使用过程。</strong></p>
<p>2、FreeRTOS 中断方式二值信号量的实现</p>
<p>FreeRTOS 中断方式二值信号量的实现是指中断与任务间使用信号量实现同步功能。下面我们通过如下的框图来说明一下 FreeRTOS 中断方式二值信号量的实现，让大家有一个形象的认识。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_3.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<ul>
<li><p>创建 1 个任务 Task1 和一个串口接收中断。 </p>
</li>
<li><p>二值信号量的初始值为 0，串口中断调用函数 <code>xSemaphoreGiveFromISR</code>释放信号量，任务 Task1调用函数 <code>xSemaphoreTake</code>获取信号量资源。</p>
</li>
</ul>
<p><strong>运行过程描述如下：</strong></p>
<p>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>，由于信号量的初始值是 0，没有信号量资源可用，任务 Task1 由运行态进入到阻塞态。</p>
<p>Task1 阻塞的情况下，串口接收到数据进入到了串口中断服务程序，在串口中断服务程序中调用函数<code>xSemaphoreGiveFromISR</code>释放信号量资源，信号量数值加 1，此时信号量计数值为 1，任务 Task1由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态，任务 Task1 获得信号量后，信号量数值减 1，此时信号量计数值又变成了 0。 </p>
<p>再次循环执行时，任务 Task1 调用函数 <code>xSemaphoreTake</code>由于没有资源可用再次进入到挂起态，等待串口释放二值信号量资源，如此往复循环。</p>
<p><strong>上面就是一个简单的 FreeRTOS 中断方式二值信号量同步过程。</strong></p>
<p>实际应用中，中断方式的消息机制要注意以下四个问题：</p>
<blockquote>
<p>中断函数的执行时间越短越好，防止其它低于这个中断优先级的异常不能得到及时响应</p>
<p>实际应用中，建议不要在中断中实现消息处理，用户可以在中断服务程序里面发送消息通知任务，在任务中实现消息处理，这样可以有效地保证中断服务程序的实时响应。同时此任务也需要设置为高优先级，以便退出中断函数后任务可以得到及时执行</p>
<p>中断服务程序中一定要调用专用于二值信号量设置函数，即以 <code>FromISR</code>结尾的函数</p>
<p>如果 FreeRTOS 工程的中断函数中调用了 FreeRTOS 的二值信号量的 API 函数，退出的时候要检测是否有高优先级任务就绪，如果有就绪的，需要在退出中断后进行任务切换</p>
</blockquote>
<h2 id="二值信号量常用的API函数"><a href="#二值信号量常用的API函数" class="headerlink" title="二值信号量常用的API函数"></a>二值信号量常用的API函数</h2><p> 1、使用二值信号量的典型流程如下：</p>
<blockquote>
<p>创建二值信号量</p>
<p>释放二值信号量</p>
<p>获取二值信号量</p>
<p>删除二值信号量</p>
</blockquote>
<p>2、常用API函数如下：</p>
<blockquote>
<p><code>xSemaphoreCreateBinary</code>()</p>
<p><code>xSemaphoreGive</code>() 与 <code>xSemaphoreGiveFromISR</code>() </p>
<p><code>xSemaphoreTake</code>()</p>
<p><code>vSemaphoreDelete</code>()</p>
</blockquote>
<p>3、二值信号量创建与删除</p>
<ul>
<li>二值信号量控制块(句柄)</li>
</ul>
<p>如下图：二值信号量的句柄为消息队列的句柄，因为二值信号量是一种长度为1，消息大小为0的特殊消息队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_4.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_5.webp" alt=""></p>
<ul>
<li>二值信号量创建</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateBinary</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreCreateBinary</code>用于创建二值信号量。 </p>
<p>返回值，如果创建成功会返回二值信号量的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此二值信号量提供所需的空间会返回 NULL。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_6.webp" alt=""></p>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_7.webp" alt=""></p>
<ul>
<li>二值信号量删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vSemaphoreDelete</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vSemaphoreDelete</code>可用于删除二值信号量。 </p>
<p>4、任务中二值信号量释放</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreGive</span>( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 *</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreGive</code>用于在任务代码中释放信号量。</p>
<p>第 1 个参数是信号量句柄。</p>
<p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xSemaphoreGiveFromISR</code>。</p>
<p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p>
<p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_8.webp" alt=""></p>
<p>5、中断中二值信号量释放</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGiveFromISR ( </span><br><span class="line">    SemaphoreHandle_t xSemaphore`, <span class="comment">/* 信号量句柄 */</span></span><br><span class="line">	<span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken <span class="comment">/* 高优先级任务是否被唤醒的状态保存 */</span> )</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreGiveFromISR</code>用于中断服务程序中释放信号量。</p>
<blockquote>
<p>第 1 个参数是信号量句柄。</p>
<p>第 2 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p>
<p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数是基于消息队列函数 <code>xQueueGiveFromISR</code>实现的：</p>
<p><code>`#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken ) \xQueueGiveFromISR( ( QueueHandle_t )( xSemaphore ), ( pxHigherPriorityTaskWoken ))</code></p>
<p>此函数是用于中断服务程序中调用的，故不可以任务代码中调用此函数，任务代码中中使用的是<code>xSemaphoreGive</code>。</p>
<p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>()或者 <code>xSemaphoreCreateCounting</code>()创建了信号量。</p>
<p>此函数不支持使用 <code>xSemaphoreCreateMutex</code>()创建的信号量。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_9.webp" alt=""></p>
<p>6、二值信号量获取</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake( </span><br><span class="line">	SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">	TickType_t xTicksToWait )`; <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p>
<blockquote>
<p>第 1 个参数是信号量句柄。 </p>
<p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p>
<p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xSemaphoreTakeFromISR</code>。</p>
<p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p>
<p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_10.webp" alt=""></p>
<h2 id="二值信号量的应用编程-任务与任务"><a href="#二值信号量的应用编程-任务与任务" class="headerlink" title="二值信号量的应用编程 - 任务与任务"></a>二值信号量的应用编程 - 任务与任务</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_1.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_11.webp" alt=""></p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二值信号量</span></span><br><span class="line">osSemaphoreId xBinarySem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(xBinarySem,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收到二值信号量同步信号，次数 = %u\r\n\r\n&quot;</span>,++TakeCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span> </span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>];  <span class="comment">//保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> GiveCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送同步信号\r\n&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreGive</span>(xBinarySem);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功发送二值信号量同步信号，次数 = %u\r\n&quot;</span>,++GiveCnt);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送二值信号量同步信号失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>myinit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----二值信号量同步应用编程 - 任务与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：释放二值信号量，发送同步信号\r\n\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二值信号量的应用编程-中断与任务"><a href="#二值信号量的应用编程-中断与任务" class="headerlink" title="二值信号量的应用编程 - 中断与任务"></a>二值信号量的应用编程 - 中断与任务</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_2.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_3.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_12.webp" alt=""></p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>	ucUART3_Rec_Data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,<span class="number">0</span>); <span class="comment">//STM32CubeMX生成的FreeRTOS代码创建二值信号量时，默认为1，此处释放，避免串口误同步</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//通过串口3中断接收10个字符</span></span><br><span class="line">	  <span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line">		xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,portMAX_DELAY);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;成功接受到二值信号量同步信,次数 = %u\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;接收到的串口数据：%s\r\n\r\n&quot;</span>, ucUART3_Rec_Data);</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>CallBack.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>	ucUART3_Rec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> osSemaphoreId myBinarySem01Handle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(huart-&gt;Instance == huart3.Instance)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//测试用</span></span><br><span class="line">		LED.<span class="built_in">LED_Flip</span>(LED3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送同步信号</span></span><br><span class="line">		<span class="built_in">xSemaphoreGiveFromISR</span>(myBinarySem01Handle, &amp;xHigherPriorityTaskWoken);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果有高优先级任务就绪，执行一次任务切换</span></span><br><span class="line">		<span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken);</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----二值信号量同步应用编程 - 中断与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;通过RS-485接口向队列1发送10个字符\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">HAL_GPIO_WritePin</span>(RS485_DE_nRE_GPIO_Port,RS485_DE_nRE_Pin,GPIO_PIN_SET);</span><br><span class="line">	<span class="built_in">HAL_UART_Transmit</span>(&amp;huart3, (<span class="type">uint8_t</span> *)<span class="string">&quot;通过RS-485接口向队列1发送10个字符\r\n&quot;</span>,<span class="number">33</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">HAL_GPIO_WritePin</span>(RS485_DE_nRE_GPIO_Port,RS485_DE_nRE_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h1><h2 id="信号量的概念-1"><a href="#信号量的概念-1" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p>
<blockquote>
<p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p>
<p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p>
<p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p>
<p>信号量是一个非负正数，二值信号量与互斥信号量取值范围为0-1，计数信号量取值范围是0-N(N&gt;1)</p>
<p>0：<strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</strong></p>
<p><strong>正数：</strong>表示有一个或多个信号量供获取</p>
</blockquote>
<p>2、信号量的分类</p>
<p>二值信号量(重点讲解同步应用)</p>
<p>计数信号量(重点讲解资源管理)</p>
<p>互斥信号量(重点讲解互斥访问)</p>
<p>递归互斥信号量(简要了解即可)</p>
<h2 id="计数信号量的定义与应用"><a href="#计数信号量的定义与应用" class="headerlink" title="计数信号量的定义与应用"></a>计数信号量的定义与应用</h2><p>1、计数信号量的定义</p>
<blockquote>
<p>取值只有0与1两种状态的信号量称之为二值信号量</p>
<p>取值大于1的信号量称之为计数信号量</p>
</blockquote>
<p><strong>Note：</strong></p>
<blockquote>
<p>计数信号量的取值也可以为1，但通常大于1，如果取值为1，相当于只有0与1两种状态，用二值信号量即可。</p>
</blockquote>
<p>创建计数信号量时，系统会为创建的计数信号量分配内存，计数信号量创建完成后的示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_1.webp" alt=""></p>
<p>从上图可以看出，计数信号量是一种长度大于1，消息大小为0的特殊消息队列。 </p>
<p>因为这个队列的消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p>
<p>2、计数信号量的应用</p>
<p>在嵌入式操作系统中，技术信号量是资源管理的重要手段，主要用于任务与任务间。</p>
<p><strong>应用场景:</strong></p>
<p>计数信号量允许多个任务对其进行操作，但限制了任务的数量。比如有一个停车场，里面只有50个车位，那么只能停50辆车，相当于我们的信号量有50 个。假如一开始停车场的车位还有50个，那么每进去一辆车就要消耗一个停车位，车位的数量就要减1，相应地，我们的信号量在使用之后也需要减 1。当停车场停满了50 辆车时，此时的停车位数量为 0，再来的车就不能停进去了，否则将没法停车了，也相当于我们的信号量为0，后面的任务对这个停车场资源的访问也无法进行。当有车从停车场离开时，车位又空余出来了，那么后面的车就能停进去了。信号量操作也是一样的，当我们释放了这个资源，后面的任务才能对这个资源进行访问。</p>
<h2 id="计数信号量的运作机制"><a href="#计数信号量的运作机制" class="headerlink" title="计数信号量的运作机制"></a>计数信号量的运作机制</h2><p>FreeRTOS 任务间计数信号量的实现</p>
<p>任务间信号量的实现是指各个任务之间使用信号量实现任务的同步或者资源共享功能。下面我们通过如下的框图来说明一下 FreeRTOS 计数信号量的实现，让大家有一个形象的认识。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_2.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<blockquote>
<ul>
<li>创建 任务 Task1 和 Task2至N。 </li>
<li>创建计数信号量可用资源为N。</li>
</ul>
</blockquote>
<p><strong>运行过程描述如下：</strong></p>
<blockquote>
<ul>
<li>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，如果信号量大于0，Task1 将直接获取资源。如果信号量为0，任务 Task1 将由运行态转到阻塞状态，等待资源可用。一旦获取了资源并使用完毕后会通过函数 <code>xSemaphoreGive</code>释放掉资源。</li>
<li>任务 Task2至N 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，如果信号量大于0，Task2至N 将直接获取资源。如果信号量为0，任务 Task2至N将由运行态转到阻塞状态，等待资源可用。一旦获取了资源并使用完毕后会通过函数 <code>xSemaphoreGive</code>释放掉资源。</li>
</ul>
</blockquote>
<p><strong>上面就是一个简单的 FreeRTOS 任务间计数信号量的使用过程。</strong></p>
<h2 id="计数信号量常用的API函数"><a href="#计数信号量常用的API函数" class="headerlink" title="计数信号量常用的API函数"></a>计数信号量常用的API函数</h2><p>1、使用计数信号量的典型流程如下：</p>
<blockquote>
<p>创建计数信号量</p>
<p>释放计数信号量</p>
<p>获取计数信号量</p>
<p>删除计数信号量</p>
</blockquote>
<p>2、常用API函数如下：</p>
<blockquote>
<p><code>xSemaphoreCreateCounting</code>()</p>
<p><code>xSemaphoreGive</code>() 与 <code>xSemaphoreGiveFromISR</code>() </p>
<p><code>xSemaphoreTake</code>()</p>
<p><code>vSemaphoreDelete</code>()</p>
</blockquote>
<p>3、二值信号量创建与删除</p>
<ul>
<li>二值信号量控制块(句柄)</li>
</ul>
<p>如下图：计数信号量的句柄为消息队列的句柄，因为计数信号量是一种长度大于1，消息大小为0的特殊消息队列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_3.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_4.webp" alt=""></p>
<ul>
<li>计数信号量创建</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">/* 支持的最大计数值 */</span> </span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>`;  <span class="comment">/* 初始计数值 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreCreateCounting</code>用于创建计数信号量。 </p>
<blockquote>
<p>第 1 个参数是设置此计数信号量支持的最大计数值。 </p>
<p>第 2 个参数是设置计数信号量的初始值。</p>
<p>返回值，如果创建成功会返回消息队列的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此消息队列提供所需的空间会返回 <code>NULL</code></p>
</blockquote>
<p>说明：此函数基于消息队列函数实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_5.webp" alt=""></p>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_6.webp" alt=""></p>
<ul>
<li>计数信号量删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">(句柄)</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vSemaphoreDelete</code>可用于删除计数信号量。 </p>
<p>4、任务中计数信号量释放</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreGive</code>用于在任务代码中释放信号量。</p>
<ul>
<li><p>第 1 个参数是信号量句柄。</p>
</li>
<li><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p>
</li>
</ul>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xSemaphoreGiveFromISR</code>。</p>
</li>
<li><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p>
</li>
<li><p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p>
</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_7.webp" alt=""></p>
<p>5、中断中计数信号量释放</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGiveFromISR (</span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span></span><br><span class="line">  	<span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken <span class="comment">/*  高优先级任务是否被唤醒的状态保存 */</span> )</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreGiveFromISR</code>用于中断服务程序中释放信号量。</p>
<blockquote>
<p>第 1 个参数是信号量句柄。</p>
<p>第 2 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p>
<p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>此函数是基于消息队列函数 <code>xQueueGiveFromISR</code>实现的：</p>
<p> <code>#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken ) \xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )</code></p>
</li>
<li><p>此函数是用于中断服务程序中调用的，故不可以任务代码中调用此函数，任务代码中中使用的是<code>xSemaphoreGive</code>。</p>
</li>
<li><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>()或者 <code>xSemaphoreCreateCounting</code>()创建了信号量。</p>
</li>
<li><p>此函数不支持使用 <code>xSemaphoreCreateMutex</code>()创建的信号量。</p>
</li>
</ol>
</blockquote>
<p>6、计数信号量获取</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake(</span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p>
<blockquote>
<p>第 1 个参数是信号量句柄。 </p>
<p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p>
<p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xSemaphoreTakeFromISR</code>。</p>
</li>
<li><p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p>
</li>
<li><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p>
</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_8.webp" alt=""></p>
<h2 id="计数信号量的应用编程"><a href="#计数信号量的应用编程" class="headerlink" title="计数信号量的应用编程"></a>计数信号量的应用编程</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_10.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_11.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_12.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_13.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_14.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_15.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_9.webp" alt=""></p>
<p>我的代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> myCountingSem_ucMessagesWaiting = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,<span class="number">0</span>); <span class="comment">//STM32CubeMX生成的FreeRTOS代码创建二值信号量时，默认为1，此处释放，避免串口误同步</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (myCountingSem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建计数信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建计数信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无限等待同步信号更新显示，第%u次等待，等待中\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,portMAX_DELAY);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">	  </span><br><span class="line">	 <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">	 &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;现在还有%d个车位\r\n\r\n&quot;</span>,myCountingSem_ucMessagesWaiting);</span><br><span class="line">	 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;获取计数信号量，模拟车辆入库，申请停车位&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreTake</span>(myCountingSem01Handle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取成功，成功申请停车位，发送同步显示信号\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting--;</span><br><span class="line"><span class="comment">//		 printf(&quot;现在还有%d个车位\r\n&quot;,myCountingSem_ucMessagesWaiting);</span></span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取失败，停车位已满\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;释放计数信号量，模拟车辆出库，让出停车位&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreGive</span>(myCountingSem01Handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放成功，成功让出停车位，发送同步显示信号\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting++;</span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放失败，停车位以空&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>MyInit.c</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----计数信号量应用编程 - 模拟车库----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;默认车库可以停放20辆车，串口打印显示车位数量\r\n\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：获取信号量，模拟车辆入库，同时通过二值信号量发同步信号给显示任务\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：释放信号量，模拟车辆出库，同时通过二值信号量发同步信号给显示任务\r\n\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h1><h2 id="信号量的概念-2"><a href="#信号量的概念-2" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p>
<blockquote>
<p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p>
<p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p>
<p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p>
<p>信号量是一个非负正数，二值信号量与互斥信号量取值范围为0-1，计数信号量取值范围是0-N(N&gt;1)</p>
<p>0：<strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</strong></p>
<p><strong>正数：</strong>表示有一个或多个信号量供获取</p>
</blockquote>
<p>2、信号量的分类</p>
<p>二值信号量(重点讲解同步应用)</p>
<p>计数信号量(重点讲解资源管理)</p>
<p>互斥信号量(重点讲解互斥访问)</p>
<p>递归互斥信号量(简要了解即可)</p>
<h2 id="互斥信号量的定义与应用"><a href="#互斥信号量的定义与应用" class="headerlink" title="互斥信号量的定义与应用"></a>互斥信号量的定义与应用</h2><p>1、互斥信号量的定义</p>
<p>前面学过，取值只有0与1两种状态的信号量称之为二值信号量。 而互斥信号量是一种特殊的二值信号量，具有防止优先级翻转的特性。</p>
<p>创建互斥信号量时，系统会为创建的互斥信号量分配内存，<strong>互斥</strong>信号量创建完成后的示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_1.webp" alt=""></p>
<p>从上图可以看出，互斥信号量是一种长度为1，消息大小为0的特殊消息队列。 </p>
<p>因为这个队列只有空或满两种状态，而且消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p>
<p>2、互斥信号量的应用</p>
<p>在嵌入式操作系统中，互斥信号量用于临界资源的独占式访问，只能用于任务与任务间，因为其特有的优先级继承机制只能在任务中起作用，在中断的上下文环境毫无意义。</p>
<p><strong>应用场景:</strong></p>
<p>比如有两个任务需要通过同一串口发送数据，其硬件资源只有一个，那么两个任务不能同时发送，否则会导致数据错误。此时就可以用互斥信号量对串口资源进行保护，当任务1正在使用串口发送数据时，互斥信号量变为无效，任务2无法使用串口，任务2必须等待互斥信号量有效(任务1释放信号量)，才能获得串口使用权，进而发送数据。</p>
<p>3、简要了解递归互斥信号量</p>
<p>递归互斥信号量是一种特殊的互斥信号量，支持拥有该信号量使用权的任务重复多次获取，而不会死锁。 </p>
<p>任务成功获取几次递归互斥信号量，就要返还几次，在此之前，递归互斥信号量都处于无效状态。</p>
<p>递归互斥信号量应用很少，简要了解即可。</p>
<h2 id="优先级翻转问题"><a href="#优先级翻转问题" class="headerlink" title="优先级翻转问题"></a>优先级翻转问题</h2><p>下面我们通过如下的框图来说明一下优先级翻转的问题，让大家有一个形象的认识。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_2.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<blockquote>
<ul>
<li>创建 3 个任务 Task1，Task2 和 Task3，优先级分别为 3，2，1。也就是 Task1 的优先级最高。 </li>
<li>任务 Task1 和 Task3 互斥访问串口打印 printf，采用二值信号实现互斥访问。</li>
<li>起初 Task3 通过二值信号量正在调用 printf，被任务 Task1 抢占，开始执行任务 Task1，也就是上图的起始位置。</li>
<li>任务 Task1 运行的过程需要调用函数 printf，发现任务 Task3 正在调用，任务 Task1 会被挂起，等待 Task3 释放函数 printf。 </li>
<li>在调度器的作用下，任务 Task3 得到运行，Task3 运行的过程中，由于任务 Task2 就绪，抢占了 Task3的运行。优先级翻转问题就出在这里了，<code>从任务执行的现象上看，任务 Task1 需要等待 Task2 执行完毕才有机会得到执行，这个与抢占式调度正好反了，正常情况下应该是高优先级任务抢占低优先级任务的执行，这里成了高优先级任务 Task1 等待低优先级任务 Task2 完成。这种情况被称之为</code><mark>优先级翻转问题</mark>。 </li>
<li>任务 Task2 执行完毕后，任务 Task3 恢复执行，Task3 释放互斥资源后，任务 Task1 得到互斥资源，从而可以继续执行。</li>
</ul>
</blockquote>
<p>上面就是一个产生优先级翻转问题的现象，想象一下，如果介于任务1与任务3之间的任务特别多，对于抢占式实时操作系统来说是致命的危害，有可能导致系统崩溃 ，下一讲通过编程进行验证。</p>
<p><mark>不过也不用担心，使用互斥信号量，可以有效的防止优先级翻转问题，后面会讲解。</mark></p>
<h2 id="优先级翻转编程测试"><a href="#优先级翻转编程测试" class="headerlink" title="优先级翻转编程测试"></a>优先级翻转编程测试</h2><p>串口输出信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree13_1.png" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span></span><br><span class="line">  <span class="comment">/* add semaphores, ... */</span></span><br><span class="line">	  <span class="keyword">if</span> (myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_SEMAPHORES */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN HighPriority_Task */</span></span><br><span class="line"></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END HighPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN MidPriority_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END MidPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LowPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LowPriority_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_Delay</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LowPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----二值信号量—优先级翻转测试----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="互斥信号量的运作机制"><a href="#互斥信号量的运作机制" class="headerlink" title="互斥信号量的运作机制"></a>互斥信号量的运作机制</h2><p>互斥量处理不同任务对临界资源的访问时，任务要获得互斥量才能进行资源访问。一旦有任务成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源。任务会根据用户自定义的等待时间进行等待，直到互斥量被持有的任务释放，其他任务才能获取互斥量从而得以访问该临界资源。此时互斥量再次上锁，如此一来就可以确保每个时刻只有一个任务正在访问这个临界资源，保证了临界资源操作的安全性，具体如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_4.webp" alt=""></p>
<blockquote>
<p>①：因为互斥量具有优先级继承机制，一般选择使用互斥量对资源进行保护。当采用互斥量保护的资源被占用时，无论是什么优先级的任务，想要使用该资源都会被阻塞</p>
<p>②：假如正在使用该资源的任务1比阻塞中的任务2的优先级低，那么任务1的优先级将被系统临时提升到与高优先级任务2相等(任务1的优先级从L变成H),<mark>这个就是所谓的优先级继承，这样就有效地防止了优先级翻转问题，因为此时优先级介于任务1与任务2之间的任务，抢占不了CPU</mark>。</p>
<p>③：当任务1使用完资源之后，释放互斥量，此时任务1的优先级会从H变回原来的L</p>
<p>④~⑤：任务2此时可以获得互斥量，然后进行资源的访问，当任务2访问了资源时，该互斥量的状态又变为闭锁状态，其他任务无法获取互斥量。</p>
</blockquote>
<h2 id="互斥信号量常用的API函数"><a href="#互斥信号量常用的API函数" class="headerlink" title="互斥信号量常用的API函数"></a>互斥信号量常用的API函数</h2><p> 1、使用互斥信号量的典型流程如下：</p>
<blockquote>
<p>创建互斥信号量</p>
<p>释放互斥信号量</p>
<p>获取互斥信号量</p>
<p>删除互斥信号量</p>
</blockquote>
<p>2、常用API函数如下：</p>
<blockquote>
<p><code>xSemaphoreCreateMutex</code>()</p>
<p><code>xSemaphoreGive</code>()</p>
<p><code>xSemaphoreTake</code>()</p>
<p><code>vSemaphoreDelete</code>()</p>
</blockquote>
<p>3、互斥信号量创建与删除</p>
<ul>
<li>互斥信号量控制块(句柄)</li>
</ul>
<p>如下图：二值信号量的句柄为消息队列的句柄，因为二值信号量是一种长度为1，消息大小为0<strong>的特殊消息队列</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_5.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_6.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_7.webp" alt=""></p>
<ul>
<li>互斥信号量创建</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreCreateMutex</code>用于创建互斥信号量。</p>
<p> 返回值，如果创建成功会返回互斥信号量的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此互斥信号量提供所需的空间会返回 NULL。</p>
<p>使用这个函数要注意以下问题</p>
<p>使用此函数要在 <code>FreeRTOSConfig.h</code> 文件中使能宏定义：</p>
<p><code>#define configUSE_MUTEXES 1</code></p>
<p>说明：此函数基于消息队列函数实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_8.png" alt=""></p>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_9.webp" alt=""></p>
<ul>
<li>互斥信号量删除</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>; <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vSemaphoreDelete</code>可用于删除互斥信号量。 </p>
<p>4、互斥信号量释放</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreGive</code> 用于在<mark>任务代码</mark>中释放信号量。</p>
<blockquote>
<p>第 1 个参数是信号量句柄。</p>
<p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<p>此函数是用于任务代码中调用的，不可以在中断服务程序中调用此函数。</p>
<p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p>
<p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_10.webp" alt=""></p>
<p>5、互斥信号量获取</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p>
<blockquote>
<p>第 1 个参数是信号量句柄。 </p>
<p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p>
<p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>此函数是用于任务代码中调用的，不可以在中断服务程序中调用此函数。</p>
</li>
<li><p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p>
</li>
<li><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p>
</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_11.webp" alt=""></p>
<h2 id="互斥信号量的应用编程"><a href="#互斥信号量的应用编程" class="headerlink" title="互斥信号量的应用编程"></a>互斥信号量的应用编程</h2><p>视频讲解，互斥信号量应用于临界资源管理，解决优先级翻转问题</p>
<p>串口输出信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_12.png" alt=""></p>
<p>STM32cubeMX配置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_13.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_14.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_15.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_16.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_17.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_18.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (myMutex01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建互斥信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建互斥信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN HighPriority_Task */</span></span><br><span class="line"></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myMutex01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myMutex01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END HighPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN MidPriority_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END MidPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LowPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LowPriority_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myMutex01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_Delay</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myMutex01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LowPriority_Task */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----互斥信号量—优先级翻转测试----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件的概念与应用"><a href="#事件的概念与应用" class="headerlink" title="事件的概念与应用"></a>事件的概念与应用</h2><p>1、事件的概念</p>
<p><strong>事件</strong>是实现任务与任务或任务与中断间通信的机制，用于同步，无数据传输。</p>
<p><mark>与信号量不同的是，事件可以实现一对多、多对多的同步，即一个任务可以等待多个事件的发生:可以是任意一个事件发生时唤醒任务进行事件处理;也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件</mark></p>
<p>FreeRTOS提供的事件具有如下特点:</p>
<blockquote>
<p>① 事件相互独立，一个32位的事件集合(<code>EventBitst</code>类型的变量，实际可用于表示事件的只有低24位)用于标识该任务发生的事件类型，其中每一位表示一种事件类型(0表示该事件类型未发生，1表示该事件类型已经发生)，一共有 24种事件类型。</p>
<p>②事件仅用于同步，不提供数据传输功能。</p>
<p>③ 事件无排队性，即多次向任务设置同一事件(如果任务还未来得及读取)，等效于只设置一次。</p>
<p>④允许多个任务对同一事件进行读写操作。</p>
<p>⑤ 支持事件等待超时机制。</p>
</blockquote>
<p>在FreeRTOS 事件中，获取每个事件时，用户可以选择感兴趣的事件，并且选择读取事件信息标记。它有3个属性，分别是逻辑与、逻辑或以及是否清除标记。当任务等待事件同步时，可以通过任务感兴趣的事件位和事件信息标记来判断当前接收的事件是否满足要求，如果满足，则说明任务等到对应的事件，系统将唤醒等待的任务;否则，任务会根据用户指定的阻塞超时时间继续等待下去。</p>
<p>2、事件的应用</p>
<p>FrecRTOS的事件用于任务与任务或任务与中断间的同步。为什么不直接用变量呢?那样岂不是更有效率?若是在裸机编程中，用全局变量是最有效的方法，但是在操作系统中，使用全局变量就要考虑以下问题了:</p>
<blockquote>
<p>①如何对全局变量进行保护?如何处理多任务同时对它进行访问的情况?</p>
<p>②如何让内核对事件进行有效管理?</p>
</blockquote>
<p>如果使用全局变量，就需要在任务中轮询查看事件是否发送，这会造成CPU 资源的浪费，此外，用户还需要自己去实现等待超时机制。所以，在操作系统中最好还是使用系统提供的通信机制，简单、方便、实用。</p>
<p>在某些场合，可能需要多个事件发生后才能进行下一步操作，比如一些危险机器的启动，需要检查各项指标，当指标不达标时就无法启动。但是检查各个指标时，不会立刻检测完毕，所以需要事件来做统一的等待。当所有的事件都完成了，那么机器才允许启动，这只是事件的应用之一</p>
<p>事件可用于多种场合，能够在一定程度上替代信号量，用于任务与任务间、中断与任务间的同步。一个任务或中断服务例程发送一个事件给事件对象，而后等待的任务被唤醒并对相应的事件进行处理。但是事件与信号量不同的是，事件的发送操作是不可累计的，而信号量的释放动作是可累计的。事件的另外一个特性是，接收任务可等待多种事件，即多个事件对应一个任务或多个任务。同时按照任务等待的参数，可选择是“逻辑或”触发还是“逻辑与”触发。这个特性也是信号量等所不具备的，信号量只能识别单一同步动作，而不能同时等待多个事件的同步。</p>
<p>各个事件可分别发送或一起发送给事件对象，而任务可以等待多个事件，任务仅对感兴趣的事件进行关注。当有它们感兴趣的事件发生并且符合条件时，任务将被唤醒并进行后续的处理动作。</p>
<h2 id="事件的运作机制"><a href="#事件的运作机制" class="headerlink" title="事件的运作机制"></a>事件的运作机制</h2><p>1、FreeRTOS中事件组的句柄</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">xEventGroupDefinition</span></span><br><span class="line">&#123;</span><br><span class="line">	EventBits_t uxEventBits;</span><br><span class="line">	List_t xTasksWaitingForBits;		<span class="comment">/*&lt; List of tasks waiting for a bit to be set. */</span></span><br><span class="line"></span><br><span class="line">&#125; EventGroup_t;</span><br></pre></td></tr></table></figure>
<p><code>uxEventBits</code>: 对于STM32，此变量为32位，其中低24位用于事件位，高8位用于其他用途，暂时不必深究。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_2.webp" alt=""></p>
<p>2、FreeRTOS 任务间事件标志组的实现</p>
<p>任务间事件标志组的实现是指各个任务之间使用事件标志组实现任务的同步机制。</p>
<p>下面的框图说明FreeRTOS 事件标志的实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_3.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<p>创建 2 个任务：Task1 和 Task2</p>
<p><strong>运行过程描述如下：</strong></p>
<blockquote>
<ul>
<li>任务 Task1 运行过程中调用函数 <code>xEventGroupWaitBits</code>，等待事件标志位被设置，任务 Task1 由运行态进入到阻塞态。</li>
<li>任务 Task2 设置 Task1 等待的事件标志，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态。</li>
</ul>
</blockquote>
<p>上面就是一个简单的 FreeRTOS 任务间事件标志通信过程。</p>
<p>3、FreeRTOS 中断方式事件标志组的实现</p>
<p>FreeRTOS 中断方式事件标志组的实现是指中断函数和 FreeRTOS 任务之间使用事件标志。</p>
<p>下面的框图说明FreeRTOS 事件标志的实现：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_4.webp" alt=""></p>
<p><strong>运行条件：</strong></p>
<p>创建一个任务和一个串口接收中断</p>
<p><strong>运行过程描述如下：</strong></p>
<blockquote>
<p>任务 Task1 运行过程中调用函数 <code>xEventGroupWaitBits</code>，等待事件标志位被设置，任务 Task1 由运行态进入到阻塞态。</p>
<p>Task1 阻塞的情况下，串口接收到数据进入到了串口中断服务程序，在串口中断服务程序中设置 Task1等待的事件标志，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态。</p>
</blockquote>
<p>上面就是一个简单的 FreeRTOS 中断方式事件标志通信过程。</p>
<p><mark>实际应用中，中断方式的消息机制要注意以下三个问题：</mark></p>
<blockquote>
<ul>
<li>中断函数的执行时间越短越好，防止其它低于这个中断优先级的异常不能得到及时响应。</li>
<li>实际应用中，建议不要在中断中实现消息处理，用户可以在中断服务程序里面发送消息通知任务，在任务中实现消息处理，这样可以有效地保证中断服务程序的实时响应。同时此任务也需要设置为高优先级，以便退出中断函数后任务可以得到及时执行。</li>
<li>中断服务程序中一定要调用专用于中断的事件标志设置函数，即以 <code>FromISR</code>结尾的函数。</li>
</ul>
</blockquote>
<h2 id="事件的API函数‍"><a href="#事件的API函数‍" class="headerlink" title="事件的API函数‍"></a>事件的API函数‍</h2><p> 1、使用事件的典型流程如下：</p>
<blockquote>
<p>创建事件组</p>
<p>置位事件组</p>
<p>等待事件组</p>
<p>删除事件组</p>
</blockquote>
<p>2、常用API函数如下：</p>
<blockquote>
<p><code>xEventGroupCreate</code>()</p>
<p><code>xEventGroupSetBits</code>() , <code>xEventGroupSetBitsFromISR</code>()</p>
<p><code>xEventGroupWaitBits</code>()</p>
<p><code>vEventGroupDelete</code>()</p>
</blockquote>
<p>3、事件组创建与删除</p>
<ul>
<li>事件组控制块(句柄)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_5.png" alt=""></p>
<p><code>uxEventBits</code>: 对于STM32，此变量为32位，其中低24位用于事件位</p>
<p><code>xTasksWaitingForBits</code>： 任务等待链表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_6.png" alt=""></p>
<ul>
<li>创建事件组</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xEventGroupCreate</code>用于创建事件标志组。</p>
<blockquote>
<p>返回值，如果创建成功，此函数返回事件标志组的句柄，如果 <code>FreeRTOSConfig.h</code> 文件中定义的 <code>heap</code>空间不足会返回 <code>NULL</code></p>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_7.webp" alt=""></p>
<ul>
<li>删除事件组</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vEventGroupDelete</span>(EventGroupHandle_t xEventGroup);</span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>vEventGroupDelete</code>可用于删除事件组。 </p>
<p>4、任务内置位事件组</p>
<p><strong>函数原型：</strong></p>
<p><code>EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,</code> /<em> 事件标志组句柄 </em>/</p>
<p><code>const EventBits_t uxBitsToSet )</code>; /<em> 事件标志位设置 </em>/</p>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xEventGroupSetBits</code>用于设置指定的事件标志位为 1。</p>
<blockquote>
<ul>
<li>第 1 个参数是事件标志组句柄。</li>
<li>第 2 个参数表示 24 个可设置的事件标志位，<code>EventBits_t</code>是定义的 32 位变量，低 24 位用于事件标志设置。变量 <code>uxBitsToSet</code>的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 <code>uxBitsToSet</code>设置为 0 的位对事件标志相应位没有影响。比如设置变量 <code>uxBitsToSet</code> = 0x0003 就表示将事件标志的位 0 和位 1 设置为 1，其余位没有变化。</li>
<li>返回当前的事件标志组数值。</li>
</ul>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>使用前一定要保证事件标志组已经通过函数 <code>xEventGroupCreate</code>创建了。</p>
</li>
<li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xEventGroupSetBitsFromISR</code></p>
</li>
<li><p>用户通过参数 <code>uxBitsToSet</code>设置的标志位并不一定会保留到此函数的返回值中，下面举两种情况：</p>
<ul>
<li>调用此函数的过程中，其它高优先级的任务就绪了，并且也修改了事件标志，此函数返回的事件标志位会发生变化。</li>
<li>调用此函数的任务是一个低优先级任务，通过此函数设置了事件标志后，让一个等待此事件标志的高优先级任务就绪了，会立即切换到高优先级任务去执行，相应的事件标志位会被函数<code>xEventGroupWaitBits</code> 清除掉，等从高优先级任务返回到低优先级任务后，函数<code>xEventGroupSetBits</code>的返回值已经被修改。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_8.webp" alt=""></p>
<p>5、中断内置位事件组</p>
<p><strong>函数原型：</strong></p>
<p><code>BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup,</code> /<em> 事件标志组句柄 </em>/</p>
<p><code>const EventBits_t uxBitsToSet,</code> /<em> 事件标志位设置 </em>/</p>
<p><code>BaseType_t *pxHigherPriorityTaskWoken )</code>; / <em> 高优先级任务是否被唤醒的状态保存 </em>/</p>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xEventGroupSetBits</code>用于设置指定的事件标志位为 1。</p>
<blockquote>
<ul>
<li>第 1 个参数是事件标志组句柄。</li>
<li>第 2 个参数表示 24 个可设置的事件标志位，<code>EventBits_t</code> 是定义的 32 位变量，低 24 位用于事件标志设置。变量 <code>uxBitsToSet</code> 的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 <code>uxBitsToSet</code>设置为 0 的位对事件标志相应位没有影响。比如设置变量 <code>uxBitsToSet</code>= 0x0003 就表示将事件标志的位 0 和位 1 设置为 1，其余位没有变化。</li>
<li>第 3 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</li>
<li>返回值，如果消息成功发送给守护任务（就是FreeRTOS 的定时器服务任务）返回 <code>pdPASS</code>，否则返回 <code>pdFAIL</code>，另外守护任务中的消息队列满了也会返回 <code>pdFAIL</code>。</li>
</ul>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li>使用前一定要保证事件标志已经通过函数 <code>xEventGroupCreate</code>创建了。同时要在<code>FreeRTOSConfig.h</code></li>
</ol>
<p>文件中使能如下三个宏定义：</p>
<p><code>#define INCLUDE_xEventGroupSetBitFromISR 1</code></p>
<p><code>#define configUSE_TIMERS 1</code></p>
<p><code>#define INCLUDE_xTimerPendFunctionCall 1</code></p>
<ol>
<li><p>函数 <code>xEventGroupSetBitsFromISR</code>是用于中断服务程序中调用的，故不可以在任务代码中调用此函数，任务代码中使用的是 <code>xEventGroupSetBits</code>。</p>
</li>
<li><p>函数 <code>xEventGroupSetBitsFromISR</code>对事件标志组的操作是不确定性操作，因为不知道当前有多少个任务在等待此事件标志。而 FreeRTOS 不允许在中断服务程序和临界段中执行不确定性操作。为了不在中断服务程序中执行，就通过此函数给 FreeRTOS 的守护任务（就是 FreeRTOS 的定时器服务任务，内核自动创建的）发送消息，在守护任务中执行事件标志的置位操作。同时也为了不在临界段中执行此不确定操作，将临界段改成由调度锁来完成。这样不确定性操作在中断服务程序和临界段中执行的问题就都得到解决了。</p>
</li>
<li><p>由于函数 <code>xEventGroupSetBitsFromISR</code>对事件标志的置位操作是在守护任务里面执行的，如果想让置位操作立即生效，即让等此事件标志的任务能够得到及时执行，需要设置守护任务的优先级高于使用此事件标志组的所有其它任务。</p>
</li>
</ol>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_9.webp" alt=""></p>
<p>6、等待事件组</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupWaitBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> EventGroupHandle_t xEventGroup,` <span class="comment">/* 事件标志组句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> EventBits_t uxBitsToWaitFor,` <span class="comment">/* 等待被设置的事件标志位*/</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> BaseType_t xClearOnExit,` <span class="comment">/* 选择是否清零被置位的事件标志位 */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> BaseType_t xWaitForAllBits,` <span class="comment">/* 选择是否等待所有标*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">TickType_t xTicksToWait )</span>`</span>; <span class="comment">/* 设置等待时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xEventGroupWaitBits</code>等待事件标志被设置。</p>
<blockquote>
<ul>
<li>第 1 个参数是事件标志组句柄。</li>
<li>第 2 个参数表示等待 24 个事件标志位中的指定标志，<code>EventBits_t</code>是定义的 32 位变量，低 24 位用于事件标志设置。比如设置变量 <code>uxBitsToWaitFor</code>= 0x0003 就表示等待事件标志的位 0 和位 1 设置为 1。此参数切不可设置为 0。</li>
<li>第 3 个参数选择是否清除已经被置位的事件标志，如果这个参数设置为 <code>pdTRUE</code>，且函数<code>xEventGroupWaitBits</code>在参数 <code>xTicksToWait</code>设置的溢出时间内返回或等到满足任务唤醒的事件时，相应被设置的事件标志位会被清零。如果这个参数设置为 <code>pdFALSE</code>，对已经被设置的事件标志位没有影响。</li>
<li>第 4 个参数选择是否等待所有的标志位都被设置，如果这个参数设置为 <code>pdTRUE</code>，要等待第 2 个参数 <code>uxBitsToWaitFor</code>所指定的标志位全部被置 1，函数才可以返回。当然，超出了在参数<code>xTicksToWait</code>设置的溢出时间也是会返回的。如果这个参数设置为 <code>pdFALSE</code>，第 2 个参数<code>uxBitsToWaitFor</code>所指定的任何标志位被置 1，函数都会返回，超出溢出时间也会返回。</li>
<li>第 5 个参数设置等待时间，单位时钟节拍周期。如果设置为 <code>portMAX_DELAY</code>，表示永久等待。</li>
<li>返回值，由于设置的时间超时或者指定的事件标志位被置 1，导致函数退出时返回的事件标志组数值。</li>
</ul>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li><p>此函数切不可在中断服务程序中调用。</p>
</li>
<li><p>着重说明下这个函数的返回值，通过返回值用户可以检测是哪个事件标志位被置 1 了</p>
<ul>
<li>如果由于设置的等待时间超时，函数的返回值可会有部分事件标志位被置 1。</li>
<li>如果由于指定的事件标志位被置1而返回，并且设置了这个函数的参数<code>xClearOnExit</code>为<code>pdTRUE</code>，那么此函数的返回值是清零前的事件标志组数值。</li>
</ul>
</li>
</ol>
<p>另外，调用此函数的任务在离开阻塞状态到退出函数 <code>xEventGroupWaitBits</code>之间这段时间，如果一个高优先级的任务抢占执行了，并且修改了事件标志位，那么此函数的返回值会跟当前的事件标志组数值不同。</p>
</blockquote>
<p><strong>使用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_10.webp" alt=""></p>
<h2 id="事件的应用-任务与任务"><a href="#事件的应用-任务与任务" class="headerlink" title="事件的应用 - 任务与任务"></a>事件的应用 - 任务与任务</h2><p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_11.png" alt=""></p>
<p>2、任务配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_12.png" alt=""></p>
<p>LED1_Task： 运行指示灯</p>
<p>KEY_Task：  按键，打印任务信息，触发事件</p>
<p>Event_Sync_Task:  等待事件，同步任务</p>
<p>3、创建事件组</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_13.webp" alt=""></p>
<p>4、按键任务部分代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_14.webp" alt=""></p>
<p>5、同步任务代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_15.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_EVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_EVENT (EventBits_t)(0x0001 &lt;&lt; 8)  <span class="comment">// 设置事件掩码8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_EVENT (EventBits_t)(0x0001 &lt;&lt; 16) <span class="comment">// 设置事件掩码16</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVent_WaitAllBits <span class="comment">// 用于预编译</span></span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键2事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键2事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY2_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键3事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键3事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY3_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键4事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键4事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY4_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line">  <span class="type">uint16_t</span> SyncCnt = <span class="number">0</span>; <span class="comment">// 同步计数</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EVent_WaitAllBits</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,                      <span class="comment">// 事件句柄</span></span><br><span class="line">        KEY2_EVENT | KEY3_EVENT | KEY4_EVENT, <span class="comment">// 事件 - 按键2，3，4</span></span><br><span class="line">        pdTRUE,                               <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdTRUE,                               <span class="comment">//&quot;逻辑与&quot; - 满足所有条件</span></span><br><span class="line">        portMAX_DELAY);                       <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((xEvent &amp; (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT)) == (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收事件同步信号，次数=%u\r\n\r\n&quot;</span>, ++SyncCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,                      <span class="comment">// 事件句柄</span></span><br><span class="line">        KEY2_EVENT | KEY3_EVENT | KEY4_EVENT, <span class="comment">// 事件 - 按键2，3，4</span></span><br><span class="line">        pdTRUE,                               <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdFALSE,                              <span class="comment">//&quot;逻辑或&quot; - 满足所有条件</span></span><br><span class="line">        portMAX_DELAY);                       <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((xEvent &amp; KEY2_EVENT) == KEY2_EVENT) || ((xEvent &amp; KEY3_EVENT) == KEY3_EVENT) || ((xEvent &amp; KEY4_EVENT) == KEY4_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收事件同步信号，次数=%u\r\n\r\n&quot;</span>, ++SyncCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----事件组同步应用编程 - 任务与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：打印按键事件2\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：打印按键事件3\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：打印按键事件4\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件的应用-中断与任务"><a href="#事件的应用-中断与任务" class="headerlink" title="事件的应用 - 中断与任务"></a>事件的应用 - 中断与任务</h2><p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_16.png" alt=""></p>
<p>2、任务配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_17.png" alt=""></p>
<p>LED1_Task： 运行指示灯</p>
<p>KEY_Task：  按键，打印任务信息，触发事件</p>
<p>Event_Sync_Task:  等待事件，同步任务</p>
<p>3、开启FreeRTOS软件定时器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_18.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_19.webp" alt=""></p>
<p>4、创建事件组</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_20.webp" alt=""></p>
<p>5、同步任务代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_21.webp" alt=""></p>
<p>6、串口3回调函数代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_22.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART3_RecEVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>	ucUART3_Rec_Data[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;  <span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;通过串口接口发送12个字符\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3,(<span class="type">uint8_t</span> *)ucUART3_Rec_Data,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待事件同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">      MyEvent01Handle,</span><br><span class="line">      UART3_RecEVENT,</span><br><span class="line">      pdTRUE,</span><br><span class="line">      pdTRUE,</span><br><span class="line">      portMAX_DELAY</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((xEvent&amp;UART3_RecEVENT)  == UART3_RecEVENT)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收到的串口数据: %s\r\n\r\n&quot;</span>,ucUART3_Rec_Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>CallBack.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART3_RecEVENT (EventBits_t)(0x0001 &lt;&lt; 0) <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="type">uint8_t</span> ucUART3_Rec_Data[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//存放串口数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> EventGroupHandle_t MyEvent01Handle;  <span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE; <span class="comment">// 定义一个用于确定是否需要进行任务切换的变量，默认为pdFALSE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == huart3.Instance) <span class="comment">// 检查接收数据的UART实例是否为huart3</span></span><br><span class="line">    &#123;</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED2); <span class="comment">// 如果是huart3，则翻转LED（假设LED为某种指示灯）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">xEventGroupSetBitsFromISR</span>(MyEvent01Handle, UART3_RecEVENT, &amp;xHigherPriorityTaskWoken); <span class="comment">// 设置一个事件标志以通知其他任务数据已经接收完成，如果有高优先级任务被唤醒，则将xHigherPriorityTaskWoken设置为pdTRUE</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken); <span class="comment">// 根据xHigherPriorityTaskWoken的值来决定是否进行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h1><h2 id="软件定时器的概念"><a href="#软件定时器的概念" class="headerlink" title="软件定时器的概念"></a>软件定时器的概念</h2><p>1、软件定时器的概念</p>
<p>FreeRTOS 软件定时器的时基是基于系统时钟节拍实现的，之所以叫软件定时器是因为它的实现不需要额外使用硬件定时器，而且可以创建很多个，综合这些因素，这个功能就被称之为软件定时器组。既然是定时器，那么它实现的功能与硬件定时器也是类似的。在硬件定时器中，我们是在定时器中断中实现需要的功能，而使用软件定时器时，我们是在创建软件定时器时指定软件定时器的回调函数，在回调函数中实现相应的功能。</p>
<p>2、FreeRTOS提供的软件定时器支持如下功能：</p>
<blockquote>
<p>① 裁剪，可通过宏关闭软件定时器功能</p>
<p>② 软件定时器创建</p>
<p>③ 软件定时器启动</p>
<p>④ 软件定时器停止</p>
<p>⑤ 软件定时器复位</p>
<p>⑥ 软件定时器删除</p>
</blockquote>
<p>软件定时器的使用相当于扩展了定时器的数量，允许创建更多的定时任务。 </p>
<p>3、单次模式与周期模式</p>
<p>FreeRTOS 提供的软件定时器支持单次模式和周期性模式，单次模式就是用户创建了定时器并启动了定时器后，定时时间到将不再重新执行，这就是单次模式软件定时器的含义。周期模式就是此定时器会按照设置的时间周期重复去执行，这就是周期模式软件定时器的含义。另外就是单次模式或者周期模式的定时时间到后会调用定时器的回调函数，用户可以回调函数中加入需要执行的工程代码。</p>
<p>4、定时器守护任务</p>
<p>FreeRTOS通过一个<code>prvTimerTask</code>任务(也叫作守护任务(<code>Daemon</code>))管理软件定时器，它是在启动调度器时自动创建的，以满足用户定时需求。<code>pryTimerTask</code>任务会在其执行期间检查用户启动的时间周期溢出的定时器，并调用其回调函数。只有设置 <code>FreeRTOSConfig.h</code>中的宏定义<code>configUSE_TIMERS</code>为<code>1</code>，将相关代码编译进来，才能正常使用软件定时器相关功能。</p>
<p>FreeRTOS 定时器组的大部分 API 函数都是通过消息队列给定时器任务发消息，在定时器任务里面执行实际的操作。为了更好的说明这个问题，我们将官方在线版手册中的这个截图贴出来进行说明：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_1.webp" alt=""></p>
<p>左侧图是用户应用程序，右侧是定时器任务。在用户应用程序里面调用了定时器组API函数<code>xTimerReset</code>，这个函数会通过消息队列给定时器任务发消息，在定时器任务里面执行实际操作。消息队列在此处的作用有一个专门的名字：<mark>Timer command queue</mark>，即专门发送定时器组命令的队列。</p>
<h2 id="软件定时器的应用"><a href="#软件定时器的应用" class="headerlink" title="软件定时器的应用"></a>软件定时器的应用</h2><p>1、应用场景</p>
<p>在很多应用中，我们需要用到一些定时器任务，硬件定时器受硬件的限制，数量上不足以满足用户的实际需求，无法提供更多的定时器，那么可以采用软件定时器来完成，由软件定时器任务代替硬件定时器任务。但需要注意的是，软件定时器的精度是无法和硬件定时器相比的，因为在软件定时器的定时过程中极有可能被其他中断所打断，这是由于软件定时器的执行上下文环境是任务<strong>(<code>prvTimerTask</code>任务)</strong>。所以，软件定时器更适用于对时间精度要求不高的任务，或一些辅助型的任务。</p>
<p>2、软件定时器的精度</p>
<p>在操作系统中，通常软件定时器以系统节拍周期为计时单位。系统节拍是系统的心跳节拍，表示系统时钟的频率，类似人的心跳 1s 能跳动多少下。系统节拍配置为 <code>configTICK_RATE</code>HZ，该宏在<code>FreeRTOSConfig.h</code> 中有定义，默认是<code>1000</code>。那么系统的时钟节拍周期就为1ms(1s 跳动 1000 下，每一下时长就为 1ms)。软件定时器的所定时数值必须是这个节拍周期的整数倍，例如节拍周期是10ms，那么上层软件定时器定时数值只能是 10ms、20ms、100ms 等，而不能取值为 15ms。由于节拍定义了系统中定时器能够分辨的精确度，系统可以根据实际CPU的处理能力和实时性需求设置合适的数值，系统节拍周期的值越小，精度越高，但是系统开销也将越大，因为这代表在1s 中系统进入时钟中断的次数也就越多。</p>
<p>3、回调函数</p>
<p>在<code>prvTimerTask</code>任务中检测软件定时器，一旦定时时间到，将执行回调函数(<mark>被作为参数传递的函数，间接调用</mark>)，以完成任务。 </p>
<p>详情如下面的图片：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_2.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_3.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_4.png" alt=""></p>
<p>4、使用时注意事项</p>
<blockquote>
<p>① <code>prvTimerTask</code>任务的优先级设置高些，以便及时处理软件定时器的相关指令；</p>
<p>② 定时器回调函数是在定时器任务中执行的，实际应用中不可在定时器回调函数中调用任何将定时器任务挂起的函数，比如<code>vTaskDelay</code>(), <code>vTaskDelayUntil</code>()以及非零延迟的消息队列和信号量相关的函数。将定时器任务挂起，会导致定时器任务负责的相关功能都不能正确执行了。</p>
</blockquote>
<h2 id="软件定时器的API函数‍"><a href="#软件定时器的API函数‍" class="headerlink" title="软件定时器的API函数‍"></a>软件定时器的API函数‍</h2><p> 1、使用软件定时器的典型流程如下：</p>
<blockquote>
<p>创建软件定时器</p>
<p>启动软件定时器</p>
<p>停止软件定时器</p>
<p>删除软件定时器</p>
<p>获取软件定时器ID</p>
</blockquote>
<p>2、常用API函数如下：</p>
<blockquote>
<p><code>xTimerCreate</code>()</p>
<p><code>xTimerStart</code>()</p>
<p><code>xTimerStop</code>()</p>
<p><code>xTimerDelete</code>()</p>
<p><code>pvTimerGetTimerID</code>()</p>
</blockquote>
<p>3、软件定时器的创建与删除</p>
<ul>
<li>软件定时器控制块(句柄)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_5.png" alt=""></p>
<p>结构体成员变量说明：</p>
<blockquote>
<p>① 软件定时器的名字，一般用于调试，因为控制定时器是通过句柄</p>
<p>② 软件定时器的列表项，用于插入定时器链表</p>
<p>③ 软件定时器的周期，单位为系统节拍(<code>tick</code>)</p>
<p>④ 软件定时器是否自动重置，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p>
<p>⑤ 软件定时器的数字ID，典型用法是多个定时器共用一个回调函数时，通过ID辨别</p>
<p>⑥ 软件定时器的回调函数，当定时时间到就会调用这个函数</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_6.png" alt=""></p>
<ul>
<li>创建软件定时器</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerCreate</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName, <span class="comment">/* 定时器名字 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TickType_t xTimerPeriod, <span class="comment">/* 定时器周期，单位系统时钟节拍 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">	 <span class="type">const</span> UBaseType_t uxAutoReload, <span class="comment">/* 选择单次模式或者周期模式 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">void</span> * <span class="type">const</span> pvTimerID,        <span class="comment">/* 定时器 ID */</span></span></span></span><br><span class="line"><span class="params"><span class="function">     TimerCallbackFunction_t pxCallbackFunction )</span></span>; <span class="comment">/* 定时器回调函数 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xTimerCreate</code>用于创建软件定时器。</p>
<blockquote>
<p>第 1 个参数是定时器名字，用于调试目的，方便识别不同的定时器。</p>
<p>第 2 个参数是定时器周期，单位系统时钟节拍。</p>
<p>第 3 个参数是选择周期模式还是单次模式，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p>
<p>第 4 个参数是定时器 ID，当不同的定时器使用相同的回调函数时，在回调函数中通过不同的ID 号来区分不同的定时器。</p>
<p>第 5 个参数是定时器回调函数。</p>
<p>返回值，创建成功返回定时器的句柄，由于 <code>FreeRTOSCongfig.h</code> 文件中 <code>heap</code>空间不足，或者定时器周期设置为 0，会返回 NULL。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<p>在 <code>FreeRTOSConfig.h</code> 文件中使能宏定义：</p>
<p><code>#define configUSE_TIMERS   1</code></p>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_7.webp" alt=""></p>
<ul>
<li>删除软件定时器</li>
</ul>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerDelede</span>    </span></span><br><span class="line"><span class="function">          <span class="params">(TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">          TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xTimerCreate</code>用于创建软件定时器。</p>
<blockquote>
<p>第 1 个参数是定时器句柄</p>
<p>第 2 个参数定时器队列消息发送超时间，定时器组的大部分 API函数不是直接运行的，而是通过消息队列给定时器任务发消息来实现的，此参数设置的等待时间就是当消息队列已经满的情况下，等待消息队列有空间时的最大等待时间。</p>
<p>返回值，返回 <code>pdFAIL</code>表示此函数向消息队列发送消息失败，返回 <code>pdPASS</code>表示此函数向消息队列发送消息成功。定时器任务实际执行消息队列发来的命令依赖于定时器任务的优先级，如果定时器任务是高优先级会及时得到执行，如果是低优先级，就要等待其余高优先级任务释放 CPU 权才可以得到执行。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTimerDelede</span>(MyTimer01Handle, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>4、启动软件定时器</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTimerStart</span></span></span><br><span class="line"><span class="function">      <span class="params">( TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">       TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xTimerStart</code>用于启动软件定时器。</p>
<blockquote>
<p>第 1 个参数是定时器名字，用于调试目的，方便识别不同的定时器。</p>
<p>第 2 个参数是定时器周期，单位系统时钟节拍。</p>
<p>第 3 个参数是选择周期模式还是单次模式，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p>
<p>第 4 个参数是定时器 ID，当不同的定时器使用相同的回调函数时，在回调函数中通过不同的ID 号来区分不同的定时器。</p>
<p>第 5 个参数是定时器回调函数。</p>
<p>返回值，创建成功返回定时器的句柄，由于 <code>FreeRTOSCongfig.h</code>文件中 <code>heap</code>空间不足，或者定时器周期设置为 0，会返回 NULL。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li>使用前一定要保证定时器组已经通过函数 <code>xTimerCreate</code>创建了。</li>
<li>对于已经被激活的定时器，即调用过函数 <code>xTimerStart</code>进行启动，再次调用此函数相当于调用了函数<code>xTimerReset</code>对定时器时间进行了复位。</li>
<li>如果在启动 FreeRTOS 调度器前调用了此函数，定时器是不会立即执行的，需要等到启动了 FreeRTOS调度器才会得到执行，即从此刻开始计时，达到 <code>xTimerCreate</code>中设置的单次或者周期性延迟时间才会执行相应的回调函数。</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_8.webp" alt=""></p>
<p>5、停止软件定时器</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTimerStop</span></span></span><br><span class="line"><span class="function">      <span class="params">( TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">       TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>xTimerStart</code>用于停止软件定时器。</p>
<blockquote>
<p>第 1 个参数是定时器句柄。</p>
<p>第 2 个参数定时器队列消息发送超时间</p>
<p>返回值，返回 <code>pdFAIL</code>表示此函数向消息队列发送消息失败，返回 <code>pdPASS</code>表示此函数向消息队列发送消息成功。才可以得到执行。</p>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_9.webp" alt=""></p>
<p>5、获取软件定时器ID</p>
<p><strong>函数原型：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span></span>; <span class="comment">/* 定时器句柄 */</span></span><br></pre></td></tr></table></figure>
<p><strong>函数描述：</strong></p>
<p>函数 <code>pvTimerGetTimerID</code>用于获取软件定时器ID。</p>
<blockquote>
<p>第 1 个参数是定时器句柄。</p>
<p>返回值，返回定时器 ID。</p>
</blockquote>
<p>使用这个函数要注意以下问题：</p>
<blockquote>
<ol>
<li>使用前一定要保证定时器组已经通过函数 <code>xTimerCreate</code>创建了。</li>
<li>创建不同的定时器时，可以对定时器使用相同的回调函数，在回调函数中通过此函数获取是哪个定时器的时间到了，这个功能就是此函数的主要作用。</li>
</ol>
</blockquote>
<p><strong>应用举例：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_10.png" alt=""></p>
<h2 id="软件定时器的应用编程"><a href="#软件定时器的应用编程" class="headerlink" title="软件定时器的应用编程"></a>软件定时器的应用编程</h2><p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_11.png" alt=""></p>
<p>2、STM32CubeMX初始化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_12.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_13.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_14.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_15.webp" alt=""></p>
<p>4、创建并启动软件定时器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_16.webp" alt=""></p>
<p>5、软件定时器回调函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_17.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器ID</span></span><br><span class="line"><span class="type">uint8_t</span> Timer01_ID = <span class="number">1</span>;</span><br><span class="line"><span class="type">uint8_t</span> Timer02_ID = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义软件定时器</span></span><br><span class="line"><span class="type">static</span> TimerHandle_t MyTimer01Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> TimerHandle_t MyTimer02Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//软件定时器回调函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">vMyTimerCallback</span><span class="params">(xTimerHandle pxTimer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> Timer_ID = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Timer01CallbackCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Timer02CallbackCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检验形参</span></span><br><span class="line">  <span class="built_in">configASSERT</span>(pxTimer);</span><br><span class="line">  <span class="comment">// 获取软件定时器ID</span></span><br><span class="line">  Timer_ID = *((<span class="type">uint8_t</span> *)<span class="built_in">pvTimerGetTimerID</span>(pxTimer));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行软件定时器1任务</span></span><br><span class="line">  <span class="keyword">if</span> (Timer_ID == Timer01_ID)</span><br><span class="line">  &#123;</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;软件定时器1回调次数 = %u\r\n&quot;</span>, ++Timer01CallbackCnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行软件定时器2任务</span></span><br><span class="line">  <span class="keyword">if</span> (Timer_ID == Timer02_ID)</span><br><span class="line">  &#123;</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;软件定时器2回调次数 = %u\r\n&quot;</span>, ++Timer02CallbackCnt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建软件定时器1并启动</span></span><br><span class="line">  MyTimer01Handle = <span class="built_in">xTimerCreate</span>(</span><br><span class="line">      <span class="string">&quot;timer01&quot;</span>,  <span class="comment">//名字</span></span><br><span class="line">      <span class="number">100</span>,  <span class="comment">//定时周期 - 100ms</span></span><br><span class="line">      pdTRUE,  <span class="comment">//周期模式</span></span><br><span class="line">      (<span class="type">void</span> *)&amp;Timer01_ID,  <span class="comment">//ID</span></span><br><span class="line">      (TimerCallbackFunction_t)vMyTimerCallback <span class="comment">//回调函数</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MyTimer01Handle != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建软件定时器1成功\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer01Handle, <span class="number">0</span>) == pdPASS)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;启动软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软件定时器2并启动</span></span><br><span class="line">  MyTimer02Handle = <span class="built_in">xTimerCreate</span>(</span><br><span class="line">      <span class="string">&quot;timer02&quot;</span>,  <span class="comment">//名字</span></span><br><span class="line">      <span class="number">500</span>,  <span class="comment">//定时周期 - 500ms</span></span><br><span class="line">      pdTRUE,  <span class="comment">//周期模式</span></span><br><span class="line">      (<span class="type">void</span> *)&amp;Timer02_ID,  <span class="comment">//ID</span></span><br><span class="line">      vMyTimerCallback  <span class="comment">//回调函数</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MyTimer02Handle != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建软件定时器2成功\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer02Handle, <span class="number">0</span>) == pdPASS)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;启动软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 关闭软件定时器1</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStop</span>(MyTimer01Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器1失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭软件定时器2</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStop</span>(MyTimer02Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器2失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 打开软件定时器1</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer01Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器1失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 打开软件定时器2</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer02Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器2失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----软件定时器应用编程----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：停止软件定时器1和2\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：启动软件定时器1\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：启动软件定时器2\r\n\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h1><h2 id="任务通知的概念"><a href="#任务通知的概念" class="headerlink" title="任务通知的概念"></a>任务通知的概念</h2><p>FreeRTOS 从 V8.2.0 版本开始提供任务通知功能，每个任务都有一个 32位的通知值，在多数情况下，任务通可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列(可以保存一个 32位整数或指针值)。</p>
<p>相对于以前使用 FreeRTOS 内核通信的资源时必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等ICP通信方式解除阻塞的任务速度快45%，并且更加省RAM内存空间，任务通知的使用无须创建队列。要想使用任务通知，必须将<code>FreeRTOSConfig.h</code>中的宏定义<code>configUSE_TASK_NOTIFICATIONS</code>设置为<code>1</code>。其实 FreeRTOS 默认是为1的，所以任务通知是默认可用的。</p>
<p>FreeRTOS 提供以下几种方式发送通知给任务：</p>
<blockquote>
<p>发送通知给任务，如果有通知未读，则不覆盖通知值。</p>
<p>发送通知给任务，直接覆盖通知值。</p>
<p>发送通知给任务， 设置通知值的一个或者多个位，可以当作事件组来使用。</p>
<p>发送通知给任务，递增通知值，可以当作信号量使用。</p>
</blockquote>
<p>通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量、队列、事件组等。</p>
<p>当然，凡事都有利弊，消息通知虽然处理更快，RAM 开销更小，但也有以下限制:</p>
<blockquote>
<p>只能有一个任务接收通知消息，因为必须指定接收通知的任务。</p>
<p>只有等待通知的任务可以被阻塞，发送通知的任务在任何情况下都不会因为发送失败而进入阻塞态。</p>
</blockquote>
<h2 id="任务通知的运行机制"><a href="#任务通知的运行机制" class="headerlink" title="任务通知的运行机制"></a>任务通知的运行机制</h2><p>任务通知属于任务附带的资源，所以在任务被创建时，任务通知也被初始化，我们知道在使用队列、信号量前，必须先创建队列和信号量，目的是创建队列数据结构，比如使用<code>xQueueCreate</code>() 函数创建队列，用<code>xSemaphoreCreateBinary</code>()函数创建二值信号量等。再来看任务通知，由于任务通知的数据结构包含在任务控制块中，只要任务存在，任务通知数据结构就已经创建完毕，可以直接使用，所以使用时很方便</p>
<p>任务通知可以在任务中向指定任务发送通知，也可以在中断中向指定任务发送通知。FreeRTOS的每个任务都有一个32位的通知值，任务控制块中的成员变量<code>ulNotifiedValue</code>就是这个通知值。只有在任务中可以等待通知，而不允许在中断中等待通知。如果任务在等待的通知暂时无效，任务会根据用户指定的阻塞超时时间进入阻塞状态，我们可以将等待通知的任务看作消费者;其他任务和中断可以向等待通知的任务发送通知，发送通知的任务和中断服务函数可以看作生产者，当其他任务或者中断向这个任务发送任务通知，且任务获得通知以后，该任务就会从阻塞态中解除，这与 FreeRTOS 中内核的其他通信机制一致。</p>
<h2 id="任务通知的API函数‍"><a href="#任务通知的API函数‍" class="headerlink" title="任务通知的API函数‍"></a>任务通知的API函数‍</h2><p>1、任务通知的数据结构</p>
<p>任务通知是任务控制块的资源，属于任务控制块中的成员变量，具体如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_1.png" alt=""></p>
<p><code>ulNotifiedValue</code>: 任务通知值，用于保存一个32位整数或指针值</p>
<p><code>ucNotifyState</code>： 任务通知状态，用于标识任务的通知状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_2.png" alt=""></p>
<p>2、常用的API函数</p>
<p>① 替代二值信号量与计数信号量</p>
<p>发送任务通知：</p>
<p><code>xTaskNotifyGive</code>()</p>
<p><code>vTaskNotifyGiveFromISR</code>()</p>
<p>获取任务通知：</p>
<p><code>ulTaskNotifyTake</code>()</p>
<p>② 替代长为1的队列与事件组</p>
<p>发送任务通知：</p>
<p><code>xTaskNotify</code>()</p>
<p><code>vTaskNotifyFromISR</code>()</p>
<p>获取任务通知：</p>
<p><code>ulTaskNotifyWait</code>()</p>
<p>3、函数<code>xTaskNotifyGive</code>()</p>
<p>① 函数原型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_3.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_4.png" alt=""></p>
<p><code>功能如下</code>：在任务中向指定任务发送通知，使任务通知值加1，这种方式用于信号量</p>
<p>②形参说明</p>
<blockquote>
<p>形参1：任务句柄</p>
<p>形参2： 任务通知值，取0</p>
<p>形参3： 指示任务控制块中的变量 <code>ulNotifiedValue</code>实现加一操作</p>
<p>形参4：空</p>
</blockquote>
<p>③返回值</p>
<p>没有超时机制，永远返回<code>pdPASS</code></p>
<p>4、函数<code>ulTaskNotifyTake</code>()</p>
<p>① 函数原型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_5.webp" alt=""></p>
<p><code>功能如下</code>：在任务中获取通知，与<code>xTaskNotifyGive</code>()配套使用，用于替代二值信号量与计数信号量</p>
<p>②形参说明</p>
<blockquote>
<p>形参1：退出时是否清零计数。<code>pdTRUE</code>-&gt;清零， <code>pdFALSE</code>-&gt; 减1</p>
<p>形参2： 超时时间，单位为系统节拍</p>
</blockquote>
<p>③返回值</p>
<p>返回任务之前的任务通知值</p>
<p>5、函数<code>xTaskNotify</code>()</p>
<p>① 函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t <span class="title">xTaskGenericNotify</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle t xTaskToNotify</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulValue,</span></span></span><br><span class="line"><span class="params"><span class="function">    eNotifyAction eAction</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t *pulPreviousNotificationValue</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_7.png" alt=""></p>
<p><code>功能如下</code>：在任务中向指定任务发送通知，根据<code>eAction</code>的值完成不同操作</p>
<p>②形参说明</p>
<blockquote>
<p>形参1：任务句柄</p>
<p>形参2： 任务通知值</p>
<p>形参3： 如下图片</p>
<p>形参4：空</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_8.webp" alt=""></p>
<p>③返回值</p>
<p>根据上面第 3 个形参的说明，将其设置为 <code>eSetValueWithoutOverwrite</code>，有可能返回<code>pdFALSE</code>，其余所有情况都返回值 <code>pdPASS</code></p>
<p>6、函数<code>ulTaskNotifyWait</code>()</p>
<p>① 函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t <span class="title">xTaskNotifyWait</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulBitsToClearOnEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulBitsToClearOnExit,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t *pulNotificationValue,</span></span></span><br><span class="line"><span class="params"><span class="function">    TickType t xTicksToWait </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure>
<p>功能如下：在任务中获取通知，与<code>xTaskNotify</code>()配套使用，用于替代长度位1的队列与事件组</p>
<p>②形参说明</p>
<blockquote>
<p>形参1：进入函数时，清除哪些位 -&gt; 0：无变化  1：清除相应位</p>
<p>形参2：退出函数时，清除哪些位 -&gt; 0：无变化  1：清除相应位</p>
<p>形参3：保存通知值</p>
<p>形参4： 超时时间，单位为系统节拍</p>
</blockquote>
<p>③返回值</p>
<blockquote>
<p><code>pdTRUE</code>： 获取任务通知成功</p>
<p><code>pdFALSE</code>：获取任务通知失败</p>
</blockquote>
<p>7、使用说明</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_10.webp" alt=""></p>
<h2 id="任务通知代替二值信号量的应用编程"><a href="#任务通知代替二值信号量的应用编程" class="headerlink" title="任务通知代替二值信号量的应用编程"></a>任务通知代替二值信号量的应用编程</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_1.png" alt=""></p>
<p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_11.png" alt=""></p>
<p>2、发送任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_12.webp" alt=""></p>
<p>3、获取任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_13.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> GiveCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      xResult = <span class="built_in">xTaskNotifyGive</span>(BinarySem_SynHandle);</span><br><span class="line">      <span class="keyword">if</span>(xResult == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务通知发送成功，次数 = %u\r\n&quot;</span>,++GiveCnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">ulTaskNotifyTake</span>(pdTRUE,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xResult == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知，次数 = %u\r\n\r\n&quot;</span>,++TakeCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替二值信号量 - 任务与任务间得同步----\r\n\r\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：发送任务通知\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务通知代替计数信号量的应用编程"><a href="#任务通知代替计数信号量的应用编程" class="headerlink" title="任务通知代替计数信号量的应用编程"></a>任务通知代替计数信号量的应用编程</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_2.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_3.webp" alt=""></p>
<p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_14.png" alt=""></p>
<p>2、发送任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_15.webp" alt=""></p>
<p>3、获取任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_16.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CountingSemMAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> myCountingSem_ucMessagesWaiting = CountingSemMAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TakeNotify_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN TakeNotify_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取任务通知，获取后，任务通知值减一</span></span><br><span class="line">      myCountingSem_ucMessagesWaiting = <span class="built_in">ulTaskNotifyTake</span>(pdFALSE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (myCountingSem_ucMessagesWaiting &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知成功，申请1个停车位，发送同步显示信号\r\n\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting--;</span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知失败，停车位已满\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END TakeNotify_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GiveNotify_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN GiveNotify_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化计数信号量初始值</span></span><br><span class="line">  <span class="built_in">xTaskNotify</span>(TakeNotifyHandle, myCountingSem_ucMessagesWaiting, eSetValueWithOverwrite);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (myCountingSem_ucMessagesWaiting &lt; CountingSemMAX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 发送任务通知</span></span><br><span class="line">        xResult = <span class="built_in">xTaskNotifyGive</span>(TakeNotifyHandle);</span><br><span class="line">        <span class="keyword">if</span> (xResult == pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知成功，释放1个停车位\r\n&quot;</span>);</span><br><span class="line">          myCountingSem_ucMessagesWaiting++;</span><br><span class="line">          <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放失败，停车位已空\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END GiveNotify_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Display_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无限等待同步信号更新显示，第%u次等待，等待中\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;现在还有%d个车位\r\n\r\n&quot;</span>, myCountingSem_ucMessagesWaiting);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Display_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替计数信号量 - 模拟车库----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;默认车库可以停放20辆车，串口打印显示车位数量\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：获取信号量，模拟车辆入库，同时通过二值信号量发同步信号给显示任务\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：释放信号量，模拟车辆出库，同时通过二值信号量发同步信号给显示任务\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务通知代替队列的应用编程"><a href="#任务通知代替队列的应用编程" class="headerlink" title="任务通知代替队列的应用编程"></a>任务通知代替队列的应用编程</h2><p>工程配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_4.png" alt=""></p>
<p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_20.png" alt=""></p>
<p>2、发送任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_21.webp" alt=""></p>
<p>3、获取任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_22.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulReceiveBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">        <span class="number">0x00000000</span>,        <span class="comment">// 进入函数不清除任务通知值</span></span><br><span class="line">        <span class="number">0xFFFFFFFF</span>,        <span class="comment">// 退出函数清除任务通知值</span></span><br><span class="line">        &amp;ucRec_Data,       <span class="comment">// 保存任务通知值</span></span><br><span class="line">        ulReceiveBlockTime <span class="comment">// 阻塞时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知的数据: %u\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知的数据超时！！\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue2_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue2_Receive_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint8_t</span> *pucRec_Data = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">        <span class="number">0x00000000</span>,               <span class="comment">// 进入函数不清除任务通知值</span></span><br><span class="line">        <span class="number">0xFFFFFFFF</span>,               <span class="comment">// 退出函数清除任务通知值</span></span><br><span class="line">        (<span class="type">uint32_t</span> *)&amp;pucRec_Data, <span class="comment">// 保存任务通知值</span></span><br><span class="line">        portMAX_DELAY             <span class="comment">// 阻塞时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知的数据: %s\r\n&quot;</span>, pucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue2_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送单个数据\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue1_ReceiveHandle, ucRec_Data, eSetValueWithoutOverwrite);</span><br><span class="line"></span><br><span class="line">      ucRec_Data += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;MCU123123123&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue2_ReceiveHandle, (<span class="type">uint32_t</span>) <span class="string">&quot;MCU123123123&quot;</span>, eSetValueWithoutOverwrite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;SUE333222111&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue2_ReceiveHandle, (<span class="type">uint32_t</span>) <span class="string">&quot;SUE333222111&quot;</span>, eSetValueWithoutOverwrite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替消息队列----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：向队列1发送单个数据\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：向队列2发送字符串\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务通知代替事件组的应用编程"><a href="#任务通知代替事件组的应用编程" class="headerlink" title="任务通知代替事件组的应用编程"></a>任务通知代替事件组的应用编程</h2><p>1、实验现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_17.png" alt=""></p>
<p>2、发送任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_18.webp" alt=""></p>
<p>3、获取任务通知</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_19.webp" alt=""></p>
<p>代码</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_EVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_EVENT (EventBits_t)(0x0001 &lt;&lt; 8)  <span class="comment">// 设置事件掩码8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_EVENT (EventBits_t)(0x0001 &lt;&lt; 16) <span class="comment">// 设置事件掩码16</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define EVent_WaitAllBits // 用于预编译</span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint32_t</span> Rec_Event = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> Last_Event = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint16_t</span> SyncCnt = <span class="number">0</span>; <span class="comment">// 同步计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EVent_WaitAllBits</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">      <span class="number">0x00000000</span>,  <span class="comment">//进入函数时不清除任务通知值</span></span><br><span class="line">      <span class="number">0xFFFFFFFF</span>,  <span class="comment">//退出函数时清除任务通知值</span></span><br><span class="line">      &amp;Rec_Event,   <span class="comment">//保存任务通知值</span></span><br><span class="line">      portMAX_DELAY  <span class="comment">//阻塞时间</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      Last_Event |= Rec_Event; <span class="comment">//缓存</span></span><br><span class="line">      <span class="keyword">if</span>((Last_Event&amp;(KEY2_EVENT | KEY3_EVENT | KEY4_EVENT)) == (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功接收到任务通知同步信号（替代时间），次数= %u\r\n\r\n&quot;</span>,++SyncCnt);</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">        Last_Event = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">      <span class="number">0x00000000</span>,  <span class="comment">//进入函数时不清除任务通知值</span></span><br><span class="line">      <span class="number">0xFFFFFFFF</span>,  <span class="comment">//退出函数时清除任务通知值</span></span><br><span class="line">      &amp;Rec_Event,   <span class="comment">//保存任务通知值</span></span><br><span class="line">      portMAX_DELAY  <span class="comment">//阻塞时间</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( ((Rec_Event&amp;KEY2_EVENT) == KEY2_EVENT) || ((Rec_Event&amp;KEY3_EVENT) == KEY3_EVENT) || ((Rec_Event&amp;KEY4_EVENT) == KEY4_EVENT))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功接收到任务通知同步信号（替代时间），次数= %u\r\n\r\n&quot;</span>,++SyncCnt);</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键2事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY2_EVENT,eSetBits);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line"> 	  <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键3事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY3_EVENT,eSetBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line"> 	  <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键4事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY4_EVENT,eSetBits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替队列的应用编程----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：设置按键事件2\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：设置按键事件3\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：设置按键事件4\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="综合应用1"><a href="#综合应用1" class="headerlink" title="综合应用1"></a>综合应用1</h1><p>实验现象</p>
<p>1、间隔1s获取传感器数据，通过数码管显示</p>
<p>2、按键2,3,4触发蜂鸣器状态改变</p>
<p>3、上位机通过RS-485接口与实战板通讯</p>
<p>4、USB串口打印收到的上位机数据</p>
<hr>
<h1 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h1><h2 id="动态内存管理介绍"><a href="#动态内存管理介绍" class="headerlink" title="动态内存管理介绍"></a>动态内存管理介绍</h2><p>动态内存管理是 FreeRTOS 非常重要的一项功能，前面章节讲解的任务创建、信号量、消息队列、事件标志组、互斥信号量、软件定时器组等需要的 RAM 空间都是通过动态内存管理从 <code>FreeRTOSConfig.h</code> 文件定义的 heap 空间中申请的。</p>
<p>FreeRTOS 支持 5 种动态内存管理方案，分别通过文件 <code>heap_1</code>，<code>heap_2</code>，<code>heap_3</code>，<code>heap_4</code>和 <code>heap_5</code>实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_1.webp" alt=""></p>
<ul>
<li>heap_1</li>
</ul>
<blockquote>
<p><code>heap_1</code>动态内存管理方式是五种动态内存管理方式中最简单的，这种方式的动态内存管理一旦申请了相应内存后，是不允许被释放的。</p>
<p>尽管如此，这种方式的动态内存管理还是满足大部分嵌入式应用的，因为这种嵌入式应用在系统启动阶段就完成了任务创建、事件标志组、信号量、消息队列等资源的创建，而且这些资源是整个嵌入式应用过程中一直要使用的，所以也就不需要删除，不需要释放内存。</p>
</blockquote>
<ul>
<li>heap_2</li>
</ul>
<blockquote>
<p>与 <code>heap_1</code>动态内存管理方式不同，<code>heap_2</code>动态内存管理利用了最适应算法，并且支持内存释放。但是 <code>heap_2</code>不支持内存碎片整理，动态内存管理方式<code>heap_4</code>支持内存碎片整理。</p>
</blockquote>
<ul>
<li>heap_3</li>
</ul>
<blockquote>
<p>这种方式实现的动态内存管理是对编译器提供的 <code>malloc</code>和 <code>free</code>函数进行了封装，保证是线程安全的。</p>
</blockquote>
<ul>
<li>heap_4</li>
</ul>
<blockquote>
<p>与 <code>heap_2</code>动态内存管理方式不同，<code>heap_4</code>动态内存管理利用了最适应算法，且支持内存碎片的回收并将其整理为一个大的内存块。</p>
</blockquote>
<ul>
<li>heap_5</li>
</ul>
<blockquote>
<p>有时候我们希望 <code>FreeRTOSConfig.h</code> 文件中定义的 heap 空间可以采用不连续的内存区，比如我们希望可以将其定义在内部 SRAM 一部分，外部 SRAM 一部分，此时我们就可以采用 <code>heap_5</code>动态内存管理方式。另外，<code>heap_5</code>动态内存管理是在 <code>heap_4</code>的基础上实现的。</p>
</blockquote>
<h2 id="动态内存总结与应用"><a href="#动态内存总结与应用" class="headerlink" title="动态内存总结与应用"></a>动态内存总结与应用</h2><p>五种动态内存管理方式简单总结如下，实际项目中，用户根据需要选择合适的：</p>
<blockquote>
<p><strong>heap_1：</strong>五种方式里面最简单的，但是申请的内存不允许释放</p>
<p>heap_2：支持动态内存的申请和释放，但是不支持内存碎片的处理</p>
<p>heap_3：将编译器自带的 malloc 和 free 函数进行简单的封装</p>
<p><strong>heap_4：</strong>支持动态内存的申请和释放，支持内存碎片处理</p>
<p><strong>heap_5：</strong>在 heap_4 的基础上支持将动态内存设置在不连续的区域上</p>
</blockquote>
<p><strong>1、heap_1：</strong></p>
<p>FreeRTOS 的动态内存大小在 <code>FreeRTOSConfig.h</code> 文件中进行了定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) <span class="comment">//单位字节</span></span></span><br></pre></td></tr></table></figure>
<p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 FreeRTOS 动态内存的剩余，进而可以根据剩余情况优化动态内存的大小。</p>
<p>heap_1 方式的动态内存管理有以下特点：</p>
<blockquote>
<p>① 项目应用不需要删除任务、信号量、消息队列等已经创建的资源。</p>
<p>② 具有时间确定性，即申请动态内存的时间是固定的并且不会产生内存碎片。</p>
<p>③ 确切的说这是一种静态内存分配，因为申请的内存是不允许被释放掉的。</p>
</blockquote>
<p><strong>2、heap_4：</strong></p>
<p>FreeRTOS 的动态内存大小在 <code>FreeRTOSConfig.h</code> 文件中进行了定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) <span class="comment">//单位字节</span></span></span><br></pre></td></tr></table></figure>
<p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 FreeRTOS 动态内存的剩余，但是不提供动态内存是如何被分配成各个小内存块的信息。使用函数 <code>xPortGetMinimumEverFreeHeapSize</code>能够获取从系统启动到当前时刻的动态内存最小剩余，从而用户就可以根据剩余情况优化动态内存的大小。</p>
<p><strong>heap_4 方式的动态内存管理有以下特点：</strong></p>
<blockquote>
<p>① 可以用于需要重复的创建和删任务、信号量、事件标志组、软件定时器等内部资源的场合。</p>
<p>② 随机的调用 <code>pvPortMalloc</code>() 和 <code>vPortFree</code>()，且每次申请的大小都不同，也不会像 heap_2 那样产生很多的内存碎片。</p>
<p>③ 不具有时间确定性，即申请动态内存的时间不是确定的</p>
</blockquote>
<p><strong>3、heap_5：</strong></p>
<p>heap_5 动态内存管理是通过函数 <code>vPortDefineHeapRegions</code>进行初始化的，也就是说用户在创建任务 FreeRTOS 的内部资源前要优先级调用这个函数 <code>vPortDefineHeapRegions</code>，否则是无法通过函数<code>pvPortMalloc</code>申请到动态内存的。</p>
<p>函数 <code>vPortDefineHeapRegions</code>定义不同段的内存空间采用了下面这种结构体：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_2.webp" alt=""></p>
<p>定义的时候要注意三个问题，一个是内存段结束时要定义 <code>NULL</code>。另一个是内存段的地址是<mark>从低地址到高地址排列</mark>，最后，内存的区域与系统变量分开，尽量把地址放在后面，前面给系统用，避免冲突。</p>
<p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 <code>FreeRTOS</code>动态内存的剩余，但是不提供动态内存是如何被分配成各个小内存块的信息。使用函数 <code>xPortGetMinimumEverFreeHeapSize</code>能够获取从系统启动到当前时刻的动态内存最小剩余，从而用户就可以根据剩余情况优化动态内存的大小。</p>
<h2 id="内存管理编程测试"><a href="#内存管理编程测试" class="headerlink" title="内存管理编程测试"></a>内存管理编程测试</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_3.webp" alt=""></p>
<p>分别测试heap_4，heap_1与heap_5。</p>
<p><strong>1、heap_4</strong></p>
<p>输出内存信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_4.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_5.png" alt=""></p>
<p><strong>2、heap_1</strong></p>
<p>输出内存信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_6.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_7.png" alt=""></p>
<p><code>Note</code>：</p>
<blockquote>
<p>KEY1按下后，系统会死机，原因是<code>vTaskList</code>()函数会调用<code>vPortFree</code>()函数释放内存，而<code>heap_1</code>内存管理方案不支持内存释放，导致死机，</p>
</blockquote>
<p><strong>3、heap_5</strong></p>
<p>定义内存区域：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_8.webp" alt=""></p>
<p>输出内存信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_9.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_10.png" alt=""></p>
<hr>
<h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="独立看门狗介绍"><a href="#独立看门狗介绍" class="headerlink" title="独立看门狗介绍"></a>独立看门狗介绍</h2><p>IWDG主要性能</p>
<blockquote>
<ul>
<li>自由运行的递减计数器</li>
<li>时钟由独立的RC振荡器提供(可在停止和待机模式下工作)、</li>
<li>看门狗被激活后，则在计数器计数至0x000时产生复位</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_1.webp" alt=""></p>
<h2 id="看门狗监测多任务执行思路"><a href="#看门狗监测多任务执行思路" class="headerlink" title="看门狗监测多任务执行思路"></a>看门狗监测多任务执行思路</h2><p>1、监测目标</p>
<blockquote>
<p>① 监测系统死机</p>
<p>② 监测任务执行</p>
</blockquote>
<p>2、监测方案</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_2.webp" alt=""></p>
<p>说明：</p>
<blockquote>
<p>①、监测任务通过独立看门狗监测自身，如果长时间得不到执行，看门狗将复位系统；</p>
<p>②、监测任务通过事件标志监控其它任务，如果任一任务长时间得不到执行，看门狗将复位系统；</p>
<p>③、监测任务收到全部被监测任务发来的事件标志后，才进行喂狗。</p>
</blockquote>
<p>3、应用注意事项</p>
<blockquote>
<p>①、监测任务优先级设置最高，以便及时喂狗</p>
<p>②、监测任务与被监测任务均不可以挂起或删除，否则，无法及时喂狗导致系统复位</p>
<p>③、喂狗时间由被监测任务的最大发送事件标志间隔时间确定，并且留有足够余量</p>
<p>④、考虑事件标志只有低24位可用，被监测任务最多24个，足够使用</p>
</blockquote>
<h2 id="看门狗监测多任务编程"><a href="#看门狗监测多任务编程" class="headerlink" title="看门狗监测多任务编程"></a>看门狗监测多任务编程</h2><p>1、STM32cubeMX配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_3.webp" alt=""></p>
<p>看门狗计数周期 = <code>(1/40000) * 64 * 3750</code> = 6s</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_4.webp" alt=""></p>
<p>2、监控任务代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_5.webp" alt=""></p>
<p>3、串口输出信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_6.png" alt=""></p>
<p>代码：</p>
<ul>
<li>freertos.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task01_EVENT (EventBits_t)(0x0001 &lt;&lt; 0) <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task02_EVENT (EventBits_t)(0x0002 &lt;&lt; 1) <span class="comment">// 设置事件掩码1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task03_EVENT (EventBits_t)(0x0003 &lt;&lt; 2) <span class="comment">// 设置事件掩码2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task04_EVENT (EventBits_t)(0x0004 &lt;&lt; 3) <span class="comment">// 设置事件掩码3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_TaskAll_EVENT BIT_Task01_EVENT | BIT_Task02_EVENT | BIT_Task03_EVENT | BIT_Task04_EVENT</span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IWDG_Monitor_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN IWDG_Monitor_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line">  <span class="type">const</span> TickType_t xTicksToWait = <span class="number">6000</span> / portTICK_PERIOD_MS; <span class="comment">// 设置等待时间为6s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,   <span class="comment">// 事件句柄</span></span><br><span class="line">        BIT_TaskAll_EVENT, <span class="comment">// 事件</span></span><br><span class="line">        pdTRUE,            <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdTRUE,            <span class="comment">//&quot;逻辑与&quot; - 满足所有事件</span></span><br><span class="line">        xTicksToWait       <span class="comment">// 等待时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((xEvent &amp; (BIT_TaskAll_EVENT)) == (BIT_TaskAll_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;喂狗，监测任务与被监测任务均正常运行\r\n&quot;</span>);</span><br><span class="line">      MyIWDG.<span class="built_in">FeedDog</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 用于调试</span></span><br><span class="line">      <span class="comment">// 关闭独立看门狗，通过变量xEvent判断哪个任务没有发送事件标志</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END IWDG_Monitor_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">KEY_Task</span>(<span class="type">void</span> <span class="type">const</span> *argument)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;挂起Task01任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskSuspend</span>(task01Handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;删除Task01任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(task01Handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;挂起IWDG_Monitor任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskSuspend</span>(IWDG_MonitorHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task01_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task01_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task01_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task01_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task02_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task02_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task02_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task02_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task03_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task03_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task03_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task03_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task04_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task04_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">4000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task04_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task04_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED1_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED1_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">1000</span>);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED1_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MyInit.c</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;----独立看门狗检测任务----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY2：挂起任务1\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY3：删除任务1\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;KEY4：挂起事件任务\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	HAL_TIM_Base_Start_IT(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyIWDG.c</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FeedDog</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">MyIWDG_t MyIWDG = </span><br><span class="line">&#123;</span><br><span class="line">	TRUE,</span><br><span class="line">	</span><br><span class="line">	FeedDog</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FeedDog</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">HAL_IWDG_Refresh</span>(&amp;hiwdg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MyIWDG.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> FeedDog_Flag;  <span class="comment">//喂狗标志位</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">void</span> (*FeedDog)(<span class="type">void</span>); <span class="comment">//喂狗</span></span><br><span class="line">&#125; MyIWDG_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  MyIWDG_t  MyIWDG;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="低功耗Tickless模式"><a href="#低功耗Tickless模式" class="headerlink" title="低功耗Tickless模式"></a>低功耗Tickless模式</h1><h2 id="STM32低功耗模式讲解"><a href="#STM32低功耗模式讲解" class="headerlink" title="STM32低功耗模式讲解"></a>STM32低功耗模式讲解</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_1.webp" alt=""></p>
<blockquote>
<p>①电池类产品，一般要求低功耗设计，比如农业物联网的节点采集设备</p>
<p>②低功耗设计，除了MCU，软件， 硬件设计同等重要，以STC15低功耗实战为例说明 </p>
<p>③<code>Tickless</code>模式主要针对睡眠模式，当然，也可以自行使用停机模式，待机模式</p>
<p>④ 由于STM32物联网实战板的硬件没有低功耗设计，本例程只讲解<code>Tickless</code>模式原理与应用</p>
<p>⑤ STM32的3种低功耗详细讲解与应用编程，直接观看stm32物联网实战的视频，不再重复讲解，本例程重点讲解<code>FreeRTOS</code>的<code>Tickless</code>模式</p>
</blockquote>
<h2 id="Tickless模式介绍"><a href="#Tickless模式介绍" class="headerlink" title="Tickless模式介绍"></a>Tickless模式介绍</h2><p>1、<code>Tickless</code>模式介绍</p>
<p><code>Tickless</code>低功耗机制是当前小型 RTOS 所采用的通用低功耗方法，比如<code>FreeRTOS</code>，<code>RTX</code>和 <code>uCOS-III</code>等。</p>
<p><code>Tickless</code>是怎样一种模式呢？</p>
<p>仅从字母上看，<code>Tick</code>是滴答时钟的意思，<code>less</code>是 Tick<code> </code>的后缀，表示较少的，整体看就是表示减少滴答时钟节拍运行。</p>
<p>在FreeRTOS系统中，当用户任务都被挂起或者阻塞时，最低优先级的空闲任务会得到执行。那么 STM32 支持的低功耗模式就可以放在空闲任务里面实现。为了实现低功耗最优设计，我们还不能直接把睡眠模式放在空闲任务就可以了。由于Tick中断停止，将导致无法及时运行阻塞超时的任务，进入空闲任务后，首先要计算可以执行低功耗的最大时间，也就是求出下一个要执行的高优先级任务还剩多少时间。然后就是把低功耗的唤醒时间设置为这个求出的时间(其实就是重载<code>Systick</code>)，如果没有其它中断或事件唤醒STM32，到时间后<code>Systick</code>中断会将STM32唤醒，继续执行任务。</p>
<p>这个就是所谓的 <code>`Tickless</code>模式。从上面的讲解中可以看出，实现<code>Tickless</code>模式最麻烦的是计算低功耗可以执行的时间。这个难题，FreeRTOS 已为我们做好。</p>
<p>2、<code>Tickless</code>模式配置</p>
<blockquote>
<p>① 将宏定义<code>configUSE_TICKLESS_IDLE</code>设置为1即可</p>
<p>② 配置 <code>configEXPECTED_IDLE_TIME_BEFORE_SLEEP</code>，只有当系统可运行于低功耗模式的时钟节拍数大于等于这个参数时，系统才可以进入到低功耗模式。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_2.png" alt=""></p>
<p>此参数已在 <code>FreeRTOS.h</code>文件中定义了，默认为2，用户可以自定义时，不能小于2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_3.webp" alt=""></p>
<h2 id="Tickless模式源码分析"><a href="#Tickless模式源码分析" class="headerlink" title="Tickless模式源码分析"></a>Tickless模式源码分析</h2><blockquote>
<ul>
<li>阅读源码</li>
<li>讲讲如何在进入低功耗模式前关闭外设，退出模式后恢复，进一步降低系统功耗</li>
<li>讲讲如何在<code>Tickless</code>框架中应用待机与停机模式</li>
</ul>
</blockquote>
<h2 id="Tickless模式编程"><a href="#Tickless模式编程" class="headerlink" title="Tickless模式编程"></a>Tickless模式编程</h2><p>1、STM32cubeMX配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_4.webp" alt=""></p>
<p>2、<code>configEXPECTED_IDLE_TIME_BEFORE_SLEEP</code>设置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_5.webp" alt=""></p>
<p>3、在进入与退出<code>Tickless</code>模式时增加代码，通常是关闭外设等，此例程是关闭数码管显示，作为演示用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_6.webp" alt=""></p>
<hr>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>FreeRTOS</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://example.com/2023/11/18/FreeRTOS/">http://example.com/2023/11/18/FreeRTOS/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>6+1</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-11-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-12-10</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B%E4%B8%8E%E7%A7%BB%E6%A4%8D"><span class="toc-number">1.</span> <span class="toc-text">系统简介与移植</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">FreeRTOS简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">嵌入式操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">FreeRTOS实时操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9FreeRTOS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">为什么选择FreeRTOS操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreeRTOS%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">FreeRTOS特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">裸机系统与多任务系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">裸机系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">多任务系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">裸机系统与多任务系统对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%AD%A6FreeRTOS%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.3.</span> <span class="toc-text">初学FreeRTOS准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%A7%BB%E6%A4%8DFreeRTOS"><span class="toc-number">1.4.</span> <span class="toc-text">手动移植FreeRTOS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32CubeMX%E7%94%9F%E6%88%90FreeRTOS"><span class="toc-number">1.5.</span> <span class="toc-text">STM32CubeMX生成FreeRTOS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E3%80%81%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E4%B8%8E%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">启动流程、编码风格与调试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">启动流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.2.</span> <span class="toc-text">编码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">变量名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D"><span class="toc-number">2.2.3.</span> <span class="toc-text">函数名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-number">2.2.4.</span> <span class="toc-text">宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">调试方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">系统配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">系统配置说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9CConfig%E2%80%9D%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AE%8F-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.</span> <span class="toc-text">“Config”开始的宏 - 内核配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9CConfig%E2%80%9D%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AE%8F-%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">“Config”开始的宏 - 其他配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9CINCLUDE-%E2%80%9D%E5%BC%80%E5%A7%8B%E7%9A%84%E5%AE%8F"><span class="toc-number">3.4.</span> <span class="toc-text">“INCLUDE_”开始的宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">任务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">任务概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">任务的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.2.</span> <span class="toc-text">任务状态的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">4.1.3.</span> <span class="toc-text">任务状态的切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%B8%8E%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">系统启动与空闲任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">系统启动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">4.3.</span> <span class="toc-text">任务创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%88%A0%E9%99%A4"><span class="toc-number">4.4.</span> <span class="toc-text">任务删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7"><span class="toc-number">4.5.</span> <span class="toc-text">任务挂起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%81%A2%E5%A4%8D-%E6%99%AE%E9%80%9A%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">任务恢复(普通方式与中断方式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B"><span class="toc-number">4.7.</span> <span class="toc-text">任务管理编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%A0%88"><span class="toc-number">5.</span> <span class="toc-text">任务调度与任务栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">调度器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">抢占式调度编程测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%B0%83%E5%BA%A6%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">5.3.</span> <span class="toc-text">时间片调度编程测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E5%A4%A7%E5%B0%8F%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.4.</span> <span class="toc-text">任务栈大小确认</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A3%80%E6%B5%8B"><span class="toc-number">5.5.</span> <span class="toc-text">任务栈溢出与检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">5.5.1.</span> <span class="toc-text">任务栈溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FreerRTOS%E6%A0%88%E6%BA%A2%E5%87%BA%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.2.</span> <span class="toc-text">FreerRTOS栈溢出检测机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">5.6.</span> <span class="toc-text">栈溢出编程测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E4%B8%B4%E7%95%8C%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.</span> <span class="toc-text">任务与中断优先级，临界保护</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.1.</span> <span class="toc-text">中断优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.2.</span> <span class="toc-text">任务优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%85%B3%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%B8%B4%E7%95%8C%E6%AE%B5%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">开关中断与临界段函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">6.4.</span> <span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-number">6.4.1.</span> <span class="toc-text">CubeMX配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">6.4.2.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">6.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%94%81%EF%BC%8C%E4%B8%AD%E6%96%AD%E9%94%81%EF%BC%8C%E4%BB%BB%E5%8A%A1%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">调度锁，中断锁，任务锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%94%81%E3%80%81%E4%B8%AD%E6%96%AD%E9%94%81%EF%BC%8C%E4%BB%BB%E5%8A%A1%E9%94%81"><span class="toc-number">7.1.</span> <span class="toc-text">调度锁、中断锁，任务锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%94%81"><span class="toc-number">7.1.1.</span> <span class="toc-text">调度锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">7.1.2.</span> <span class="toc-text">中断锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%94%81"><span class="toc-number">7.1.3.</span> <span class="toc-text">任务锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%94%81%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">7.2.</span> <span class="toc-text">调度锁在线编程测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86-%E7%B3%BB%E7%BB%9F%E8%8A%82%E6%8B%8D%EF%BC%8C%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">时间管理(系统节拍，延时函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%8A%82%E6%8B%8D"><span class="toc-number">8.1.</span> <span class="toc-text">系统节拍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">延时相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E5%BB%B6%E6%97%B6%E4%B8%8E%E7%BB%9D%E5%AF%B9%E5%BB%B6%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">8.3.</span> <span class="toc-text">对延时与绝对延时的区别与编程测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.4.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.</span> <span class="toc-text">链表(数据结构)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%AE%80%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">链表简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">9.2.</span> <span class="toc-text">单向链表与双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FreeRTOS%E4%B8%AD%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">9.3.</span> <span class="toc-text">FreeRTOS中链表实现代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%8E%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">链表与节点初始化函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0-%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5%E3%80%81%E5%8D%87%E5%BA%8F%E6%8F%92%E5%85%A5%E3%80%81%E7%A7%BB%E9%99%A4"><span class="toc-number">9.5.</span> <span class="toc-text">链表操作函数(尾部插入、升序插入、移除)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">9.6.</span> <span class="toc-text">链表编程测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">消息队列的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8API%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">消息队列常用API函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">10.3.</span> <span class="toc-text">消息队列创建与删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E4%B8%AD%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81"><span class="toc-number">10.4.</span> <span class="toc-text">任务中消息队列发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%AD%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E9%80%81"><span class="toc-number">10.5.</span> <span class="toc-text">中断中消息队列发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%8E%A5%E6%94%B6"><span class="toc-number">10.6.</span> <span class="toc-text">消息队列接收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.7.</span> <span class="toc-text">消息队列应用编程 - 任务与任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">10.8.</span> <span class="toc-text">消息队列应用编程 - 中断与任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">二值信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">信号量的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">二值信号量的定义与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.</span> <span class="toc-text">二值信号量的运作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%B8%B8%E7%94%A8%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">11.4.</span> <span class="toc-text">二值信号量常用的API函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">11.5.</span> <span class="toc-text">二值信号量的应用编程 - 任务与任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">11.6.</span> <span class="toc-text">二值信号量的应用编程 - 中断与任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">12.</span> <span class="toc-text">计数信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5-1"><span class="toc-number">12.1.</span> <span class="toc-text">信号量的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">12.2.</span> <span class="toc-text">计数信号量的定义与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">计数信号量的运作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%B8%B8%E7%94%A8%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">12.4.</span> <span class="toc-text">计数信号量常用的API函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">12.5.</span> <span class="toc-text">计数信号量的应用编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">13.</span> <span class="toc-text">互斥信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5-2"><span class="toc-number">13.1.</span> <span class="toc-text">信号量的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">13.2.</span> <span class="toc-text">互斥信号量的定义与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC%E9%97%AE%E9%A2%98"><span class="toc-number">13.3.</span> <span class="toc-text">优先级翻转问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E7%BF%BB%E8%BD%AC%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">13.4.</span> <span class="toc-text">优先级翻转编程测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">13.5.</span> <span class="toc-text">互斥信号量的运作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%B8%B8%E7%94%A8%E7%9A%84API%E5%87%BD%E6%95%B0"><span class="toc-number">13.6.</span> <span class="toc-text">互斥信号量常用的API函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">13.7.</span> <span class="toc-text">互斥信号量的应用编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">14.1.</span> <span class="toc-text">事件的概念与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">14.2.</span> <span class="toc-text">事件的运作机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84API%E5%87%BD%E6%95%B0%E2%80%8D"><span class="toc-number">14.3.</span> <span class="toc-text">事件的API函数‍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8-%E4%BB%BB%E5%8A%A1%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">14.4.</span> <span class="toc-text">事件的应用 - 任务与任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8-%E4%B8%AD%E6%96%AD%E4%B8%8E%E4%BB%BB%E5%8A%A1"><span class="toc-number">14.5.</span> <span class="toc-text">事件的应用 - 中断与任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">软件定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">15.1.</span> <span class="toc-text">软件定时器的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">15.2.</span> <span class="toc-text">软件定时器的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84API%E5%87%BD%E6%95%B0%E2%80%8D"><span class="toc-number">15.3.</span> <span class="toc-text">软件定时器的API函数‍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">15.4.</span> <span class="toc-text">软件定时器的应用编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5"><span class="toc-number">16.</span> <span class="toc-text">任务通知</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.</span> <span class="toc-text">任务通知的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">16.2.</span> <span class="toc-text">任务通知的运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E7%9A%84API%E5%87%BD%E6%95%B0%E2%80%8D"><span class="toc-number">16.3.</span> <span class="toc-text">任务通知的API函数‍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%BB%A3%E6%9B%BF%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">16.4.</span> <span class="toc-text">任务通知代替二值信号量的应用编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%BB%A3%E6%9B%BF%E8%AE%A1%E6%95%B0%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">16.5.</span> <span class="toc-text">任务通知代替计数信号量的应用编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%BB%A3%E6%9B%BF%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">16.6.</span> <span class="toc-text">任务通知代替队列的应用编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E9%80%9A%E7%9F%A5%E4%BB%A3%E6%9B%BF%E4%BA%8B%E4%BB%B6%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B"><span class="toc-number">16.7.</span> <span class="toc-text">任务通知代替事件组的应用编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A81"><span class="toc-number">17.</span> <span class="toc-text">综合应用1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">18.</span> <span class="toc-text">动态内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">18.1.</span> <span class="toc-text">动态内存管理介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E6%80%BB%E7%BB%93%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">18.2.</span> <span class="toc-text">动态内存总结与应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BC%96%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">18.3.</span> <span class="toc-text">内存管理编程测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97"><span class="toc-number">19.</span> <span class="toc-text">看门狗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E7%9C%8B%E9%97%A8%E7%8B%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.1.</span> <span class="toc-text">独立看门狗介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E7%9B%91%E6%B5%8B%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%80%9D%E8%B7%AF"><span class="toc-number">19.2.</span> <span class="toc-text">看门狗监测多任务执行思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E7%9B%91%E6%B5%8B%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">19.3.</span> <span class="toc-text">看门狗监测多任务编程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8E%E5%8A%9F%E8%80%97Tickless%E6%A8%A1%E5%BC%8F"><span class="toc-number">20.</span> <span class="toc-text">低功耗Tickless模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E4%BD%8E%E5%8A%9F%E8%80%97%E6%A8%A1%E5%BC%8F%E8%AE%B2%E8%A7%A3"><span class="toc-number">20.1.</span> <span class="toc-text">STM32低功耗模式讲解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tickless%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">20.2.</span> <span class="toc-text">Tickless模式介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tickless%E6%A8%A1%E5%BC%8F%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">20.3.</span> <span class="toc-text">Tickless模式源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tickless%E6%A8%A1%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">20.4.</span> <span class="toc-text">Tickless模式编程</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 🏀 6+1</div><div id="running-time" style="color: #bbbbbb;"><script>setInterval(()=>{let create_time=Math.round(new Date('2023/11/21 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);
let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=
parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml= 
  '<svg t="1700709558688" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1687" width="200" height="200"><path d="M471.49511147 378.65244479c62.57777813-20.02488853 153.48622187-17.6355552 190.80533333 44.032-27.76177813-2.50311147-55.5235552-5.46133333-83.17155627-8.64711146-1.70666667 2.95822187-5.23377813 8.76088853-6.94044373 11.60533333-41.64266667 3.52711147-77.5964448 26.51022187-103.08266667 58.82311147-12.17422187-34.70222187-9.55733333-71.4524448 2.38933334-105.81333334zM257.59288853 378.19733333c24.00711147-1.8204448 48.01422187-2.95822187 71.90755627-4.20977814 10.69511147 10.24 21.39022187 20.36622187 32.1991104 30.4924448-2.61688853 24.3484448-8.07822187 48.24177813-15.01866667 71.68-7.3955552-3.52711147-22.3004448-10.4675552-29.696-13.88088853-44.48711147-25.71377813-97.28-29.4684448-147.00088853-20.59377813 13.19822187-38.6844448 65.19466667-31.40266667 87.60888853-63.488z" fill="#FDFEFA" p-id="1688"></path><path d="M506.88 470.69866666c32.5404448-26.96533333 75.88977813-30.26488853 116.39466667-30.83377813-39.02577813 35.95377813-38.912 101.26222187 3.75466666 133.6888896-39.936-4.096-84.42311147-2.16177813-118.10133333-27.53422294-25.8275552-15.5875552-27.07911147-58.48177813-2.048-75.32088853zM116.05333333 521.78488853c10.24-51.65511147 62.6915552-65.3084448 107.7475552-69.0631104-32.88177813 38.57066667-28.4444448 92.04622187 0.7964448 131.2995552-43.46311147-3.64088853-89.65688853-19.11466667-108.544-62.2364448zM238.93333333 465.69244479c8.4195552 0.11377813 25.3724448 0.45511147 33.792 0.56888854 1.70666667 5.00622187 5.12 14.79111147 6.71288854 19.6835552-11.83288853 3.18577813-23.66577813 6.25777813-35.49866667 9.32977813l-5.00622187-29.58222187zM654.67733333 587.43466666c23.09688853-4.77866667 45.73866667-11.37777813 68.608-17.29422187 65.7635552 7.73688853 133.46133333 16.04266667 190.80533334 51.88266667 1.024 13.88088853 1.8204448 27.76177813 2.73066666 41.64266667 3.52711147 37.31911147-18.2044448 70.4284448-34.5884448 102.17244373-30.4924448 58.1404448-79.53066667 103.08266667-130.5031104 142.9048896-15.01866667 7.9644448-29.80977813 16.27022187-44.37333333 24.8035552-23.66577813 10.12622187-47.44533333 19.91111147-71.2248896 29.9235552-135.168 39.48088853-287.63022187 11.0364448-396.5155552-78.848-49.60711147-44.37333333-96.82488853-96.59733333-116.16711147-161.67822187-6.3715552-25.14488853-13.19822187-50.176-19.9111104-75.20711146 68.26666667-9.67111147 116.62222187 42.09777813 173.5111104 68.608 19.56977813 35.95377813 52.4515552 60.416 89.6568896 75.88977813-5.80266667 13.42577813-8.76088853 28.672-18.432 40.04977813-44.48711147 19.00088853-88.51911147-7.85066667-129.5928896-22.528 18.54577813 25.03111147 41.87022187 48.9244448 73.84177814 54.95466667 64.7395552 13.42577813 132.096 12.288 197.8595552 6.5991104 54.61333333-4.096 101.71733333-53.93066667 95.0044448-110.13688853-16.95288853 22.7555552-26.51022187 53.13422187-51.54133334 68.608-54.0444448 23.7795552-132.096 23.3244448-162.24711146-36.18133334 36.6364448-16.49777813 67.01511147-42.89422187 90.6808896-75.20711146 68.49422187-31.40266667 114.34666667-97.96266667 187.50577706-120.0355552 1.2515552-2.73066667 3.64088853-8.192 4.8924448-10.92266667M526.67733333 931.83999999c-54.38577813 12.288-109.68177813-1.70666667-163.38488853-11.15022186 5.12 42.2115552 48.46933333 28.672 76.45866667 36.75022186 25.8275552 26.05511147 65.7635552 17.52177813 98.07644373 12.40177814 38.6844448-12.62933333 79.98577813-33.22311147 93.7528896-75.09333334-35.72622187 10.4675552-69.51822187 26.05511147-104.90311147 37.0915552z" fill="#FDFEFA" p-id="1689"></path><path d="M799.63022187 8.53333333h16.1564448c28.21688853 22.7555552 55.86488853 47.9004448 70.76977813 81.80622186 34.36088853 72.9315552 55.86488853 154.96533333 45.62488853 235.97511147-7.168 36.75022187 11.60533333 70.54222187 21.16266667 105.01688853 55.63733333 179.4275552-19.6835552 388.096-172.8284448 495.50222294-105.2444448 76.34488853-244.05333333 106.04088853-370.80177707 75.43466666-109.568-25.6-210.37511147-91.3635552-273.63555626-184.8888896-82.7164448-117.87377813-108.99911147-277.04888853-56.5475552-412.672 42.7804448-91.70488853-5.80266667-190.35022187-19.56977814-283.0791104-8.9884448-43.2355552 37.54666667-77.36888853 77.48266667-70.08711146 66.7875552 8.30577813 119.35288853 52.67911147 174.76266667 86.47111146 44.14577813-10.80888853 85.44711147-32.31288853 131.18577813-37.31911146 73.728-13.88088853 148.7075552-0.7964448 220.04622187 18.77333333C709.06311147 83.05777813 735.80088853 15.13244479 799.63022187 8.53333333m-30.37866667 38.00177813c-28.10311147 37.0915552-57.5715552 73.728-92.84266667 104.22044373-28.78577813 2.61688853-55.75111147-13.42577813-83.85422186-18.20444373-96.93866667-16.72533333-199.68-3.2995552-286.26488854 44.60088853-54.38577813-49.60711147-120.14933333-92.84266667-195.92533333-96.71111146-8.53333333 9.32977813-17.06666667 18.54577813-25.48622293 27.87555626 19.456 62.80533333 32.5404448 127.54488853 40.27733333 192.7395552 13.88088853-15.92888853 27.19288853-32.31288853 40.16355627-49.03822186 7.85066667 0 23.66577813-0.2275552 31.63022186-0.22755627-22.3004448 45.62488853-60.87111147 81.6924448-77.5964448 130.38933333-52.11022187 112.29866667-43.008 242.80177813-4.096 357.48977814l8.192-16.72533334C142.79111147 788.02488853 190.00888853 840.24888853 239.616 884.62222186c108.88533333 89.8844448 261.3475552 118.32888853 396.5155552 78.848 23.7795552-10.0124448 47.55911147-19.79733333 71.2248896-29.9235552 14.5635552-8.53333333 29.35466667-16.83911147 44.37333333-24.8035552 50.9724448-39.82222187 100.01066667-84.7644448 130.5031104-142.9048896 16.384-31.744 38.1155552-64.85333333 34.5884448-102.17244373l20.02488854-0.7964448c-0.34133333-70.4284448 9.78488853-142.22222187-7.96444374-211.28533334-14.79111147-65.3084448-49.3795552-124.1315552-90.6808896-176.01422186-1.59288853-38.79822187-35.49866667-59.50577813-62.9191104-80.78222294 14.22222187-39.36711147 28.55822187-79.41688853 28.1031104-121.96977706 22.98311147 40.39111147 41.1875552 83.28533333 53.248 128.2275552 1.47911147 37.888 8.4195552 80.6684448 47.21777814 98.0764448-0.68266667-79.872-19.2284448-163.84-66.44622187-229.60355627-14.79111147-24.3484448-42.89422187-25.03111147-68.1528896-22.9831104z" fill="#9F4B06" p-id="1690"></path><path d="M469.10577813 484.46577813c25.48622187-32.31288853 61.44-55.296 103.08266667-58.82311147 56.43377813-2.73066667 128.11377813-10.92266667 170.09777707 35.38488853 29.35466667 34.70222187 15.47377813 83.85422187-19.00088854 109.1128896-22.86933333 5.9164448-45.51111147 12.5155552-68.608 17.29422187-55.75111147 3.52711147-121.0595552 7.28177813-165.54666666-32.88177813-20.93511147-17.1804448-19.79733333-45.62488853-20.02488854-70.0871104m37.77422187-13.76711147c-25.03111147 16.83911147-23.7795552 59.73333333 2.048 75.32088853 33.67822187 25.3724448 78.16533333 23.43822187 118.10133333 27.53422294-42.66666667-32.42666667-42.7804448-97.73511147-3.75466666-133.6888896-40.50488853 0.56888853-83.85422187 3.8684448-116.39466667 30.83377813m143.01866667 2.16177813c14.90488853 4.77866667 29.80977813 4.55111147 44.71466666-0.5688896-0.56888853-16.04266667-16.83911147-21.39022187-27.30666666-30.1511104-8.53333333 8.87466667-22.528 15.92888853-17.408 30.72zM101.83111147 533.39022186c-9.89866667-44.8284448 31.9715552-76.34488853 68.15288853-91.70488853 49.72088853-8.87466667 102.51377813-5.12 147.00088853 20.59377813 21.2764448 27.98933333 36.864 70.08711147 7.85066667 98.7591104-58.70933333 60.07466667-186.5955552 54.272-223.00444373-27.648m14.22222186-11.60533333c18.88711147 43.12177813 65.08088853 58.5955552 108.544 62.2364448-29.24088853-39.25333333-33.67822187-92.72888853-0.7964448-131.2995552-45.056 3.75466667-97.5075552 17.408-107.7475552 69.0631104M238.93333333 465.69244479l5.00622187 29.58222187c11.83288853-3.072 23.66577813-6.144 35.49866667-9.32977813-1.59288853-4.8924448-5.00622187-14.67733333-6.71288854-19.6835552-8.4195552-0.11377813-25.3724448-0.45511147-33.792-0.56888854zM325.29066667 671.40266666c48.69688853-0.7964448 118.89777813-12.74311147 136.9884448 46.99022187-23.66577813 32.31288853-54.0444448 58.70933333-90.6808896 75.20711146 30.15111147 59.50577813 108.20266667 59.96088853 162.24711146 36.18133334 25.03111147-15.47377813 34.5884448-45.8524448 51.54133334-68.608 6.71288853 56.20622187-40.39111147 106.04088853-95.0044448 110.13688853-65.7635552 5.68888853-133.12 6.82666667-197.8595552-6.5991104-31.9715552-6.03022187-55.296-29.9235552-73.84177814-54.95466667 41.07377813 14.67733333 85.10577813 41.52888853 129.5928896 22.528 9.67111147-11.37777813 12.62933333-26.624 18.432-40.04977813-37.20533333-15.47377813-70.08711147-39.936-89.6568896-75.88977813 11.94666667-14.5635552 23.89333333-29.12711147 35.95377814-43.69066667 2.048 9.4435552 6.25777813 28.4444448 8.4195552 37.888 0.91022187-9.78488853 2.8444448-29.35466667 3.8684448-39.1395552z" fill="#9F4B06" p-id="1691"></path><path d="M769.2515552 46.53511146c25.25866667-2.048 53.36177813-1.36533333 68.1528896 22.9831104 47.21777813 65.7635552 65.7635552 149.7315552 66.44622187 229.60355627-38.79822187-17.408-45.73866667-60.1884448-47.21777814-98.0764448-12.0604448-44.94222187-30.26488853-87.8364448-53.248-128.2275552 0.45511147 42.55288853-13.88088853 82.60266667-28.1031104 121.96977706 27.4204448 21.2764448 61.32622187 41.984 62.9191104 80.78222294 41.30133333 51.88266667 75.88977813 110.70577813 90.6808896 176.01422186 17.74933333 69.06311147 7.62311147 140.85688853 7.96444374 211.28533334l-20.02488854 0.7964448c-0.91022187-13.88088853-1.70666667-27.76177813-2.73066666-41.64266667-57.344-35.84-125.04177813-44.14577813-190.80533334-51.88266667 34.47466667-25.25866667 48.3555552-74.41066667 19.00088854-109.1128896-41.984-46.3075552-113.664-38.1155552-170.09777707-35.38488853 1.70666667-2.8444448 5.23377813-8.64711147 6.94044373-11.60533333 27.648 3.18577813 55.40977813 6.144 83.17155627 8.64711146-37.31911147-61.6675552-128.2275552-64.05688853-190.80533333-44.032-11.94666667 34.36088853-14.5635552 71.11111147-2.38933334 105.81333334 0.2275552 24.46222187-0.91022187 52.90666667 20.02488854 70.0871104 44.48711147 40.1635552 109.7955552 36.40888853 165.54666666 32.88177813-1.2515552 2.73066667-3.64088853 8.192-4.8924448 10.92266667-73.15911147 22.07288853-119.0115552 88.63288853-187.50577706 120.0355552-18.09066667-59.73333333-88.2915552-47.78666667-136.9884448-46.99022187-1.024 9.78488853-2.95822187 29.35466667-3.8684448 39.1395552-2.16177813-9.4435552-6.3715552-28.4444448-8.4195552-37.888-12.0604448 14.5635552-24.00711147 29.12711147-35.95377814 43.69066667-56.88888853-26.51022187-105.2444448-78.27911147-173.5111104-68.608 6.71288853 25.03111147 13.5395552 50.06222187 19.9111104 75.20711146l-8.192 16.72533334c-38.912-114.688-48.01422187-245.19111147 4.096-357.48977814 16.72533333-48.69688853 55.296-84.7644448 77.5964448-130.38933333-7.9644448 0-23.7795552 0.2275552-31.63022186 0.22755627A1108.13866667 1108.13866667 0 0 1 125.1555552 301.05599999c-7.73688853-65.19466667-20.82133333-129.93422187-40.27733333-192.7395552 8.4195552-9.32977813 16.95288853-18.54577813 25.48622293-27.87555626 75.776 3.8684448 141.5395552 47.104 195.92533333 96.71111146 86.58488853-47.9004448 189.32622187-61.32622187 286.26488854-44.60088853 28.10311147 4.77866667 55.0684448 20.82133333 83.85422186 18.20444373 35.27111147-30.4924448 64.7395552-67.12888853 92.84266667-104.22044373M257.59288853 378.19733333c-22.41422187 32.08533333-74.41066667 24.8035552-87.60888853 63.488-36.18133333 15.36-78.0515552 46.8764448-68.15288853 91.70488853 36.40888853 81.92 164.29511147 87.72266667 223.00444373 27.648 29.01333333-28.672 13.42577813-70.76977813-7.85066667-98.7591104 7.3955552 3.41333333 22.3004448 10.35377813 29.696 13.88088853 6.9404448-23.43822187 12.40177813-47.3315552 15.01866667-71.68-10.80888853-10.12622187-21.504-20.2524448-32.1991104-30.4924448-23.89333333 1.2515552-47.9004448 2.38933333-71.90755627 4.20977814z" fill="#FEE173" p-id="1692"></path><path d="M649.89866667 472.86044479c-5.12-14.79111147 8.87466667-21.84533333 17.408-30.72 10.4675552 8.76088853 26.73777813 14.1084448 27.30666666 30.1511104-14.90488853 5.12-29.80977813 5.3475552-44.71466666 0.5688896zM526.67733333 931.83999999c35.38488853-11.0364448 69.17688853-26.624 104.90311147-37.0915552-13.76711147 41.87022187-55.0684448 62.464-93.7528896 75.09333334-32.31288853 5.12-72.24888853 13.65333333-98.07644373-12.40177814-27.98933333-8.07822187-71.33866667 5.46133333-76.45866667-36.75022186 53.70311147 9.4435552 108.99911147 23.43822187 163.38488853 11.15022186z" fill="#FEE173" p-id="1693"></path></svg> 已经活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer src="/js/fomal.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//at.alicdn.com/t/c/font_4341224_thz0gklagdp.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script async src="/js/title.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topLeft', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E6%98%9F%E6%98%9F.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '😝好好学习，天天向上😝' // 通知消息内容
        });
    }
</script>
<script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.6.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt="">STM32HAL库</a><div class="blog-slider__text">HAL库</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt="">STM32标准库</a><div class="blog-slider__text">标准库</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num11.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt="">FreeRTOS</a><div class="blog-slider__text">单片机操作系统</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('pagination');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__rotateInDownLeft');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>