<!DOCTYPE html><html lang="zh-CN" data-theme="light"> <head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>普中51单片机 | 会飞的鱼</title><meta name="author" content="6+1"><meta name="copyright" content="6+1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="学习资料加学习源码 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1aybvYKSoAEGx5kTOUW1PjQ提取码：0613 一、开发板的功能及使用介绍开发板的功能及使用介绍 我们先来看下开发板各功能模块， 如下：     二、51单片机介绍单片机简历一台能够工作的计算机要有这样几个部件构成： CPU（进行运算、 控制） 、 RAM （数据存储） 、 ROM（程序存储） 、 输入&#x2F;输出">
<meta property="og:type" content="article">
<meta property="og:title" content="普中51单片机">
<meta property="og:url" content="http://example.com/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/index.html">
<meta property="og:site_name" content="会飞的鱼">
<meta property="og:description" content="学习资料加学习源码 链接：https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1aybvYKSoAEGx5kTOUW1PjQ提取码：0613 一、开发板的功能及使用介绍开发板的功能及使用介绍 我们先来看下开发板各功能模块， 如下：     二、51单片机介绍单片机简历一台能够工作的计算机要有这样几个部件构成： CPU（进行运算、 控制） 、 RAM （数据存储） 、 ROM（程序存储） 、 输入&#x2F;输出">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/num3.webp">
<meta property="article:published_time" content="2023-11-22T01:41:45.000Z">
<meta property="article:modified_time" content="2023-11-25T11:32:27.242Z">
<meta property="article:author" content="6+1">
<meta property="article:tag" content="51单片机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/num3.webp"><link rel="shortcut icon" href="/img/tubiao.webp"><link rel="canonical" href="http://example.com/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '普中51单片机',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-25 19:32:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><link rel="stylesheet" href="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/css/iziToast.min.css" media="all" onload="this.media='all'"><link rel="stylesheet" href="/css/readPercent.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/TX1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-MBEfenggechangyongtubiao-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-MBEfenggechangyongtubiao-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlecidai">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingyuan-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-aixin"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin"></use></svg><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/num3.webp')"><nav class="fixed" id="nav"><span id="blog-info"><a href="/" title="会飞的鱼"><span class="site-name">会飞的鱼</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-home"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-home"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-guidang"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-guidang"></use></svg><span> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><i class="fa-fw icon-MBEfenggechangyongtubiao-biaoqian"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-MBEfenggechangyongtubiao-biaoqian"></use></svg><span> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-fenlei"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-fenlei"></use></svg><span> 分类</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liebiao"></use></svg><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-yinlecidai">                   </use></svg><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon--dianyingyuan-">                   </use></svg><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-liuyanban"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-liuyanban"></use></svg><span> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw icon-lianjie"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-lianjie"></use></svg><span> 友链</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><i class="fa-fw icon-aixin"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-aixin"></use></svg><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">普中51单片机</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表</span><time class="post-meta-date-created" datetime="2023-11-22T01:41:45.000Z" title="发表 2023-11-22 09:41:45">2023-11-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新</span><time class="post-meta-date-updated" datetime="2023-11-25T11:32:27.242Z" title="更新 2023-11-25 19:32:27">2023-11-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数:</span><span class="word-count">8.4w</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学习资料加学习源码</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1aybvYKSoAEGx5kTOUW1PjQ">https://pan.baidu.com/s/1aybvYKSoAEGx5kTOUW1PjQ</a><br>提取码：0613</p>
<h3 id="一、开发板的功能及使用介绍"><a href="#一、开发板的功能及使用介绍" class="headerlink" title="一、开发板的功能及使用介绍"></a>一、开发板的功能及使用介绍</h3><p>开发板的功能及使用介绍</p>
<p>我们先来看下开发板各功能模块， 如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610201214200.png" alt="image-20230610201214200"> </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610201232031.png" alt="image-20230610201232031"> </p>
<h3 id="二、51单片机介绍"><a href="#二、51单片机介绍" class="headerlink" title="二、51单片机介绍"></a>二、51单片机介绍</h3><h4 id="单片机简历"><a href="#单片机简历" class="headerlink" title="单片机简历"></a>单片机简历</h4><p>一台能够工作的计算机要有这样几个部件构成： CPU（进行运算、 控制） 、 RAM （数据存储） 、 ROM（程序存储） 、 输入/输出设备（例如： 串行口、 并行输出口等） 。 在个人计算机上这些部件被分成若干块芯片， 安装一个称之为主板的印刷线路板上。 而在单片机中， 这些部件全部被做到一块集成电路芯片中， 所以就称为单片机（也称微控制器 MCU） ， 而且有一些单片机中除了上述部份外， 还集成了其它部份如 A/D， D/A 等。 体积不大， 一般用 40 脚封装， 当然功能多一些单片机也有引脚比较多的， 如 68 引脚， 功能少的只有 10 多个或 20 多个引脚， 有的甚至只 8 只引脚。  </p>
<h4 id="51单片机简介"><a href="#51单片机简介" class="headerlink" title="51单片机简介"></a>51单片机简介</h4><p>51 单片机是对所有兼容 Intel 8031 指令系统的单片机的统称。 该系列单片机的始祖是 Intel 的 8004 单片机， 后来随着 Flash rom 技术的发展， 8004 单片机取得了长足的进展， 成为应用最广泛的 8 位单片机之一， 其代表型号是 ATMEL公司的 AT89 系列， 它广泛应用于工业测控系统之中。 很多公司都有 51 系列的兼容机型推出， 今后很长的一段时间内将占有大量市场。 51 单片机是基础入门的一个单片机， 还是应用最广泛的一种。 需要注意的是 51 系列的单片机一般不具备自编程能力。  </p>
<p>80C51 是 MCS-51 系列中的一个典型品种； 其它厂商以 8051 为基核开发出的CMOS 工艺单片机产品统称为 80C51 系列。 当前常用的 80C51 系列单片机主要产品有：  </p>
<p>Intel(英特尔)的： i80C31、 i80C51、 i87C51， i80C32、 i80C52、 i87C52 等；ATMEL(艾德梅尔)的： AT89C51、 AT89C52、 AT89C2051， AT89S51（RC）AT89S52 （RC） 等；</p>
<p>Philips(飞利浦)、 华邦、 Dallas(达拉斯)、 Siemens(西门子)等公司的许多产品；  </p>
<p>STC(国产宏晶)单片机： STC89C51、 STC89C52、 STC89C516、 STC90C516 等众多品牌。80C51 芯片管脚图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203251280.png" alt="image-20230610203251280"></p>
<p>上图中左图是 51 单片机非常经典的管脚图， 通常采用的是 DIP-40 封装。<br>其内部资源如下：<br>· 8 位 CPU<br>· 4kbytes 程序存储器(ROM) (52 为 8K)<br>· 128bytes 的数据存储器(RAM) （52 有 256bytes 的 RAM）<br>· 32 条 I/O 口线<br>· 111 条指令， 大部分为单字节指令<br>· 21 个专用寄存器<br>· 2 个可编程定时/计数器<br>· 5 个中断源， 2 个优先级（52 有 6 个）<br>· 一个全双工串行通信口<br>· 外部数据存储器寻址空间为 64kB<br>· 外部程序存储器寻址空间为 64kB<br>· 逻辑操作位寻址功能<br>· 双列直插 40PinDIP 封装<br>· 单一+5V 电源供电<br>CPU： 由运算和控制逻辑组成， 同时还包括中断系统和部分外部特殊功能寄<br>存器；</p>
<p>RAM： 用以存放可以读写的数据， 如运算的中间结果、 最终结果以及欲显示<br>的数据；<br>ROM： 用以存放程序、 一些原始数据和表格；<br>I/O 口： 四个 8 位并行 I/O 口， 既可用作输入， 也可用作输出<br>T/C： 两个定时/记数器， 既可以工作在定时模式， 也可以工作在计数模式；<br>五个中断源的中断控制系统；<br>一个全双工 UART（通用异步接收发送器） 的串行 I/O 口， 用于实现单片机之<br>间或单片机与微机之间的串行通信；<br>片内振荡器和时钟产生电路， 石英晶体和微调电容需要外接。 最佳振荡频率<br>为 6M—12M。</p>
<p>其内部结构图如下所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203426520.png" alt="image-20230610203426520"></p>
<p>总线（BUS） 是单片机各部件之间传送信息的公共通道。 单片机中有内部总线和外部总线两类， 内部总线是 CPU 内部之间的连线， 外部总线是指 CPU 与其它部件之间的连线； 外部总线有三种: 数据总线 DB（ Data Bus） ,地址总线 AB （Address Bus） 和控制总线 CBControl Bus） 。  </p>
<h4 id="STC89Cxx芯片介绍"><a href="#STC89Cxx芯片介绍" class="headerlink" title="STC89Cxx芯片介绍"></a>STC89Cxx芯片介绍</h4><p>前面介绍了很多款基于 MCS-51 内核设计的 51 单片机， 这么多款 51 单片机是不是都要去学习呢？ 当然不是， 既然他们的内核指令都是一样的， 那我们只需要学会一款典型并具代表性的 51 单片机即可， 其他的都是可以兼容的。  </p>
<p>早期很长一段时间， 51 单片机大部分使用的是 AT89C51 或者 AT89C52。 随着我国芯片技术的快速发展， 宏晶公司推出的增强型 51 单片机 STC89Cxx/STC90Cxx等系列更受大众喜爱， 除内部资源及功能大大增强外， 还有一个非常重要的是它支持 ISP（在系统可编程） /IAP（在应用可编程） ， 无需专用编程器或专用仿真器。 宏晶公司推出的 51 芯片种类非常多， 我们只需选择一款经典的学习即可。我们开发板上使用的是STC89C52或者STC89C516， 这两款芯片以及其他STC89Cxx或者 STC90Cxx 除 Flash 和 RAM 容量差异外， 内部资源功能几乎一样， 我们只需学习任意一种即可。 下面我们看下常见 PDIP 封装（直插封装） 的 51 单片机芯片实物图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203704417.png" alt="image-20230610203704417"> </p>
<p>上图可看到芯片表面印有 STC89C52RC 40I-PDIO40 1947H0XN52.X90C 丝印，下面我们了解下芯片表面丝印的含义：  </p>
<p>STC—表示芯片为 STC 公司生产的产品， 其他公司的也有 AT、 i、 SST 等。<br>8—表示该芯片为 8051 内核芯片。<br>9—表示内部含有 Flash EEPROM 存储器， 还有如 80C51 中 0 表内部含有MaskROM（掩模 ROM） 存储器； 如 87C51 中 7 表示内部含有 EPROM（紫外线可擦除ROM） 存储器。  </p>
<p>C—表示该器件为 CMOS 产品。 还有如 89LV52 和 89LE58 中的 LV 和 LE 都表示<br>该芯片为低电压产品（通常为 3.3V 电压供电） ； 而 89S52 中 S 表示该芯片含有<br>可串行下载功能的 Flash 存储器， 即具有 ISP 可在线编程功能。<br>5—固定不变。</p>
<p>2—表示该芯片内部程序存储（FLASH） 空间大小， 1 为 4KB， 2 为 8KB， 3 为<br>12KB， 即该数乘以 4KB 就是芯片内部的程序存储空间大小。 程序空间大小决定了<br>一个芯片所能装入执行代码的多少。 一般来说， 程序存储空间越大， 芯片价格也<br>越高， 所以我们再选择芯片的时候要根据自己需求选择合适芯片。<br>RC—STC 单片机内部 RAM（随机读写存储器） 为 512B。 还有如 RD+表示内部<br>RAM 为 1280B。 还有芯片会省略此部分。<br>40—表示芯片外部晶振最高可接入 40MHz。 对 AT 单片机数值一般为 24， 表<br>示外部晶振最高位 24MHz。<br>I—产品级别， 表示芯片使用温度范围。<br>C 表示商业级， 温度范围为 0~+70 度。<br>I 表示工业级， 温度范围为-40~+85 度。<br>A 表示汽车级， 温度范围为-40~+125 度。<br>M 表示军用级， 温度范围为-55~+150 度。<br>PDIP40—产品封装型号。 PDIP 表示双列直插式。<br>1947—表示本批芯片生产日期为 19 年第 47 周。<br>H0XN52.X90C—不详， 有关资料显示， 此标号表示芯片制造工艺或处理工艺。</p>
<h5 id="STC89C51芯片简介"><a href="#STC89C51芯片简介" class="headerlink" title="STC89C51芯片简介"></a>STC89C51芯片简介</h5><p>STC89C51 是 STC 推出的新一代超强抗干扰/高速/低功耗的 51 单片机， 它是<br>采用 8051 核的 ISP（In System Programming） 在系统可编程芯片， 指令代码完<br>全兼容传统的 8051 单片机， 最高工作时钟频率为 80MHz， 片内含 4K Bytes 的可<br>反复擦写 1000 次的 Flash 只读程序存储器， 器件兼容标准 MCS-51 指令系统及<br>80C51 引脚结构， 芯片内集成了通用 8 位中央处理器和 ISP Flash 存储单元， 具<br>有在系统可编程（ISP） 特性， 配合 PC 端的控制程序即可将用户的程序代码下载<br>进单片机内部， 省去了购买通用编程器， 而且速度更快。 STC89C51 系列单片机<br>是单时钟/机器周期(1T)的兼容 8051 内核单片机， 是高速/ 低功耗的新一代<br>8051 单片机， 全新的流水线/精简指令集结构,内部集成 MAX810 专用复位电路。<br>其特性功能主要如下：<br>1： 增强型 8051 单片机， 6 时钟/机器周期和 12 时钟/机器周期可任意选择，指令代码完全兼容传统 8051。<br>2： 工作电压： 5.5V - 3.3V (5V 单片机) / 3.6V - 2.0V (3V 单片机）<br>3： 工作频率范围： 0～40MHz， 相当于普通 8051 的 0～80MHz， 实际工作频<br>率可达 48MHz<br>4： 用户应用程序空间： 4K / 8K / 13K / 16K / 32K / 64K 字节（STC89C516）<br>5： 片上集成 1280 字节或 512 字节或 256 字节 RAM<br>6： 通用 I/O 口(35/39 个)， 复位后为： P1/P2/P3/P4 是准双向口/弱上拉(普<br>通 8051 传统 I/O 口)； P0 口是开漏输出， 作为总线扩展用时， 不用加上拉电阻，<br>作为 I/O 口用时， 需加上拉电阻。<br>7： ISP（在系统可编程） / IAP（在应用可编程） ， 无需专用编程器， 无<br>需专用仿真器， 可通过串口（ RxD/P3.0, TxD/P3.1） 直接下载用户程序， 数秒<br>即可完成一片。<br>8： 有 EEPROM 功能<br>9： 看门狗<br>10： 内部集成 MAX810 专用复位电路（HD 版本和 90C 版本才有） ， 外部晶体<br>20M 以下时， 可省外部复位电路,复位脚可直接接地。<br>11： 有 3 个 16 位定时器/ 计数器， 其中定时器 0 还可以当成 2 个 8 位定时<br>器使用。<br>12： 外部中断 4 路,下降沿中断或低电平触发中断,Power Down 模式可由外<br>部中断低电平触发中断方式唤醒<br>13： 通用异步串行口(UART)， 还可用定时器软件实现多个 UART<br>14： 工作温度范围： -40 ~ +85℃(工业级) / 0 ~ 75℃(商业级)<br>15： 封装： LQFP-44, PDIP-40, PLCC-44, PQFP-44</p>
<h5 id="STC89C51-芯片引脚介绍"><a href="#STC89C51-芯片引脚介绍" class="headerlink" title="STC89C51 芯片引脚介绍"></a>STC89C51 芯片引脚介绍</h5><p>下图我们可以看到 51 单片机不同封装的引脚图， 当大家首次看见这些引脚<br>时， 一定会有又多又乱的感觉， 而且难以记忆。 千万不要着急， 对于初学者来说，<br>单纯的记忆引脚标号没有任何意义， 最好的方法是边学边记忆。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204218476.png" alt="image-20230610204218476"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204231443.png" alt="image-20230610204231443"></p>
<h6 id="单片机脚位判断"><a href="#单片机脚位判断" class="headerlink" title="单片机脚位判断"></a>单片机脚位判断</h6><p>​    在在讲解各引脚含义之前， 我们首先应该学会如何在实物上区分引脚序号，<br>基于 8051 内核的单片机， 若引脚数相同， 或封装相同， 它们的引脚功能是相同<br>的， 其中用的较多的是 40 脚 DIP 封装的 51 单片机， 也有 20,28,32， 44 等不同<br>引脚数的 51 单片机， 这些大家也要了解， 不能只见了 40 脚的芯片才认为它是<br>51 单片机。<br>无论哪种芯片， 单片机也好， 其他不知名的芯片也好， 当我们观察它的表面<br>时， 大都会找到一个凹进去的小圆坑， 或是用颜色标记的一个小标记（圆点或三<br>角或其他小图形） ， 这个小圆坑或者小标记所对应的引脚就是这个芯片的第 1脚， 然后逆时针方向数下去， 即 1 到最后一个引脚。 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204539108.png" alt="image-20230610204539108"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204546382.png" alt="image-20230610204546382"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204558377.png" alt="image-20230610204558377"></p>
<p>上图中对于 LQFP/PQFP 封装， 小圆坑在左下角位置； 对于 DIP 封装， 小圆坑<br>在芯片上方正中间位置， 对应左边第一个脚位为 1； 对于 PLCC 封装， 小圆坑在<br>芯片上方正中间位置， 对应脚位为 1； 在实际焊接或绘制电路板时， 大家务必要<br>注意它们的脚位标号， 否则若焊接错误则导致产品无法正常工作</p>
<h6 id="51-单片机脚位功能"><a href="#51-单片机脚位功能" class="headerlink" title="51 单片机脚位功能"></a>51 单片机脚位功能</h6><p>接下来我们以上图 PDIP 封装引脚图为例介绍各个引脚的功能， 40 引脚我们<br>按其功能类别可分为四类：<br>①电源引脚。 如 VCC、 GND<br>②时钟引脚。 如 XTAL1、 XTAL2<br>③编程控制引脚。 如 RST、 PSEN、 ALE/PROG、 EA/Vpp。 （此处了解即可）<br>④I/O 口引脚。 如 P0、 P1、 P2、 P3， 4 组 8 位 I/O 口。<br>VCC（40 脚） 、 GND（20 脚） ： 电源引脚， 不同型号单片机接入对应电压，<br>常压为+5V， 低压为+3.3V， 大家在使用时要查看其芯片所要求的电压。</p>
<p>XTAL1（19 脚） 、 XTAL2（18 脚） ： 外接时钟引脚。 XTAL1 为片内振荡电路的<br>输入端， XTAL2 为片内振荡电路的输出端。 8051 的时钟有两种方式， 一种是片内<br>时钟振荡方式， 即需在这两个引脚处外接石英晶振和振荡电容， 振荡电容的值一<br>般取 10p~30p； 另一种是外部时钟方式， 即将 XTAL1 接地， 外部时钟信号从 XTAL2脚输入。 通常使用第一种方式。<br>RST（9 脚） ： 复位引脚。 当输入连续两个机器周期以上高电平时为有效， 用<br>来完成单片机的复位初始化操作， 即单片机从头开始执行程序。</p>
<p>PSEN（29 脚） ： 程序存储器允许输出控制端。 在读外部程序存储器时 PSEN<br>低电平有效， 以实现外部程序存储器单元的读操作， 由于现在我们使用的单片机<br>内部已经有足够大的 ROM， 所以几乎没有人再去扩展外部 ROM， 因此这个引脚大<br>家只需了解即可。</p>
<p>ALE/PROG（30 脚） ： 在扩展外部 RAM 时， ALE 用于控制把 P0 口的输出低 8<br>位地址送锁存器锁存起来， 以实现低位地址和数据的隔离。 ALE 有可能是高电平<br>也有可能是低电平， 当 ALE 为高电平时， 允许地址锁存型号， 当访问外部存储器<br>时， ALE 信号负跳变（即由正变负） 将 P0 口上低 8 位地址信号送入锁存器； 当<br>ALE 为高电平时， P0 口上的内容和锁存器输出一致。 关于锁存器后面我们会有介<br>绍。 在没有访问外部存储器期间， ALE 以 1/6 振荡周期频率输出（即 6 分频） ，<br>当访问外部存储器时， 以 1/12 振荡周期输出（12 分频） 。 从这里可以看到， 当<br>没有扩展外部 RAM 时， ALE 会以 1/6 振荡周期的固定频率输出， 因此可以作为外部时钟， 或作为外部定时脉冲使用。 PROG 为编程脉冲的输入端， 单片机的内部<br>有程序存储器（ROM） ， 它的作用是用来存放用户需要执行的程序， 那么我们怎<br>样才能将写好的程序存入这个 ROM 中呢？ 实际上， 我们是通过编程脉冲输入才写<br>进去的， 这个脉冲的输入端口就是 PROG。 现在绝大多数单片机都已经不需要编<br>程脉冲引脚往内部写程序了， 比如我们使用的 STC 单片机， 它可以直接通过串口<br>往里面写程序， 只需要三条线与计算机相连即可。 而且现在的单片机内部都已经<br>带有丰富的 RAM， 所以也不需要再扩展 RAM 了， 因此 ALE/PROG 引脚用于不大，大家了解即可。</p>
<p>EA/Vpp（31 脚） ： EA 接高电平时， 单片机读取内部程序存储器。 当扩展有<br>外部 ROM 时， 当读取完内部 ROM 后自动读取外部 ROM。 EA 接低电平时， 单片机直接读取外部 ROM。 我们没有外扩 ROM， 并且需要单片机直接读取内部程序存储器，因此 EA/Vpp 脚直接接高电平。</p>
<p>P0 口（39 脚~32 脚） ： 双向 8 位三态 I/O 口， 每个口可独立控制。 51 单片<br>机 P0 口内部没有上拉电阻， 若输出高时为高阻态， 不能正常输出高电平， 因此<br>该组 I/O 口， 每个口可独立控制。 51 单片机 P0 口内部没有上拉电阻， 若输出高<br>时为高阻态， 不能正常输出高电平， 因此该组 I/O 口在使用时务必要外接上拉电<br>阻， 一般我们选择接入 10K 欧上拉电阻。</p>
<p>P1 口（1 脚~8 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上拉<br>电阻， 这种接口输出没有高阻态， 输入也不能锁存， 故不是真正的双向 I/O 口。<br>之所以称它为“准双向” 是因为该口在作为输入使用前， 要先向该口进行写 1<br>操作， 然后单片机内部才可正确读出外部信号， 也就是要使其先有个“准” 备的<br>过程， 所以才称为准双向口。 对 52 单片机 P1.0 引脚的第二功能未 T2 定时器/<br>计数器的外部输入， P1.1 引脚的第二功能为 T2EX 捕捉、 重装触发， 即 T2 的外<br>部控制端。</p>
<p>P2 口（21 脚~28 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上<br>拉电阻， 与 P1 口相似。</p>
<p>P3 口（10 脚~17 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上<br>拉电阻。 作为第一功能使用时就当做普通 I/O 口， 与 P1 口相似。 作为第二功能<br>使用时， 各引脚的定义如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204858363.png" alt="image-20230610204858363"></p>
<p>从图中可知， P3 口的每一个引脚均可独立定义为第一功能的输入/输出或第二功能。  </p>
<h5 id="STC89C51-芯片内部结构"><a href="#STC89C51-芯片内部结构" class="headerlink" title="STC89C51 芯片内部结构"></a>STC89C51 芯片内部结构</h5><p>STC89C51 系列单片机的内部结构框图如下图所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610205026326.png" alt="image-20230610205026326"></p>
<p>STC89C51 单片机中包含中央处理器(CPU)、 程序存储器(Flash)、 数据存储器<br>(SRAM)、定时/计数器、 UART 串口、 I/O 接口、 EEPROM、看门狗等模块。 STC89C51系列单片机几乎包含了数据采集和控制中所需的所有单元模块， 可称得上一个片上系统。<br>想要了解更多 STC89C5xx 系列芯片介绍， 可以百度搜索对应数据手册。 在我<br>们资料内也提供了该芯片的数据手册， 可作为 STC89C5XX 单片机学习参考。</p>
<h3 id="三、数字电路与C语言"><a href="#三、数字电路与C语言" class="headerlink" title="三、数字电路与C语言"></a>三、数字电路与C语言</h3><h4 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h4><p>单片机是一种数字集成芯片， 数字电路中只有两种电平： 高电平和低电平。<br>为了让大家在刚起步的时候对电平特性有一个清晰的认识， 我们暂时定义单片机<br>输出与输入为 TTL 电平， 其中高电平为+5V， 低电平为 0V。 计算机的串口为 RS232电平， 其中高电平为-12V， 低电平为+12V。 这里强调的是， RS232C 电平为负逻辑电平， 大家不要认为上面是我写错了。 因此当计算机与单片机之间要通信时，需要依靠电平转换芯片， 比如 MAX232 电平转换芯片。</p>
<p>常用的逻辑电平还有很多， 比如 TTL、 CMOS、 LVTTL、 RS-232、 RS-485 等。<br>其中TTL和CMOS的逻辑电平按典型电压可分为四类： 5V系列（5V TTL和5V CMOS）、3.3V 系列， 2.5V 系列和 1.8V 系列。</p>
<p>5V TTL 和 5V CMMOS 是通用的逻辑电平。 3.3V 及以下的逻辑电平被称为低电<br>压逻辑电平， 常用的为 LVTTL 电平。 低电压逻辑电平还有 2.5V 和 1.8V 两种。<br>RS-232 和 RS-485 是串口的接口标准， RS-232 是单端输入/输出。 RS-485 是差分<br>输入/输出。<br>TTL 电平信号用的最多， 这是因为数据表示通常采用二进制， +5V 等价于逻<br>辑 1， 0V 等价于逻辑 0， 这被称为 TTL（晶体管-晶体管逻辑电平） 信号系统。</p>
<p>CMOS 电平 VCC 可达 12V， CMOS 电路输出高电平约为 0.9VCC， 而输出低电平<br>约为 0.1VCC。 CMOS 电路中不使用的输入端不能悬空， 否则会造成逻辑混乱。 另<br>外， CMOS 集成电路电源电压可以在较大范围内变化， 因而对电源的要求不像 TTL<br>集成电路那样严格。</p>
<p>TTL 电路和 CMOS 电路的逻辑电平关系如下：<br>①VOH： 逻辑电平 1 的输出电压。<br>②VOL： 逻辑电平 0 的输出电压。<br>③VIH： 逻辑电平 1 的输入电压。<br>④VIL： 逻辑电平 0 的输入电压。</p>
<p>TTL 电平临界值：</p>
<p>①VOHmin=2.4V， VOLmax=0.4V。<br>②VIHmin=2.0V， VILmax=0.8V。<br>CMOS 电平临界值（假设电源电压为+5V） ：<br>①VOHmin=4.99V， VOLmax=0.01V。<br>②VIHmin=3.5V， VILmax=1.5V。<br>TTL 和 CMOS 的逻辑电平转换： CMOS 电平能驱动 TTL 电平， 但 TTL 电平不能<br>驱动 CMOS 电平， 需加上拉电阻。<br>常用逻辑芯片的特点如下：<br>74LS 系列： TTL 输入： TTL， 输出： TTL<br>74HC 系列： CMOS 输入： CMOS， 输出： CMOS<br>74HCT 系列： CMOS 输入： TTL， 输出： CMOS<br>CD4000 系列： CMOS 输入： TTL， 输出： CMOS</p>
<p>通常情况下， 单片机、 DSP、 FPGA 之间引脚能否直接相连要参考以下方法进<br>行判断： 一般来说， 同电压的是可以相连的， 不过最好还是要查看下芯片技术手<br>册上的 VIL、 VIH、 VOL 和 VOH 的值， 看是否能够匹配。 有些情况在一般应用中没有问题， 但是参数上就是有点不够匹配， 在某些情况下运行可能就不够稳定， 或<br>者不同批次的器件就不能运行</p>
<h4 id="二进制与十六进制"><a href="#二进制与十六进制" class="headerlink" title="二进制与十六进制"></a>二进制与十六进制</h4><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><p>数字电路中只有两种电平特性， 即高电平和低电平， 这也就决定了数字电路<br>中使用二进制。 十进制数大家应该都不陌生， “逢十进一， 借一当十” 是十进制<br>数的特点。 有了十进制数的基础， 我们学习二进制数便非常容易了， “逢二进一，<br>借一当二” 便是二进制数的特点。 十进制数 1 转换为二进制数是 1B（这里 B 表<br>示二进制数的后缀） ； 十进制数 2 转换为二进制数时， 因为已经到 2， 所以需要<br>进 1， 那么二进制数即为 10B； 十进制数 5 转换为二进制数， 2 为 10B， 那么 3<br>即为 10B+1B=11B， 4 即为 11B+1B=100B， 5 即为 100B+1B=101B。 依次类推， 当十<br>进制数为 254 时， 对应而=二进制数为 1111 1110B<code>（中间空一格是为了方便阅读，实际编写不要空格）</code> 。  </p>
<p>我们可以找出一般规律， 当二进制数转换为十进制数时， 从二进制数的最后<br>一位往前看， 每一位代表的数为 2 的 n 次幂， 这里的 n 表示从最后起的第几位二<br>进制数， n 从 0 算起， 若对应该二进制数位上有 1， 那么就有值， 为 0 则无值。<br>例如， 再把二进制数 1111 1110B 反推回十进制数， 计算过程如下：<br><strong>0 <em> 2^0^+1 </em> 2^1^+1 <em> 2^2^+1 </em> 2^3^+1 <em> 2^4^+1 </em> 2^5^+1 <em> 2^6^+1 </em> 2^7^=254</strong><br>其中 2^n^ 称为“ 位权” 。 对于十进制与二进制之间的转换， 我们能熟练掌握<br>0-15 以内的数就够用了， 为了方便记忆， 我们归纳如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211212487.png" alt="image-20230610211212487"></p>
<p>实际开发中常常会用到其它比较大的数， 这时我们用 Windows 系统自带的计算器， 选择程序员模式， 可以非常方便的进行二进制、 八进制、 十进制、 十六进制数之间的任意转换， 如下图所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211240014.png" alt="image-20230610211240014"></p>
<h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><p>十六进制与二进制大同小异， 不同之处就是十六进制是“逢十六进一， 借一当十六”  。还有一点特别之处需要注意， 十进制的 0-15 表示成十六进制为 0~9、A、 B、 C、 D、 E、 F， 即十进制的 10 对应十六进制的 A， 11 对应 B， 以此类推。我们一般在十六进制数的最后面加上后缀 H， 表示该数为十六进制数， 如 AH、 DEH等。 这里的字母不区分大小写， 在 C 语言编程时要写成“0xa， 0xde” ， 在数的最前面加上“0x” 表示该数为十六进制数。 十进制数与十六进制数之间的转换在这里不再讲解， 大家可参考十进制与二进制数之间的转换规则。 关于十进制、 二进制与十六进制数之间的转换， 我们要熟练掌握 0~15 之间的数， 因为在以后的单片机 C 语言编程中， 我们要大量使用它们。 一般的转换规律是， 先将二进制数转换为十进制数， 再将十进制数转换为十六进制数， 这里不用死机， 在后面的学习中遇到多了也就记住了。 二进制、 十进制、 十六进制 0~15 的数的转换关系如下  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211859176.png" alt="image-20230610211859176"></p>
<h4 id="二进制的逻辑运算"><a href="#二进制的逻辑运算" class="headerlink" title="二进制的逻辑运算"></a>二进制的逻辑运算</h4><p>与运算</p>
<p>“与” 运算是实现“必须都有， 否则就没有” 这种逻辑关系的一种运算。 C语言中运算符为<code>“&amp;”</code> ， 其运算规则如下： 0&amp;0=0， 0&amp;1=0（1&amp;0=0） ,1&amp;1=1。 其运算符号如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212201143.png" alt="image-20230610212201143"></p>
<p>C 语言中<code>“&amp;&amp;”</code> 表示“按位与” 运算， 意思是变量之间按二进制位数对应关系一一进行“与” 运算。 如（0101 0101） &amp;&amp;（1010 1010） =0000 0000， 而上面讲到的“&amp;” 运算只是对单一位进行运算  </p>
<p>或运算</p>
<p>或” 运算是实现“只要其中之一有就有” 这种逻辑关系的一种运算。 C 语言中运算符为<code>“|”</code> ， 其运算规则如下： 0|0=0， 0|1=1（1|0=1） ， 1|1=1。 其运算符号如下  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212329934.png" alt="image-20230610212329934"></p>
<p>C 语言中<code>“||”</code> 表示“按位或” 运算， 意思是变量之间按二进制位数对应关系一一进行“或” 运算。 如（0101 0101） ||（1010 1010） =1111 1111， 而上面讲到的“|” 运算只是对单一位进行运算。  </p>
<p>非运算  </p>
<p>“非” 运算是实现“求反” 这种逻辑关系的一种运算。 C 语言中运算符为“!”，其运算规则如下： !0=1， !1=0。 其运算符号如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212415422.png" alt="image-20230610212415422"></p>
<p>C 语言中<code>“~”</code> 表示“按位取反” 运算。 如~0101 0101=1010 1010， 而上面讲到的“!” 运算只是对单一位进行运算  </p>
<p>同或运算  </p>
<p>“同或” 与“异或” 运算使用的较少， 我们在这里只做简单了解， 大家用到之处可再查找相关资料。 “同或” 运算是实现“必须相同， 否则就没有” 这种逻辑关系的一种运算， 其逻辑运算符为<code>“⊙”</code>。 其运算规则如下：0⊙0=1， 0⊙1=0（1⊙0=0） ， 1⊙1=1。 ==在 C 语言中没有规定符号==。 其运算符号如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212508215.png" alt="image-20230610212508215"></p>
<p>异或运算  </p>
<p>异或” 运算是实现“必须不同， 否则就没有” 这种逻辑关系的一种运算，其逻辑运算符为<code>“⊕ ”</code> 。 其运算规则如下： 0⊕ 0=0， 0⊕ 1=1（1⊕ 0=1） ， 1⊕ 1=0。在 C 语言中有“按位异或” 运算<code>“^”</code>。 其运算符号如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212544416.png" alt="image-20230610212544416"></p>
<h4 id="C51-扩充数据类型"><a href="#C51-扩充数据类型" class="headerlink" title="C51 扩充数据类型"></a>C51 扩充数据类型</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212720411.png" alt="image-20230610212720411"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212654220.png" alt="image-20230610212654220"></p>
<h3 id="四、51单片机最小系统"><a href="#四、51单片机最小系统" class="headerlink" title="四、51单片机最小系统"></a>四、51单片机最小系统</h3><h4 id="51-单片机最小系统构成"><a href="#51-单片机最小系统构成" class="headerlink" title="51 单片机最小系统构成"></a>51 单片机最小系统构成</h4><p>若要使系统正常运行， 必须确保单片机的最小系统稳定工作。 51 单片机的最<br>小系统由以下几部分组成：<br>（1） 晶振电路<br>（2） 复位电路<br>（3） 电源电路<br>（4） 下载电路<br>第（4） 是我们添加进来的， 实际上最小系统只由前面 3 个部分组成。 为什<br>么要加入第（4） 部分呢？ 仅靠前面 3 个部分电路只能使单片机正常运行， 但如<br>果我们要给系统更新程序即烧入程序时就没有办法了， 所以我们将第（4） 部分<br>电路也加入到最小系统当中， 这时候我们就可以给系统自由烧入程序了。</p>
<p>晶振电路提供时钟给单片机工作， 犹如人的心脏。 复位电路提供系统复位操<br>作， 当系统出现运行不正常或者死机等情况时， 可以通过复位按键重新启动系统。<br>电源电路也是非常关键的一个部分， 因为单片机对供电电压是有要求的， 如果电压过大将烧坏芯片， 如果电压过小系统将运行不了。 所以选择一个合适稳定的电源电路是非常关键的  </p>
<p>还有一点非常重要， 由于 51 单片机的 P0 口是漏极开路， 即输出高电平会导致高阻态， 要让它输出高电平就必须外接上拉电阻， 如下  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610213006547.png" alt="image-20230610213006547"></p>
<p>相同网络标号的表示其线路是连接在一起的， 这个在后面章节会介绍。 为了增强其他 IO 口的驱动能力， 开发板上也都为其外接了上拉电阻（除了串口） ，通常上拉电阻选择 10K 左右。下面就来介绍下这 4 部分的电路</p>
<h4 id="晶振电路"><a href="#晶振电路" class="headerlink" title="晶振电路"></a>晶振电路</h4><p>由于单片机正常工作需要一个时钟， 因此就需要在其晶振引脚上外接晶振（我们使用的 STC89CXX 单片机晶振引脚是 18 和 19 脚） ， 至于需要多大晶振这就取决于你所使用的单片机， 由于我们使用的是 51 单片机， 其时钟频率可在0-40MHZ 上运行， 一般情况下我们建议选择 12M（ 适合计算延时时间） 或者是11.0592M（适合串口通信） 。 若直接将此晶振接入单片机晶振引脚， 会发现系统工作不稳定， 这是因为晶振起振的一瞬间会产生一些电感， 为了消除这个电感所带来的干扰， 可以在此晶振两端分别加上一个电容， 电容的选取需要无极性的，另一端需要共地。 根据选取的晶振大小决定电容值， 通常电容可在 10-33PF 值范围内选取。 我们使用的是 33PF 电容。 这样一来就构成了晶振电路。 只有保证晶振电路稳定， 单片机才能继续工作。 其电路如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214427564.png" alt="image-20230610214427564"></p>
<h4 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h4><p>前面我们已经将晶振电路搭建完成， 我们知道晶振犹如人的心脏， 需要无时无刻给单片机提供运行周期。 但即使时钟周期在不停的运行， 系统也有可能会出现崩溃或者瘫痪状态。 这就好比人会生病一样， 人一生病就得看医生， 服用医生开的药后重新获得正常状态。 那么单片机呢， 它是如何获取重生的？ 这就需要设计一个复位电路来实现此功能。 我们知道单片机引脚当中就有一个 RST 复位引脚， 而 STC89CXX 单片机又是高电平复位， 所以只需要让这个引脚保持一段时间高电平就可以。 要实现此功能通常有两种方式， 一种是通过按键进行手动复位，还有一种是上电复位， 即电源开启后自动复位。 手动复位是通过一个按键及电容电阻所组成， 利用按键的开关功能实现复位， 按键按下后 VCC 直接进入到单片机RST 引脚， 松开后 VCC 断开， RST 被电阻拉为低电平。 这一合一开就实现了手动复位。 而自动复位主要是利用 RC 充放电功能， 电源已开启， 由于电容隔直， VCC直接进入 RST， 然后电容开始慢慢充电， 直到充电完成， 此时 RST 被电阻拉低。这样就起到上电复位的效果。 这里我们采用手动复位。 不到系统崩溃， 我们几乎不会操作复位。 复位电路如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214512005.png" alt="image-20230610214512005">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214517742.png" alt="image-20230610214517742">                </p>
<p>当按下按键 RSTK1， VCC 直接连接到 RST 复位脚， VCC 是高电平所以系统复位。  </p>
<h4 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h4><p>任何电子器件都需要有一个合适的电源进行供电， 这就好比人要吃饭一样，没有电源， 系统是不会工作的。 STC89CXX 单片机的工作电压是 3.3-5.5V 范围，通常我们使用 5V 直流。 将电源接入到各芯片电源引脚即可。 开发板电源电路如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214623132.png" alt="image-20230610214623132">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214632548.png" alt="    "> </p>
<p>开发板上还预留了 P3（5V/3V） 端子， 这些端子可以很方便的给外部模块连接电源  </p>
<h4 id="下载电路"><a href="#下载电路" class="headerlink" title="下载电路"></a>下载电路</h4><p>在前面已经介绍过为什么要加下载电路到最小系统中， 这里就不再重复。 程<br>序要烧写到单片机内是通过上位机（ PC 机） 及对应的软件将编译器生成的<br>xxx.HEX 文件通过单片机串口写入进去。<br>        我们知道现在的笔记本电脑没有 RS232 接口， 所以要使用 USB 转 TTL 串口电<br>平芯片来建立 PC 机和单片机数据传输通路。 通常使用 CH340G 或者 CH340C 芯片<br>来完成电平转换。 CH340G 需外接 12M 晶振， 而 CH340C 内部自带晶振， 所以可<br>不接外部 12M 晶振。 开发板上使用的是 CH340C 芯片。</p>
<p>开发板下载电路如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214837737.png" alt="image-20230610214837737"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214842614.png" alt="image-20230610214842614"></p>
<p>本电路是我们自主研发的一键自动下载电路， 无需冷启动。 主要依靠上位机<br>软件（PZ-ISP） 控制 CH340 芯片的 RTS 和 DTR 脚输出， 进而使 MOS 管 Q3 自动断电后上电， 完成冷启动工作。<br>        从上图可以知道， USB1 接口即为程序下载接口， D-和 D+连接到 CH340 芯片<br>的 D-和 D+， 然后 CH340 芯片的串口 TXD 和 RXD 管脚就连接到单片机的串口（P3.0、P3.1） 上， 这里不是直接连接到单片机串口， 而是通过 P5 端子进行转接。 这样做不仅可以让开发板 USB 接口下载程序， 还可以让单片机串口不受 CH340 干扰，这样开发板也可以当成 USB 转 TTL 模块使用， 该设计也是考虑 WIFI、 蓝牙等模块与串口通信不受干扰问题。</p>
<p>​        USB1 接口不仅可以作为程序下载口， 还可以作为串口通信口， 因为它本身就<br>是实现串口下载。 同时还可以作为电源供电口， 可以看到 USB1 的管脚 1 就是 5V<br>电源脚， 所以开发板的可以直接使用 USB 线来供电， 如果提供的 USB 线有问题，<br>可以使用安卓手机数据线， 接口都是兼容的。 当电源开关打开后， 电源指示灯<br>DP1 即会点亮， 表明系统电源正常。<br>​        至此， 我们就把 51 单片机的最小系统介绍完， 大家在制作最小系统时， 可<br>以参考我们的电路， 这样成功几率会更高。</p>
<h3 id="五、51单片机工程模板"><a href="#五、51单片机工程模板" class="headerlink" title="五、51单片机工程模板"></a>五、51单片机工程模板</h3><h4 id="单片机工程模板创建"><a href="#单片机工程模板创建" class="headerlink" title="单片机工程模板创建"></a>单片机工程模板创建</h4><h5 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h5><p>首先在电脑任意位置新建一个文件夹， 命名为“51 单片机工程模板创建” 。打开 KEIL C51 软件， 新建一个工程， 工程名根据喜好命名， 但是要注意使用英文， 如果使用中文名可能会出现一些奇怪的错误， 这里我们命名为template， 直接保存在刚才创建的“51 单片机工程模板创建” 文件夹下。 具体步骤如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215508546.png" alt="image-20230610215508546"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215514833.png" alt="image-20230610215514833"></p>
<h5 id="选择CPU型号"><a href="#选择CPU型号" class="headerlink" title="选择CPU型号"></a>选择CPU型号</h5><p>这个根据开发板使用的 CPU 具体的型号来选择， 我们开发板使用的是STC89C52 或 STC89C516 芯片。 在 KEIL C51 软件内找不到这种型号的单片机， 因为 51 内核单片机具有通用性， 所以在这里可以任选一款 89C52 就行， Keil 软件的关键是程序代码的编写， 而非用户选择什么硬件， 在这里我们选择 Ateml 的89C52 来说明。 具体操作如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215616757.png" alt="image-20230610215616757"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215623993.png" alt="image-20230610215623993"></p>
<p>点击 OK 键后， 弹出如下对话框：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215637391.png" alt="image-20230610215637391"></p>
<p>该对话框内容是提示我们是否要将 8051 启动文件添加到工程中， 这里我们选择“否” ， 原因是 KEIL C51 内已经帮我们完成了启动， 所以只需要编写应用程序即可。 选择“否” 后界面如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215648213.png" alt="image-20230610215648213"></p>
<h5 id="给工程添加文件"><a href="#给工程添加文件" class="headerlink" title="给工程添加文件"></a>给工程添加文件</h5><p>选择 File/New…或者使用工具栏的图标 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215726575.png" alt="image-20230610215726575"> 来新建一个文件后点击保存， 系统会自动定位到我们工程目录， 只需要在文件名栏输入新建的文件名即可， 一个 51 单片机工程必须含有且仅有一个 main 函数， 因此将新建的文件命名为 main.c（当然也可以根据个人习惯自定义命名， 但必须是英文） ， 点击保存。 具体操作步骤如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215746484.png" alt="image-20230610215746484"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215753306.png" alt="image-20230610215753306"></p>
<p>然后将新建的 main.c 文件添加到工程中， 选择工程组“Source Group 1”,鼠标右键选择“Add Files to Group ‘Source Group 1’ …” ,然后选择对应的 xxx.c 文件， 点击 Add 键后在点击 Close 关闭。 这时工程中就显示已加入的文件。 具体操作如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215823160.png" alt="image-20230610215823160"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215828167.png" alt="image-20230610215828167"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215831837.png" alt="image-20230610215831837"></p>
<h5 id="配置魔术棒选项卡"><a href="#配置魔术棒选项卡" class="headerlink" title="配置魔术棒选项卡"></a>配置魔术棒选项卡</h5><p>这一步的配置工作非常重要， 很多人自己编写程序编译后发现找不到 .HEX 文件， 或者使用我们 51 仿真器的时候出现仿真失败， 这些问题都是在这个地方没有配置好导致的。1， 选择魔术棒工具的 Output 选项卡， 勾选红色框 3， 即程序编译成功后会产生 HEX 文件。 具体操作如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610220013528.png" alt="image-20230610220013528"></p>
<h3 id="reg52-h-头文件"><a href="#reg52-h-头文件" class="headerlink" title="reg52.h 头文件"></a>reg52.h 头文件</h3><p>头文件作用  </p>
<p>在代码中引用头文件， 其实际意义就是将这个头文件中的全部内容放到引用头文件的位置处， 免去我们每次编写同类程序都要将头文件中的语句重复编写。在代码中加入头文件有两种书写方法， 分别为#include <reg52.h>和#include “reg52.h”， 包含头文件时都不需要在后面加分号。 两种写法的区别如下：  </p>
<p>①当使用&lt;&gt;包含头文件时， 编译器先进入到软件安装文件夹处开始搜索这个头文件， 也就是 KEILC51/C51/INC 这个文件夹下， 如果这个文件夹没有引用的头文件， 编译器将会报错。</p>
<p>②当使用””包含头文件时， 编译器先进入到当前工程所在文件夹处开始搜索该头文件， 如果当前工程所在文件夹下没有该头文件， 编译器将继续回到软件安装文件夹处搜索这个头文件， 若找不到该头文件， 编译器将报错。</p>
<h3 id="点亮第一个LED"><a href="#点亮第一个LED" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h3><p>不论学习什么单片机， 最简单的外设莫过于 IO 口的高低电平控制， 本章将向大家介绍如何在创建好的工程模板上， 通过控制 51 单片机的 GPIO 使开发板上的 LED 灯点亮。 通过本章的学习， 让大家学会如何在程序中操作 51 单片机的 GPIO 口输出高低电平  </p>
<h4 id="单片机-GPIO-介绍"><a href="#单片机-GPIO-介绍" class="headerlink" title="单片机 GPIO 介绍"></a>单片机 GPIO 介绍</h4><p>GPIO 概念  </p>
<p>GPIO（general purpose intput output） 是通用输入输出端口的简称， 可<br>以通过软件来控制其输入和输出。 51 单片机芯片的 GPIO 引脚与外部设备连接<br>起来， 从而实现与外部通讯、 控制以及数据采集的功能。 不过 GPIO 最简单的应<br>用还属点亮 LED 灯了， 只需通过软件控制 GPIO 输出高低电平即可。 当然 GPIO<br>还可以作为输入控制， 比如在引脚上接入一个按键， 通过电平的高低判断按键是<br>否按下。<br>我们开发板上使用的 51 单片机型号是 STC89C52 或 STC89C516， 此芯片共有<br>40 引脚， 芯片引脚图如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085529785.png" alt="image-20230611085529785"></p>
<p>那么是不是所有引脚都是 GPIO 呢？ 当然不是， 51 单片机引脚可以分为这么<br>几大类：<br>（1） 电源引脚： 引脚图中的 VCC、 GND 都属于电源引脚。<br>（2） 晶振引脚： 引脚图中的 XTAL1、 XTAL2 都属于晶振引脚。<br>（3） 复位引脚： 引脚图中的 RST/VPD 属于复位引脚， 不做其他功能使用。<br>（4） 下载引脚： 51 单片机的串口功能引脚（TXD、 RXD） 可以作为下载引脚</p>
<p>（5） GPIO 引脚： 引脚图中带有 Px.x 等字样的均属于 GPIO 引脚。 从引脚<br>图可以看出， GPIO 占用了芯片大部分的引脚， 共达 32 个， 分为了 4 组， P0、 P1、P2、 P3， 每组为 8 个 IO， 而且在 P3 组中每个 IO 都具备额外功能， 只要通过相<br>应的寄存器设置即可配置对应的附加功能， 同一时刻， 每个引脚只能使用该引脚的一个功能。</p>
<p>​        对于这么多 GPIO 管脚， 我们怎么知道具体某个引脚有什么功能呢？ 很简<br>单， 可以查阅 STC89CXX 芯片数据手册获取信息， 数据手册在我们资料“\6—芯<br>片资料\开发板芯片数据手册” 内， 里面有一个 STC89CXX 数据手册.pdf。 里面的<br>第 23 页中就有介绍， 我们截取了一部分内容如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085706291.png" alt="image-20230611085706291"></p>
<p>从上图中我们可以获取引脚的名字和引脚功能等信息。 这个我们开发板芯片原理图内已经将引脚所有功能都标进去了， 所以后面也不需要查找具体引脚有什么功能， 直接看原理图即可  </p>
<h4 id="GPIO-结构框图与工作原理"><a href="#GPIO-结构框图与工作原理" class="headerlink" title="GPIO 结构框图与工作原理"></a>GPIO 结构框图与工作原理</h4><p>我们使用的 51 单片机 GPIO 分为 P0、 P1、 P2 和 P3 口， 下面分别来介绍其内部结构框图与工作原理。  </p>
<h5 id="P0-端口"><a href="#P0-端口" class="headerlink" title="P0 端口"></a>P0 端口</h5><p>P0 端口含有 8 位引脚， 下图为其中一个， 其它几个与之完全一致， 因此只需了解当中一个即可。 如下图所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085920770.png" alt="image-20230611085920770"></p>
<p>​    由上图可见， P0 端口由锁存器、 输入缓冲器、 切换开关、 一个非门、 一个与<br>非门及场效应管驱动电路构成。 再看图的最右边， 标号为 P0.x 引脚的图标， 也<br>就是说 P0.x 引脚可以是 P0.0 到 P0.7 的任何一位， 即在 P0 口有 8 个与上图相同<br>的电路组成</p>
<p>下面， 我们先就组成 P0 口的每个单元部份跟大家介绍一下：  </p>
<p><strong>①输入缓冲器</strong>  </p>
<p>​        在 P0 口中， 有两个三态的缓冲器， 在学数字电路时， 我们已知道， 三态门<br>有三个状态， 即在输出端可以是高电平、 低电平， 同时还有一种就是高阻状态（或<br>称为禁止状态） ， 大家看上图， 上面一个是读锁存器的缓冲器， 也就是说， 要读<br>取 D 锁存器输出端 Q 的数据， 那就得使读锁存器的这个缓冲器的三态控制端（上<br>图中标号为‘读锁存器’ 端） 有效。 下面一个是读引脚的缓冲器， 要读取 P0.x<br>引脚上的数据， 也要使标号为‘读引脚’ 的这个三态缓冲器的控制端有效， 引脚<br>上的数据才会传输到我们单片机的内部数据总线上。 </p>
<p><strong>②D 锁存器</strong>  </p>
<p>​        构成一个锁存器， 通常要用一个时序电路， 时序的单元电路在学数字电路时<br>我们已知道， 一个触发器可以保存一位的二进制数（即具有保持功能） ， 在 51<br>单片机的 32 根 I/O 口线中都是用一个 D 触发器来构成锁存器的。 大家看上图中<br>的 D 锁存器， D 端是数据输入端， CP（CLK） 是控制端（也就是时序控制信号输<br>入端） ， Q 是输出端， Q 非是反向输出端。<br>​        对于 D 触发器来讲， 当 D 输入端有一个输入信号， 如果这时控制端 CP 没有<br>信号（也就是时序脉冲没有到来） ， 这时输入端 D 的数据是无法传输到输出端 Q<br>及反向输出端 Q 非的。 如果时序控制端 CP 的时序脉冲一旦到了， 这时 D 端输入的数据就会传输到 Q 及 Q 非端。 数据传送过来后， 当 CP 时序控制端的时序信号消失了， 这时， 输出端还会保持着上次输入端 D 的数据（即把上次的数据锁存起来了） 。 如果下一个时序控制脉冲信号来了， 这时 D 端的数据才再次传送到 Q端， 从而改变 Q 端的状态。  </p>
<p><strong>③多路开关</strong>  </p>
<p>​        在 51 单片机中， 当内部的存储器够用（也就是不需要外扩展存储器时， 这<br>里讲的存储器包括数据存储器及程序存储器） 时， P0 口可以作为通用的输入输<br>出端口（即 I/O） 使用， 对于 8031（内部没有 ROM） 的单片机或者编写的程序超<br>过了单片机内部的存储器容量， 需要外扩存储器时， P0 口就作为‘地址/数据’<br>总线使用。 那么这个多路选择开关就是用于选择是做为普通 I/O 口使用还是作为<br>‘数据/地址’ 总线使用的选择开关了。 大家看上图， 当多路开关与下面接通时，<br>P0 口是作为普通的 I/O 口使用的， 当多路开关是与上面接通时， P0 口是作为‘地<br>址/数据’ 总线使用的</p>
<p><strong>④场效应管输出驱动</strong>  </p>
<p>​        从上图中可以看出， P0 口的输出是由两个 MOS 管组成的推拉式结构， 也就是<br>说， 这两个 MOS 管一次只能导通一个， 当 V1 导通时， V2 就截止， 当 V2 导通时，V1 截止。</p>
<p><strong>⑤与非门、 非门</strong>  </p>
<p>​            这个在学习数字电路时也很好理解， 如果没有数字电路基础的用户， 可以百<br>度查找与非门、 非门以及前面的 D 触发器详细了解， 这里就不再过多叙述。 当然<br>如果搞不明白这些也不会影响后续我们学习 51 单片机编程， 大家也可以忽略。<br>​            前面我们已将 P0 口的各单元部件进行了一个详细的讲解， 下面我们就来研究一下 P0 口做为 I/O 口及地址/数据总线使用时的具体工作过程</p>
<p>（1） 作为 I/O 端口输出使用时的工作原理  </p>
<p>​            P0 口作为 I/O 端口使用时， 多路开关的控制信号为 0（低电平） ， 看上图中的红线部份， 多路开关的控制信号同时与与非门的一个输入端是相接的， 我们知道与门的逻辑特点是“全 1 出 1， 有 0 出 0” 那么控制信号是 0 的话， 这时与门输出的也是一个 0（低电平） ， 与门的输出是 0， V1 管就截止， 在多路控制开关的控制信号是 0（低电平） 时， 多路开关是与锁存器的 Q 非端相接的（即 P0 口作为 I/O 口线使用）  </p>
<p>​            P0 口用作 I/O 口线， 其由数据总线向引脚输出（即输出状态 Output） 的工作过程： 当写锁存器信号 CP 有效， 数据总线的信号→锁存器的输入端→D 锁存器的反向输出 Q 非端→多路开关→V2 管的栅极→V2 的漏极到输出端 P0.X。 前面我们已讲了， 当多路开关的控制信号为低电平 0 时， 与门输出为低电平， V1 管是截止的， 所以作为输出口时， P0 是漏极开路输出， 类似于 OC 门， 当驱动上接电流负载时， 需要外接上拉电阻。  </p>
<p>​            下图就是由内部数据总线向 P0 口输出数据的流程图（红色箭头） ：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090402480.png" alt="image-20230611090402480"></p>
<p>(2） 作为 I/O 端口输入使用时的工作原理  </p>
<p>数据输入时（读 P0 口） 有两种情况：<br>1、 读引脚<br>读芯片引脚上的数据， 读引脚数时， 读引脚缓冲器打开（即三态缓冲器的控<br>制端要有效） ， 通过内部数据总线输入， 请看下图（红色箭头） 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090445235.png" alt="image-20230611090445235"></p>
<p>2、 读锁存器  </p>
<p>通过打开读锁存器三态缓冲器读取锁存器输出端 Q 的状态， 请看下图（红色箭头)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090531712.png" alt="image-20230611090531712"></p>
<p>因为现在 STC 51 单片机内存已经足够使用， 所以也用不到通过 P0 口外扩存储器， 对于 P0 口作为外扩存储器时的工作原理这里就不叙述， 如需了解的朋友可以上网百度。  </p>
<h5 id="P1端口"><a href="#P1端口" class="headerlink" title="P1端口"></a>P1端口</h5><p>​            P1 口的结构最简单， 用途也单一， 仅作为数据输入/输出端口使用。 输出的信息有锁存， 输入有读引脚和读锁存器之分。 P1 端口的一位结构见下图  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090756900.png" alt="image-20230611090756900"></p>
<p>​            由图可见， P1 端口与 P0 端口的主要差别在于， P1 端口用内部上拉电阻 R 代替了 P0 端口的场效应管 V1， 并且输出的信息仅来自内部总线。 由内部总线输出<br>的数据经锁存器反相和场效应管反相后， 锁存在端口线上， 所以， P1 端口是具有输出锁存的静态口。</p>
<p>​            由上图可见， 要正确地从引脚上读入外部信息， 必须先使场效应管关断， 以<br>便由外部输入的信息确定引脚的状态。 为此， 在作引脚读入前， 必须先对该端口<br>写入 l。 具有这种操作特点的输入/输出端口， 称为准双向 I/O 口。 8051 单片机<br>的 P1、 P2、 P3 都是准双向口。 P0 端口由于输出有三态功能， 输入前， 端口线已<br>处于高阻态， 无需先写入 l 后再作读操作。<br>​            P1 口的结构相对简单， 前面我们已详细的分析了 P0 口， 只要大家认真的分<br>析了 P0 口的工作原理， P1 口我想大家都有能力去分析， 这里我就不多论述了。<br>​            单片机复位后， 各个端口已自动地被写入了 1， 此时， 可直接作输入操作。<br>如果在应用端口的过程中， 已向 P1 一 P3 端口线输出过 0， 则再要输入时， 必须<br>先写 1 后再读引脚， 才能得到正确的信息。 此外， 随输入指令的不同， P1 端口<br>也有读锁存器与读引脚之分。</p>
<h5 id="P2端口"><a href="#P2端口" class="headerlink" title="P2端口"></a>P2端口</h5><p>P2 端口的一位结构见下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090901412.png" alt="image-20230611090901412"></p>
<p>​        由图可见， P2 端口在片内既有上拉电阻， 又有切换开关 MUX， 所以 P2 端口<br>在功能上兼有 P0 端口和 P1 端口的特点。 这主要表现在输出功能上， 当切换开关<br>向下接通时， 从内部总线输出的一位数据经反相器和场效应管反相后， 输出在端<br>口引脚线上； 当多路开关向上时， 输出的一位地址信号也经反相器和场效应管反<br>相后， 输出在端口引脚线上。</p>
<p>​            对于 8031 单片机必须外接程序存储器才能构成应用电路（或者我们的应用<br>电路扩展了外部存储器） ， 而 P2 端口就是用来周期性地输出从外存中取指令的<br>地址(高 8 位地址)， 因此， P2 端口的多路开关总是在进行切换， 分时地输出从<br>内部总线来的数据和从地址信号线上来的地址。 因此 P2 端口是动态的 I/O 端口。<br>输出数据虽被锁存， 但不是稳定地出现在端口线上。 其实， 这里输出的数据往往<br>也是一种地址， 只不过是外部 RAM 的高 8 位地址。<br>​            P2 口既可作为 I/O 口使用， 也可作为地址总线使用， 通常主要用作 I/O 口使<br>用， 地址总线使用不作分析。<br>​            P2 口的结构相对简单， 前面我们已详细的分析了 P0 和 P1 口， 只要大家认真的分析了它们的工作原理， P2 口我想大家都有能力去分析， 这里我就不多论述<br>了</p>
<h5 id="P3端口"><a href="#P3端口" class="headerlink" title="P3端口"></a>P3端口</h5><p>​        P3 口是一个多功能口， 它除了可以作为 I/O 口外， 还具有第二功能， P3 端口的一位结构见下图  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091031839.png" alt="image-20230611091031839"></p>
<p>​        由上图可见， P3 端口和 Pl 端口的结构相似， 区别仅在于 P3 端口的各端口线有两种功能选择。 当处于第一功能时， 第二输出功能线为 1， 此时， 内部总线信号经锁存器和场效应管输入/输出， 其作用与 P1 端口作用相同， 也是静态准双向 I/O 端口。 当处于第二功能时， 锁存器输出 1， 通过第二输出功能线输出特定的内含信号， 在输入方面， 即可以通过缓冲器读入引脚信号， 还可以通过替代输入功能读入片内的特定第二功能信号。 由于输出信号锁存并且有双重功能， 故P3 端口为静态双功能端口。 有关 P3 口第二功能， 在前面章节芯片管脚功能定义已经讲解过， 此处不再重复  </p>
<p>​            至此， 我们就把 51 单片机的 P0、 P1、 P2 和 P3 口内部结构及原理讲解完，可能有的朋友会很懵、 看不懂， 没关系， 这些都不会影响你编写单片机应用程序， 大家记住以下几点即可：</p>
<p><code>①P0 口是漏极开路， 要使其输出高电平， 必须外接上拉电阻， 通常选择4.7K~10K 阻值。</code></p>
<p><code>②P0、 P1、 P2 几乎都用作普通 I/O 口使用， 既可作为输入， 又可作为输出。</code></p>
<p><code>③P3 口既可用作普通 I/O 口， 又可作为第二功能使用， 比如串口、 外部中断、 计数器等</code></p>
<h4 id="LED-简介"><a href="#LED-简介" class="headerlink" title="LED 简介"></a>LED 简介</h4><p>​        LED 即发光二极管。 它具有单向导电性， 通过 5mA 左右电流即可发光， 电流<br>越大， 其亮度越强， 但若电流过大， 会烧毁二极管， 一般我们控制在 3 mA-20mA<br>之间， 通常我们会在 LED 管脚上串联一个电阻， 目的就是为了限制通过发光二极管的电流不要太大， 因此这些电阻又可以称为“限流电阻” 。 当发光二极管发光时， 测量它两端电压约为 1.7V， 这个电压又叫做发光二极管的“导通压降” 。下图左右分别为直插式发光二极管和贴片式发光二极管实物图。 发光二极管正极又称阳极， 负极又称阴极， 电流只能从阳极流向阴极。 直插式发光二极管长脚为阳极， 短脚为阴极。 仔细观察贴片式发光二极管正面的一端有彩色标记， 通常有标记的一端为阴极。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091320385.png" alt="image-20230611091320385">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091358434.png" alt="image-20230611091358434"></p>
<h4 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上 LED 模块电路如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091447518.png" alt="image-20230611091447518"></p>
<p>​                在前面我们介绍过如何查看原理图， 相同网络标号表示它们是连接在一起<br>的， 因此 D1-D8 连接到单片机的 P20-P27 口。 图中 LED 采用共阳接法， 即所有<br>LED 阳极管脚接电源 VCC， 阴极管脚通过一个 470 欧的限流电阻接到 P2 口上。 根<br>据前面 LED 的介绍我们知道， 要让 LED 发光即对应的阴极管脚应该为低电平， 若<br>为高电平则熄灭。<br>​            如果要想 51 单片机控制 LED， 就必须通过单片机管脚在 P2 口上输出低电平。本章所要实现的功能是： 点亮 D1 指示灯。</p>
<h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><h5 id="点亮第一个LED-1"><a href="#点亮第一个LED-1" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h5><p>点亮 D1 指示灯， 即让 P2.0 管脚输出一个低电平。完成后可再控制 D1 指示灯闪烁， 即间隔一段时间点亮和熄灭 D1 指示灯  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>; <span class="comment">//将 P2.0 管脚定义为 LED1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	LED1=<span class="number">0</span>; <span class="comment">//LED1 端口设置为低电平</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091756870.png" alt="image-20230611091756870">    </p>
<p>code： 表示程序所占用 FLASH 的大小。<br>data： 数据储存器内部 RAM 占用大小。<br>xdata： 数据储存器外部 RAM 占用大小。</p>
<h5 id="LED-闪烁实验"><a href="#LED-闪烁实验" class="headerlink" title="LED 闪烁实验"></a>LED 闪烁实验</h5><p>​            如果要实现 LED 闪烁， 只需循环让 D1 指示灯先亮一会后熄灭。 这里就有一<br>个延时问题， 如何来产生延时呢？ 我们知道单片机执行每条代码指令都是需要时<br>间的， 在前面介绍 C 语言时讲解过循环语句， 因此只需编写一个循环函数， 让<br>CPU 不干其它事， 专门在那循环运行即可实现延时功能。 依据人的肉眼余晖效应，<br>延时时间不能太短， 否则就无法观察到 LED 闪烁。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码即为延时函数， 通过 while 循环来实现。 函数入口有一个形式参数ten_us， 如果 ten_us 等于 1， 则 while 循环执行一次， 调用该函数延时时间大约 10us， 当然使用循环来实现延时， 这种延时是不精确的， 目前我们先得到个大概的时间即可。细心的朋友可能会看到函数形参 ten_us 是 u16 类型的， 这个似乎不是 C 语言数据类型关键字， 这是我们重定义的数据类型， 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br></pre></td></tr></table></figure>
<p>使用关键字 typedef 对系统默认数据类型 unsigned int 和 unsigned char重新命名， 主要是方便我们代码的书写和变量类型的查看。 u16 即代表该变量是16 位的无符号整型数据， u8 代表该变量是 8 位的无符号字符型数据。 有了这个就知道参数的传送范围， 不能超过形参定义的范围。  </p>
<p>下面看下 main 函数代码， 如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED1=<span class="number">0</span>; <span class="comment">//点亮</span></span><br><span class="line">		delay_10us(<span class="number">50000</span>); <span class="comment">//大约延时 450ms</span></span><br><span class="line">		LED1=<span class="number">1</span>; <span class="comment">//熄灭</span></span><br><span class="line">		delay_10us(<span class="number">50000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 函数内实现功能很简单， 在 while 循环内不断间隔一定时间点亮 LED1和熄灭 LED1， 这样即可实现 D1 指示灯闪烁。 细心的朋友可能会问， 前面delay_10us 函数形参为 1 时大约是 10us， 那现在实参传输 50000， 不应该是 500ms吗， 为什么注释写的是 450ms 呢？ 这里还得回到刚才话题， 使用循环来延时只是获得一个大概的时间， 并不能精确， 如需精确延时， 后期我们会学习定时器。 此处就不用纠结这个问题  </p>
<h5 id="通过-KEIL-软件仿真查看延时时间"><a href="#通过-KEIL-软件仿真查看延时时间" class="headerlink" title="通过 KEIL 软件仿真查看延时时间"></a>通过 KEIL 软件仿真查看延时时间</h5><p>上述代码中我们传递实参是 50000， 得到的延时大约是 450ms， 如何来验证呢？ 可以通过 KEIL 自带的软件仿真功能， 操作如下：  </p>
<p>打开实验工程， 点击魔术棒， 选择“Target” 选项卡， 在 Xtal(MHz)文本框中输入 12M， 该值表示开发板上实际使用外部晶振大小， 如果开发板上使用外部晶振是 11.0592M， 则修改为对应值。 然后点击 OK。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092046007.png" alt="image-20230611092046007"></p>
<p>②点击仿真按钮， 进入仿真界面， 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092058330.png" alt="image-20230611092058330"></p>
<p>③点击 RST 按钮， 重新复位系统参数， 此时参数列表中 sec 则为 0， 然后在所要查看调试的代码数字前面用鼠标左键双击即可出现“红色块” ， 我们称之为断点。 如果再次双击， 即可取消该断点。 当点击红色标记 8 运行的时候就能直接运行到我们设置的断点处。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092112656.png" alt="image-20230611092112656"></p>
<p>④当点击红色标记 8 运行时， 可以看到黄色箭头直接定位到 36 行代码， 也就是我们刚才设置的第一个断点位置， 此时参数列表中 sec 时间是 0.00039s。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092125304.png" alt="image-20230611092125304"></p>
<p>⑤再次点击红色标记 8 运行时， 此时黄色箭头指向第 37 行代码， 此时 sec为 0.450601s。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092137475.png" alt="image-20230611092137475"></p>
<p>将现在这个时间减去上一步的 sec 时间就可以得到 delay_10us(50000)运行的实际时间了。 再次点击仿真按钮则可退出仿真界面， 回到程序编辑界面。  </p>
<p>KEIL 软件的仿真功能非常强大， 里面有很多功能， 包括在仿真时使用单步调试观察变量参数等都有， 这里就不过多介绍， 如果对这个感兴趣的可以自行百度搜索 KEILC51 软件仿真的使用  </p>
<h5 id="LED流水灯实验"><a href="#LED流水灯实验" class="headerlink" title="LED流水灯实验"></a>LED流水灯实验</h5><h6 id="使用移位和循环实现"><a href="#使用移位和循环实现" class="headerlink" title="使用移位和循环实现"></a>使用移位和循环实现</h6><p>如果要实现 LED 流水灯， 只需循环让 D1-D8 指示灯逐个点亮。 同样本实验也需要延时， 这个在前面已介绍， 这里就不多说。 要实现循环点亮， 可以使用最容易理解的方法： 点亮 D1 且把 D2-D8 熄灭， 延时一段时间后再点亮 D2 且把 D1、D3-D8 熄灭， 延时一段时间后再点亮 D3 且把 D1-D2、 D4-D8 熄灭， 如此循环， 这样就可以很简单的实现 LED 流水灯实验， 当然我们不推荐此种方法。 在前面我们学习了 C 语言相关的基础知识， 里面有移位以及循环语句操作， 根据流水灯实现原理， 即 IO 口由低往高或者由高往低逐个输出低电平特点， 那么我们可以将移位操作以及循环结合进来。 实现代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT P2 <span class="comment">//使用宏定义 P2 端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		u8 i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					LED_PORT=~(<span class="number">0x01</span>&lt;&lt;i); <span class="comment">//将 1 右移 i 位， 然后取反将结果赋值到 LED_PORT</span></span><br><span class="line">					delay_10us(<span class="number">50000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入 main 函数后首先定义一个变量 i， 然后进入 while 循环， 由于要实现 8个 LED 从 D1-&gt;D8 循环点亮， 因此可以使用 for 循环语句循环 8 次， 每循环一次，点亮的小灯向右移动一个， 而 D1-D8 是连接到 P2.0-P2.7 的， 因此输出的低电平要左移一位， 因此可以使用 LED_PORT=~(0x01&lt;&lt;i);语句实现。 0X01&lt;&lt;i 表示 i 增加 1 次， 0x01 中的 1 就移动多少位， 因为 1（高电平） 不会让 LED 点亮， 需要取反后变为低电平 0 才能点亮， 所以最后的结果需要取反后给 LED_PORT 口， 并且每次循环都要延时一段时间， 这样才能分辨出来 LED 在流水 。</p>
<h6 id="使用左移-crol-、-右移-cror-函数"><a href="#使用左移-crol-、-右移-cror-函数" class="headerlink" title="使用左移_crol_、 右移_cror_函数"></a>使用左移<code>_crol_</code>、 右移<code>_cror_</code>函数</h6><p>除了使用 for 循环语句实现移位， KEIL C51 软件内还有对应的移位库函数，左移函数是<code>_crol_()</code>， 右移函数是<code>_cror_()</code>， 要使用这两个函数在我们的程序中必须包含 intrins.h 头文件。 这两个移位函数大家可以百度了解下， 其内部实现过程是看不到的， 该移位函数实现的移位功能就相当于一个队列内循环移动， 如果是左移， 那么最高位就被移到最低位了， 次高位变为最高位， 依次类推。 使用左移、 右移函数实现的流水灯操作代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line">	<span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		u8 i=<span class="number">0</span>;</span><br><span class="line">		LED_PORT=~<span class="number">0x01</span>;</span><br><span class="line">		delay_10us(<span class="number">50000</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) <span class="comment">//将 led 左移一位</span></span><br><span class="line">			&#123;</span><br><span class="line">				LED_PORT=_crol_(LED_PORT,<span class="number">1</span>);</span><br><span class="line">				delay_10us(<span class="number">50000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) <span class="comment">//将 led 右移一位</span></span><br><span class="line">			&#123;</span><br><span class="line">				LED_PORT=_cror_(LED_PORT,<span class="number">1</span>);</span><br><span class="line">				delay_10us(<span class="number">50000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>进入 main 函数后首先定义一个变量 i， LED<em>PORT=~0x01， 因为 LED 是低电平点亮， 所以 0X01 取反后的结果是 0XFE， 对应二进制数为 1111 1110， 即最低位 为 0， 因此最开始的 D1 指示灯会点亮， 然后进入 while 循环， 使用 for 循环、`_crol</em><code>和</code><em>cror</em>`移位函数实现 LED 左右流水显示。  </p>
<p>细心的朋友可能会发现此处每个 for 循环只有 7 次， 为什么不是 8 次呢， 这是因为在进入 main 开始， 就已经将 LED_PORT 端口设置了一次状态， 即让 D1 点亮， 并且我们是想让 LED 从左至右依次点亮， 然后继续又从右至左依次点亮， 这样形成左右流水效果。 假如将循环次数改为 8 次， 我们列举下第一个 for 循环的LED_PORT 端口状态值， 如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始状态： LED_PORT=<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">i=<span class="number">0</span>： LED_PORT=<span class="number">1111</span> <span class="number">1101</span></span><br><span class="line">i=<span class="number">1</span>： LED_PORT=<span class="number">1111</span> <span class="number">1011</span></span><br><span class="line">i=<span class="number">2</span>： LED_PORT=<span class="number">1111</span> <span class="number">0111</span></span><br><span class="line">i=<span class="number">3</span>： LED_PORT=<span class="number">1110</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">4</span>： LED_PORT=<span class="number">1101</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">5</span>： LED_PORT=<span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">6</span>： LED_PORT=<span class="number">0111</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">7</span>： LED_PORT=<span class="number">1111</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure>
<p>过上述列举， 可以非常清楚的了解端口 LED 状态， 所以此处应该将循环次数设置为 7 次， 即 i 最大等于 6。 这样到下一个循环右移时就可以从最高位开始往低位移动， 从而实现左右流水灯效果  </p>
<h3 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h3><p>前面章节我们已经介绍了如何控制 51 单片机的 IO 口输出高低电平， 本章我们通过另外一个实验来讲述 51 单片机 IO 口的输出。 通过单片机的一个 IO 口控制板载无源蜂鸣器， 实现蜂鸣器控制。 学习本章可以参考前面 LED 实验章节内容。本章分为如下几部分内容 </p>
<h4 id="蜂鸣器介绍"><a href="#蜂鸣器介绍" class="headerlink" title="蜂鸣器介绍"></a>蜂鸣器介绍</h4><p>蜂鸣器是一种一体化结构的电子讯响器， 采用直流电压供电， 广泛应用于计算机、 打印机、 复印机、 报警器、 电子玩具、 汽车电子设备、 电话机、 定时器等电子产品中作发声器件。 蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。</p>
<p>压电式蜂鸣器主要由多谐振荡器、 压电蜂鸣片、 阻抗匹配器及共鸣箱、 外壳等组成。 多谐振荡器由晶体管或集成电路构成， 当接通电源后（1.5~15V 直流工作电压） ， 多谐振荡器起振,输出 1.5～5kHZ 的音频信号， 阻抗匹配器推动压电蜂鸣片发声。</p>
<p>电磁式蜂鸣器由振荡器、 电磁线圈、 磁铁、 振动膜片及外壳等组成。 接通电源后， 振荡器产生的音频信号电流通过电磁线圈， 使电磁线圈产生磁场， 振动膜片在电磁线圈和磁铁的相互作用下， 周期性地振动发声。</p>
<p>其实一句话就可概括它们之间的区别， 想要压电式蜂鸣器发声， 需提供一定频率的脉冲信号； 想要电磁式蜂鸣器发声， 只需提供电源即可。</p>
<p>我们开发板上使用的蜂鸣器是无源蜂鸣器， 属于压电式蜂鸣器类型。 这里说的有源和无源， 并不是指电源的意思， 而是指蜂鸣器内部是否含有振荡电路， 有源蜂鸣器内部自带振荡电路， 只需提供电源即可发声， 而无源蜂鸣器则需提供一定频率的脉冲信号才能发声， 频率大小通常在 1.5-5KHz 之间。 蜂鸣器实物图如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081555865.png" alt="image-20230612081555865"></p>
<p>对于无源蜂鸣器， 如果改变频率就可以调节蜂鸣器音调， 产生各种不同音色、音调的声音。 如果改变输出电平的高低电平占空比， 则可以改变蜂鸣器的声音大小。  </p>
<p>对于有源蜂鸣器， 通常内部已经固定了频率， 对于调节频率或占空比可能改变不了蜂鸣器的音调和音量， 当然也有的有源蜂鸣器可以实现和无源蜂鸣器一样的效果。</p>
<h4 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>在前面章节中我们已经对 51 单片机的 GPIO 做了简单介绍， 并且还使用了其中 IO 口直接控制开发板上的 LED。 对于本章要实现蜂鸣器的控制， 我们能否直接使用单片机的 IO 口驱动呢？ 答案是否定的， 因为 51 单片机 IO 口的驱动能力较弱（即使外接上拉电阻） ， 而蜂鸣器驱动需要约 30mA， 所以非常困难， 即使可以驱动， 那对于整个芯片的其它 IO 剩下驱动能力就更加弱甚至无法工作。所以我们不会直接使用 IO 口驱动蜂鸣器， 而是通过三极管把电流放大后再驱动蜂鸣器， 这样 51 单片机的 IO 口只需要提供不到 1mA 的电流就可控制蜂鸣器。所以我们也经常说到 51 单片机是用来做控制的， 而不是驱动。</p>
<p>我们开发板上的蜂鸣器模块电路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081716667.png" alt="image-20230612081716667">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081722333.png" alt="image-20230612081722333"></p>
<p>​                    从图中可以看出， 蜂鸣器控制管脚直接连接到 51 单片机的 P2.5 管脚上。 图中并没有使用三极管进行电流放大， 而是使用 ULN2003 芯片来驱动， 有关 ULN2003芯片的使用此处先不作介绍， 后面章节会有， 大家暂时只需知道当 P25 输出高电平， BEEP 则输出低电平； 当 P25 输出低电平， BEEP 则输出高电平， 类似一个非门。  </p>
<p>开发板上使用的是无源蜂鸣器， 它需要一定频率的脉冲（高低电平） 才会发声， 因此需要让 P25 脚以一定频率不断输出高低电平信号才能控制蜂鸣器发出声音。  </p>
<h4 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 让蜂鸣器发出声音， 一段时间后再关闭， 即让 P2.5管脚输出一定频率的脉冲信号（高低电平） 控制无源蜂鸣器。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 i=<span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(i--)<span class="comment">//循环 2000 次</span></span><br><span class="line">		&#123;</span><br><span class="line">			BEEP=!BEEP;<span class="comment">//产生一定频率的脉冲信号</span></span><br><span class="line">			delay_10us(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">        i=<span class="number">0</span>;<span class="comment">//清零</span></span><br><span class="line">		BEEP=<span class="number">0</span>;<span class="comment">//关闭蜂鸣器</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后使用 sbit 关键字来定义 P2.5 管脚， 定义好后即可使用 BEEP 来替代 P2.5口的操作。 主函数功能非常简单， 直接进入 while 循环， 在循环内再次套用了一个 while 循环， 只不过这里并非死循环， 而是通过变量 i 值来决定何时退出， i值初始化为 2000， 即该循环会执行 2000 次， 此循环内不断对 BEEP 取反， 然后延时一定时间， 即 P2.5 间隔一定时间输出高低电平， 这样就会产生脉冲信号控制蜂鸣器发出声音， 当 i 值递减到 0 时则退出 while 循环， 然后将 i 值清零， 且将 BEEP 输出 0。 若修改变量 i 的值可以改变蜂鸣器发声时间。</p>
<p>若要改变音调可以修改延时时间， 但要注意频率不能太大或者太小， 具体大家可以试着调试。 若要改变音量， 可以修改 BEEP 输出高电平时间， 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEEP=<span class="number">1</span>;</span><br><span class="line">delay_10us(<span class="number">190</span>);</span><br><span class="line">BEEP=<span class="number">0</span>;</span><br><span class="line">delay_10us(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h3 id="静态数码管实验"><a href="#静态数码管实验" class="headerlink" title="静态数码管实验"></a>静态数码管实验</h3><p>前面章节我们已经介绍了如何控制 51 单片机的 IO 口输出高低电平， 本章我们通过另外一个实验来讲述 51 单片机 IO 口的输出。 通过单片机的 IO 口控制板载数码管显示。  </p>
<h4 id="数码管介绍"><a href="#数码管介绍" class="headerlink" title="数码管介绍"></a>数码管介绍</h4><p>​            数码管是一种半导体发光器件， 其基本单元是发光二极管。 数码管也称 LED数码管， 不同行业人士对数码管的称呼不一样， 其实都是同样的产品。 数码管按段数可分为七段数码管和八段数码管， 八段数码管比七段数码管多一个发光二极管单元， 也就是多一个小数点（DP） ， 这个小数点可以更精确的表示数码管想要显示的内容； 按能显示多少个（8） 可分为 1 位、 2 位、 3 位、 4 位、 5 位、6 位、 7 位等数码管。 按发光二极管单元连接方式可分为共阳极数码管和共阴极数码管。  </p>
<p>​            共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极(COM)的数码管， 共阳数码管在应用时应将公共极 COM 接到+5V， 当某一字段发光二极管的阴极为低电平时， 相应字段就点亮， 当某一字段的阴极为高电平时， 相应字段就不亮。</p>
<p>​            共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极(COM)的数码管， 共阴数码管在应用时应将公共极 COM 接到地线 GND 上， 当某一字段发光二极管的阳极为高电平时， 相应字段就点亮， 当某一字段的阳极为低电平时， 相应字段就不亮。</p>
<p>不同位数的数码管实物图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612131708416.png" alt="image-20230612131708416"></p>
<h4 id="数码管显示原理"><a href="#数码管显示原理" class="headerlink" title="数码管显示原理"></a>数码管显示原理</h4><p>​            不管将几位数码管连在一起， 数码管的显示原理都是一样的， 都是靠点亮内部的发光二极管来发光， 下面我们就来讲解一个数码管是如何亮起来的。 数码管内部电路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612131741061.png" alt="image-20230612131741061"></p>
<p>​                从上图可看出， 一位数码管的引脚是 10 个， 显示一个 8 字需要 7 个小段，另外还有一个小数点， 所以其内部一共有 8 个小的发光二极管， 最后还有一个公共端， 多数生产商为了封装统一， 单位数码管都封装 10 个引脚， 其中第 3 和第 8 引脚是连接在一起的。 而它们的公共端又可分为共阳极和共阴极， 图中间为共阳极内部原理图， 右图为共阴极内部原理图。  </p>
<p>对共阴极数码来说， 其 8 个发光二极管的阴极在数码管内部全部连接在一起，所以称“共阴” ， 而它们的阳极是独立的， 通常在设计电路时一般把阴极接地。当我们给数码管的任意一个阳极加一个高电平时， 对应的这个发光二极管就点亮了。 如果想要显示出一个 8 字， 并且把右下角的小数点也点亮的话， 可以给 8个阳极全部送高电平， 如果想让它显示出一个 0 字， 那么我们可以除了给第“g, dp” 这两位送低电平外， 其余引脚全部都送高电平， 这样它就显示出 0 字了。  </p>
<p>如果使用共阴数码管， 需要注意增加单片机 IO 口驱动电流， 因为共阴数码管是要靠单片机 IO 口输出电流来点亮的， 但单片机 I/O 口难以输出稳定的、 如此大的电流， 所以数码管与单片机连接时需要加驱动电路， 可以用上拉电阻的方法或使用专门的数码管驱动芯片， 比如 74HC573、 74HC245 等， 其输出电流较大，电路接口简单。</p>
<p>共阳极数码管其内部 8 个发光二极管的所有阳极全部连接在一起， 电路连接时， 公共端接高电平， 因此我们要点亮哪个发光管二极管就需要给阴极送低电平，此时显示数字的编码与共阴极编码是相反的关系， 数码管内部发光二极管点亮时， 也需要 5mA 以上的电流， 而且电流不可过大， 否则会烧坏发光二极管。 因此不仅要防止数码管电流过大， 同时要防止流经数码管的电流集中到单片机时电流不能过大， 否则会损坏主芯片。</p>
<p>一般共阳极数码管更为常用， 为什么呢？ 这是因为数码管的非公共端往往接在 IC 芯片的 I/O 上， 而 IC 芯片的驱动能力往往是比较小的， 如果采用共阴极数码管， 它的驱动端在非公共端， 就有可能受限于 IC 芯片输出电流不够而显示昏暗， 要外加上拉电阻或者是增加三极管加大驱动能力。 但是 IC 芯片的灌电流，即输入电流范围比较大。 所以使用共阳极数码管的好处是： 将驱动数码管的工作交到公共端（一般接驱动电源） ， 加大驱动电源的功率自然要比加大 IC 芯片 I/O口的驱动电流简单许多。 另一方面， 这样也能减轻主芯片的负担。  </p>
<p>我们开发板上使用的数码管是 2 个四位一体的共阴极数码管（即 8 个 LED的阳极全部并联一起引出， 阴极分别引出如 A、 B…DP） ， 本章实验也是在该数码管上实现单个的静态显示。 如果要让共阴数码管显示数字 0， 即对应的段ABCDEF 要点亮即给它高电平， 其他的段熄灭即给它低电平。 其他的数字显示方式一样， 这里就不多说。 下面给出共阴和共阳数码管的 0-F 段码数据表， 如下所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132208405.png" alt="image-20230612132208405"></p>
<p>​    ①共阴数码管码表  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x3f</span>,  <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>,</span><br><span class="line"> <span class="number">0</span>      <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">0x7d</span>,  <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0x77</span>, <span class="number">0x7c</span>,</span><br><span class="line"> <span class="number">6</span>      <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     A     B</span><br><span class="line"><span class="number">0x39</span>, <span class="number">0x5e</span>, <span class="number">0x79</span>, <span class="number">0x71</span>, <span class="number">0x00</span>,</span><br><span class="line"> C     D     E     F    无显示</span><br></pre></td></tr></table></figure>
<p>②共阳数码管码表  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>,</span><br><span class="line"> <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>,</span><br><span class="line"> <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     A     B</span><br><span class="line"><span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>, <span class="number">0xFF</span>,</span><br><span class="line"> C     D     E     F    无显示</span><br></pre></td></tr></table></figure>
<p>从上述共阳和共阴码表中不难发现， 它们的数据正好是相互取反的值。 比如共阴数码管数字 0 段码： 0x3f， 其二进制是： 0011 1111， 取反后为： 1100 0000，转换成 16 进制即为 0XC0。 其他段码依此类推。 该段码数据由来， 是将 a 段作为最低位， b 段作为次低位， 其他按顺序类推， dp 段为最高位， 共 8 位， 正好和51 单片机的一组端口数一样， 因此可以直接使用某一组端口控制数码管的段选数据口， 比如 P0 口。  </p>
<h4 id="数码管静态显示原理"><a href="#数码管静态显示原理" class="headerlink" title="数码管静态显示原理"></a>数码管静态显示原理</h4><p>LED 数码管显示器工作方式有两种： 静态显示方式和动态显示方式。 静态显示的特点是每个数码管的段选必须接一个 8 位数据线来保持显示的字形码。 当送入一次字形码后， 显示字形可一直保持， 直到送入新字形码为止。 这种方法的优点是占用 CPU 时间少， 显示便于监测和控制。 缺点是硬件电路比较复杂， 成本较高， 比如使用 4 个静态数码管， 那么就得 32 个 IO 来控制， 这对 51 单片机来说是无法承受的， 正因为如此才会有后面章节动态数码实验的讲解  </p>
<p>动态显示的特点是将所有数码管的段选线并联在一起， 由位选线控制是哪一位数码管有效。 选亮数码管采用动态扫描显示。 所谓动态扫描显示即轮流向各位数码管送出字形码和相应的位选， 利用发光管的余辉和人眼视觉暂留作用， 使人的感觉好像各位数码管同时都在显示。 动态显示的亮度比静态显示要差一些， 所以在选择限流电阻时应略小于静态显示电路中的。  </p>
<p>章实验使用的数码管虽然是动态数码管电路， 但我们依然可以使用数码管其中一位来学习静态数码管知识。 本章实验主要介绍静态数码管的控制， 有关动态数码管控制将在下一章节介绍。 有关静态数码管的详细介绍， 大家可以在百度上查找了解。</p>
<h4 id="硬件设计-2"><a href="#硬件设计-2" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上的静态数码管模块电路如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132752909.png" alt="image-20230612132752909"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132756970.png" alt="image-20230612132756970"></p>
<p>​        上图电路实际上是动态数码管电路， 使用的是 2 个四位一体的共阴数码管组成， 即 8 位数码管的段选数据 a-dp 全部并联一起引出， 每位数码管的位选即公共端引出， 前面我们也说了， 虽然开发板上没有单个的静态数码管， 但依然可以在动态数码管电路中使用其中一个来学习静态数码管显示。 本实验使用 SMG1 最左边那个数码管作为静态数码管， 因为单片机 IO 口外部都增加了外部上拉电阻，因此 P22、 P23、 P24 引脚默认就是高电平， 根据 38 译码器输出特点， 此时 Y7脚（LED8） 输出有效， 即低电平。 而数码管的段选 a-dp 连接在 74HC245 驱动芯片输出口， 由 P0 端口控制。 所以只要控制 P0 口输出高电平， SMG1 最左边那个数码管默认就可以显示。 此处暂时不去理会 38 译码器的工作原理， 后面动态数码管实验会专门介绍。 74HC245 作为驱动芯片使用， 目的是让数码管能获得更大的电流， 为防止因电流过大烧坏数码管， 在 74HC245 芯片输出管脚又串联了 2个 4 位的 100 欧排阻后连接数码管段码 a-dp 脚。 本章暂时不必了解 74HC245 芯片使用， 只要知道 P0 口输出什么， 74HC245 芯片就输出什么  </p>
<h4 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 控制静态数码管显示数字 0， 即让 P0 端口输出数字0 的段码 0x3f（共阴） 。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">实验名称： 静态数码管实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后“数码管模块” 最左边数码管显示数字 0</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">				  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">			SMG_A_DP_PORT=gsmg_code[<span class="number">0</span>];<span class="comment">//将数组第 1 个数据赋值给数码管段选口</span></span><br><span class="line">			<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>​        main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后定义一个全局数组变量 gsmg_code 存放共阴数码管 0-F 段码数据。 主函数功能也很简单，首先将数组的第 1 个数据赋值给 SMG_A_DP_PORT， 因为数组内定义的是共阴数码管段码，数组角标为0存储的就是第一个数据0X3F。然后进入while循环，单片机此时一直在 while 内循环操作。当然该条语句也可以放在 while循环语句内，同样会让静态数码管显示 0 。</p>
<h3 id="动态数码管实验"><a href="#动态数码管实验" class="headerlink" title="动态数码管实验"></a>动态数码管实验</h3><p>​            前面章节我们已经介绍了如何使用 51 单片机控制静态数码管显示， 在实际应用中通常都需要显示多位数值， 如果采用静态数码管显示就不够好， 因此就需要采用另外一种显示方式，即数码管动态显示。 开发板上板载 2 个四位一体的共阴数码管， 本章我们就来介绍下如何使用 51 单片机控制动态数码管显示。本章所要实现的功能是：控制动态数码管从左至右显示数字 0-7。 学习本章可以参考前面的实验章节内容。   </p>
<h4 id="数码管介绍-1"><a href="#数码管介绍-1" class="headerlink" title="数码管介绍"></a>数码管介绍</h4><p>​        上一章我们主要是介绍一位数码管的内部结构及控制原理。下面我们再来介绍下多位数码管及动态显示原理的相关知识  </p>
<h5 id="多位数码管简介"><a href="#多位数码管简介" class="headerlink" title="多位数码管简介"></a>多位数码管简介</h5><p>​            多位数码管，即两个或两个以上单个数码管并列集中在一起形成一体的数码管。 当多位一体时，它们内部的公共端是独立的，而负责显示什么数字的段线（a-dp） 全部是连接在一起的， 独立的公共端可以控制多位一体中的哪一位数码管点亮， 而连接在一起的段线可以控制这个能点亮数码管亮什么数字， 通常我们把公共端叫做“位选线” ， 连接在一起的段线叫做“段选线” ， 有了这两个线后，通过单片机及外部驱动电路就可以控制任意的数码管显示任意的数字了。  </p>
<p>​            一般一位数码管有 10 个引脚， 二位数码管也是 10 个引脚， 四位数码管是12 个引脚， 关于具体的引脚及段、 位标号大家可以查询相关资料， 最简单的办法就是用数字万用表测量， 若没有数字万用表也可用 5V 直流电源串接 1k 电阻后测量， 将测量结果记录， 通过统计便可绘制出引脚标号。 多位数码管有许多是按一定要求设计的， 引脚不完全按照一般规则设定， 所以需要在使用时查找手册，最直接的办法就是按照数码管上的标示向生产商要求。我们开发板上使用了 2 个四位一体的共阴数码管， 这样可在上面同时显示 8个数值。 </p>
<h5 id="数码管动态显示原理"><a href="#数码管动态显示原理" class="headerlink" title="数码管动态显示原理"></a>数码管动态显示原理</h5><p>​        位数码管依然可以静态显示， 但是显示时要么只显示一位数码管， 要么多位同时显示相同内容。 当多位数码管应用于某一系统时， 它们的“位选” 是可独立控制的， 而“段选” 是连接在一起的， 我们可以通过位选信号控制哪几个数码管亮， 而在同一时刻， 位选选通的所有数码管上显示的数字始终都是一样的， 因为它们的段选是连接在一起的， 送入所有数码管的段选信号都是相同的， 所以它们显示的数字必定一样， 数码管的这种显示方法叫做静态显示。</p>
<p>​        而动态显示， 就是利用减少段选线， 分开位选线， 利用位选线不同时选择通断， 改变段选数据来实现的。 比如在第一次选中第一位数码管时， 给段选数据 0，下一次位选中第二位数码管时显示 1。 为了在显示 1 的时候， 0 不会消失（当然实际上是消失了） ， 必须在人肉眼观察不到的时间里再次点亮第一次点亮的 0。而这时就需要记住， 人的肉眼正常情况下只能分辨变化超过 24ms 间隔的运动。也就是说， 在下一次点亮 0 这个数字的时间差不得大于 24ms。 这时就会发现，数码管点亮是在向右或者向左一位一位点亮， 形成了动态效果。 如果把间隔时间改长就能直接展现这一现象。</p>
<p>​        数码管动态显示的应用非常多， 所以大家一要认真学好数码管的动态显示方法。</p>
<h4 id="245和138-芯片介绍"><a href="#245和138-芯片介绍" class="headerlink" title="245和138 芯片介绍"></a>245和138 芯片介绍</h4><p>​    通过前面内容的介绍我们知道， 要使单片机能控制开发板上 2 位一体的共阴数码管显示， 仅靠单片机 IO 口来驱动是不行的， 这里就需要增加外部驱动芯片，开发板上使用的是 74HC245 芯片。 2 个 4 位一体的共阴数码管的位选线有 8 根，直接让单片机 IO 口控制是没有任何问题的， 但考虑到 51 单片机 IO 口资源的限制， 通常我们会使用一种 IO 扩展芯片， 比如 74HC138、 74HC164、 74HC595 芯片等， 只需要很少的单片机 IO 口就可以扩展出 8 个控制口， 通过级联方式甚至可扩展出更多的控制口（这个在后面 LED 点阵实验章节中会有详细介绍） 。 我们开发板上使用的是74HC138 译码器芯片， 只需单片机 3 个 IO 口就可以实现 8 个位选管脚的控制， 节省了芯片的 IO 资源。  </p>
<p>​    下面就来看看这两个芯片功能及使用方法。</p>
<h4 id="74HC245-芯片简介"><a href="#74HC245-芯片简介" class="headerlink" title="74HC245 芯片简介"></a>74HC245 芯片简介</h4><p>​    74HC245 是一种三态输出、八路信号收发器，主要应用于大屏显示， 以及其它的消费类电子产品中增加驱动。  </p>
<p>（1）主要特性<br>①采用 CMOS 工艺<br>②宽电压工作范围：3.0V-5.0V<br>③双向三态输出<br>④八线双向收发器<br>⑤封装形式：SOP20、SOP20-2、TSSOP20、DIP20</p>
<p>（1）主要特性<br>①采用 CMOS 工艺<br>②宽电压工作范围：3.0V-5.0V<br>③双向三态输出<br>④八线双向收发器<br>⑤封装形式：SOP20、SOP20-2、TSSOP20、DIP20</p>
<p>（2）管脚功能定义</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134832661.png" alt="image-20230612134832661"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134837862.png" alt="image-20230612134837862"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134841707.png" alt="image-20230612134841707"></p>
<p>​        从上面的管脚功能定义说明及真值表可以知道该芯片使用方法很简单，给 OE使能管脚低电平，DIR 管脚为高电平传输方向是 A-&gt;B 输出，DIR 为低电平传输方向是 B-&gt;A，至于输出高电平还是输出低电平取决于输入端的状态，如果输入为低电平，输出即为低；输入为高电平，输出即为高。如果 OE 使能管脚为高电平，不论 DIR 管脚是高还是低，输出是高组态。<br>通常我们使用 74HC245 芯片用作驱动只会让其在一个方向输出，即 DIR 管脚<br>为高电平，传输方向是 A-&gt;B。</p>
<h4 id="74HC138-芯片简介"><a href="#74HC138-芯片简介" class="headerlink" title="74HC138 芯片简介"></a>74HC138 芯片简介</h4><p>74HC138D 是一种三通道输入、 八通道输出译码器， 主要应用于消费类电子产品。  </p>
<p>（1） 主要特性<br>①采用 CMOS 工艺<br>②低功耗<br>③工作电压： 3.0V-5.0V<br>④封装形式： SOP16</p>
<p>（2） 管脚功能定义  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135000064.png" alt="image-20230612135000064"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135005612.png" alt="image-20230612135005612"></p>
<p>L代表低电平   0  </p>
<p>H代表 高电平  1</p>
<p>X是代表<strong>任意</strong>，可高电平，也可低电平，</p>
<p>A代表输入、Y代表输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135009222.png" alt="image-20230612135009222"></p>
<p>​        从上面的管脚功能定义说明及真值表可以知道该芯片使用方法很简单， 给E1、 E2 使能管脚低电平， E3 管脚为高电平， 至于哪个管脚输出有效电平（低电平） ， 要看 A0， A1， A2 输入管脚的电平状态。 如果 A0， A1， A2 都为低电平， 则Y0 输出有效电平（低电平） ， 其他管脚均输出高电平。 如果 A0 为高电平， A1， A2 都为低电平， 则 Y1 输出有效电平（低电平） ， 其他管脚均输出高电平。 其他几种输出大家可以对照真值表查看。 如果 E1、 E2 使能管脚任意一个为高电平或者 E3 为低电平， 不论输入是什么， 输出都为高电平。  </p>
<p><strong>==这里给大家总结一个方法： A0、 A1、 A2 输入就相当于 3 位 2 进制数， A0 是低位， A1 是次高位， A2 是高位。 而 Y0-Y7 具体哪一个输出有效电平， 就看输入二进制对应的十进制数值。 比如输入是 101（A2， A1， A0） ， 其对应的十进制数是 5， 所以 Y5 输出有效电平（低电平）。==</strong></p>
<h4 id="硬件设计-3"><a href="#硬件设计-3" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管模块<br>（2） 74HC138<br>开发板上的动态数码管模块电路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612141602247.png" alt="image-20230612141602247"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612141607938.png" alt="image-20230612141607938"></p>
<p>​        上图电路使用的是 2 个四位一体的共阴数码管组成，即 8 位数码管的段选数据 a-dp 全部并联一起引出， 每位数码管的位选即公共端引出。数码管的段选 a-dp连接在 74HC245 驱动芯片输出口，由 P0 端口控制。 由 P2.2、 P2.3、 P2.4 管脚控制 74HC138 译码器输入从而控制数码管位选。</p>
<h4 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 控制动态数码管从左至右显示数字 0-7。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">实验名称： 动态数码管实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后“数码管模块” 显示 01234567</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//定义数码管位选信号控制脚</span></span><br><span class="line">	sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">	sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">	sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">				  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(ten_us--);</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125; </span><br><span class="line">       		SMG_A_DP_PORT=gsmg_code[i];<span class="comment">//传送段选数据</span></span><br><span class="line">			delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">			SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消音</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		smg_display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后定义 38 译码器的控制引脚， 并将共阴数码管 0-F 段码数据使用数组定义好。主函数功能也很简单， 直接进入 while 循环， 在循环体内执行 smg_display()数码管动态显示函数。 该函数是根据动态数码管显示原理所编写， 即选中所要显示的那位数码管， 然后发送在该位数码管上所要显示的段码数据， 延时一定时间后 在将段选口清零即消隐（消除之前的显示） ， 如此循环 8 次即可实现 8 位数码管显示。 在动态显示中， 要注意延时时间， 只要保证在人肉眼所能感觉时间之内即可， 让我们看到所要显示的内容就像是同时显示一样。 如果时间过长或者过短都可能会影响数码管的显示效果， 大家可以在例程基础上试着修改延时时间观察效果  </p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 动态数码管显示01234567。 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612143533993.png" alt="image-20230612143533993"> </p>
<h3 id="独立按键实验"><a href="#独立按键实验" class="headerlink" title="独立按键实验"></a>独立按键实验</h3><p>​        前几章介绍的都是 IO 口输出的使用， 这一章我们通过独立按键实验来介绍IO 口作为输入的使用。 开发板上板载 4 个独立按键。 本章所要实现的功能是：通过开发板上的独立按键 K1 控制 D1 指示灯亮灭。 学习本章可以参考前面的实验章节内容。  </p>
<h4 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h4><p>键是一种电子开关， 使用时轻轻按开关按钮就可使开关接通， 当松开手时,开关断开。 开发板上使用的按键及内部简易图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144057558.png" alt="image-20230612144057558"></p>
<p>按键管脚两端距离长的表示默认是导通状态， 距离短的默认是断开状态， 如果按键按下， 初始导通状态变为断开， 初始断开状态变为导通。通常的按键所用开关为机械弹性开关,当机械触点断开、 闭合时， 电压信号如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144139303.png" alt="image-20230612144139303"></p>
<p>​        由于机械点的弹性作用， 按键开关在闭合时不会马上稳定的接通， 在断开时也不会一下子断开， 因而在闭合和断开的瞬间均伴随着一连串的抖动。 抖动时间的长短由按键的机械特性决定的， 一般为 5ms 到 10ms。 按键稳定闭合时间的长短则由操作人员的按键动作决定的， 一般为零点几秒至数秒。 按键抖动会引起按键被误读多次。 为了确保 CPU 对按键的一次闭合仅作一次处理， 必须进行消抖。  </p>
<p>​        按键消抖有两种方式， 一种是硬件消抖， 另一种是软件消抖。 为了使电路更加简单， 通常采用软件消抖。 我们开发板也是采用软件消抖， 一般来说一个简单的按键消抖就是先读取按键的状态， 如果得到按键按下之后， 延时 10ms， 再次读取按键的状态， 如果按键还是按下状态， 那么说明按键已经按下。 其中延时10ms 就是软件消抖处理， 至于硬件消抖， 大家可以百度了解下， 网上都有非常详细的介绍。 这里给大家列出单片机常用的软件去抖动方法：  </p>
<p>1， 先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻， 所以默认 IO 为高<br>电平） 。<br>2， 读取 IO 口电平确认是否有按键按下。<br>3， 如有 IO 电平为低电平后， 延时几个毫秒。<br>4， 再读取该 IO 电平， 如果仍然为低电平， 说明按键按下。<br>5， 执行按键控制程序。</p>
<p>独立按键电路构成是由各个按键的一个管脚连接在一起接地， 按键其他引脚分别接到单片机 IO 口。</p>
<p>我们知道单片机的 IO 口既可作为输出也可作为输入使用， 当检测按键时用的是它的输入功能， 独立按键的一端接地， 另一端与单片机的 I/O 口相连， 开始时先给该 IO 口赋一高电平， 然后让单片机不断地检测该 I/O 口是否变为低电平， 当按键闭合时， 即相当于该 I/O 口通过按键与地相连， 变成低电平， 程序一旦检测到 I/O 口变为低电平则说明按键被按下， 然后执行相应的指令。</p>
<h4 id="硬件设计-4"><a href="#硬件设计-4" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p>
<p>（1） LED 模块中 D1 指示灯</p>
<p>（2） K1 按键</p>
<p>LED 模块电路在前面章节都介绍过， 这里就不多说， 开发板上的独立按键模块电路如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144532165.png" alt="image-20230612144532165"></p>
<p>​            从上图中可以看出， 4 个独立按键的控制管脚连接到 51 单片机的 P3.0-P3.3脚上。 其中 K1 连接在 P3.1 上， K2 连接在 P3.0 上， K3 连接在 P3.2 上， K4 连接在 P3.3 上。 4 个按键另一端全部连接在 GND， 当按键按下后， 对应 IO 口即为低电平。  </p>
<h4 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过开发板上的独立按键 K1 控制 D1 指示灯亮灭。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">    <span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//定义 LED1 控制脚</span></span><br><span class="line"></span><br><span class="line">    sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">		&#123;</span><br><span class="line">       		<span class="keyword">while</span>(ten_us--);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :	   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line">    u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    	&#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    		&#123;</span><br><span class="line">   				key=<span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">            key=key_scan(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//检测按键 K1 是否按下</span></span><br><span class="line">            LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        key_scan 函数带一个形参 mode， 该参数用来设定是否连续扫描按键， 如果mode 为 0， 只能操作一次按键， 只有当按键松开后才能触发下次的扫描， 这样做的好处是可以防止按下一次出现多次触发的情况。 如果 mode 为 1， 函数是支持连续扫描的， 即使按键未松开， 在函数内部有 if(mode==1)这条判断语句， 因此 key 始终是等于 1 的， 所以可以连续扫描按键， 当按下某个按键， 会一直返回这 个按键的键值， 这样做的好处是可以很方便实现连按操作。 函数内的 delay_10us(1000)即为软件消抖处理， 通常延时 10ms 即可。  </p>
<p>​        key_scan 函数还带有一个返回值， 如果未有按键按下， 返回值即为KEY_UNPRESS， 否则返回值即为对应按键的键值， 如 KEY1_PRESS、 KEY2_PRESS、KEY3_PRESS、 KEY4_PRESS， 这都是程序开头定义好的宏， 方便大家理解和使用。函数内定义了一个 static 变量 key， 相当于全局变量， 所以该函数不是一个可重入函数。 还有一点要注意的就是该函数按键的扫描是有优先级的， 因为函数内用了 if…else if…else 格式， 所以最先扫描处理的按键是 KEY1， 其次是KEY2， 然后是 KEY3， 最后是 KEY4。 如果需要将其优先级设置一样， 那么可以全部用 if 语句。  </p>
<p>​        main 函数中主要就是调用 key_scan 函数用于检测按键， 此时传入的 mode值为 0， 表示单次扫描按键， 然后将扫描按键的值保存在变量 key 中， 最后通过if 判断语句控制 LED1 状态。  </p>
<h4 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K1 键， D1 指示灯亮， 再按下 K1 键， D1 指示灯灭， 如此循环。  </p>
<h3 id="矩阵按键实验"><a href="#矩阵按键实验" class="headerlink" title="矩阵按键实验"></a>矩阵按键实验</h3><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K1 键， D1 指示灯亮， 再按下 K1 键， D1 指示灯灭， 如此循环。  </p>
<h4 id="矩阵按键介绍"><a href="#矩阵按键介绍" class="headerlink" title="矩阵按键介绍"></a>矩阵按键介绍</h4><p>​        独立按键与单片机连接时， 每一个按键都需要单片机的一个 I/O 口， 若某单片机系统需较多按键， 如果用独立按键便会占用过多的 I/O 口资源。 单片机系统中 I/O 口资源往往比较宝贵， 当用到多个按键时为了减少 I/O 口引脚， 引入了矩阵按键。  </p>
<p>​        本章以 4*4 矩阵键盘为例讲解其工作原理和检测方法。 开发板上将 16 个按键排成 4 行 4 列， 第一行将每个按键的一端连接在一起构成行线， 第一列将每个按键的另一端连接在一起构成列线， 这样便一共有 4 行 4 列共 8 根线， 我们将这 8 根线连接到单片机的 8 个 I/O 口上， 通过程序扫描键盘就可检测 16 个键。 用这种方法我们也可实现 3 行 3 列 9 个键、 5 行 5 列 25 个键、 6 行6 列 36 个键甚至更多。  </p>
<p>​        无论是独立键盘还是矩阵键盘， 单片机检测其是否被按下的依据都是一样的， 也就是检测与该键对应的 I/O 口是否为低电平。 独立键盘有一端固定为低电平， 此种方式编程比较简单。 而矩阵键盘两端都与单片机 I/O 口相连， 因此在检测时需编程通过单片机 I/O 口送出低电平。 检测方法有多种， 最常用的是行列扫描和线翻转法。  </p>
<p>​        行列扫描法检测时， 先送一列为低电平， 其余几列全为高电平(此时我们确定了列数)， 然后立即轮流检测一次各行是否有低电平， 若检测到某一行为低电平(这时我们又确定了行数)， 则我们便可确认当前被按下的键是哪一行哪一列的， 用同样方法轮流送各列一次低电平， 再轮流检测一次各行是否变为低电平，这样即可检测完所有的按键， 当有键被按下时便可判断出按下的键是哪一个键。当然我们也可以将行线置低电平， 扫描列是否有低电平。 从而达到整个键盘的检测。</p>
<p>​        线翻转法， 就是使所有行线为低电平时， 检测所有列线是否有低电平， 如果有， 就记录列线值； 然后再翻转， 使所有列线都为低电平， 检测所有行线的值，由于有按键按下， 行线的值也会有变化， 记录行线的值。 从而就可以检测到全部按键。  </p>
<p>​        矩阵键盘也少不了按键消抖的环节， 本章实验中采用的是行列扫描法来检测哪个按键按下。</p>
<h4 id="硬件设计-5"><a href="#硬件设计-5" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 静态数码管<br>（2） 4*4 矩阵按键<br>静态数码管模块电路在前面章节都介绍过， 这里就不多说， 开发板上的矩阵按键模块电路如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613081823539.png" alt="image-20230613081823539"></p>
<p>板子是上拉电阻，上拉电阻为1，输入低电平0则按下</p>
<p>P17为高位，P10为低位</p>
<p>当P17按下时为 0111 1111    我们赋值0X7F就可以判断P17是否按下    依次类推</p>
<p>从上图中可以看出， 4*4 矩阵按键引出的 8 根控制线直接连接到 51 单片机的P1 口上。 电路中的 P17 连接矩阵键盘的第 1 行， P13 连接矩阵键盘第 1 列。  </p>
<h4 id="软件设计-5"><a href="#软件设计-5" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过数码管显示矩阵按键 S1-S16 按下后键值 0-F。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 矩阵按键实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 按下“矩阵按键” 模块中 S1-S16 键， 对应数码管最左边显示 0-F</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> KEY_MATRIX_PORT P1 <span class="comment">//使用宏定义矩阵按键控制口</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">	u8 gsmg_code[<span class="number">17</span>]=</span><br><span class="line">    			&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">				 <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(ten_us--);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_matrix_ranks_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 使用行列式扫描方法， 检测矩阵按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : key_value： 1-16， 对应 S1-S16 键，</span></span><br><span class="line"><span class="comment">0： 按键未按下</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_matrix_ranks_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xf7</span>;<span class="comment">//给第一列赋值 0， 其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>)<span class="comment">//判断第一列按键是否按下</span></span><br><span class="line">	&#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第一列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x77</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb7</span>: key_value=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd7</span>: key_value=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe7</span>: key_value=<span class="number">13</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">   	KEY_MATRIX_PORT=<span class="number">0xfb</span>;<span class="comment">//给第二列赋值 0， 其余全为 1</span></span><br><span class="line">	<span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>)<span class="comment">//判断第二列按键是否按下</span></span><br><span class="line">	&#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第二列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbb</span>: key_value=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdb</span>: key_value=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xeb</span>: key_value=<span class="number">14</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">	KEY_MATRIX_PORT=<span class="number">0xfd</span>;<span class="comment">//给第三列赋值 0， 其余全为 1</span></span><br><span class="line">	<span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>)<span class="comment">//判断第三列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第三列按键按下后的键值</span></span><br><span class="line">   		&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbd</span>: key_value=<span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdd</span>: key_value=<span class="number">11</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xed</span>: key_value=<span class="number">15</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfe</span>;<span class="comment">//给第四列赋值 0， 其余全为 1</span></span><br><span class="line">	<span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>)<span class="comment">//判断第四列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第四列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbe</span>: key_value=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xde</span>: key_value=<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xee</span>: key_value=<span class="number">16</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">	<span class="keyword">return</span> key_value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_matrix_flip_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 使用线翻转扫描方法， 检测矩阵按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : key_value： 1-16， 对应 S1-S16 键，</span></span><br><span class="line"><span class="comment">0： 按键未按下</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_matrix_flip_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0x0f</span>;<span class="comment">//给所有行赋值 0， 列全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)<span class="comment">//判断按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//测试列</span></span><br><span class="line">        KEY_MATRIX_PORT=<span class="number">0x0f</span>;</span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存行为 0， 按键按下后的列值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x07</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//测试行</span></span><br><span class="line">        KEY_MATRIX_PORT=<span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存列为 0， 按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x70</span>: key_value=key_value;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb0</span>: key_value=key_value+<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd0</span>: key_value=key_value+<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe0</span>: key_value=key_value+<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf0</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        key_value=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key=key_matrix_ranks_scan();</span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="number">0</span>)</span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[key<span class="number">-1</span>];<span class="comment">//得到的按键值减 1 换算成数组下标对应 0-F 段码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        本实验核心代码为 key_matrix_ranks_scan 函数和 key_matrix_flip_scan函数， 前者是使用行列式扫描方式实现， 而后者是使用线翻转式扫描方式实现，实现功能一致， 二者可选其一。 对于初学者， 可能行列式扫描方式更易于理解，因为比较接近独立按键的编程方式。  </p>
<p>​        行列式扫描原理比较简单， 与独立式按键操作类似， 即给每一列赋值 0， 此时的矩阵按键就被分割成独立按键， 然后再判断每一列中的按键按下情况， 并返回对应的键值。 如此循环 4 组， 就可将 4 列 4 行按键按下键值全部得到。  </p>
<p>​        而线翻转式扫描相对较难理解， 不过静下心， 在纸上画画， 列举几个数据也是比较容易理解的。  </p>
<h4 id="实验现象-1"><a href="#实验现象-1" class="headerlink" title="实验现象"></a>实验现象</h4><p>​        使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 S1-S16 键， 最左边数码管对应显示 0-F。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084447693.png" alt="image-20230613084447693"> </p>
<h3 id="IO扩展（串转并）-74HC595"><a href="#IO扩展（串转并）-74HC595" class="headerlink" title="IO扩展（串转并）-74HC595"></a>IO扩展（串转并）-74HC595</h3><p>​        在前面章节实验中， 我们是直接使用单片机 IO 口控制外围设备， 从 LED 流水灯到动态数码管显示， 可以看到这些外围设备已经占据了很多的 IO 口， 而 51单片机 IO 口非常有限， 如果想要连接更多外围设备， 此时可以通过 IO 扩展来实现。 本章就来介绍另外一种 IO 口扩展方式-串转并， 使用的芯片是 74HC595。 开发板板载 1 个 74HC595 芯片， 仅需单片机 3 个 IO 口即可扩展 8 个， 如果需要还可以将 2 个 74HC595 级联扩展出 16 个 IO， 这就实现用少数 IO 资源控制多个设备。 通过本章的学习， 让大家学会使用 74HC595 芯片来扩展 IO 口。 本章所要实现的功能是： 通过 74HC595 模块控制 LED 点阵以一行循环滚动显示。 学习本章可以参考前面的实验章节内容。 本章分为如下几部分内容：  </p>
<h4 id="74HC595芯片介绍"><a href="#74HC595芯片介绍" class="headerlink" title="74HC595芯片介绍"></a>74HC595芯片介绍</h4><p>74HC595 是一个 8 位串行输入、 并行输出的位移缓存器， 其中并行输出为三态输出（即高电平、 低电平和高阻抗） 。 芯片管脚及功能说明如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084758935.png" alt="image-20230613084758935">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084804258.png" alt="image-20230613084804258"></p>
<p>​        上面两张都是 74HC595 芯片管脚图， 细心的朋友就会发现左侧的 1 脚是 QB，而右侧芯片的 1 脚是 Q1， 左侧芯片的 11 脚是 SCK， 而右侧芯片的 11 脚SH_CP，还有很多其他管脚不一样， 其实这个都没有什么， 每个人在绘制芯片管脚图时命名可能不一样而已， 看一个芯片重点是管脚功能  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> 和 <span class="number">1</span> 到 <span class="number">7</span> 脚 QA--QH： 并行数据输出</span><br><span class="line"><span class="number">9</span> 脚 QH 非： 串行数据输出</span><br><span class="line"><span class="number">10</span> 脚 SCLK 非（ MR） ： 低电平复位引脚</span><br><span class="line"><span class="number">11</span> 脚 SCK（ SHCP） ： 移位寄存器时钟输入</span><br><span class="line"><span class="number">12</span> 脚 RCK（ STCP） ： 存储寄存器时钟输入</span><br><span class="line"><span class="number">13</span> 脚 G 非（ OE） ： 输出有效</span><br><span class="line"><span class="number">14</span> 脚 SER（ DS） ： 串行数据输入</span><br></pre></td></tr></table></figure>
<p>​        74HC595 是具有 8 位移位寄存器和一个存储器，三态输出功能。移位寄存器和存储器是单独的时钟。 数据在 SCK 的上升沿输入，在 RCK 的上升沿进入到存储器中。 如果两个时钟连在一起， 则移位寄存器总是比存储器早一个脉冲。 移位寄存器有一个串行输入（DS） ，和一个串行输出（Q7 非） ，和一个异步的低电平复位， 存储寄存器有一个并行 8 位的， 具有三态的总线输出， 当 MR 为高电平， OE 为低电平时， 数据在 SHCP 上升沿进入移位寄存器， 在 STCP 上升沿输出到并行端口。  </p>
<h4 id="硬件设计-6"><a href="#硬件设计-6" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：  </p>
<p>（1） 8*8LED 点阵模块<br>（2） 74HC595 模块<br>开发板上的 74HC595 模块电路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613085130884.png" alt="image-20230613085130884"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613085138403.png" alt="image-20230613085138403"></p>
<p>​        h为高位，a为低位</p>
<p>​        从上图中可以看出， 74HC595 需要用到的控制管脚 SER、 RCLK、 SRCLK 直接连接到 51 单片机的 P3.4-P3.6 IO 口上， <code>输出端则是直接连接到 LED 点阵模块的行端口上， 即为 LED 发光二极管的阳极， LED 点阵的列则为发光二极管的阴极</code>。</p>
<p>​        要想控制 LED 点阵， 可以将单片机管脚按照 74HC595 芯片的通信时序要求来传输数据， 这样即可控制 LED 点阵的行数据。 根据 LED 发光二极管导通原理， 当阳极为高电平， 阴极为低电平则点亮， 否则熄灭。 因此通过单片机 P0 口可控制点阵列， 74HC595 可控制点阵行。</p>
<h4 id="软件设计-6"><a href="#软件设计-6" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过 74HC595 模块控制 LED 点阵以一行循环滚动显示。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： IO 扩展(串转并)实验-74HC595</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵以一行循环滚动显示</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 74HC595 控制管脚</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>; <span class="comment">//移位寄存器时钟输入</span></span><br><span class="line">sbit RCLK=P3^<span class="number">5</span>; <span class="comment">//存储寄存器时钟输入</span></span><br><span class="line">sbit SER=P3^<span class="number">4</span>; <span class="comment">//串行数据输入</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDZ_COL_PORT P0 <span class="comment">//点阵列控制端口</span></span></span><br><span class="line"></span><br><span class="line">u8 ghc595_buf[<span class="number">8</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,</span><br><span class="line">                  <span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时10us 微秒</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	u16 i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : hc595_write_data(u8 dat)</span></span><br><span class="line"><span class="comment">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc595_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次即可将一个字节写入寄存器中</span></span><br><span class="line">    &#123;</span><br><span class="line">        SER=dat&gt;&gt;<span class="number">7</span>;<span class="comment">//优先传输一个字节中的高位</span></span><br><span class="line">        dat&lt;&lt;=<span class="number">1</span>;<span class="comment">//将低位移动到高位</span></span><br><span class="line">        SRCLK=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        SRCLK=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);<span class="comment">//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span><br><span class="line">    &#125;</span><br><span class="line">    RCLK=<span class="number">0</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    RCLK=<span class="number">1</span>;<span class="comment">//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    LEDDZ_COL_PORT=<span class="number">0x00</span>;<span class="comment">//将 LED 点阵列全部设置为 0， 即 LED 阴极为低电平</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   		&#123;</span><br><span class="line">            hc595_write_data(<span class="number">0x00</span>);<span class="comment">//消除前面寄存器缓存数据   消隐</span></span><br><span class="line">            hc595_write_data(ghc595_buf[i]);<span class="comment">//写入新的数据</span></span><br><span class="line">            delay_ms(<span class="number">500</span>);<span class="comment">//延时 500ms</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​        代码还是比较简单易懂的， 首先定义好 74HC595 控制管脚， 以及点阵列控制口， 代码中重新定义了一个 ms 级延时函数 delay_ms， 该函数与前面 delay_10us类似， 都是利用循环占用 CPU 起到延时效果。 然后又定义了 74HC595 的控制函数hc595_write_data， 该函数完全按照 74HC595 的通信时序要求编写， 主要要注意的是 74HC595 是先传输字节的高位后传输低位， 所以需要将字节低位移动到高位传输， 在传输数据时， 要注意移位寄存器时钟和存储寄存器时钟的先后顺序， 将要写入的数据先传输到 74HC595 寄存器中， 即在准备好每位数据时要将 SRCLK进行一个上升沿变化， 此时即可将数据传输到寄存器内， 待循环 8 次即一个字节传输到寄存器中时， 就可以来一个存储时钟上升沿， 此时就可以将 74HC595 寄存器中的数据全部一次传输到 595 端口输出。最后就是在 main 函数中调用 74HC595的控制函数， 将实验中要实现的效果数据写入进去， 从而控制 LED 点阵的阳极，而阴极由 P0 口控制， 默认初始化时已经设置为 0， 也就是说只要 595 输出高电平， 那么对应的行就会点亮。  </p>
<h4 id="实验现象-2"><a href="#实验现象-2" class="headerlink" title="实验现象"></a>实验现象</h4><p>​        使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口），把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 8*8LED 点阵以一行循环滚动显示。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613090448384.png" alt="image-20230613090448384"></p>
<p>注意： 做 LED 点阵实验时， 一定要将 LED 点阵旁的 J24 黄色跳线帽短接到 GND一端。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613090521573.png" alt="image-20230613090521573"></p>
<h3 id="LED点阵实验"><a href="#LED点阵实验" class="headerlink" title="LED点阵实验"></a>LED点阵实验</h3><p>​        在前面章节，我们介绍过静态数码管和动态数码管显示， 其中动态数码管是一种应用非常多的显示设备，除此之外还有很多应用广泛的显示装置， 比如 LED点阵屏、LCD 液晶显示器等。我们开发板上使用了 64 个红色 LED 按照行列排布组成的 <code>8 * 8</code>LED 点阵。 本章就来介绍 LED 点阵的使用，通过本章的学习，让大家能够在 <code>8 * 8</code>LED 点阵屏上显示信息。本章所要实现的功能是： 在 8*8LED 点阵屏上点亮一个点， 上述功能实现后再显示数字图形等。   </p>
<h4 id="LED点阵介绍"><a href="#LED点阵介绍" class="headerlink" title="LED点阵介绍"></a>LED点阵介绍</h4><p>​        LED 点阵是由发光二极管排列组成的显示器件,在我们日常生活的电器中随处可见， 被广泛应用于汽车报站器， 广告屏等。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613091945253.png" alt="image-20230613091945253">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613091951353.png" alt="image-20230613091951353">        <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092039980.png" alt="image-20230613092039980">        </p>
<p>​    通常应用较多的是 8 <em> 8 点阵， 然后使用多个 8 </em> 8 点阵可组成不同分辨率的 LED点阵显示屏， 比如 16 <em> 16 点阵可以使用 4 个 8 </em> 8 点阵构成。 因此理解了8 <em> 8LED点阵的工作原理， 其他分辨率的 LED 点阵显示屏都是一样的。 这里以8 </em> 8LED 点阵来做介绍。 其内部结构图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092151892.png" alt="image-20230613092151892"></p>
<p>8*8 点阵共由 64 个发光二极管组成， 且每个发光二极管是放置在行线和列线的交叉点上， 当对应的某一行置 1 电平， 某一列置 0 电平， 则相应的二极管就亮；如要将第一个点点亮， 则 1 脚接高电平 a 脚接低电平， 则第一个点就亮了； 如果要将第一行点亮， 则第 1 脚要接高电平， 而（a、 b、 c、 d、 e、 f、 g、 h ） 这些引脚接低电平， 那么第一行就会点亮； 如要将第一列点亮， 则第 a 脚接低电平，而（1、 2、 3、 4、 5、 6、 7、 8） 接高电平， 那么第一列就会点亮。 由此可见， LED点阵的使用也是非常简单的。  </p>
<h4 id="硬件设计-7"><a href="#硬件设计-7" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 8 <em> 8LED 点阵模块<br>（2） 74HC595 模块<br>74HC595 模块、 8 </em> 8LED 点阵模块电路在前面章节都介绍过， 电路如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092303759.png" alt="image-20230613092303759"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092308683.png" alt="image-20230613092308683"></p>
<p>​    从上图中可以看出， 74HC595 需要用到的控制管脚 SER、 RCLK、 SRCLK 直接连接到 51 单片机的 P3.4-P3.6 IO 口上， 输出端则是直接连接到 LED 点阵模块的行端口上， 即为 LED 发光二极管的阳极， LED 点阵的列则为发光二极管的阴极。  </p>
<p>​    要想控制 LED 点阵， 可以将单片机管脚按照 74HC595 芯片的通信时序要求来传输数据， 这样即可控制 LED 点阵的行数据。 根据 LED 发光二极管导通原理， 当阳极为高电平， 阴极为低电平则点亮， 否则熄灭。 因此通过单片机 P0 口可控制点阵列， 74HC595 可控制点阵行。  </p>
<h4 id="软件设计-7"><a href="#软件设计-7" class="headerlink" title="软件设计"></a>软件设计</h4><p>​        本章所要实现的功能是： 在点阵屏上点亮一个点， 上述功能实现后再显示数字和图形。  </p>
<h5 id="LED点阵（点亮一个点）"><a href="#LED点阵（点亮一个点）" class="headerlink" title="LED点阵（点亮一个点）"></a>LED点阵（点亮一个点）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LED 点阵实验(点亮一个点)</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵点亮左上角第一个点</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned int u16; //对系统默认数据类型进行重定义</span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned char u8;</span></span></span><br><span class="line"><span class="string"><span class="meta">//定义 74HC595 控制管脚</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SRCLK=P3^6; //移位寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit rCLK=P3^5; //存储寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SER=P3^4; //串行数据输入</span></span></span><br><span class="line"><span class="string"><span class="meta">#define LEDDZ_COL_PORT P0 //点阵列控制端口</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : delay_10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : ten_us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void delay_10us(u16 ten_us)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">while(ten_us--);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta">void hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    for(i=0;i&lt;8;i++)//循环 8 次即可将一个字节写入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        SER=dat&gt;&gt;7;//优先传输一个字节中的高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        dat&lt;&lt;=1;//将低位移动到高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=1;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; </span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=1;//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/***********************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">************************************************************/  </span></span></span><br><span class="line"><span class="string"><span class="meta">void main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    LEDDZ_COL_PORT=0x7f;//将 LED 点阵左边第一列设置为 0， 即 LED 阴极为低电平， 其余列为 1， 即高电平</span></span></span><br><span class="line"><span class="string"><span class="meta">    while(1)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    	hc595_write_data(0x80);//将 LED 点阵上边第一行设置为 1， 即 LED 阳极为高电平， 其余行为 0， 即低电平</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>
<p>代码很简单， 与上一章核心代码是一样的， 这里主要是理解如何让 LED 点阵的左上角第一个点点亮， 实际上就是将第一个点对应的行为高电平， 列为低电平即可。 也就是让 74HC595 输出 0X80（1000 0000） ， 这样点阵第一行就是高电平，而 P0 口输出 0X7F（0111 1111） ， 这样点阵第一列就是低电平， 从而让 LED 点阵第一个点点亮。  </p>
<h5 id="显示数字"><a href="#显示数字" class="headerlink" title="显示数字"></a>显示数字</h5><p>点亮一个点很简单， 可是如何点亮多个点呢？ 如果需要一次显示多个怎么办？ 从原理图上可以看到每一行上都连接着多个 LED 灯， 每一列上也都连接着多个 LED 灯， 如果要点亮一个， 按照上面原理可以， 但是要同时点亮多个怎么办？  </p>
<p>么就需要用到动态数码管的动态扫描原理。 首先如何点亮一行上面多个灯或者一列上面多个灯？ 明显需要某行或某列有效， 同时使多列或多行有效。 比如在第一行有效（输出高电平） 的情况下， 有效列（输出低电平） 与这一行交点上的 LED 灯就会被点亮。 那么实现一行或一列点亮会比较容易。 如何实现不同行不同列上的灯被多个点亮呢？ 是否是行有效， 列有效就可以？ 并不是！  </p>
<p>要实现行列不同位置亮灯， 需要使用动态显示的方法， 也要结合扫描的方法。在第一行亮灯一段时间以后灭掉， 点亮第二行一段时间以后灭掉， 点亮第三行一段时间以后灭掉， 如此点亮， 直到八行全部点亮一次， 在第一行点亮到最后一行灭掉的总时间不能超过人肉眼可识别的时间， 即 24 毫秒。 在每一行点亮的时候，给列一个新的数据， 此时对应列的数据就可以体现在这行上要点亮的灯上。 这样就和动态数码管的显示一样， 只不过数码管的 LED 灯是段值。 这里使用 LED 点阵显示数字， 也是多个 LED 同时点亮  </p>
<p>要想在点阵上显示数字等字符， 首先要获取在 LED 点阵上显示数字字符所需的数据， 即一个数字字符在 LED 点阵上显示， 对应的每行每列都会有一些灯点亮或者熄灭， 这样就会构成一组数据， 也就是数字字符的显示数据， 我们只要将这些数据通过 74HC595 发送到点阵对应的行或列就能显示数字字符  </p>
<p>数字字符数据如何获取呢？ 这里给大家介绍一个非常好用的工具-取字模软件。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121024046.png" alt="image-20230614121024046"></p>
<p>双击打开该软件， 首先选择“基本操作-&gt;新建图像” ， 设置图像的宽度和高度为8， 点击确定后将在显示窗口出现一个8 <em> 8的白色格子， 这个就类似于8</em>8LED点阵， 具体操作如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121049722.png" alt="image-20230614121049722"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121053736.png" alt="image-20230614121053736"></p>
<p>可以看到上图 8*8 点阵区域非常小， 我们可以将其放大， 选择“模拟动画” ，后点击“放大格点” ， 如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121106194.png" alt="image-20230614121106194">  </p>
<p>然后可以在这个 8*8 白色格子里面点击， 点击后即会在对应位置出现一个黑点， 表示在 LED 点阵对应位置的 LED 灯点亮， 未点击位置（白色） 表示LED 点阵对应位置的 LED 灯熄灭。  </p>
<p>然后可以在这个 8*8 白色格子里面点击， 点击后即会在对应位置出现一个黑点， 表示在 LED 点阵对应位置的 LED 灯点亮， 未点击位置（白色） 表示LED 点阵对应位置的 LED 灯熄灭。  </p>
<p>比如在 8 <em> 8LED 点阵上显示数字 0， 那么可以在图中 8</em>8 白色框内通过点击对应位置描出一个数字 0 的外形， 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121150495.png" alt="image-20230614121150495"></p>
<p>然后设置取模数据的取模方式等内容， 选择“参数设置” 后点击“其他选项” ， 具体操作如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121203793.png" alt="image-20230614121203793"></p>
<p>然后点击“取模方式” ， 选择 C51 格式选项， 然后在点阵生成区自动会生成数字字符对应的数据（如果是使用汇编编程， 那么汇编对应的汉字数据可选择 A51 格式） 。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121218688.png" alt="image-20230614121218688"></p>
<p>到这里我们就将数字 0 的数据生成了， 然后将生成的数据复制到我们程序定义的数组中， 如下所示：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_row[<span class="number">8</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x7C</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x7C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示数字 0 的行数据</span></span><br></pre></td></tr></table></figure>
<p>这些数据其实就是上述描绘的数字 0 从左到右依次每列对应的行数据。至于其它数字或字符及简单图形的显示取模方法与上述类似。既然是动态扫描， 就需要不断的扫描每列， 因此可以把 LED 点阵的列控制也用数组存储起来， 为后面循环调用提供方便。 根据数字 0 取模的数据特点是从左至右每列对应的行数据， 因此扫描时也应该从左至右的顺序， 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示数字 0 的列数据  </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LED 点阵实验(点亮一个点)</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵点亮左上角第一个点</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned int u16; //对系统默认数据类型进行重定义</span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned char u8;</span></span></span><br><span class="line"><span class="string"><span class="meta">//定义 74HC595 控制管脚</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SRCLK=P3^6; //移位寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit rCLK=P3^5; //存储寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SER=P3^4; //串行数据输入</span></span></span><br><span class="line"><span class="string"><span class="meta">#define LEDDZ_COL_PORT P0 //点阵列控制端口</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">u8 gled_row[8]=&#123;0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0x00&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">//LED 点阵显示数字 0 的行数据</span></span></span><br><span class="line"><span class="string"><span class="meta">u8 gled_col[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">//LED 点阵显示数字 0 的列数据</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : delay_10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : ten_us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void delay_10us(u16 ten_us)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">while(ten_us--);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta">void hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    for(i=0;i&lt;8;i++)//循环 8 次即可将一个字节写入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        SER=dat&gt;&gt;7;//优先传输一个字节中的高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        dat&lt;&lt;=1;//将低位移动到高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=1;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; </span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=1;//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/***********************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : main</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 主函数</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">************************************************************/  </span></span></span><br><span class="line"><span class="string"><span class="meta">void main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    while(1)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for(i=0;i&lt;8;i++)//循环 8 次扫描 8 行、 列</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            EDDZ_COL_PORT=gled_col[i];//传送列选数据</span></span></span><br><span class="line"><span class="string"><span class="meta">            hc595_write_data(gled_row[i]);//传送行选数据</span></span></span><br><span class="line"><span class="string"><span class="meta">            delay_10us(100);//延时一段时间， 等待显示稳定</span></span></span><br><span class="line"><span class="string"><span class="meta">            hc595_write_data(0x00);//消影</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125; 	</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>
<p>实验代码与前面点亮一个点的核心代码是一样的， 这里重点要理解动态扫描， 如果动态数码管代码能理解， 这个也就没有任何问题。 main 函数中主要是在 while 循环内从上至下， 从左至右不断扫描 8 行、 列， 即首先设置左边第一列有效（P0.7 输出低电平） ， 其余列无效（P0.6-P0.0 输出高电平） ， 然后通过74HC595 输出该列对应的行数据， 延时一段时间等待显示稳定， 最后清除列对应的行数据， 即消影。 从整个流程下来与动态数码管显示程序是很相似的。  </p>
<h5 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h5><p>该取模软件不仅可以用来取汉字、 数字等字符数据， 还可以用来取图像数据，这里以“心” 形图像为例， 教大家如何使用该软件来获取图像数据。</p>
<p>（1） 新建图像。 弹出选择框， 开发板 LED 点阵是 8X8 的， 就建一个高 8 宽8 的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121938430.png" alt="image-20230614121938430"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122004947.png" alt="image-20230614122004947"></p>
<p>（2） 选中图像需用格点。 这里每一个格点代表一个 LED 灯， 点击可选中，再次点击也可取消。 在界面上点出爱心。 如下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122016631.png" alt="image-20230614122016631"></p>
<p>（3） 参数设置。 “参数设置” 选项中有许多可选项， 可以自己进行设置，得到自己想要的结果。 可参考前面取模里面的设置。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122038297.png" alt="image-20230614122038297"></p>
<p>（4） 生成数据。 设计好图案和参数以后， 就需要生成可用数据。 当点击格式以后会出现相应数据。 如下图所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122049051.png" alt="image-20230614122049051"></p>
<p>这里将生成的图形数据复制出来粘贴到例程中， 替换数字 0 的数据， 如下  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_row[<span class="number">8</span>]=&#123;<span class="number">0x38</span>,<span class="number">0x7C</span>,<span class="number">0x7E</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x7E</span>,<span class="number">0x7C</span>,<span class="number">0x38</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示图像的行数据</span></span><br></pre></td></tr></table></figure>
<p>其余代码与显示数字完全一样， 这里就不再列出。  </p>
<h4 id="实验现象-3"><a href="#实验现象-3" class="headerlink" title="实验现象"></a>实验现象</h4><p>​    注意： 做 LED 点阵实验时， 一定要将 LED 点阵旁的 J24 黄色跳线帽短接到 GND一端。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092815573.png" alt="image-20230613092815573"></p>
<p>LED 点阵（点亮一个点）  </p>
<p>  使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 8*8LED 点阵左上角显示第一个点。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093012649.png" alt="image-20230613093012649"></p>
<p>LED 点阵（显示数字） </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093031677.png" alt="image-20230613093031677"></p>
<p>LED 点阵（显示图像） </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093058969.png" alt="image-20230613093058969"></p>
<p>注意： ==当不使用 LED 点阵时， 将 LED 点阵旁的 J24 黄色跳线帽短接到 VCC 一端。 这是因为 LED 点阵使用到了 P0 口， 而数码管也使用到 PO 口， 为了不干扰后续数码管显示的一些实验， 所以短接到 VCC 一端==， 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093200730.png" alt="image-20230613093200730"></p>
<h3 id="直流电机实验"><a href="#直流电机实验" class="headerlink" title="直流电机实验"></a>直流电机实验</h3><p>在 51 单片机应用中， 电机控制的应用也非常多。 所以有必要先来了解下电机相关的知识以及如何使用 51 单片机控制电机， 在未学习 PWM 之前， 我们先简单使用 GPIO 来控制电机的旋转和停止。 不能直接使用 GPIO 来驱动电机， 而需要相应的驱动芯片来驱动电机， 开发板板载了一个 ULN2003 驱动芯片， 该芯片是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 不仅可以用来驱动我们的直流电机， 还可用来驱动五线四相步进电机， 比如 28BYJ-48 步进电机。 本章使用的是 ULN2003 芯片来驱动， 本章所要实现的功能是： 直流电机工作约 5S 后停止。 学习本章可以参考前面的实验章节内容。 本章分为如下几部分内容：  </p>
<h4 id="直流电机介绍"><a href="#直流电机介绍" class="headerlink" title="直流电机介绍"></a>直流电机介绍</h4><p>直流电机是指能将直流电能转换成机械能（直流电动机） 或将机械能转换成直流电能（直流发电机） 的旋转电机。 它是能实现直流电能和机械能互相转换的电机。 当它作电动机运行时是直流电动机， 将电能转换为机械能； 作发电机运行时是直流发电机， 将机械能转换为电能。  </p>
<p>直流电机的结构应由定子和转子两大部分组成。 直流电机运行时静止不动的部分称为定子， 定子的主要作用是产生磁场， 由机座、 主磁极、 换向极、 端盖、轴承和电刷装置等组成。 运行时转动的部分称为转子， 其主要作用是产生电磁转矩和感应电动势， 是直流电机进行能量转换的枢纽， 所以通常又称为电枢， 由转轴、 电枢铁心、 电枢绕组、 换向器和风扇等组成。  </p>
<p>直流电机没有正负之分， 在两端加上直流电就能工作。 需要知道直流电机的额定电压和额定功率， 不能使之长时间超负荷运作。 在交换接线后， 可以形成正反转  </p>
<p>开发板配置的直流电机为 5V 直流电机， 其主要参数如下：<br>轴长： 8mm<br>轴径： 2mm<br>电压： 1-6V<br>参考电流： 0.35-0.4A<br>3V 转速： 17000-18000 转每分钟<br>外观实物图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122343073.png" alt="image-20230614122343073"></p>
<p>其内部结构如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122353693.png" alt="image-20230614122353693"></p>
<h4 id="ULN2003芯片介绍"><a href="#ULN2003芯片介绍" class="headerlink" title="ULN2003芯片介绍"></a>ULN2003芯片介绍</h4><p>前面讲过， 51 单片机主要是用来控制而非驱动， 如果直接使用芯片的 GPIO管脚去驱动大功率器件， 要么将芯片烧坏， 要么就驱动不起来。 所以要驱动大功率器件， 比如电机。 就必须搭建驱动电路， 开发板上板载的驱动芯片是 ULN2003，该芯片是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 不仅可以用来驱动直流电机， 还可用来驱动五线四相步进电机， 比如 28BYJ-48 步进电机。 本章我们使用 ULN2003 来驱动直流电机， 下面来具体介绍下 ULN2003 芯片的使用  </p>
<p>ULN2003 是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 它是由7 对 NPN 达林顿管组成的， 它的高电压输出特性和阴极箝位二极管可以转换感应负载。 单个达林顿对的集电极电流是 500mA。 达林顿管并联可以承受更大的电流。此电路主要应用于继电器驱动器， 字锤驱动器， 灯驱动器， 显示驱动器（LED 气体放电） ， 线路驱动器和逻辑缓冲器。 ULN2003 的每对达林顿管都有一个 2.7k串联电阻， 可以直接和 TTL 或 5V CMOS 装置  </p>
<p>（1） 主要特点<br>①500mA 额定集电极电流（单个输出）<br>②高电压输出： 50V<br>③输入和各种逻辑类型兼容<br>④继电器驱动器<br>（2） 逻辑框图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122515458.png" alt="image-20230614122515458"></p>
<p>从上图可以很容易理解该芯片的使用方法， 其内部相当于非门电路， 即输入高输出为低， 输入为低输出是高， 这里要注意：==因为 ULN2003 的输出是集电极开路， ULN2003 要输出高电平， 必须在输出口外接上拉电阻。 这也就能解释在后面连接直流电机时为什么不能直接将 ULN2003 的 2 个输出口接电机线， 而必须一根线接电源， 另一个才接 ULN2003 输出口==。</p>
<p>若使用该芯片驱动直流电机， 只可实现单方向控制， 电机一端接电源正极，另一端接芯片的输出口。 若想控制五线四相步进电机， 则可将四路输出接到步进电机的四相上， 电机另一条线接电源正。  </p>
<h4 id="硬件设计-8"><a href="#硬件设计-8" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 步进电机驱动模块<br>（2） 直流电机<br>开发板上的步进电机驱动模块电路如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122740295.png" alt="image-20230614122740295"></p>
<p>从上图可知， ULN2003 的输入口与单片机的 P1.0-P1.3 连接， 对应输出则是OUT1-OUT4， 而 J47 则是提供给外部连接电机的接口， 可以支持直流电机、 五线四相步进电机 28BYJ-48 连接。 本实验使用的是直流电机， 电机的一根线连接在VCC 上， 另一根连接在 OUT1 上， 因此可通过单片机 P1.0 口输出高电平来控制电机旋转， 输出低电源控制电机停止。 注意： 单片机 P1.0 输出低电平时， ULN2003的 OUT1 并不会输出高电平导致停止， 而是因为集电极开路， 导致电机无电流流入致使停止。</p>
<h4 id="软件设计-8"><a href="#软件设计-8" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 直流电机工作约 5S 后停止。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 直流电机实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 直流电机旋转 5S 后停止</span></span><br><span class="line"><span class="comment">注意事项： 将直流电机两根线分别连接到“步进电机模块” 输出端子 J47 的 5V 和 O1 上。</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义直流电机控制管脚</span></span><br><span class="line">sbit DC_Motor=P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DC_MOTOR_RUN_TIME 5000 <span class="comment">//定义直流电机运行时间为 5000ms</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DC_Motor=<span class="number">1</span>;<span class="comment">//开启电机</span></span><br><span class="line">    delay_ms(DC_MOTOR_RUN_TIME);</span><br><span class="line">    DC_Motor=<span class="number">0</span>;<span class="comment">//关闭电机</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实验代码比较简单， 主要就是理解 ULN2003 的电平输出关系， 然后就像控制LED 一样。 这里就不再详细分析了  </p>
<h4 id="实验现象-4"><a href="#实验现象-4" class="headerlink" title="实验现象"></a>实验现象</h4><p>用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 直流电机工作约 5S后停止。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614170924104.png" alt="image-20230614170924104"></p>
<p>注意： ==直流电机的两根线要连接在 J47 端子的 O1 和 5V 上。 如下所示==：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614170946727.png" alt="image-20230614170946727"></p>
<h3 id="步进电机实验"><a href="#步进电机实验" class="headerlink" title="步进电机实验"></a>步进电机实验</h3><h4 id="步进电机简介"><a href="#步进电机简介" class="headerlink" title="步进电机简介"></a>步进电机简介</h4><p>步进电机是将电脉冲信号转变为角位移或线位移的开环控制元件。 在非超载的情况下， 电机的转速、 停止的位置只取决于脉冲信号的频率和脉冲数， 而不受负载变化的影响， 即给电机加一个脉冲信号， 电机则转过一个步距角。 这一线性关系的存在， 加上步进电机只有周期性的误差而无累计误差等特点。 使得在速度、位置等控制领域用步进电机来控制变的非常的简单。 虽然步进电机已被广泛的应用， 但步进电机并不能像普通的直流电机， 交流电机在常规下使用。 它必须由双环形脉冲信号、 功率驱动电路等组成控制系统方可使用。 因此用好步进电机也并非易事， 它涉及到机械、 电机、 电子及计算机等多专业知识。 下图即为混合式步进电机组成图。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173248513.png" alt="image-20230616173248513"></p>
<h4 id="步进电机工作原理"><a href="#步进电机工作原理" class="headerlink" title="步进电机工作原理"></a>步进电机工作原理</h4><p>通常步进电机的转子为永磁体， 当电流流过定子绕组时， 定子绕组产生一矢量磁场。 磁场会带动转子旋转一定的角度， 使得转子的一对磁场方向与定子的磁场方向一致。 当定子的矢量磁场旋转一个角度。 转子也随着该磁场转步距角。 每输入一个电脉冲， 电动机转动一个角度前进一步。 它输出的角位移与输入的脉冲数成正比、 转速与脉冲频率成正比。 改变绕组通电的顺序， 电机就会反转。 所以可以控制脉冲数量、 频率及电动机各相绕组的通电顺序来控制步进电机的转动。具体看下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173306284.png" alt="image-20230616173306284"></p>
<h4 id="步进电机极性区分"><a href="#步进电机极性区分" class="headerlink" title="步进电机极性区分"></a>步进电机极性区分</h4><p>步进电机又分为单极性的步进电机和双极性的步进电机； 具体简易图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173332981.png" alt="image-20230616173332981"></p>
<p>其中左侧为单极性步进电机， 右侧为双极性的步进电机， 从上图中不难看出区别是什么。 单双极性是指一个步进电机里面有几种电流的流向， 左侧的五线四相步进电机就是单极性的步进电机， 图中的红色箭头为电流的走向， 四根线的电流走向汇总到公共线， 所以称之为单极性电机； 但是右侧则不同， 电机中有两个电流的回路， 两个电流的回路自然就是双极性， 所以称之为双极性电机。  </p>
<p><code>单极性绕组</code></p>
<p>单极性步进电机使用的是单极性绕组。 其一个电极上有两个绕组， 这种联接方式为当一个绕组通电时， 产生一个北极磁场； 另一个绕组通电， 则产生一个南极磁场。 因为从驱动器到线圈的电流不会反向， 所以可称其为单极绕组。  </p>
<p><code>双极性绕组</code>  </p>
<p>双极性步进电机使用的是双极性绕组。 每相用一个绕组， 通过将绕组中电流反向， 电磁极性被反向。 典型的两相双极驱动的输出步骤在电气原理图和下图中的步进顺序中进一步阐述。 按图所示， 转换只利用绕组简单地改变电流的方向，就能改变该组的极性。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173418031.png" alt="image-20230616173418031"></p>
<p>永磁步进电机包括一个永磁转子、 线圈绕组和导磁定子， 只要将线圈通电根据电磁铁的原理就会产生磁场， 分为南北极， 见上图所示； 通过改变步进电机定子的磁场， 转子就会因磁场的变化而发生转动， 同理， 依次改变通电的顺序就可以使得电机转动起来。  </p>
<h4 id="双极性步进电机驱动原理"><a href="#双极性步进电机驱动原理" class="headerlink" title="双极性步进电机驱动原理"></a>双极性步进电机驱动原理</h4><p>下图是一个双极性的步进电机整步， 步进顺序。 在第一步中： 将 A 相通电，根据电磁铁原理， 产生磁性， 并且因异性相吸， 所以磁场将转子固定在第一步的位置； 第二步： 当 A 相关闭， B 相通电时， 转子会旋转 90° ； 第三步： B 相关闭、 A 相通电， 但极性与第 1 步相反， 这促使转子再次旋转 90° 。 在第四步中： A 相关闭、 B 相通电， 极性与第 2 步相反。 重复该顺序促使转子按 90° 的步距角顺时针旋转。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173450584.png" alt="image-20230616173450584"></p>
<p>上图中显示的步进顺序是单相激励步进， 也可以理解为每次通电产生磁性的相只有一个， 要么 A 相， 要么 B 相； 但是更常用的是双相激励， 但是在转换时，一次只能换相一次， 具体详见下图  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173459038.png" alt="image-20230616173459038"></p>
<p>上图是两相同时通电的旋转顺序， 与单相激励不同的是， 单相通电后被固定在了与定子正对着的绕组极性， 但是双相同时激励时转子却被固定在两个绕阻的极性中间； 此时通电顺序就变成了 AB 相同时通电即可。  </p>
<p>在双相激励的过程中， 也可以在换相位时加一个关闭相位的状态而产生走半步的现象， 这将步进电机的整个步距角一分为二， 例如， 一个 90° 的步进电机将每半步移动 45° ， 具体见下图  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173512127.png" alt="image-20230616173512127"></p>
<ol>
<li>A 相通电， B 相不通电</li>
<li><p>A、 B 相全部通电， 且电流相同， 产生相同磁性</p>
</li>
<li><p>B 相通电， A 断电</p>
</li>
<li>B 相通电， A 相通电， 且电流相等， 产生相同磁性</li>
<li>A 相通电， B 断电</li>
<li>A、 B 相全部通电， 且电流相同， 产生相同磁性</li>
<li>B 相通电， A 断电</li>
<li>B 相通电， A 相通电， 且电流相等， 产生相同磁性<br> 其中 1~4 步与 5~8 步的电流方向相反（电流相反， 电磁的极性就相反） 这<br> 样就产生了顺时针旋转， 同理逆时针是将通电顺序反过来即可。</li>
</ol>
<h4 id="单极性步进电机驱动原理"><a href="#单极性步进电机驱动原理" class="headerlink" title="单极性步进电机驱动原理"></a>单极性步进电机驱动原理</h4><p>单极性与双极性步进电机驱动类似， 都可以分为整步与半步的驱动方式， 不同的是， 双极性的步进电机可以通过改变电流的方向来改变每相的磁场方向， 但是单极性的就不可以了， 它有一个公共端， 这就直接决定了， 电流方向。 具体旋转顺序详见下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173550016.png" alt="image-20230616173550016"></p>
<p>上图是单极性步进电机整步旋转的过程， 其中， 在图示中分为 5 根线， 分别为 A、 B、 C、 D 和公共端（+） ， 公共端需要一直通电， 剩下 ABCD 相中只要有一个相通电， 即可形成回路产生磁场， 图中的通电顺序为 A-&gt;B-&gt;C-&gt;D， 即可完成上图中的顺时针旋转， 如果想要逆时针旋转只需要将其倒序即可。  </p>
<p>以上是单相通电产生的整步旋转， 两相通电也可以产生， 两个相邻的相通电，这样相邻的两个相就都产生了回路， 也就产生了磁场， 图中的通电顺序为AB-&gt;BC-&gt;CD-&gt;DA， 同理逆时针旋转的顺序为逆序。 具体看下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173612410.png" alt="image-20230616173612410"></p>
<p>上面两张图清晰的描述了单极性步进电机的通电顺序与旋转的过程， 综合这两张图就是单极性步进电机半步的通电顺序， 具体看下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173621285.png" alt="image-20230616173621285"></p>
<p>上图兼容了前两张图的所有特点， 也可以说前两张图是这张图的子集， 图中的通电顺序为： A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA 转子每次只走半步 45 度， 所以这也被称为半步驱动， 与整步相比半步的旋转方式旋转起来更加的顺滑。  </p>
<h4 id="细分驱动原理"><a href="#细分驱动原理" class="headerlink" title="细分驱动原理"></a>细分驱动原理</h4><p>对于细分驱动的原理， 不分单双极性步进电机， 下图以单极性为例：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173640692.png" alt="image-20230616173640692"></p>
<p>在上图中均为双相激励； 其中图（a） 为 A 相电流很大， B 相的电流极其微弱， 接近 0； 图 (C) 为 A 相和 B 相的电流相同， 电流决定磁场， 所以说 A 相和 B 相的磁场也是相同的， (a) 和（c） 可以是极限特殊的情况， 再看图（b）和图（d） 这两个是由于 A 相和 B 相的电流不同产生位置情况； 由此可以得出改变定子的电流比例就可以使得转子在任意角度停住。 细分的原理就是： 通过改变定子的电流比例， 改变转子在一个整步中的不同位置， 可以将一个整步分成多个小步来运行。  </p>
<p>在上图中就是一个整步分成了 4 步来跑， 从（a） ~（d） 是 A 相的电流逐渐减小， B 相电流逐渐增大的过程， 如果驱动器的细分能力很强， 可以将其分成32 细分、 64 细分等； 这不仅提高了步进电机旋转的顺畅度而且提高了每步的精度。 细分驱动具有转动顺畅、 精度高、 转矩大的特点， 但控制复杂， 一般需要专用芯片来实现， 例如东芝公司的 TB67S10xA 系列步进电机细分驱动芯片， 最多可以把 1 个整步分为 32 个小步。  </p>
<h4 id="步进电机技术指标"><a href="#步进电机技术指标" class="headerlink" title="步进电机技术指标"></a>步进电机技术指标</h4><h5 id="静态技术指标"><a href="#静态技术指标" class="headerlink" title="静态技术指标"></a>静态技术指标</h5><p>• 相数： 产生不同对极 N、 S 磁场的激磁线圈对数， 也可以理解为步进电机中线圈的组数， 其中两相步进电机步距角为 1.8° ， 三相的步进电机步距角为1.5° ， 相数越多的步进电机， 其步距角就越小。</p>
<p>• 拍数： 完成一个磁场周期性变化所需脉冲数或导电状态用 n 表示， 或指电机转过一个齿距角所需脉冲数， 以四相电机为例， 有四相四拍运行方式即AB-BC-CD-DA-AB， 四相八拍运行方式即 A-AB-B-BC-C-CD-D-DA-A。</p>
<p>• 步距角： 一个脉冲信号所对应的电机转动的角度， 可以简单理解为一个脉冲信号驱动的角度， 电机上都有写， 一般 42 步进电机的步距角为 1.8°</p>
<p>• 定位转矩： 电机在不通电状态下， 电机转子自身的锁定力矩（由磁场齿形的谐波以及机械误差造成的） 。</p>
<p>• 静转矩： 电机在额定静态电压作用下， 电机不作旋转运动时， 电机转轴的锁定力矩。 此力矩是衡量电机体积的标准， 与驱动电压及驱动电源等无关。</p>
<h5 id="动态技术指标"><a href="#动态技术指标" class="headerlink" title="动态技术指标"></a>动态技术指标</h5><p>• 步距角精度： 步进电机转动一个步距角度的理论值与实际值的误差。 用百分比表示： 误差/步距角 *100%。<br>• 失步： 电机运转时运转的步数， 不等于理论上的步数。 也可以叫做丢步，一般都是因负载太大或者是频率过快。<br>• 失调角： 转子齿轴线偏移定子齿轴线的角度， 电机运转必存在失调角， 由失调角产生的误差， 采用细分驱动是不能解决的。<br>• 最大空载起动频率： 在不加负载的情况下， 能够直接起动的最大频率。<br>• 最大空载的运行频率： 电机不带负载的最高转速频率。<br>• 运行转矩特性： 电机的动态力矩取决于电机运行时的平均电流（而非静态电流） ， 平均电流越大， 电机输出力矩越大， 即电机的频率特性越硬。<br>• 电机正反转控制： 通过改变通电顺序而改变电机的正反转。</p>
<h4 id="28BYJ-48-步进电机简介"><a href="#28BYJ-48-步进电机简介" class="headerlink" title="28BYJ-48 步进电机简介"></a>28BYJ-48 步进电机简介</h4><p>28BYJ48 步进电机自带减速器， 为四相五线步进电机， 直径为 28mm， 实物如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173848598.png" alt="image-20230616173848598"></p>
<p>28BYJ48 电机内部结构等效图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173855516.png" alt="image-20230616173855516"></p>
<p>28BYJ48 步进电机旋转驱动方式如下表  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173905222.png" alt="image-20230616173905222"></p>
<p>28BYJ48 步进电机主要参数如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173915259.png" alt="image-20230616173915259"></p>
<p>在上图中 28BYJ48 步进电机主要参数中可以看到有一个减速比： 1:64， 步进角为 5.625/64 度， 如果需要转动一圈， 那么需要 360/5.625*64=4096 个脉冲信号。</p>
<p>减速比这个和之前介绍的直流减速电机有点类似， 所以 28BYJ48 步进电机实际上是： 减速齿轮+步进电机组成， 28BYJ48 步进电机减速齿轮实物图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173954265.png" alt="image-20230616173954265"></p>
<p>减速齿轮计算方法如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616174000811.png" alt="image-20230616174000811"></p>
<h4 id="硬件设计-9"><a href="#硬件设计-9" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 步进电机驱动模块<br>（2） 28BYJ-48 步进电机<br>该电路在前面直流电机实验中已介绍， 此处不再重复。</p>
<h4 id="软件设计-9"><a href="#软件设计-9" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过 ULN2003 驱动模块控制 28BYJ48 步进电机运行方向及速度， 当按下 KEY1 键可调节电机旋转方向； 当按下 KEY2 键， 电机加速；  当按下 KEY3 键， 电机减速。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 步进电机实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后，当按下 KEY1 键可调节电机旋转方向；当按下KEY2键，电机           加速；当按下 KEY3 键， 电机减速</span></span><br><span class="line"><span class="comment">注意事项： 将步进电机红色线对接到“步进电机模块” 输出端子 J47 的 5V 上， 其          它相序依次接入。</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 ULN2003 控制步进电机管脚</span></span><br><span class="line">    sbit IN1_A=P1^<span class="number">0</span>;</span><br><span class="line">    sbit IN2_B=P1^<span class="number">1</span>;</span><br><span class="line">    sbit IN3_C=P1^<span class="number">2</span>;</span><br><span class="line">    sbit IN4_D=P1^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="comment">// 定义步进电机速度， 值越小， 速度越快</span></span><br><span class="line"><span class="comment">// 最小不能小于 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MAXSPEED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MINSPEED 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">oid <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : step_motor_28BYJ48_send_pulse</span></span><br><span class="line"><span class="comment">* 函数功能 : 输出一个数据给 ULN2003 从而实现向步进电机发送一个脉冲</span></span><br><span class="line"><span class="comment">* 输 入 : step： 指定步进序号， 可选值 0~7</span></span><br><span class="line"><span class="comment">         dir： 方向选择,1： 顺时针,0： 逆时针</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">step_motor_28BYJ48_send_pulse</span><span class="params">(u8 step,u8 dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp=step;</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="number">0</span>) <span class="comment">//如果为逆时针旋转</span></span><br><span class="line">    temp=<span class="number">7</span>-step;<span class="comment">//调换节拍信号</span></span><br><span class="line">    <span class="keyword">switch</span>(temp)<span class="comment">//8 个节拍控制： A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :	   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"></span><br><span class="line"> u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    	&#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    		&#123;</span><br><span class="line">   				key=<span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  u8 key=<span class="number">0</span>;</span><br><span class="line">  u8 dir=<span class="number">0</span>;<span class="comment">//默认逆时针方向</span></span><br><span class="line">  u8 speed=STEPMOTOR_MAXSPEED;<span class="comment">//默认最大速度旋转</span></span><br><span class="line">  u8 step=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    key=key_scan(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//换向</span></span><br><span class="line">    &#123;</span><br><span class="line">    	dir=!dir;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==KEY2_PRESS)<span class="comment">//加速</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(speed&gt;STEPMOTOR_MAXSPEED)</span><br><span class="line">        speed-=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==KEY3_PRESS)<span class="comment">//减速</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(speed&lt;STEPMOTOR_MINSPEED)</span><br><span class="line">        speed+=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">     	step_motor_28BYJ48_send_pulse(step++,dir);</span><br><span class="line">		<span class="keyword">if</span>(step==<span class="number">8</span>)step=<span class="number">0</span>;</span><br><span class="line">		delay_ms(speed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step_motor_28BYJ48_send_pulse 函数用于输出一个数据给 ULN2003， 从而实现向步进电机发送一个脉冲信号。 它有两个形参， 第一个为 step， 指定步进序号， 可选值为 0-7， 代表步进电机控制信号的 8 个节拍。 第二个为 dir， 指定电机的旋转方向， 可选 1:顺时针， 0:逆时针。 这里指的顺时针逆时针是两个不同方向。  </p>
<p>函数先判断 dir 参数值， 如果为 0， 则为逆时针旋转， 将 step 值变为 8 的互补数， 其实就是将 8 个节拍反向输出  </p>
<p>主函数实现的功能很简单， 首先定义一些变量， 进入循环， 检测是否有按键按下， 当 KEY1 按下， 切换步进电机方向； 当 KEY2 按下， 使电机加速； 当 KEY3按下， 使电机减速。  </p>
<p>程序中所用 STEPMOTOR_MAXSPEED 和 STEPMOTOR_MINSPEED 在开头已定义， 表示步进电机最大运行速度和最低运行速度， 当然可以根据实际现象适当调整这两个值。  </p>
<h4 id="实验现象-5"><a href="#实验现象-5" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 KEY1 键可调节电机旋转方向； 当按下 KEY2 键， 电机加速； 当按下 KEY3 键， 电机减速。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616175032529.png" alt="image-20230616175032529"></p>
<p>注意： 将步进电机红色线对接到“步进电机模块” 输出端子 J47 的 5V 上，其它相序依次接入。 如下所示  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616175041386.png" alt="image-20230616175041386"></p>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>在前面章节， 我们通过介绍 51 单片机 IO 口学习了很多相关的实验。 从最简单的 LED 到数码管动态扫描再到 LED 点阵以及电机控制， 无不体现学习 51 单片机 IO 口操作的重要性。 在前面章节， 我们还提到了学习 51 单片机的重点及难点主要有中断、 定时器、 串口等内容， 这部分内容大家一定要认真掌握， 这部分没有学好就不能说学会了51单片机。因此专门用一章来介绍51单片机的中断系统，为后面学习外部中断、 定时器中断、 串口中断做好铺垫。   </p>
<h4 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h4><p>中断概念</p>
<p>中断是为使单片机具有对外部或内部随机发生的事件实时处理而设置的，中断功能的存在， 很大程度上提高了单片机处理外部或内部事件的能力。 它也是单片机最重要的功能之一， 是我们学习单片机必须要掌握的。 很多初学者被困在中断中， 学了很久仍然不知道中断究竟是如何运作的。 千万不要认为它有多难，其实只要掌握正确的学习方法， 没有哪个知识点是学不会的。  </p>
<p>为了能让大家更容易理解中断概念， 我们先来举一个生活事例： 你打开火，烧上一壶水。 然后去洗衣服， 在洗衣服的过程中， 突然听到水壶发出水开的报警声， 这时， 你停止洗衣服动作， 立即去关掉火， 然后将开水灌入暖水瓶中， 灌完开水后， 你又回去继续洗衣服。 这个过程中实际上就发生了一次中断。  </p>
<p>对于单片机来讲， 中断是指 CPU 在处理某一事件 A 时， 发生了另一事件 B，请求 CPU 迅速去处理(中断发生)； CPU 暂时停止当前的工作(中断响应)， 转去处理事件 B(中断服务)； 待 CPU 将事件 B 处理完毕后， 再回到原来事件 A 被中断的地方继续处理事件 A(中断返回)， 这一过程称为中断。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617095939575.png" alt="image-20230617095939575"></p>
<p>再回来看前面讲的生活事例， 与单片机中断结合分析， 你的主任务是洗衣服，水开报警这是一个中断请求， 这一时刻相当于断点处， 你响应中断去关火， 然后将开水灌入暖水瓶中， 这一动作实际上就是处理中断程序， 灌完开水后再回去继续洗衣服， 相当于处理完中断程序后再返回主程序继续执行主程序。 这里需要注意的是， 水开是随时都有可能的， 但是无论什么时候开， 只要一开你将立即去处理它， 处理完后再回来继续接着洗刚才那件衣服。 单片机在执行程序时， 中断也随时有可能发生， 但无论何时发生， 只要一旦发生， 单片机将立即暂停当前程序，赶去处理中断程序， 处理完中断程序后再返回刚才暂停处接着执行原来的程序。  </p>
<p>单片机在执行程序时其程序流程图如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100002769.png" alt="image-20230617100002769"></p>
<p>引起 CPU 中断的根源称为中断源。 中断源向 CPU 提出中断请求， CPU 暂时中断原来的事务 A， 转去处理事件 B， 对事件 B 处理完毕后， 再回到原来被中断的地方(即断点)， 称为中断返回。 实现上述中断功能的部件称为中断系统(中断机构)。  </p>
<p>当中央处理机 CPU 正在处理某件事的时候外界发生了紧急事件请求， 要求CPU 暂停当前的工作， 转而去处理这个紧急事件， 处理完以后， 再回到原来被中断的地方， 继续原来的工作， 这样的过程称为中断。 实现这种功能的部件称为中断系统， 请示 CPU 中断的请求源称为中断源。 微型机的中断系统一般允许多个中断源， 当几个中断源同时向 CPU 请求中断， 要求为它服务的时候， 这就存在CPU 优先响应哪一个中断源请求的问题。 通常根据中断源的轻重缓急排队， 优先处理最紧急事件的中断请求源， 即规定每一个中断源有一个优先级别。 CPU 总是先响应优先级别最高的中断请求。  </p>
<p>当 CPU 正在处理一个中断源请求的时候(执行相应的中断服务程序)， 发生了另外一个优先级比它还高的中断源请求。 如果 CPU 能够暂停对原来中断源的服务程序， 转而去处理优先级更高的中断请求源， 处理完以后， 再回到原低级中断服务程序， 这样的过程称为中断嵌套。 这样的中断系统称为多级中断系统， 没有中断嵌套功能的中断系统称为单级中断系统。  </p>
<p>中断的开启与关闭、 设置启用哪一个中断等都是由单片机内部的一些特殊功能寄存器来决定的， 在前面章节的学习中我们仅对单片机 IO 口操作过（实际上操作 IO 口即操作 IO 口寄存器， 只不过编译器已经帮我们把 IO 口寄存器封装好直接操作 IO 即可， 这些可在 51 单片机头文件内查看） ， 从本章开始就会介绍单片机内部更多的特殊功能寄存器以及如何配置它实现相应的功能。  </p>
<p>随着计算机技术的应用， 人们发现中断技术不仅解决了快速主机与慢速 I/O设备的数据传送问题， 而且还具有如下优点：  </p>
<p>①分时操作。 CPU 可以分时为多个 I/O 设备服务， 提高了计算机的利用率；<br>②实时响应。 CPU 能够及时处理应用系统的随机事件， 系统的实时性大大增强；<br>③可靠性高。 CPU 具有处理设备故障及掉电等突发性事件能力， 从而使系统可靠性提高。</p>
<h4 id="中断结构及相关寄存器"><a href="#中断结构及相关寄存器" class="headerlink" title="中断结构及相关寄存器"></a>中断结构及相关寄存器</h4><p>中断结构</p>
<p>STC89C5X 系列单片机提供了 8 个中断请求源， 它们分别是： 外部中断O(INTO)、 外部中断 1(INT1)、 外部中断 2(INT2)、 外部中断 3(INT3)、 定时器 0中断、 定时器 1 中断、 定时器 2 中断、 串口(UART)中断。 （==注意： 51 系列单片机一定有基本的 5 个中断， 但不全有 8 个中断， 需要查看芯片手册， 通常我们使用的都是基本的 5 个中断： INT0、 INT1、 定时器 0/1， 串口中断== ）。有的中断都具有四个中断优先级（基本型只有两个） 。 用户可以用关总中断允许位(EA/IE.7)或相应中断的允许位来屏蔽所有的中断请求， 也可以用打开相应的中断允许位来使 CPU 响应相应的中断申请。 其中有些中断源可以用软件独立地控制为开中断或关中断状态。 每一个中断的优先级别均可用软件设置。 高优先级的中断请求可以打断低优先级的中断， 反之， 低优先级的中断请求不可以打断高优先级及同优先级的中断。 当两个相同优先级的中断同时产生时， 将由查询次序来决定系统先响应哪个中断。 STC89C5X 系列单片机的各个中断查询次序表如下图所示    </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100533990.png" alt="image-20230617100533990"></p>
<p>通过设置新增加的特殊功能寄存器 IPH 中的相应位， 可将中断优先级设为四级， 如果只设置 IP 或 XICON， 那么中断优先级就只有两级， 与传统 8051 单片机两级中断优先级完全兼容。 上图中的中断查询次序即为中断号， 这个中断号在编程时非常重要， 当中断来临时， 只有中断号正确才能进入中断。  </p>
<p>下面我们以 51 单片机均有的 5 个中断来介绍， 其内部结构框图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100552185.png" alt="image-20230617100552185"></p>
<p>①INT0 对应的是 P3.2 口的附加功能， 可由 IT0(TCON.0)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.2 引脚上出现有效的中断信号时， 中断标志 IE0(TCON.1)置 1， 向 CPU 申请中断。</p>
<p>②INT1 对应的是 P3.3 口的附加功能， 可由 IT1(TCON.2)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.3 引脚上出现有效的中断信号时， 中断标志 IE1(TCON.3)置 1,向 CPU 申请中断。</p>
<p>③T0 对应的是 P3.4 口的附加功能， TF0（TCON.5） ,片内定时/计数器 T0 溢出中断请求标志。 当定时/计数器 T0 发生溢出时， 置位 TF0， 并向 CPU 申请中断。</p>
<p>④T1 对应的是 P3.5 口的附加功能， TF1（ TCON.7） ， 片内定时/计数器 T1溢出中断请求标志。 当定时/计数器 T1 发生溢出时， 置位 TF1， 并向 CPU 申请中断。</p>
<p>⑤RXD 和 TXD 对应的是 P3.0 和 P3.1 口的附加功能， RI（ SCON.0） 或 TI （SCON.1） ， 串行口中断请求标志。 当串行口接收完一帧串行数据时置位 RI 或当串行口发送完一帧串行数据时置位 TI， 向 CPU 申请中断。</p>
<h4 id="中断相关寄存器"><a href="#中断相关寄存器" class="headerlink" title="中断相关寄存器"></a>中断相关寄存器</h4><p>（1） 中断允许控制</p>
<p>CPU 对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE 控制的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100713162.png" alt="image-20230617100713162"></p>
<p>EX0(IE.0)， 外部中断 0 允许位；<br>ET0(IE.1)， 定时/计数器 T0 中断允许位；<br>EX1(IE.2)， 外部中断 0 允许位；<br>ET1(IE.3)， 定时/计数器 T1 中断允许位；<br>ES（IE.4)， 串行口中断允许位；<br>EA (IE.7)， CPU 中断允许（总允许） 位。</p>
<p>（2） 中断请求标志 TCON  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100729112.png" alt="image-20230617100729112"></p>
<p>IT0（TCON.0） ， 外部中断 0 触发方式控制位。<br>当 IT0=0 时， 为电平触发方式。<br>当 IT0=1 时， 为边沿触发方式（下降沿有效） 。<br>IE0（TCON.1） ， 外部中断 0 中断请求标志位。<br>IT1（TCON.2） ， 外部中断 1 触发方式控制位。<br>IE1（TCON.3） ， 外部中断 1 中断请求标志位。<br>TF0（TCON.5） ， 定时/计数器 T0 溢出中断请求标志位。<br>TF1（TCON.7） ， 定时/计数器 T1 溢出中断请求标志位。</p>
<p>（3） 中断优先级  </p>
<p>同一优先级中的中断申请不止一个时， 则有中断优先权排队问题。 同一优先级的中断优先权排队， 由中断系统硬件确定的自然优先级形成， 其排列如所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100752646.png" alt="image-20230617100752646"></p>
<p>（4） 中断号  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100812169.png" alt="image-20230617100812169"></p>
<p>（5） 中断响应条件  </p>
<p>①中断源有中断请求；<br>②此中断源的中断允许位为 1；<br>③CPU 开中断（即 EA=1） 。<br>以上三条同时满足时， CPU 才有可能响应中断。 在使用中断时我们需要做什<br>么呢？<br>①你想使用的中断是哪个？ 选择相应的中断号；<br>②你所希望的触发条件是什么？<br>③你希望在中断之后干什么？<br>我们以外部中断 0 为例， 如下：<br>主程序中需要有以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>； <span class="comment">//打开总中断开关</span></span><br><span class="line">EX0=<span class="number">1</span>； <span class="comment">//开外部中断 0</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>； <span class="comment">//设置外部中断的触发方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> int0() interrupt <span class="number">0</span> using <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//编写用户所需的功能代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中断函数中 int0 是函数名， 可自定义， 但必须符合 C 语言标识符定义规则， interrupt 是一个关键字， 表示 51 单片机中断。 后面的“0” 是中断号， 外部中断 0 中断号为 0， 这个可参考前面的内容。 后面的 using 1 可省略不写。  </p>
<p>至此我们就把 51 单片机的中断简单介绍完， 如果大家还有不明白的可先暂时放下， 先通过实验掌握 51 单片机中断的使用方法， 对于理论方面的知识后续可以深入研究。  </p>
<h3 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h3><p>上一章我们介绍了 51 单片机的中断系统， 这一章就来学习 51 单片机的外部中断， 通过上一章的介绍我们知道， 51 单片机外部中断有 2 个， 外部中断 0 和外部中断 1， 它们的使用方法是一样的， 所以只要学会一个即可掌握所有外部中断使用。 本章所要实现的功能是： 使用独立按键 K3 控制 LED 亮灭， K3 连接外部中断 0（P3.2） 管脚。 学习本章可以参考前面的实验章节内容。   </p>
<h4 id="外部中断介绍"><a href="#外部中断介绍" class="headerlink" title="外部中断介绍"></a>外部中断介绍</h4><p>上一章我们介绍了 51 单片机的中断系统， 我们再回顾一下 51 单片机的中断。当中央处理机 CPU 正在处理某件事的时候外界发生了紧急事件请求， 要求CPU 暂停当前的工作， 转而去处理这个紧急事件， 处理完以后， 再回到原来被中断的地方， 继续原来的工作， 这样的过程称为中断。 实现这种功能的部件称为中断系统， 请示 CPU 中断的请求源称为中断源。 微型机的中断系统一般允许多个中断源， 当几个中断源同时向 CPU 请求中断， 要求为它服务的时候， 这就存在CPU 优先响应哪一个中断源请求的问题。 通常根据中断源的轻重缓急排队， 优先处理最紧急事件的中断请求源， 即规定每一个中断源有一个优先级别。 CPU 总是先响应优先级别最高的中断请求。 中断示意图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101128577.png" alt="image-20230617101128577"></p>
<p>STC89C5X 系列单片机提供了 4 个外部中断： 外部中断 O(INTO)、 外部中断1(INT1)、 外部中断 2(INT2)、 外部中断 3(INT3)。 （注意： ==51 系列单片机一定有基本的 2 个外部中断， 但不全有 4 个中断， 需要查看芯片手册， 通常我们都是使用基本的 2 个外部中断： INT0 和 INT1==） 。  </p>
<p>下面我们来看下外部中断结构图， 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101151647.png" alt="image-20230617101151647"></p>
<p>图中 INT0 和 INT1 即为外部中断 0 和外部中断 1 输入口。<br>①INT0 对应的是 P3.2 口的附加功能， 可由 IT0(TCON.0)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.2 引脚上出现有效的中断信号时， 中断标IE0(TCON.1)置 1， 向 CPU 申请中断。  </p>
<p>②INT1 对应的是 P3.3 口的附加功能， 可由 IT1(TCON.2)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.3 引脚上出现有效的中断信号时， 中断标IE1(TCON.3)置 1,向 CPU 申请中断。  </p>
<p>（1） 中断允许控制  </p>
<p>CPU 对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE 控制的。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101236422.png" alt="image-20230617101236422"></p>
<p>EX0(IE.0)， 外部中断 0 允许位；<br>ET0(IE.1)， 定时/计数器 T0 中断允许位；<br>EX1(IE.2)， 外部中断 0 允许位；<br>ET1(IE.3)， 定时/计数器 T1 中断允许位；<br>ES（IE.4)， 串行口中断允许位；<br>EA (IE.7)， CPU 中断允许（总允许） 位。</p>
<p>（2） 中断请求标志 TCON  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101250459.png" alt="image-20230617101250459"></p>
<p>IT0（TCON.0） ， 外部中断 0 触发方式控制位。<br>当 IT0=0 时， 为电平触发方式。<br>当 IT0=1 时， 为边沿触发方式（下降沿有效） 。<br>IE0（TCON.1） ， 外部中断 0 中断请求标志位。<br>IT1（TCON.2） ， 外部中断 1 触发方式控制位。<br>IE1（TCON.3） ， 外部中断 1 中断请求标志位。<br>TF0（TCON.5） ， 定时/计数器 T0 溢出中断请求标志位。<br>TF1（TCON.7） ， 定时/计数器 T1 溢出中断请求标志位。</p>
<h4 id="外部中断配置"><a href="#外部中断配置" class="headerlink" title="外部中断配置"></a>外部中断配置</h4><p>我们知道要让 51 单片机发生中断必须要满足以下 3 个条件， 这 3 个条件的顺序可以任意：  </p>
<p>①中断源有中断请求；<br>②此中断源的中断允许位为 1；<br>③CPU 开中断（即 EA=1） </p>
<p>比如我们配置外部中断 0， 对应的配置程序如下  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>； <span class="comment">//打开总中断开关</span></span><br><span class="line">EX0=<span class="number">1</span>； <span class="comment">//开外部中断 0</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>； <span class="comment">//设置外部中断的触发方式</span></span><br></pre></td></tr></table></figure>
<p>如果要配置的是外部中断 1， 只需将 EX0 改为 EX1， IT0 改为 IT1。  </p>
<p>因为独立按键一端是共地的， 当按下后对应单片机 IO 口被拉低， 而默认单片机 IO 口是高电平， 这样就有一个下降沿过程， 所以通常使用外部中断都是配置为下降沿发， 即 IT0=1；  </p>
<p>在编写程序时通常我们会将外部中断的配置放到一个自定义函数内便于管理维护。 如下所示：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>;<span class="comment">//跳变沿触发方式（下降沿）</span></span><br><span class="line">    EX0=<span class="number">1</span>;<span class="comment">//打开 INT0 的中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当触发中断后即会进入中断服务函数， 外部中断 0 中断服务函数如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//执行所需的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中断函数中 exti0 是函数名， 可自定义， 但必须符合 C 语言标识符定义规则， interrupt 是一个关键字， 表示 51 单片机中断。 后面的“0” 是中断号， 外部中断 0 中断号为 0， 如果是外部中断 1， 则中断号为 2， 这个可参考中断章节的内容。  </p>
<h4 id="硬件设计-10"><a href="#硬件设计-10" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 独立按键模块（K3）<br>（2） LED 模块（D1）<br>LED 模块和独立按键模块电路在前面章节已介绍过， 这里就不多说。 原理图中 K3 键是连接在单片机 P3.2 口（外部中断 0） ， K4 按键是连接在 P3.3 口（外部中断 1）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617102452834.png" alt="image-20230617102452834"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617102456878.png" alt="image-20230617102456878"></p>
<h4 id="软件设计-10"><a href="#软件设计-10" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 使用独立按键 K3 控制 LED 亮灭。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 外部中断 0 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当按下 K3 键可控制 D1 指示灯亮灭</span></span><br><span class="line"><span class="comment">注意事项： 将红外接收传感器取下， 防止对 P3.2 口干扰</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 LED1 管脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义独立按键 K3 控制脚</span></span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : exti0_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 外部中断 0 配置函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>;<span class="comment">//跳变沿触发方式（下降沿）</span></span><br><span class="line">    EX0=<span class="number">1</span>;<span class="comment">//打开 INT0 的中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	exti0_init();<span class="comment">//外部中断 0 配置</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    delay_10us(<span class="number">1000</span>);<span class="comment">//消斗</span></span><br><span class="line">    <span class="keyword">if</span>(KEY3==<span class="number">0</span>)<span class="comment">//再次判断 K3 键是否按下</span></span><br><span class="line">    LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序代码比较简单， 首先定义 K3 键与 LED1 的控制管脚， 然后定义了外部中断 0 配置函数 exti0_init， 该函数内容是按照前面介绍的配置方法实现， 即开启总中断、 外部中断 0 功能， 设置外部中断 0 为下降沿触发。 然后进入 while循环， 在循环体内没有执行任何功能程序。  </p>
<p>有人就会问， 在主函数中怎么没有看到按键对 LED 的控制呢？ 因为我们在exti0_init()函数内就已经把按键管脚配置为外部中断 0 下降沿触发， 当有按键按下， 即会进入对应中断服务函数执行相应的功能程序， LED 的控制就在中断函数内完成的。  </p>
<p>外部中断 1 的使用与外部中断 0 是一样的 ，这里就不再重复。  </p>
<h4 id="实验现象-6"><a href="#实验现象-6" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K3 键， D1 指示灯亮， 再次按下 K3 键， D1 指示灯灭， 如此循环。</p>
<p>如果下载的是外部中断 1 实验程序， 实验现象如下： 当按下 K4 键， D1 指示灯亮， 再次按下 K4 键， D1 指示灯灭， 如此循环</p>
<p>注意： 由于红外接收传感器与 K3 共用 P3.2 口， 因此在做外部中断 0 实验时，将红外接收传感器从开发板取下， 防止干扰。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103336224.png" alt="image-20230617103336224"></p>
<h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>上一章我们介绍了 51 单片机的外部中断， 学习了如何配置 51 单片机的外部中断。 这一章我们来学习 51 单片机的定时器中断。 STC89C5X 含有 3 个定时器：定时器 0、 定时器 1、 定时器 2（注意： ==51 系列单片机一定有基本的 2 个定时器（定时器 0 和定时器 1） ， 但不全有 3 个中断， 需要查看芯片手册， 通常我们使用的是基本的 2 个定时器： 定时器 0/1==） 。 本章以定时器 0 为例进行讲解， 让大家学会 51 单片机定时器的使用， 定时器 1 的使用方法与定时器 0 一样。 本章要实现的功能是： 通过定时器 0 中断控制 D1 指示灯间隔 1 秒闪烁。 学习本章可以参考前面的实验章节内容。  </p>
<h4 id="定时器介绍"><a href="#定时器介绍" class="headerlink" title="定时器介绍"></a>定时器介绍</h4><p>在介绍定时器之前先科普下几个知识：  </p>
<p>1， CPU 时序的有关知识  </p>
<p>①振荡周期： 为单片机提供定时信号的振荡源的周期（晶振周期或外加振荡周期） 。②状态周期： 2 个振荡周期为 1 个状态周期，用 S 表示。振荡周期又称 S 周期或时钟周期。</p>
<p>③机器周期： 1 个机器周期含 6 个状态周期， 12 个振荡周期。</p>
<p>④指令周期： 完成 1 条指令所占用的全部时间， 它以机器周期为单位。例如： 外接晶振为 12MHz 时， 51 单片机相关周期的具体值为：</p>
<p>振荡周期=1/12us;<br>状态周期=1/6us;<br>机器周期=1us;<br>指令周期=1~4us;</p>
<p>2， 学习定时器前需要明白的几点  </p>
<p>①51 单片机有两组定时器/计数器， 因为既可以定时， 又可以计数， 故称之为定时器/计数器。</p>
<p>②定时器/计数器和单片机的 CPU 是相互独立的。 定时器/计数器工作的过程是自动完成的， 不需要 CPU 的参与。</p>
<p>③51 单片机中的定时器/计数器是根据机器内部的时钟或者是外部的脉冲信号对寄存器中的数据加 1。</p>
<p>有了定时器/计数器之后， 可以增加单片机的效率， 一些简单的重复加 1 的工作可以交给定时器/计数器处理。 CPU 转而处理一些复杂的事情。 同时可以实现精确定时作用。</p>
<h5 id="单片机定时器原理"><a href="#单片机定时器原理" class="headerlink" title="单片机定时器原理"></a>单片机定时器原理</h5><p>STC89C5X 单片机内有两个可编程的定时/计数器 T0、 T1 和一个特殊功能定时器 T2。 定时/计数器的实质是加 1 计数器（16 位） ， 由高 8 位和低 8 位两个寄存器 THx 和 TLx 组成。 它随着计数器的输入脉冲进行自加 1， 也就是每来一个脉冲， 计数器就自动加 1， 当加到计数器为全 1 时， 再输入一个脉冲就使计数器回零， 且计数器的溢出使相应的中断标志位置 1， 向 CPU 发出中断请求（定时/计数器中断允许时） 。 如果定时/计数器工作于定时模式， 则表示定时时间已到；如果工作于计数模式， 则表示计数值已满。 可见， 由溢出时计数器的值减去计数初值才是加 1 计数器的计数值。  </p>
<h5 id="单片机定时-计数器结构"><a href="#单片机定时-计数器结构" class="headerlink" title="单片机定时/计数器结构"></a>单片机定时/计数器结构</h5><p>51 单片机定时器/计数器内部结构如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103814517.png" alt="image-20230617103814517"></p>
<p>上图中的 T0 和 T1 引脚对应的是单片机 P3.4 和 P3.5 管脚。 51 单片机定时/计数器的工作由两个特殊功能寄存器控制。 TMOD 是定时/计数器的工作方式寄存器， 确定工作方式和功能； TCON 是控制寄存器， 控制 T0、 T1 的启动和停止及设置溢出标志。  </p>
<p>1， 工作方式寄存器</p>
<p> TMOD工作方式寄存器 TMOD 用于设置定时/计数器的工作方式， 低四位用于 T0， 高四位用于 T1。 其格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103832345.png" alt="image-20230617103832345"></p>
<p>GATE 是门控位, GATE＝0 时， 用于控制定时器的启动是否受外部中断源信号的影响。 只要用软件使 TCON 中的 TR0 或 TR1 为 1， 就可以启动定时/计数器工作； GATA＝1 时， 要用软件使 TR0 或 TR1 为 1， 同时外部中断引脚 INT0/1 也为高电平时， 才能启动定时/计数器工作。 即此时定时器的启动条件， 加上了 INT0/1 引脚为高电平这一条件。  </p>
<p>C/T :定时/计数模式选择位。 C/T ＝0 为定时模式;C/T =1 为计数模式。<br>M1M0： 工作方式设置位。 定时/计数器有四种工作方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103848616.png" alt="image-20230617103848616"></p>
<p>2， 控制寄存器 TCON</p>
<p>TCON 的低 4 位用于控制外部中断,已在前面介绍。 TCON 的高 4 位用于控制定时/计数器的启动和中断申请。 其格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103905583.png" alt="image-20230617103905583"></p>
<p>TF1（TCON.7） ： T1 溢出中断请求标志位。 T1 计数溢出时由硬件自动置 TF1为 1。 CPU 响应中断后 TF1 由硬件自动清 0。 T1 工作时， CPU 可随时查询 TF1 的状态。 所以， TF1 可用作查询测试的标志。 TF1 也可以用软件置 1 或清 0， 同硬件置 1 或清 0 的效果一样。  </p>
<p>TR1（TCON.6） ： T1 运行控制位。 TR1 置 1 时， T1 开始工作； TR1 置 0 时， T1 停止工作。 TR1 由软件置 1 或清 0。 所以， 用软件可控制定时/计数器的启动与停止。  </p>
<p>TF0（TCON.5） ： T0 溢出中断请求标志位， 其功能与 TF1 类同。<br>TR0（TCON.4） ： T0 运行控制位， 其功能与 TR1 类同。</p>
<h5 id="单片机定时-计数器的工作方式"><a href="#单片机定时-计数器的工作方式" class="headerlink" title="单片机定时/计数器的工作方式"></a>单片机定时/计数器的工作方式</h5><p>1， 方式 0</p>
<p>方式 0 为 13 位计数， 由 TL0 的低 5 位（高 3 位未用） 和 TH0 的 8 位组成。TL0 的低 5 位溢出时向 TH0 进位， TH0 溢出时， 置位 TCON 中的 TF0 标志， 向 CPU发出中断请求。 其结构图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104020088.png" alt="image-20230617104020088"></p>
<p>门控位 GATE 具有特殊的作用。当 GATE=0 时，经反相后使或门输出为 1，此时仅由 TR0 控制与门的开启，与门输出 1 时，控制开关接通，计数开始；当 GATE=1时，由外中断引脚信号控制或门的输出，此时控制与门的开启由外中断引脚信号和 TR0 共同控制。当 TR0=1 时，外中断引脚信号引脚的高电平启动计数， 外中断引脚信号引脚的低电平停止计数。这种方式常用来测量外中断引脚上正脉冲的宽度。 计数模式时， 计数脉冲是 T0 引脚上的外部脉冲。计数初值与计数个数的关系为：X=213-N。</p>
<p>2， 方式 1</p>
<p>方式 1 的计数位数是 16 位， 由 TL0 作为低 8 位， TH0 作为高 8 位， 组成了16 位加 1 计数器。 其结构图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104116590.png" alt="image-20230617104116590"></p>
<p>计数初值与计数个数的关系为： X=216-N。  </p>
<p>3， 方式 2  </p>
<p>方式 2 为自动重装初值的 8 位计数方式。 工作方式 2 特别适合于用作较精确的脉冲信号发生器。 其结构图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104132606.png" alt="image-20230617104132606"></p>
<p>计数初值与计数个数的关系为： X=28-N。  </p>
<p>4， 方式 3  </p>
<p>方式 3 只适用于定时/计数器 T0， 定时器 T1 处于方式 3 时相当于 TR1=0，停止计数。 工作方式 3 将 T0 分成为两个独立的 8 位计数器 TL0 和 TH0。 其结构如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104148487.png" alt="image-20230617104148487"></p>
<p>这几种工作方式中应用较多的是方式 1 和方式 2。 定时器中通常使用定时器方式 1， 串口通信中通常使用方式 2。  </p>
<h4 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h4><p>在使用定时器时， 应该如何配置使其工作？ 其步骤如下（ 各步骤顺序可任意） ：</p>
<p>①对 TMOD 赋值， 以确定 T0 和 T1 的工作方式， 如果使用定时器 0 即对 T0 配置， 如果使用定时器 1 即对 T1 配置。</p>
<p>②根据所要定时的时间计算初值,并将其写入 TH0、 TL0 或 TH1、 TL1。<br>③如果使用中断， 则对 EA 赋值， 开放定时器中断。<br>④使 TR0 或 TR1 置位， 启动定时/计数器定时或计数。</p>
<p>上述中有一个定时/计数器初值的计算， 下面我们来看下如何计算定时/计数器初值。  </p>
<p>前面我们介绍过机器周期的概念， 它是 CPU 完成一个基本操作所需要的时间。其计算公式是： 机器周期=1/单片机的时钟频率。 51 单片机内部时钟频率是外部时钟的 12 分频， 也就是说当外部晶振的频率输入到单片机里面的时候要进行 12分频。 比如说你用的是 12MHZ 晶振， 那么单片机内部的时钟频率就是 12/12MHZ，当你使用 12MHZ 的外部晶振的时候， 机器周期=1/1M=1us。 如果我们想定时 1ms的初值是多少呢？ 1ms/1us=1000。 也就是要计数 1000 个， 初值=65535-1000+1 （ 因为实际上计数器计数到 65536（ 2 的 16 次方） 才溢出， 所以后面要加 1） =64536=FC18H， 所以初值即为 THx=0XFC， TLx=0X18。  </p>
<p>知道了如何计算定时/计数器初值， 那么想定时多长时间都可以计算出， 当然由于定时计数器位数有限， 我们不可能直接通过初值定时很长时间， 如果要实现很长时间的定时， 比如定时 1 秒钟。 可以通过初值设置定时 1ms， 每当定时 1ms结束后又重新赋初值， 并且设定一个全局变量累计定时 1ms 的次数， 当累计到1000 次， 表示已经定时 1 秒了。 需要其他定时时间类似操作， 这样我们就可以使用定时器来实现精确延时来替代之前的 delay 函数。  </p>
<p>这里以定时器 0 为例介绍配置定时器工作方式 1、 设定 1ms 初值， 开启定时器计数功能以及总中断， 如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD|=<span class="number">0X01</span>;<span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">TL0=<span class="number">0X18</span>;</span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于定时器 1 的使用方法是一样的， 只是将上述的 0 变为 1 即可， 具体可参考我们定时器 1 实验例程。  </p>
<h4 id="硬件设计-11"><a href="#硬件设计-11" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） LED 模块（D1）<br>（2） 定时器 0</p>
<p>本章硬件电路非常简单， 只使用到开发板上 LED 模块的 D1， 至于定时器 0它属于 51 单片机内部资源， 只需通过软件配置即可使用。 开发板上 LED 模块电路在前面已经介绍， 这里就不多说。  </p>
<h4 id="软件设计-11"><a href="#软件设计-11" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过定时器 0 中断控制 D1 指示灯间隔 1 秒闪烁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 定时器 0 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当按下 D1 指示灯间隔 1s 闪烁</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 LED1 管脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : time0_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 定时器 0 中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X01</span>;<span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">    TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">    TL0=<span class="number">0X18</span>;</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time0_init();<span class="comment">//定时器 0 中断配置</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1 <span class="comment">//定时器 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> u16 i;<span class="comment">//定义静态变量 i</span></span><br><span class="line">     TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">     TL0=<span class="number">0X18</span>;</span><br><span class="line">     i++;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       i=<span class="number">0</span>;</span><br><span class="line">       LED1=!LED1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实验代码非常简单， 首先定义 LED1 指示灯控制管脚， 然后定义定时器 0 中断配置函数 time0_init， 该函数配置内容就是按照前面介绍的配置方法所写，即选择定时器工作模式 0、 工作方式 1、 设置定时 1ms 初值、 打开定时器计数功能和开启总中断功能。 然后进入 while 循环， 在循环体内没有执行任何功能程序。当定时时间到达即会进入定时器 0 中断， 在中断服务函数内， 重新赋初值准备下次计数， 并且定义一个静态变量来累计定时 1ms 次数， 当变量等于 1000 时， 表示定时时间达 1 秒， 然后清零变量以及控制 LED 状态翻转。 执行完成后退出中断返回主函数， 当时间到达又进入中断， 如此循环  </p>
<p><code>为什么要使用关键字 static 将 i 定义为静态变量呢？ 我们希望每次进入中断函数时， i 保存的是上次累加值， 使用了 static 关键字， 就可以让变量 i 实现这种功能， 即不会每次进入中断函数后被初始化为 0。 假如去掉 static 关键字， 那么变量 i 就是一个局部变量， 每次进入中断函数后， 变量 i 初始值都是 0，也就是说它的值永远也不会递增到 1000， 从而实现不了 1s 定时。 可以这样理解，使用了 static 关键字就相当于将 i 变成了一个全局变量功能</code></p>
<p>对于定时器 1 的使用方法是一样的， 只是将上述的 0 变为 1 即可， 具体可参考我们定时器 1 实验例程。  </p>
<h4 id="实验现象-7"><a href="#实验现象-7" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当 D1 指示灯间隔 1s闪烁。  </p>
<p>注意： 实验中我们是以 12M 晶振为例讲解初值的计算， 假如外部晶振为11.0592M， 那么使用前面的计算公式可能就比较繁琐， 这里给大家推荐一个非常好用的小工具“\5—开发工具\4-常用辅助开发软件\51 定时器计算.exe” ， 打开小工具， 选择好定时器工作方式、 晶振频率、 定时时长即可得出 TH 和 TL 的初值。 假如现在使用的晶振是 11.0592M， 使用定时器方式 1， 定时时间为 1ms， 设置界面如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617105403054.png" alt="image-20230617105403054"></p>
<p>定时器初值为 TH0=0XFC， TL0=0X66。 该值与前面 12M 晶振得到的初值是有差别的， 这也就是很多同学咨询为什么开发板上定时器工作慢或者快的原因， 一定要注意开发板上使用的外部晶振大小， 晶振大小不同， 换算的初值是不一样的。  </p>
<h3 id="串口通信实验"><a href="#串口通信实验" class="headerlink" title="串口通信实验"></a>串口通信实验</h3><h4 id="通信的基本概念"><a href="#通信的基本概念" class="headerlink" title="通信的基本概念"></a>通信的基本概念</h4><p>我们知道 51 单片机不仅可以实现串口通信， 还可以通过 IO 口模拟实现多种其他通信， 比如 SPI、 IIC 等， 学习这些通信前， 我们很有必要了解下通信的基本概念。 通信的方式可以分为多种， 按照数据传送方式可分为串行通信和并行通信。 按照通信的数据同步方式， 可分为异同通信和同步通信。 按照数据的传输方向又可分为单工、 半双工和全双工通信。 下面我们就来简单介绍这几种通信方式。  </p>
<h5 id="串行通信与并行通信"><a href="#串行通信与并行通信" class="headerlink" title="串行通信与并行通信"></a>串行通信与并行通信</h5><p>（1） 串行通信</p>
<p>串行通信是指使用一条数据线， 将数据一位一位地依次传输， 每一位数据占据一个固定的时间长度。 其只需要少数几条线就可以在系统间交换信息， 特别适用于计算机与计算机、 计算机与外设之间的远距离通信。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210128564.png" alt="image-20230617210128564"></p>
<p>串行通信的特点： 传输线少， 长距离传送时成本低， 且可以利用电话网等现成的设备， 但数据的传送控制比并行通信复杂。  </p>
<p>（2） 并行通信</p>
<p>并行通信通常是将数据字节的各位用多条数据线同时进行传送， 通常是 8位、 16 位、 32 位等数据一起传输。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210153647.png" alt="image-20230617210153647"></p>
<p>并行通信的特点： 控制简单、 传输速度快； 由于传输线较多， 长距离传送时成本高且接收方的各位同时接收存在困难， 抗干扰能力差。  </p>
<h5 id="异步通信与同步通信"><a href="#异步通信与同步通信" class="headerlink" title="异步通信与同步通信"></a>异步通信与同步通信</h5><p>1） 异步通信</p>
<p>异步通信是指通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程。 为使双方的收发协调， 要求发送和接收设备的时钟尽可能一致。</p>
<p>异步通信是以字符（构成的帧） 为单位进行传输， 字符与字符之间的间隙（时间间隔） 是任意的， 但每个字符中的各位是以固定的时间传送的， 即字符之间不一定有“位间隔” 的整数倍的关系， 但同一字符内的各位之间的距离均为“ 位间隔” 的整数倍。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210350742.png" alt="image-20230617210350742"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210353671.png" alt="image-20230617210353671"></p>
<p>异步通信的特点： 不要求收发双方时钟的严格一致， 实现容易， 设备开销较小， 但每个字符要附加 2～3 位用于起止位， 各帧之间还有间隔， 因此传输效率不高。  </p>
<p>（2） 同步通信  </p>
<p>同步通信时要建立发送方时钟对接收方时钟的直接控制， 使双方达到完全同步。 此时， 传输数据的位之间的距离均为“位间隔” 的整数倍， 同时传送的字符间不留间隙， 即保持位同步关系， 也保持字符同步关系。 发送方对接收方的同步可以通过两种方法实现。 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210501026.png" alt="image-20230617210501026"></p>
<h5 id="单工、半双工与全双工"><a href="#单工、半双工与全双工" class="headerlink" title="单工、半双工与全双工"></a>单工、半双工与全双工</h5><p>（1） 单工通信</p>
<p>单工是指数据传输仅能沿一个方向， 不能实现反向传输。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210539846.png" alt="image-20230617210539846"></p>
<p>（2） 半双工通信</p>
<p>半双工是指数据传输可以沿两个方向， 但需要分时进行。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210623643.png" alt="image-20230617210623643"></p>
<p>（3） 全双工通信全双工是指数据可以同时进行双向传输。 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210646678.png" alt="image-20230617210646678"></p>
<h5 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h5><p>衡量通信性能的一个非常重要的参数就是通信速率， 通常以比特率(Bitrate)  来表示。 比特率是每秒钟传输二进制代码的位数， 单位是： 位／ 秒（ bps） 。 如每秒钟传送 240 个字符， 而每个字符格式包含 10 位(1 个起始位、 1 个停止位、8 个数据位)， 这时的比特率为：  </p>
<p>​                            10 位× 240 个/秒 = 2400 bps  </p>
<p>在后面会遇到一个“波特率” 的概念， 它表示每秒钟传输了多少个码元。 而码元是通信信号调制的概念， 通信中常用时间间隔相同的符号来表示一个二进制数字， 这样的信号称为码元。 如常见的通信传输中， 用 0V 表示数字 0， 5V 表示数字 1， 那么一个码元可以表示两种状态 0 和 1， 所以一个码元等于一个二进制比特位， 此时波特率的大小与比特率一致； 如果在通信传输中， 有 0V、 2V、4V 以及 6V 分别表示二进制数 00、 01、 10、 11， 那么每个码元可以表示四种状态， 即两个二进制比特位， 所以码元数是二进制比特位数的一半， 这个时候的波特率为比特率的一半。 由于很多常见的通信中一个码元都是表示两种状态，所以我们常常直接以波特率来表示比特率。  </p>
<h4 id="单片机串口介绍"><a href="#单片机串口介绍" class="headerlink" title="单片机串口介绍"></a>单片机串口介绍</h4><h5 id="串口通信简介"><a href="#串口通信简介" class="headerlink" title="串口通信简介"></a>串口通信简介</h5><p>串口通信(Serial Communication)， 是指外设和计算机间通过数据信号线、地线等按位进行传输数据的一种通信方式， 属于串行通信方式。 串口是一种接口标准， 它规定了接口的电气标准， 没有规定接口插件电缆以及使用的协议。  </p>
<p>(1)接口标准</p>
<p>串口通信的接口标准有很多， 有 RS-232C、 RS-232、 RS-422A、 RS-485 等。常用的是 RS-232 和 RS-485。 RS-232 其实是 RS-232C 的改进， 原理是一样的。这里我们就以 RS-232C 接口进行讲解。  </p>
<p>RS-232C 是 EIA（美国电子工业协会） 1969 年修订 RS-232C 标准。 RS-232C定义了数据终端设备（DTE） 与数据通信设备（DCE） 之间的物理接口标准。  </p>
<p>RS-232C 接口规定使用 25 针连接器， 简称 DB25， 连接器的尺寸及每个插针的排列位置都有明确的定义， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211033056.png" alt="image-20230617211033056"></p>
<p>RS-232C 还有一种 9 针的非标准连接器接口， 简称 DB9。 串口通信使用的大多都是 DB9 接口。 DB25 和 DB9 接头有公头和母头之分， 其中带针状的接头是公头， 而带孔状的接头是母头。 9 针串口线的外观图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211044935.png" alt="image-20230617211044935"></p>
<p>从上图中可以看到公头和母头的管脚定义顺序是不一样， 这一点需要特别注意。 这些管脚都有什么作用呢？ 9 针串口和 25 针串口常用管脚的功能说明如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211435725.png" alt="image-20230617211435725"></p>
<p>在串口通信中， 通常我们只使用 2、 3、 5 三个管脚， 即 TXD、 RXD、 SGND，其他管脚功能大家看不明白也没关系。  </p>
<p>RS-232C 对逻辑电平也做了规定， 如下：<br>在 TXD 和 RXD 数据线上：<br>1.逻辑 1 为-3~-15V 的电压</p>
<p>2.逻辑 0 为 3~15V 的电压<br>在 RTS、 CTS、 DSR、 DTR 和 DCD 等控制线上：<br>1.信号有效（ ON 状态） 为 3~15V 的电压<br>2.信号无效（ OFF 状态） 为-3~-15V 的电压</p>
<p>由此可见， RS-232C 是用正负电压来表示逻辑状态， 与晶体管-晶体管逻辑集成电路（TTL） 以高低电平表示逻辑状态的规定正好相反。 而我们 51 单片机使用的就是 TTL 电平， 所以要实现 51 单片机与计算机的串口通信， 需要进行 TTL与 RS-232C 电平转换， 通常使用的电平转换芯片是 MAX232。  </p>
<p>在串口通信中通常 PC 机的 DB9 为公头， 单片机上使用的串口 DB9 为母头，通过一根直通串口线进行相连。 在 9 针串口线实物图即为直通型串口线， 串口线（COM） 母头连接计算机 DB9 的公头， 串口线公头连接单片机上使用的 DB9 母头， 这样就是将 2、 3、 5 管脚直接相连。 如果你要实现两台计算机串口通信，那么就需要一根交叉串口线， 将 2 对 3、 3 对 2、 5 对 5 连接， 交叉串口线一般两头都是母头。  </p>
<p>串口通信中还需要注意的是， 串口数据收发线要交叉连接， 计算机的 TXD要对应单片机的 RXD， 计算机的 RXD 要对应单片机的 TXD， 并且共 GND， 如下图  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211528273.png" alt="image-20230617211528273"></p>
<p>有的朋友就会问了， 在计算机与单片机进行串口通信时， 使用的不是直通线吗， 这时候怎么让 TXD 与 RXD 交叉连接？ 前面我们说了单片机处理的是 TTL电平， 需要使用 RS232 电平转换芯片， 将 RS232 电平转换芯片串行数据输出管脚交叉连接在 DB9 母头上即可， 本章后面硬件设计部分会介绍。  </p>
<p>（2） 通信协议  </p>
<p>RS232 的通信协议比较简单， 通常遵循 96-N-8-1 格式。</p>
<p>“96” 表示的是通信波特率为 9600。 串口通信中通常使用的是异步串口通信， 即没有时钟线， 所以两个设备要通信， 必须要保持一致的波特率， 当然， 波特率常用值还有 4800、 115200 等。</p>
<p>“N” 表示的是无校验位， 由于串口通信相对更容易受到外部干扰导致传输数据出现偏差， 可以在传输过程加上校验位来解决这个问题。 校验方法有奇校验(odd)、 偶校验(even)、 0 校验(space)、 1 校验(mark)以及无校验(noparity)。具体的介绍， 大家可以百度串口通信了解。  </p>
<p>“8”表示的是数据位数为 8 位， 其数据格式在前面介绍异步通信中已讲过。当然数据位数还可以为 5、 6、 7 位长度。  </p>
<p>“1” 表示的是 1 位停止位， 串口通讯的一个数据包从起始信号开始， 直到停止信号结束。 数据包的起始信号由一个逻辑 0 的数据位表示， 而数据包的停止信号可由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示， 只要双方约定一致即可  </p>
<p>（3） 串口内部结构  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211623164.png" alt="image-20230617211623164"></p>
<p>上图中右边的 TXD 和 RXD 为单片机 IO 口， TXD 对应的是 P3.1 管脚， RXD 对应的是 P3.0 管脚。 其内部工作方式在后面小节会介绍。  </p>
<h5 id="串口相关寄存器"><a href="#串口相关寄存器" class="headerlink" title="串口相关寄存器"></a>串口相关寄存器</h5><p>（1） 串口控制寄存器 SCON  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211703180.png" alt="image-20230617211703180"></p>
<p>SM0 和 SM1 为工作方式选择位：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211710640.png" alt="image-20230617211710640"></p>
<p>SM2： 多机通信控制位， 主要用于方式 2 和方式 3。 当 SM2=1 时可以利用收到的 RB8 来控制是否激活 RI（RB8＝0 时不激活 RI， 收到的信息丢弃； RB8＝1 时收到的数据进入 SBUF， 并激活 RI， 进而在中断服务中将数据从 SBUF 读走） 。 当SM2=0 时， 不论收到的 RB8 为 0 和 1， 均可以使收到的数据进入 SBUF， 并激活 RI （即此时 RB8 不具有控制 RI 激活的功能） 。 通过控制 SM2， 可以实现多机通信。  </p>
<p>REN： 允许串行接收位。 由软件置 REN=1， 则启动串行口接收数据； 若软件置REN=0， 则禁止接收。  </p>
<p>TB8： 在方式 2 或方式 3 中， 是发送数据的第 9 位， 可以用软件规定其作用。可以用作数据的奇偶校验位， 或在多机通信中， 作为地址帧/数据帧的标志位。在方式 0 和方式 1 中， 该位未用到。  </p>
<p>RB8： 在方式 2 或方式 3 中， 是接收到数据的第 9 位， 作为奇偶校验位或地址帧/数据帧的标志位。 在方式 1 时， 若 SM2=0， 则 RB8 是接收到的停止位。  </p>
<p>TI： 发送中断标志位。 在方式 0 时， 当串行发送第 8 位数据结束时， 或在其它方式， 串行发送停止位的开始时， 由内部硬件使 TI 置 1， 向 CPU 发中断申请。在中断服务程序中， 必须用软件将其清 0， 取消此中断申请。  </p>
<p>RI： 接收中断标志位。 在方式 0 时， 当串行接收第 8 位数据结束时， 或在其它方式， 串行接收停止位的中间时， 由内部硬件使 RI 置 1， 向 CPU 发中断申请。也必须在中断服务程序中， 用软件将其清 0， 取消此中断申请。  </p>
<p>（2） 电源控制寄存器 PCON  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211742829.png" alt="image-20230617211742829"></p>
<p>SMOD： 波特率倍增位。 在串口方式 1、 方式 2、 方式 3 时， 波特率与 SMOD 有关， 当 SMOD=1 时， 波特率提高一倍。 复位时， SMOD=0。  </p>
<h4 id="串口工作方式"><a href="#串口工作方式" class="headerlink" title="串口工作方式"></a>串口工作方式</h4><p>前面在介绍寄存器时已经知道了 51 单片机串口的几种工作方式， 下面分别来对它介绍。  </p>
<h5 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h5><p>方式 0 时， 串行口为同步移位寄存器的输入输出方式。 主要用于扩展并行输入或输出口。 数据由 RXD（P3.0） 引脚输入或输出， 同步移位脉冲由 TXD（P3.1）引脚输出。 发送和接收均为 8 位数据， 低位在先， 高位在后。 波特率固定为fosc/12。 对应的输入输出时序图如下所示：  </p>
<p>①方式 0 输出  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211846944.png" alt="image-20230617211846944"></p>
<p>②方式 0 输入  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211900975.png" alt="image-20230617211900975"></p>
<h5 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h5><p>方式 1 是 10 位数据的异步通信口。 TXD 为数据发送引脚， RXD 为数据接收引脚， 传送一帧数据的格式如下所示。 其中 1 位起始位， 8 位数据位， 1 位停止位。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211929371.png" alt="image-20230617211929371"></p>
<p>对应的输入输出时序图如下所示：<br>①方式 1 输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211947725.png" alt="image-20230617211947725"></p>
<p>②方式 1 输入  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211954248.png" alt="image-20230617211954248"></p>
<p>用软件置 REN 为 1 时， 接收器以所选择波特率的 16 倍速率采样 RXD 引脚电平， 检测到 RXD 引脚输入电平发生负跳变时， 则说明起始位有效， 将其移入输入移位寄存器， 并开始接收这一帧信息的其余位。 接收过程中， 数据从输入移位寄存器右边移入， 起始位移至输入移位寄存器最左边时， 控制电路进行最后一次移位。 当 RI=0， 且 SM2=0（或接收到的停止位为 1） 时， 将接收到的 9 位数据的前8 位数据装入接收 SBUF， 第 9 位（停止位） 进入 RB8， 并置 RI=1， 向 CPU 请求中断。  </p>
<h5 id="方式2和方式3"><a href="#方式2和方式3" class="headerlink" title="方式2和方式3"></a>方式2和方式3</h5><p>方式 2 或方式 3 时为 11 位数据的异步通信口。 TXD 为数据发送引脚， RXD 为数据接收引脚。 其数据格式如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212026404.png" alt="image-20230617212026404"></p>
<p>对应的输入输出时序图如下所示：<br>①方式 2、 方式 3 输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212038037.png" alt="image-20230617212038037"></p>
<p>发送开始时， 先把起始位 0 输出到 TXD 引脚， 然后发送移位寄存器的输出位（D0） 到 TXD 引脚。 每一个移位脉冲都使输出移位寄存器的各位右移一位， 并由TXD 引脚输出。 第一次移位时， 停止位“1” 移入输出移位寄存器的第 9 位上，以后每次移位， 左边都移入 0。 当停止位移至输出位时， 左边其余位全为 0， 检测电路检测到这一条件时， 使控制电路进行最后一次移位， 并置 TI=1， 向 CPU请求中断。  </p>
<p>②方式 2、 方式 3 输入  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212048439.png" alt="image-20230617212048439"></p>
<p>接收时， 数据从右边移入输入移位寄存器， 在起始位 0 移到最左边时， 控制电路进行最后一次移位。 当 RI=0， 且 SM2=0（或接收到的第 9 位数据为 1） 时，接收到的数据装入接收缓冲器 SBUF 和 RB8（接收数据的第 9 位） ， 置 RI=1， 向CPU 请求中断。 如果条件不满足， 则数据丢失， 且不置位 RI， 继续搜索 RXD 引脚的负跳变。  </p>
<h4 id="串口的使用方法"><a href="#串口的使用方法" class="headerlink" title="串口的使用方法"></a>串口的使用方法</h4><h5 id="如何计算波特率"><a href="#如何计算波特率" class="headerlink" title="如何计算波特率"></a>如何计算波特率</h5><p>方式 0 的波特率 = fosc/12<br>方式 2 的波特率 =（2SMOD/64） · fosc<br>方式 1 的波特率 =（2SMOD/32） · （T1 溢出率）<br>方式 3 的波特率 =（2SMOD/32） · （T1 溢出率）</p>
<p>其中 T1 溢出率 = fosc /{12× [256 －（TH1） ] }， 当然还可以使用资料“\5—开发工具\4-常用辅助开发软件\51 波特率初值设定.exe” 内附带的小工具自动生成波特率。 其使用方法如下：<br>①双击打开该工具， 其界面如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212330027.png" alt="image-20230617212330027"></p>
<p>②选择定时器工作方式， 输入开发板上使用的晶振频率大小， 选择所要使用的波特率， SMOD 为是否倍频， 这个在前面介绍寄存器时说过， 下面的误差大小可以反映出通信时是否出现乱码。 在使用串口通信时， 定时器 1 工作方式为 2，串口工作方式为 1， 以开发板晶振是 11.0592Mh 为例， 假如晶振频率是 12M， 那么在生成的波特率就会有误差而导致通信出错。 为什么替换可以从误差值反映出来。 在本章实验中波特率选择 9600， 使用 SMOD， 即值为 1， 点击确定后即会自动生成定时/计数器 THx 的值， 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212402571.png" alt="image-20230617212402571"></p>
<p>从上图可知， 使用 11.0592M 晶振时， 误差为 0。 我们对比下当外部晶振使用12Mh 时， 波特率误差多大， 如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212412528.png" alt="image-20230617212412528"></p>
<p>从上图可知， 当使用 12M 晶振时， 波特率误差有 6.98%， 是比较大的， 会导致在通信过程中出现乱码等错误信息。 这是我们不希望看到的， 所以再次说明下，==在做串口通信实验时， 一定要确认外部晶振是否是 11.0592M==。</p>
<p>对于波特率的计算方法大家要知道， 开发中建议大家使用小工具， 它会给你带来很多便利。  </p>
<h5 id="串口初始化步骤"><a href="#串口初始化步骤" class="headerlink" title="串口初始化步骤"></a>串口初始化步骤</h5><p>如何使用串口， 大家可以按照以下几个步骤配置。<br>①确定 T1 的工作方式（TMOD 寄存器） ；<br>②确定串口工作方式（SCON 寄存器） ；<br>③计算 T1 的初值（设定波特率） ， 装载 TH1、 TL1；<br>④启动 T1（TCON 中的 TR1 位） ；<br>⑤如果使用中断， 需开启串口中断控制位（IE 寄存器） 。</p>
<p>例如： 设置串口为工作方式 1、 波特率为 9600、 波特率加倍、 使用中断。 其配置程序如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : uart_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 串口通信中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : baud： 波特率对应的 TH、 TL 装载值</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">    TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">    TL1=baud;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主函数中调用该函数并传入 OXFA 值即可， 如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br></pre></td></tr></table></figure>
<h4 id="硬件设计-12"><a href="#硬件设计-12" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上板载一个 USB 转串口模块。 其硬件电路如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213027782.png" alt="image-20230617213027782"></p>
<p>从上图中可以看出， 通过 CH340 芯片把 51 单片机的串口与 PC 机的 USB 口进行连接， 不仅可以实现程序的烧入， 还可实现串口通信功能。 根据前面介绍，串口通信需将数据收发管脚交叉连接， 所以可以看到在 CH340 芯片的 2 和 3 脚已做处理。 电路中其他部分是自动下载电路部分， 目的是控制单片机的电源， 无需冷启动。 使用 USB 转串口芯片， 免去了一根串口线， 使用普通 USB 数据线（支持安卓手机数据线） 就可以进行串口通信。  </p>
<p>从上图中可以看到 CH340 的 2、 3 脚串口并非直接连接到单片机串口， 而是连接在 P5 端子上， 这样就把 CH340 的串口与单片机串口独立出来， 为什么不直接连接而要使用这个 P5 端子呢？ 这是方便用户可以使用开发板上的 USB 转 TTL模块（也就是 CH340 转串口模块） 做一些串口类模块的调试， 比如： WIFI、 蓝牙、GPS、 GPRS 等， 直接利用 PC 上位机来调试模块。 同时也方便用户使用板载 USB转 TTL 模块给其它类型单片机下载程序  </p>
<p>如果使用黄色跳线帽将 P5 端子的 1、 2 短接， 3、 4 短接， 那么 CH340 串口与单片机串口是连接一起的， 此时即可实现程序的下载或串口通信。  </p>
<h4 id="软件设计-12"><a href="#软件设计-12" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 串口通信实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示</span></span><br><span class="line"><span class="comment">注意事项： 使用黄色跳线帽将 CH340 旁的 P5 端子的 UTX 和 P30 短接， URX 和 P31 短接， 出厂默认已短接好</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : uart_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 串口通信中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : baud： 波特率对应的 TH、 TL 装载值</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">    TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">    TL1=baud;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123; </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 rec_data;</span><br><span class="line">    RI = <span class="number">0</span>; <span class="comment">//清除接收中断标志位</span></span><br><span class="line">    rec_data=SBUF; <span class="comment">//存储接收到的数据</span></span><br><span class="line">    SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line">    <span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">    TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实验代码比较简单， 首先定义了串口通信中断配置函数 uart_init， 该函数有一个入口参数 baud， 该值可改变通信波特率。 该函数的实现即是按照前面介绍的串口配置步骤。 最后进入 while 循环， 在循环体内不执行任何功能程序。 如果发生接收中断， 即会进入串口中断执行， 执行完后回到主函数内继续运行， 如此循环。  </p>
<h4 id="实验现象-8"><a href="#实验现象-8" class="headerlink" title="实验现象"></a>实验现象</h4><p>  使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213721647.png" alt="image-20230617213721647"></p>
<p>注意： 使用黄色跳线帽将 CH340 旁的 P5 端子的 UTX 和 P30 短接， URX 和 P31短接， 出厂默认已短接好。 如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213743554.png" alt="image-20230617213743554"></p>
<h3 id="I2C-EEPROM-实验"><a href="#I2C-EEPROM-实验" class="headerlink" title="I2C-EEPROM 实验"></a>I2C-EEPROM 实验</h3><p>这一章我们来学习如何使用 51 单片机的 IO 口模拟 I2C 时序， 并实现与AT24C02（EEPROM） 之间的双向通信。 开发板板载了 1 个 EEPROM 模块， 可实现IIC 通信。 本章要实现的功能是： 系统运行时， 数码管右 3 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加 1， 按 K4 键显示数据清零， 最大能写入的数据是 255。   </p>
<h4 id="I2C介绍"><a href="#I2C介绍" class="headerlink" title="I2C介绍"></a>I2C介绍</h4><p>I2C（Inter－Integrated Circuit） 总线是由 PHILIPS 公司开发的两线式串行总线， 用于连接微控制器及其外围设备。 是微电子通信控制领域广泛采用的一种总线标准。 它是同步通信的一种特殊形式， 具有接口线少， 控制方式简单，器件封装形式小， 通信速率较高等优点。 I2C 总线只有两根双向信号线。 一根是数据线 SDA， 另一根是时钟线 SCL。 由于其管脚少， 硬件实现简单， 可扩展性强等特点， 因此被广泛的使用在各大集成芯片内。 下面我们就从 I2C 的物理层与协议层来了解 I2C。  </p>
<h4 id="I2C物理层"><a href="#I2C物理层" class="headerlink" title="I2C物理层"></a>I2C物理层</h4><p>I2C 通信设备常用的连接方式如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618095935286.png" alt="image-20230618095935286"></p>
<p>它的物理层有如下特点：（1） 它是一个支持多设备的总线。 “总线” 指多个设备共用的信号线。 在一个 I2C 通讯总线中， 可连接多个 I2C 通讯设备， 支持多个通讯主机及多个通讯从机。</p>
<p>（2） 一个 I2C 总线只使用两条总线线路， 一条双向串行数据线(SDA)， 一条串行时钟线(SCL)。 数据线即用来表示数据， 时钟线用于数据收发同步。</p>
<p>（3） 每个连接到总线的设备都有一个独立的地址， 主机可以利用这个地址进行不同设备之间的访问。</p>
<p>（4） 总线通过上拉电阻接到电源。 当 I2C 设备空闲时， 会输出高阻态， 而当所有设备都空闲， 都输出高阻态时， 由上拉电阻把总线拉成高电平。</p>
<p>（5） 多个主机同时使用总线时， 为了防止数据冲突， 会利用仲裁方式决定由哪个设备占用总线。</p>
<p>（ 6） 具有三种传输模式： 标准模式传输速率为 100kbit/s， 快速模式为400kbit/s， 高速模式下可达 3.4Mbit/s， 但目前大多 I2C 设备尚不支持高速模式。</p>
<p>（7） 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。</p>
<p>下面我们来了解下 I2C 总线常用的一些术语：<br>主机： 启动数据传送并产生时钟信号的设备；<br>从机： 被主机寻址的器件；<br>多主机： 同时有多于一个主机尝试控制总线但不破坏传输；<br>主模式： 用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP控制数据的接收和发送；<br>从模式： 发送和接收操作都是由 I2C 模块自动控制的；<br>仲裁： 是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并使传输不被破坏的过程；<br>同步： 两个或多个器件同步时钟信号的过程；<br>发送器： 发送数据到总线的器件；<br>接收器： 从总线接收数据的器件。</p>
<h4 id="I2C协议层"><a href="#I2C协议层" class="headerlink" title="I2C协议层"></a>I2C协议层</h4><p>I2C 的协议定义了通信的起始和停止信号、 数据有效性、 响应、 仲裁、 时钟同步和地址广播等环节。 下面我们就来简单介绍下。  </p>
<p>（1） 数据有效性规定  </p>
<p>I2C 总线进行数据传送时， 时钟信号为高电平期间， 数据线上的数据必须保持稳定， 只有在时钟线上的信号为低电平期间， 数据线上的高电平或低电平状态才允许变化。 如下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100322562.png" alt="image-20230618100322562"></p>
<p>每次数据传输都以字节为单位， 每次传输的字节数不受限制。  </p>
<p>（2） 起始和停止信号  </p>
<p>SCL 线为高电平期间， SDA 线由高电平向低电平的变化表示起始信号； SCL线为高电平期间， SDA 线由低电平向高电平的变化表示终止信号。 如下图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100338176.png" alt="image-20230618100338176"></p>
<p>起始和终止信号都是由主机发出的， 在起始信号产生后， 总线就处于被占用的状态； 在终止信号产生后， 总线就处于空闲状态。  </p>
<p>（3） 应答响应  </p>
<p>每当发送器件传输完一个字节的数据后， 后面必须紧跟一个校验位， 这个校验位是接收端通过控制 SDA（数据线） 来实现的， 以提醒发送端数据我这边已经接收完成， 数据传送可以继续进行。 这个校验位其实就是数据或地址传输过程中的响应。 响应包括“应答(ACK)” 和“非应答(NACK)” 两种信号。 作为数据接收端时， 当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后， 若希望对方继续发送数据， 则需要向对方发送“应答(ACK)” 信号即特定的低电平脉冲，发送方会继续发送下一个数据； 若接收端希望结束数据传输， 则向对方发送“非应答(NACK)” 信号即特定的高电平脉冲， 发送方接收到该信号后会产生一个停止信号， 结束信号传输。 应答响应时序图如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100351714.png" alt="image-20230618100351714"></p>
<p>每一个字节必须保证是 8 位长度。 ==数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（即一帧共有 9 位）==。  </p>
<p>由于某种原因从机不对主机寻址信号应答时（如从机正在进行实时性的处理工作而无法接收总线上的数据） ， 它必须将数据线置于高电平， 而由主机产生一个终止信号以结束总线的数据传送。  </p>
<p>如果从机对主机进行了应答， 但在数据传送一段时间后无法继续接收更多的数据时， 从机可以通过对无法接收的第一个数据字节的“非应答” 通知主机， 主机则应发出终止信号以结束数据的继续传送。  </p>
<p>当主机接收数据时， 它收到最后一个数据字节后， 必须向从机发出一个结束传送的信号。 这个信号是由对从机的“非应答” 来实现的。 然后， 从机释放 SDA线， 以允许主机产生终止信号。  </p>
<p>这些信号中， 起始信号是必需的， 结束信号和应答信号都可以不要。  </p>
<p>（4） 总线的寻址方式  </p>
<p>I2C 总线寻址按照从机地址位数可分为两种， 一种是 7 位， 另一种是 10位。 采用 7 位的寻址字节（寻址字节是起始信号后的第一个字节） 的位定义如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100501806.png" alt="image-20230618100501806"></p>
<p>D7～D1 位组成从机的地址。 D0 位是数据传送方向位， 为“ 0” 时表示主机向从机写数据， 为“1” 时表示主机由从机读数据。  </p>
<p>10 位寻址和 7 位寻址兼容， 而且可以结合使用。 10 位寻址不会影响已有的 7 位寻址， 有 7 位和 10 位地址的器件可以连接到相同的 I2C 总线。 我们就以 7 位寻址为例进行介绍。  </p>
<p>当主机发送了一个地址后， 总线上的每个器件都将头 7 位与它自己的地址比较， 如果一样， 器件会判定它被主机寻址， 其他地址不同的器件将被忽略后面的数据信号。 至于是从机接收器还是从机发送器， 都由 R/W 位决定的。 从机的地址由固定部分和可编程部分组成。 在一个系统中可能希望接入多个相同的从机， 从机地址中可编程部分决定了可接入总线该类器件的最大数目。 如一个从机的 7 位寻址位有 4 位是固定位， 3 位是可编程位， 这时仅能寻址 8 个同样的器件， 即可以有 8 个同样的器件接入到该 I2C 总线系统中。  </p>
<p>（5） 数据传输  </p>
<p>I2C 总线上传送的数据信号是广义的， 既包括地址信号， 又包括真正的数据信号。 在起始信号后必须传送一个从机的地址（7 位） ， 第 8 位是数据的传送方向位（R/W） ， 用“ 0” 表示主机发送（写） 数据（W） ， “ 1” 表示主机接收数据（R） 。 每次数据传送总是由主机产生的终止信号结束。 但是， 若主机希望继续占用总线进行新的数据传送， 则可以不产生终止信号， 马上再次发出起始信号对另一从机进行寻址。  </p>
<p>在总线的一次数据传送过程中， 可以有以下几种组合方式：<br>a、 主机向从机发送数据， 数据传送方向在整个传送过程中不变</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100530523.png" alt="image-20230618100530523"></p>
<p>注意： 有阴影部分表示数据由主机向从机传送， 无阴影部分则表示数据由从机向主机传送。 A 表示应答， A 非表示非应答（高电平） 。 S 表示起始信号， P 表示终止信号。  </p>
<p>b、 主机在第一个字节后， 立即从从机读数据  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100541210.png" alt="image-20230618100541210"></p>
<p>c、 在传送过程中， 当需要改变传送方向时， 起始信号和从机地址都被重复产生一次， 但两次读/写方向位正好相反  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100548070.png" alt="image-20230618100548070"></p>
<p>到这里我们就介绍完 I2C 总线， 由于 51 单片机没有硬件 IIC 接口， 即使有硬件接口我们通常还是采用软件模拟 I2C。 主要原因是硬件 IIC 设计的比较复杂， 而且稳定性不怎么好， 程序移植比较麻烦， 而用软件模拟 IIC， 最大的好处就是移植方便， 同一个代码兼容所有单片机， 任何一个单片机只要有 IO 口（不需要特定 IO） ， 都可以很快的移植过去。  </p>
<p>下面我们再来了解下开发板上的 AT24C02 芯片。  </p>
<h4 id="AT24C02-介绍"><a href="#AT24C02-介绍" class="headerlink" title="AT24C02 介绍"></a>AT24C02 介绍</h4><p>AT24C01/02/04/08/16…是一个 1K/2K/4K/8K/16K 位串行 CMOS， 内部含有128/256/512/1024/2048 个 8 位字节， AT24C01 有一个 8 字节页写缓冲器， AT24C02/04/08/16 有一个 16 字节页写缓冲器。 该器件通过 I2C 总线接口进行操作， 它有一个专门的写保护功能。 我们开发板上使用的是 AT24C02（EEPROM）芯片， 此芯片具有 I2C 通信接口， 芯片内保存的数据在掉电情况下都不丢失，所以通常用于存放一些比较重要的数据等。 AT24C02 芯片管脚及外观图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100619399.png" alt="image-20230618100619399"></p>
<p>芯片管脚说明如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100635643.png" alt="image-20230618100635643"></p>
<p>AT24C02 器件地址为 7 位， 高 4 位固定为 1010， 低 3 位由 A0/A1/A2 信号线的电平决定。 因为传输地址或数据是以字节为单位传送的， 当传送地址时，器件地址占 7 位， 还有最后一位（最低位 R/W） 用来选择读写方向， 它与地址无关。 其格式如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100725578.png" alt="image-20230618100725578"></p>
<p>我们开发板已经将芯片的 A0/A1/A2 连接到 GND， 所以器件地址为1010000， 即 0x50（未计算最低位） 。 如果要对芯片进行写操作时， R/W 即为 0，写器件地址即为 0XA0； 如果要对芯片进行读操作时， R/W 即为 1， 此时读器件地址为 0XA1。 开发板上也将 WP 引脚直接接在 GND 上， 此时芯片允许数据正常读写。</p>
<p>I2C 总线时序如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100737208.png" alt="image-20230618100737208"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100740278.png" alt="image-20230618100740278"></p>
<p>关于 AT24C02（EEPROM） 的更多信息， 可参考“\6—芯片资料\开发板芯片数据手册” 内 24C02 数据手册来了解。  </p>
<h4 id="硬件设计-13"><a href="#硬件设计-13" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 独立按键（K1-K4）<br>（2） 动态数码管<br>（3） EEPROM 模块电路（AT24C02）</p>
<p>独立按键和动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面我们来看下开发板上 EEPROM 模块电路， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100805470.png" alt="image-20230618100805470"></p>
<p>从图中可以看出， 芯片的 SCL 和 SDA 管脚是连接在单片机的 P2.1 和 P2.0 上，在介绍 IIC 总线的时候我们说过， 为了让 IIC 总线默认为高电平， 通常会在 IIC总线上接上拉电阻， 在图中并没有看到 SCL 和 SDA 管脚有上拉电阻， 这是因为开发板单片机 IO 都外接了 10K 上拉电阻， 当单片机 IO 口连接到芯片的 SCL 和 SDA脚时即相当于它们外接上拉电阻， 所以此处可以省去。  </p>
<h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><p>本章所要实现的功能是： 系统运行时， 数码管右 3 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加1， 按 K4 键显示数据清零， 最大能写入的数据是 255。</p>
<p>程序框架如下：<br>（1） 编写按键检测功能<br>（2） 编写数码管显示功能<br>（3） 编写 IIC 驱动， 包括起始、 停止、 应答信号等<br>（4） 编写 AT24C02 读写功能<br>（5） 编写主函数</p>
<p>前面的实验章节都已编写过按键检测、 数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 I2C 时序的模拟及数据的读写上。这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p>
<p>按键检测函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">    <span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :	   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    	&#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            	<span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    		&#123;</span><br><span class="line">   				key=<span class="number">1</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码为按键检测函数， 调用此函数后若有按键按下， 会返回对应键值。该函数在前面独立按键实验章节已详细介绍， 此处不再重复。  </p>
<p>数码管显示函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">				  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 要显示的数据</span></span><br><span class="line"><span class="comment">pos： 从左开始第几个位置开始显示， 范围 1-8</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 dat[],u8 pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    u8 pos_temp=pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=pos_temp;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">	&#125; </span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[dat[i-pos_temp]];<span class="comment">//传送段选数据</span></span><br><span class="line">		delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">		SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消音</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该代码也很好理解， 在前面动态数码管实验章节已介绍。 不同的是， 此处我们做了一些改良， 即给 smg_display 函数增加了 2 个形参， dat 和 pos， dat 是一个 u8 类型的数组， 方便外部传入要显示的数据； pos 是数码管从左开始第几个位置开始显示， 取值范围是 1-8， 如果为 1， 即从第一位数码管开始显示， 最多显示 8 位数据； 如果取 2， 即从第二位数码管开始显示， 最多显示 7 位数据。由于给函数增加了 2 个形参， 所以该条语句就变为如下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMG_A_DP_PORT=gsmg_code[dat[i-pos_temp]];</span><br></pre></td></tr></table></figure>
<p>当确定好显示位置， pos_temp 值就确定， 如果要显示的数据也确定， dat 数组内的值就直接可以通过数码管段选数据赋值给 SMG_A_DP_PORT。  </p>
<p>有些朋友可能看不懂为什么 dat[i-pos_temp]含义， 因为动态扫描， for 循环从 i 起始值开始， 而一般外部传入的数组 dat 是从下标 0 开始， 所以为i-pos_temp。</p>
<p>I2C 读写字节函数  </p>
<p>通过前面 I2C 的介绍， 我们知道， 要进行 I2C 通信， 需要编写起始信号、 停止信号、 应答和非应答信号。 因为 I2C 通信是以字节为单位进行传输的， 所以还需要编写 I2C 读写字节的函数。 打开 iic.c 具体代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_start</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 IIC 起始信号</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    IIC_SDA=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SDA=<span class="number">0</span>; <span class="comment">//当 SCL 为高电平时， SDA 由高变为低</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//钳住 I2C 总线， 准备发送或接收数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_stop</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 IIC 停止信号</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    IIC_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SDA=<span class="number">1</span>; <span class="comment">//当 SCL 为高电平时， SDA 由低变为高</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_ack</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 ACK 应答</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    IIC_SDA=<span class="number">0</span>; <span class="comment">//SDA 为低电平</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_nack</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 NACK 非应答</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    IIC_SDA=<span class="number">1</span>; <span class="comment">//SDA 为高电平</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_wait_ack</span></span><br><span class="line"><span class="comment">* 函数功能 : 等待应答信号到来</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1， 接收应答失败</span></span><br><span class="line"><span class="comment">         0， 接收应答成功</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 time_temp=<span class="number">0</span>;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(IIC_SDA) <span class="comment">//等待 SDA 为低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        <span class="keyword">if</span>(time_temp&gt;<span class="number">100</span>)<span class="comment">//超时则强制结束 IIC 通信</span></span><br><span class="line">        &#123;</span><br><span class="line">        iic_stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_write_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : IIC 发送一个字节</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 发送一个字节</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) <span class="comment">//循环 8 次将一个字节传出， 先传高再传低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat&amp;<span class="number">0x80</span>)&gt;<span class="number">0</span>)</span><br><span class="line">            IIC_SDA=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IIC_SDA=<span class="number">0</span>;</span><br><span class="line">        dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_read_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : IIC 读一个字节</span></span><br><span class="line"><span class="comment">* 输 入 : ack=1 时， 发送 ACK， ack=0， 发送 nACK</span></span><br><span class="line"><span class="comment">* 输 出 : 应答或非应答</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>,receive=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ ) <span class="comment">//循环 8 次将一个字节读出， 先读高再传低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(IIC_SDA)receive++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">    	iic_nack();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	iic_ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码是基于 I2C 时序编写， 具体可以参考时序图和程序注释来看， 非常好理解。 程序中 IIC_SDA 和 IIC_SCL 是 EEPROM 的控制引脚， 在 iic.h 头文件已定义。  </p>
<p>AT24C02 读写字节函数  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : at24c02_write_one_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : 在 AT24CXX 指定地址写入一个数据</span></span><br><span class="line"><span class="comment">* 输 入 : addr:写入数据的目的地址</span></span><br><span class="line"><span class="comment">         dat:要写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA0</span>); <span class="comment">//发送写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(dat); <span class="comment">//发送字节</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_stop(); <span class="comment">//产生一个停止条件</span></span><br><span class="line">    delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : at24c02_write_one_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : 在 AT24CXX 指定地址写入一个数据</span></span><br><span class="line"><span class="comment">* 输 入 : addr:写入数据的目的地址</span></span><br><span class="line"><span class="comment">         dat:要写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp=<span class="number">0</span>;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA0</span>); <span class="comment">//发送写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr); <span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA1</span>); <span class="comment">//进入接收模式</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    temp=iic_read_byte(<span class="number">0</span>); <span class="comment">//读取字节</span></span><br><span class="line">    iic_stop(); <span class="comment">//产生一个停止条件</span></span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//返回读取的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码也是基于 AT24C02 数据手册中读写数据格式实现， 在前面介绍 I2C协议时有介绍。 此处不再重复。  </p>
<p>主函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： I2C-EEPROM 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管右 4 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存，按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加 1， 按 K4 键显示数据清零，最大能写入的数据是 255。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_ADDRESS 0 <span class="comment">//定义数据存入 EEPROM 的起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_temp=<span class="number">0</span>;</span><br><span class="line">    u8 save_value=<span class="number">0</span>;</span><br><span class="line">    u8 save_buf[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    key_temp=key_scan(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(key_temp==KEY1_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        at24c02_write_one_byte(EEPROM_ADDRESS,save_value);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY2_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">        save_value=at24c02_read_one_byte(EEPROM_ADDRESS);</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY3_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">        save_value++;</span><br><span class="line">        <span class="keyword">if</span>(save_value==<span class="number">255</span>)save_value=<span class="number">255</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY4_PRESS)</span><br><span class="line">	&#123;</span><br><span class="line">		save_value=<span class="number">0</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    save_buf[<span class="number">0</span>]=save_value/<span class="number">100</span>;</span><br><span class="line">	save_buf[<span class="number">1</span>]=save_value%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">	save_buf[<span class="number">2</span>]=save_value%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">	smg_display(save_buf,<span class="number">6</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码很简单， 首先将所需要用到的外设驱动程序的头文件包含进来， 这样在 main.c 中才能使用， 然后在 main 中定义所需变量， 进入 while 循环后， 检测按键是否按下， 然后根据返回的键值操作对应功能， 最后是将按键调节的值显示在后 3 位数码管上。</p>
<p>实验现象  </p>
<p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 码管右 3 位显示 0，按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按K3 键显示数据加 1， 按 K4 键显示数据清零， 最大能写入的数据是 255。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618103158720.png" alt="image-20230618103158720"></p>
<h3 id="DS18B20温度传感器实验"><a href="#DS18B20温度传感器实验" class="headerlink" title="DS18B20温度传感器实验"></a>DS18B20温度传感器实验</h3><h4 id="DS18B20介绍"><a href="#DS18B20介绍" class="headerlink" title="DS18B20介绍"></a>DS18B20介绍</h4><p>DS18B20 是由 DALLAS 半导体公司推出的一种的“一线总线（单总线） ” 接口的温度传感器。 与传统的热敏电阻等测温元件相比， 它是一种新型的体积小、适用电压宽、 与微处理器接口简单的数字化温度传感器。  </p>
<p>DS18B20 温度传感器具有如下特点：  </p>
<p>1、 适应电压范围更宽， 电压范围： 3.0～5.5V， 在寄生电源方式下可由数据线供电。</p>
<p>2、 独特的单线接口方式， DS18B20 在与微处理器连接时仅需要一条口线即可实现微处理器与 DS18B20 的双向通讯。</p>
<p>3、 DS18B20 支持多点组网功能， 多个 DS18B20 可以并联在唯一的三线上，实现组网多点测温。</p>
<p>4、 DS18B20 在使用中不需要任何外围元件， 全部传感元件及转换电路集成在形如一只三极管的集成电路内。</p>
<p>5、 温范围－55℃～+125℃， 在-10～+85℃时精度为±0.5℃</p>
<p>6、 可编程的分辨率为 9～12 位， 对应的可分辨温度分别为 0.5℃、 0.25℃、0.125℃ 和 0.0625℃， 可实现高精度测温。</p>
<p>7、 在 9 位分辨率时最多在 93.75ms 内把温度转换为数字， 12 位分辨率时最多在 750ms 内把温度值转换为数字， 速度更快。</p>
<p>8、 测量结果直接输出数字温度信号， 以”一根总线”串行传送给 CPU， 同时可传送 CRC 校验码， 具有极强的抗干扰纠错能力。</p>
<p>9、 负压特性： 电源极性接反时， 芯片不会因发热而烧毁， 但不能正常工作。DS18B20 外观实物如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112628421.png" alt="image-20230618112628421"></p>
<p>从 DS18B20 外观图可以看到， 当我们正对传感器切面（传感器型号字符那一面） 时， 传感器的管脚顺序是从左到右排列。 管脚 1 为 GND， 管脚 2 为数据DQ， 管脚 3 为 VDD。 如果把传感器插反， 那么电源将短路， 传感器就会发烫，很容易损坏， 所以一定要注意传感器方向， 通常我们在开发板上都会标出传感器的凸起出， 所以只需要把传感器凸起的方向对着开发板凸起方向插入即可。  </p>
<p>DS18B20 内部结构如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112702555.png" alt="image-20230618112702555"></p>
<p>ROM 中的 64 位序列号是出厂前被光刻好的， 它可以看作是该 DS18B20 的地址序列号。 64 位光刻 ROM 的排列是： 开始 8 位（28H） 是产品类型标号， 接着的 48 位是该 DS18B20 自身的序列号， 最后 8 位是前面 56 位的循环冗余校验码。 光刻 ROM 的作用是使每一个 DS18B20 都各不相同， 这样就可以实现一根总线上挂接多个 DS18B20 的目的。  </p>
<p>DS18B20 温度传感器的内部存储器包括一个高速的暂存器 RAM 和一个非易失性的可电擦除的 EEPROM,后者存放高温度和低温度触发器 TH、 TL 和配置寄存器。  </p>
<p>配置寄存器是配置不同的位数来确定温度和数字的转化， 配置寄存器结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112728589.png" alt="image-20230618112728589"></p>
<p>低五位一直都是”1”， TM 是测试模式位， 用于设置 DS18B20 在工作模式还是在测试模式。 在 DS18B20 出厂时该位被设置为 0， 用户不需要去改动。 R1 和R0 用来设置 DS18B20 的精度（分辨率） ， 可设置为 9， 10， 11 或 12 位， 对应的分辨率温度是 0.5℃， 0.25℃， 0.125℃和 0.0625℃。 R0 和 R1 配置如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112743253.png" alt="image-20230618112743253"></p>
<p>在初始状态下默认的精度是 12 位， 即 R0=1、 R1=1。 高速暂存存储器由 9 个字节组成， 其分配如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112749937.png" alt="image-20230618112749937"></p>
<p>当温度转换命令（44H） 发布后， 经转换所得的温度值以二字节补码形式存放在高速暂存存储器的第 0 和第 1 个字节。 存储的两个字节， 高字节的前 5 位是符号位 S， 单片机可通过单线接口读到该数据， 读取时低位在前， 高位在后，数据格式如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112757551.png" alt="image-20230618112757551"></p>
<p>如果测得的温度大于 0， 这 5 位为‘ 0’ ， 只要将测到的数值乘以 0.0625 （默认精度是 12 位） 即可得到实际温度； 如果温度小于 0， 这 5 位为‘ 1’ ，测到的数值需要取反加 1 再乘以 0.0625 即可得到实际温度。 温度与数据对应关系如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112807663.png" alt="image-20230618112807663"></p>
<p>比如我们要计算+85 度， 数据输出十六进制是 0X0550， 因为高字节的高 5位为 0， 表明检测的温度是正温度， 0X0550 对应的十进制为 1360， 将这个值乘以 12 位精度 0.0625， 所以可以得到+85 度。</p>
<p>知道了怎么计算温度， 接下来我们就来看看如何读取温度数据， 由于 DS18B20是单总线器件， 所有的单总线器件都要求采用严格的信号时序， 以保证 数据的完整性。 DS18B20 时序包括如下几种： 初始化时序、 写（0 和 1） 时序、 读（0和 1） 时序。 DS18B20 发送所有的命令和数据都是字节的低位在前。 这里我们简单介绍这几个信号的时序：  </p>
<p>（1） 初始化时序  </p>
<p>单总线上的所有通信都是以初始化序列开始。 主机输出低电平， 保持低电平时间至少 480us（该时间的时间范围可以从 480 到 960 微妙） ， 以产生复位脉冲。 接着主机释放总线， 外部的上拉电阻将单总线拉高， 延时 15～60 us， 并进入接收模式。 接着 DS18B20 拉低总线 60~240 us， 以产生低电平应答脉冲， 若为低电平， 还要做延时， 其延时的时间从外部上拉电阻将单总线拉高算起最少要480 微妙。 初始化时序图如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112900120.png" alt="image-20230618112900120"></p>
<p>（2） 写时序写时序包括写 0 时序和写 1 时序。 所有写时序至少需要 60us， 且在 2 次独立的写时序之间至少需要 1us 的恢复时间， 两种写时序均起始于主机拉低总线。 写 1 时序： 主机输出低电平， 延时 2us， 然后释放总线， 延时 60us。 写 0时序： 主机输出低电平， 延时 60us， 然后释放总线， 延时 2us。 写时序图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113040438.png" alt="image-20230618113040438"></p>
<p>（3） 读时序单总线器件仅在主机发出读时序时， 才向主机传输数据， 所以， 在主机发出读数据命令后， 必须马上产生读时序， 以便从机能够传输数据。 所有读时序至少需要 60us， 且在 2 次独立的读时序之间至少需要 1us 的恢复时间。 每个读时序都由主机发起， 至少拉低总线 1us。 主机在读时序期间必须释放总线， 并且在时序起始后的 15us 之内采样总线状态。 读时序图如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113049396.png" alt="image-20230618113049396"></p>
<p>典型的读时序过程为： 主机输出低电平延时 2us， 然后主机转入输入模式延时 12us， 然后读取单总线当前的电平， 然后延时 50us。  </p>
<p>在了解了单总线时序之后， 我们来看看 DS18B20 的典型温度读取过程， DS18B20 的典型温度读取过程为： 复位→发 SKIP ROM 命令（0XCC） →发开始转换命令（0X44） →延时→复位→发送 SKIP ROM 命令（0XCC） →发读存储器命令（0XBE） →连续读出两个字节数据(即温度)→结束。  </p>
<p>至此我们就介绍完 DS18B20， 如需更详细的介绍， 请大家参考“\6—芯片资料\开发板芯片数据手册\DS18B20 中文.pdf” 。  </p>
<h4 id="硬件设计-14"><a href="#硬件设计-14" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p>
<p>（1） 动态数码管</p>
<p>（2） DS18B20动态数码管电路在前面章节已介绍， 这里就不再重复。 下面来看下开发板上DS18B20 模块电路， 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113143907.png" alt="image-20230618113143907"></p>
<p>从上图可以看出， 传感器接口的单总线管脚接至单片机 P3.7 IO 口上， 在介绍单总线的时候我们说过， 为了让单总线默认为高电平， 通常会在单总线上接上拉电阻， 在图中并没有看到有上拉电阻， 这是因为单片机 IO 都外接了 10K 上拉电阻， 当单片机 IO 口连接到传感器的总线管脚时即相当于它们外接上拉电阻，所以此处可以省去。  </p>
<h4 id="软件设计-13"><a href="#软件设计-13" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 插上 DS18B20 温度传感器， 数码管显示检测的温度值。  程序框架如下：<br>（1） 编写数码管显示功能<br>（2） 编写 DS18B20 读取温度功能<br>（3） 编写主函数</p>
<p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 DS18B20 时序的模拟及数据的读写上。 下面我们打开“\4—实验程序\1—基础实验\20-DS18B20 温度传感器实验” 工程， 在 App 工程组中可以看到新添加了 ds18b20.c 文件（里面包含了 DS18B20 驱动程序） ， 还要包含对应的头文件路径。  </p>
<p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p>
<h5 id="数码管显示函数"><a href="#数码管显示函数" class="headerlink" title="数码管显示函数"></a>数码管显示函数</h5><p>本实验要显示温度值， 就存在小数和符号位， 所以不能直接使用前面的数码管显示函数， 需要做一点点小改动， 代码如下  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 要显示的数据</span></span><br><span class="line"><span class="comment">pos： 从左开始第几个位置开始显示， 范围 1-8</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 dat[],u8 pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    u8 pos_temp=pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=pos_temp;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    MG_A_DP_PORT=dat[i-pos_temp];<span class="comment">//传送段选数据</span></span><br><span class="line">    delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">    SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消影</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与之前数码管显示驱动程序不同的就是红色加粗标记的那条语句， 可以看到此处没有直接使用数码管段码数据， 而是通过外部提供处理好的数码管段码数据传入进来， 这样可使数码管显示更加灵活， 后面实验我们都将采用这种方式。 因为要让外部提前处理好数码管段码数据， 所以段码数组 gsmg_code 就要定义为全局变量， 需在 smg.h 头文件中声明下即可： extern u8 gsmg_code[17];  </p>
<h5 id="DS18B20-初始化函数"><a href="#DS18B20-初始化函数" class="headerlink" title="DS18B20 初始化函数"></a>DS18B20 初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 初始化 DS18B20 的 IO 口 DQ 同时检测 DS 的存在</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1:不存在， 0:存在</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds18b20_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ds18b20_reset();</span><br><span class="line">    <span class="keyword">return</span> ds18b20_check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数带有一个返回值， 如果返回值为 1 表示 DS18B20 初始化失败， 返回值为 0 表示初始化成功。 函数返回值其实就是通过调用 ds18b20_check 函数获得，此函数用来检测DS18B20是否存在。初始化函数内还调用了ds18b20_reset函数，这两个函数其实就是根据前面介绍的初始化时序编写， 对应的代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_reset</span></span><br><span class="line"><span class="comment">* 函数功能 : 复位 DS18B20</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DS18B20_PORT=<span class="number">0</span>; <span class="comment">//拉低 DQ</span></span><br><span class="line">    delay_10us(<span class="number">75</span>); <span class="comment">//拉低 750us</span></span><br><span class="line">    DS18B20_PORT=<span class="number">1</span>; <span class="comment">//DQ=1</span></span><br><span class="line">    delay_10us(<span class="number">2</span>); <span class="comment">//20US</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_check</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测 DS18B20 是否存在</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1:未检测到 DS18B20 的存在， 0:存在</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds18b20_check</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 time_temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(DS18B20_PORT&amp;&amp;time_temp&lt;<span class="number">20</span>) <span class="comment">//等待 DQ 为低电平</span></span><br><span class="line">	&#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果超时则强制返回 1</span></span><br><span class="line">	<span class="keyword">else</span> time_temp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((!DS18B20_PORT)&amp;&amp;time_temp&lt;<span class="number">20</span>) <span class="comment">//等待 DQ 为高电平</span></span><br><span class="line">	&#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果超时则强制返回 1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="温度读取函数"><a href="#温度读取函数" class="headerlink" title="温度读取函数"></a>温度读取函数</h5><p>初始化 DS18B20 后， 我们就可以按照前面介绍的 DS18B20 的典型温度读取过程来编写温度读取函数， 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">** 函 数 名 : ds18b20_read_temperture</span></span><br><span class="line"><span class="comment">* 函数功能 : 从 ds18b20 得到温度值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 温度数据</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read_temperture</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    u8 dath=<span class="number">0</span>;</span><br><span class="line">    u8 datl=<span class="number">0</span>;</span><br><span class="line">    u16 value=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ds18b20_start();<span class="comment">//开始转换</span></span><br><span class="line">    ds18b20_reset();<span class="comment">//复位</span></span><br><span class="line">    ds18b20_check();</span><br><span class="line">    ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//SKIP ROM</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0xbe</span>);<span class="comment">//读存储器</span></span><br><span class="line">    </span><br><span class="line">    datl=ds18b20_read_byte();<span class="comment">//低字节</span></span><br><span class="line">    dath=ds18b20_read_byte();<span class="comment">//高字节</span></span><br><span class="line">    value=(dath&lt;&lt;<span class="number">8</span>)+datl;<span class="comment">//合并为 16 位数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((value&amp;<span class="number">0xf800</span>)==<span class="number">0xf800</span>)<span class="comment">//判断符号位， 负温度</span></span><br><span class="line">	&#123;</span><br><span class="line">        value=(~value)+<span class="number">1</span>; <span class="comment">//数据取反再加 1</span></span><br><span class="line">        temp=value*(<span class="number">-0.0625</span>);<span class="comment">//乘以精度</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//正温度</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=value*<span class="number">0.0625</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数首先调用了 ds18b20_start 函数用来开始 DS18B20 的温度转换， 其代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_start</span></span><br><span class="line"><span class="comment">* 函数功能 : 开始温度转换</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ds18b20_reset();<span class="comment">//复位</span></span><br><span class="line">    ds18b20_check();<span class="comment">//检查 DS18B20</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//SKIP ROM</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0x44</span>);<span class="comment">//转换命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最终将 2 个字节的温度数据读取出来， 判断最高字节的高 5 位是否为 0， 如果为 0 表明读取的温度值为正温度， 直接乘以 0.0625 即可， 否则为负温度， 需取反后加 1 再乘以 0.0625。  </p>
<h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><p>编写好 DS18B20 初始化和温度读取函数后， 接下来就可以编写主函数了， 代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DS18B20 温度传感器实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 插上 DS18B20 温度传感器， 数码管显示检测的温度值</span></span><br><span class="line"><span class="comment">注意事项： 注意温度传感器的方向， 在接口处我们已经用丝印画了一个凸起，</span></span><br><span class="line"><span class="comment">所以只需要将温度传感器对应插入即可</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds18b20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp_value;</span><br><span class="line">    u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">    ds18b20_init();<span class="comment">//初始化 DS18B20</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       i++;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">50</span>==<span class="number">0</span>)<span class="comment">//间隔一段时间读取温度值， 间隔时间要大于温度传感器转换温度时间</span></span><br><span class="line">          temp_value=ds18b20_read_temperture()*<span class="number">10</span>;<span class="comment">//保留温度值小数后一位</span></span><br><span class="line">       <span class="keyword">if</span>(temp_value&lt;<span class="number">0</span>)<span class="comment">//负温度</span></span><br><span class="line">       &#123;</span><br><span class="line">           temp_value=-temp_value;</span><br><span class="line">           temp_buf[<span class="number">0</span>]=<span class="number">0x40</span>;<span class="comment">//显示负号</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         temp_buf[<span class="number">0</span>]=<span class="number">0x00</span>;<span class="comment">//不显示</span></span><br><span class="line">       temp_buf[<span class="number">1</span>]=gsmg_code[temp_value/<span class="number">1000</span>];<span class="comment">//百位</span></span><br><span class="line">       temp_buf[<span class="number">2</span>]=gsmg_code[temp_value%<span class="number">1000</span>/<span class="number">100</span>];<span class="comment">//十位</span></span><br><span class="line">       temp_buf[<span class="number">3</span>]=gsmg_code[temp_value%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>]|<span class="number">0x80</span>;<span class="comment">//个位+小数点</span></span><br><span class="line">       temp_buf[<span class="number">4</span>]=gsmg_code[temp_value%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>];<span class="comment">//小数点后一位</span></span><br><span class="line">       smg_display(temp_buf,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数代码很简单， 首先调用所需外设头文件， 然后初始化 DS18B20， 在 while循环中间隔一定时间读取温度数据， 并将温度值保留小数点后一位， 然后将读取的温度数据转换为数码管可显示的段码， 最后调用数码管显示函数。  </p>
<h4 id="实验现象-9"><a href="#实验现象-9" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 插上 DS18B20 温度传感器， 数码管显示检测的温度值。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618115505081.png" alt="image-20230618115505081"></p>
<p>实验说明： DS18B20 默认起始温度是 85 度， 之后就会进入到正常温度检测，如果条件允许可以在零下温度下检测看看  </p>
<p>注意： ==一定要注意温度传感器的方向， 在接口处我们已经用丝印画了一个凸起， 所以只需要将温度传感器对应插入即可==。  </p>
<h3 id="DS1302-时钟实验"><a href="#DS1302-时钟实验" class="headerlink" title="DS1302 时钟实验"></a>DS1302 时钟实验</h3><p>在前面章节， 我们介绍了如何使用单片机 IO 口模拟 IIC 总线、 单总线时序。这一章我们来学习 DS1302 时钟芯片， 该芯片是 3 线 SPI 接口， 所以需要使用 51单片机的 3 个 IO 口模拟 SPI 时序与 DS1302 时钟芯片通信， 将时钟日历数据读取出来。 开发板上集成了 1 个 DS1302 时钟模块， 可使用它设计一个多功能电子时钟。 本章要实现的功能是： 系统运行时， 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX” 。 学习本章可以参考前面的实验章节内容。   </p>
<h4 id="DS1302-时钟芯片介绍"><a href="#DS1302-时钟芯片介绍" class="headerlink" title="DS1302 时钟芯片介绍"></a>DS1302 时钟芯片介绍</h4><h5 id="DS1302-简介"><a href="#DS1302-简介" class="headerlink" title="DS1302 简介"></a>DS1302 简介</h5><p>DS1302 是 DALLAS 公司推出的涓流充电时钟芯片， 内含有一个实时时钟/日历和 31 字节静态 RAM， 通过简单的串行接口与单片机进行通信。 实时时钟/日历电路提供秒、 分、 时、 日、 周、 月、 年的信息， 每月的天数和闰年的天数可自动调整。 时钟操作可通过 AM/PM 指示决定采用 24 或 12 小时格式。 DS1302 与单片机之间能简单地采用同步串行的方式进行通信， 仅需用到三根通信线： ①RES复位②I/O 数据线③SCLK 串行时钟。 时钟/RAM 的读/写数据以一个字节或多达31 个字节的字符组方式通信。 DS1302 工作时功耗很低保持数据和时钟信息时功率小于 1mW。  </p>
<p>DS1302 由 DS1202 改进而来增加了以下的特性： 双电源管脚用于主电源和备份电源供应， Vcc1 为可编程涓流充电电源， 附加七个字节存储器。 它广泛应用于电话、 传真、 便携式仪器以及电池供电的仪器仪表等产品领域下面。  </p>
<p>主要的性能指标：<br>★ 实时时钟具有能计算 2100 年之前的秒、 分、 时、 日、 星期、 月、 年的能力， 还有闰年调整的能力；<br>★ 31 个 8 位暂存数据存储 RAM；<br>★ 串行 I/O 口方式使得管脚数量最少；</p>
<p>★ 宽范围工作电压 2.0~5.5V；<br>★ 工作在 2.0V 时， 电流小于 300nA；<br>★ 读/写时钟或 RAM 数据时有两种传送方式单字节传送和多字节传送字符组方式；<br>★ 8 脚 DIP 封装或可选的 8 脚 SOIC 封装根据表面装配；<br>★ 简单 3 线接口；<br>★ 与 TTL 兼容 Vcc=5V；<br>★ 可选工业级温度范围-40~+85；<br>下面来看下 DS1302 芯片的管脚及功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621232901649.png" alt="image-20230621232901649"></p>
<p>1， VCC2： 主电源引脚<br>2， X1、 X2： DS1302 外部晶振引脚， 通常需外接 32.768K 晶振<br>3， GND： 电源地<br>4， CE： 使能引脚， 也是复位引脚（新版本功能变） 。<br>5， I/O： 串行数据引脚， 数据输出或者输入都从这个引脚<br>6， SCLK： 串行时钟引脚<br>7， VCC1： 备用电源</p>
<h5 id="DS1302-使用"><a href="#DS1302-使用" class="headerlink" title="DS1302 使用"></a>DS1302 使用</h5><p>操作 DS1302 的大致过程， 就是将各种数据写入 DS1302 的寄存器， 以设置它当前的时间的格式。 然后使 DS1302 开始运作， DS1302 时钟会按照设置情况运转， 再用单片机将其寄存器内的数据读出。 再用液晶显示， 就是我们常说的简易电子钟。 所以总的来说 DS1302 的操作分 2 步（显示部分属于液晶显示的内容，不属于 DS1302 本身的内容） ， 但是在讲述操作时序之前， 我们要先看看寄存器， DS1302 有一个控制寄存器、 12 个日历、 时钟寄存器和 31 个 RAM。  </p>
<p>（1） 控制寄存器  </p>
<p>控制寄存器用于存放 DS1302 的控制命令字， DS1302 的 RST 引脚回到高电平后写入的第一个字节就为控制命令。 它用于对 DS1302 读写过程进行控制， 格式如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621232947772.png" alt="image-20230621232947772"></p>
<p>上图是 DS1302 的寄存器样式， 我们看到：  </p>
<p>1、 第 7 位永远都是 1；<br>2、 第 6 位， 1 表示 RAM， 寻址内部存储器地址； 0 表示 CK， 寻址内部寄存器；<br>3、 第 5 到第 1 位， 为 RAM 或者寄存器的地址；</p>
<p>4、 最低位， 高电平表示 RD， 即下一步操作将要“读” ； 低电平表示 W， 即下一步操作将要“写” 。 （与 AT24C02 寄存器类似， 这点要理解好） 。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233040454.png" alt="image-20230621233040454"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233044573.png" alt="image-20230621233044573"></p>
<p>比如要读秒寄存器则命令为 1000 0001， 反之写为 1000 0000， 要注意其含义。</p>
<p>2） 日历/时钟寄存器<br>DS1302 共有 12 个寄存器， 其中有 7 个与日历、 时钟相关， 存放的数据为 BCD码形式。 格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233120895.png" alt="image-20230621233120895"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233128545.png" alt="image-20230621233128545"></p>
<p>下面对几个寄存器做下说明：  </p>
<p>秒寄存器： 低四位为秒的个位， 高的次三位为秒的十位。 最高位 CH 为DS1302 的运行标志， 当 CH=0 时， DS1302 内部时钟运行， 反之 CH=1 时停止；</p>
<p>小时寄存器： 时寄存器。 最高位为 12/24 小时的格式选择位， 该位为 1 时表示 12 小时格式。 当设置为 12 小时显示格式时， 第 5 位的高电平表示下午（PM） ； 而当设置为 24 小时格式时， 第 5 位位具体的时间数据。</p>
<p>写保护寄存器： 当该寄存器最高位 WP 为 1 时， DS1302 只读不写， 所以要在往 DS1302 写数据之前确保 WP 为 0。</p>
<p>慢充电寄存器（涓细电流充电） 寄存器： 我们知道， 当 DS1302 掉电时， 可以马上调用外部电源保护时间数据。 该寄存器就是配置备用电源的充电选项的。其中高四位（4 个 TCS） 只有在 1010 的情况下才能使用充电选项； 低四位的情况与 DS1302 内部电路有关， 具体大家可以查看“\6—开发板芯片资料\开发板芯片数据手册\DS1302 中文手册.pdf” 。</p>
<p>前面我们提到在日历/时钟寄存器中都是以 BCD 码存放数据， 那么 BCD 码是什么呢？ BCD 码是通过 4 位二进制码来表示 1 位十进制中的 0~9 这 10 个数码。如下所示：</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233222778.png" alt="image-20230621233222778"></p>
<p>所以从 DS1302 中读取出来的时钟数据均为 BCD 码格式， 需转换为我们习惯的 10 进制， 转换方法在源程序里， 后面我们会介绍。  </p>
<p>（3） DS1302 的读写时序在控制指令字输入后的下一个 SCLK 时钟的上升沿时， 数据被写入 DS1302，数据输入从低位（位 0） 开始。 同样， 在紧跟 8 位的控制指令字后的下一个 SCLK脉冲的下降沿读出 DS1302 的数据， 读出数据时从低位 0 位到高位 7。 其时序图如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233307314.png" alt="image-20230621233307314"></p>
<p>上图就是 DS1302 的三个时序： 复位时序， 单字节写时序， 单字节读时序；  </p>
<p>CE（RST） ： 复位时序， 即在 RST 引脚产生一个正脉冲， 在整个读写器件， RST 要保持高电平， 一次字节读写完毕之后， 要注意把 RST 返回低电平准备下次读写周期；  </p>
<p>单字节读时序： 注意读之前还是要先对寄存器写命令， 从最低位开始写； 可以看到， 写数据是在 SCLK 的上升沿实现， 而读数据在 SCLK 的下降沿实现。 所以，在单字节读时序中， 写命令的第八个上升沿结束后紧接着的第八个下降沿就将要读寄存器的第一位数据读到数据线上了！ 这个就是 DS1302 操作中最特别的地方。当然读出来的数据也是最低位开始。  </p>
<p>单字节写时序： 两个字节的数据配合 16 个上升沿将数据写入即可。  </p>
<p>程序注意事项：  </p>
<p>★要记得在操作 DS1302 之前关闭写保护；</p>
<p>★注意用延时来降低单片机的速度以配合器件时序；</p>
<p>★DS1302 读出来的数据是 BCD 码形式， 要转换成我们习惯的 10 进制， 转换方法在源程序里；</p>
<p>★读取字节之前， 将 IO 设置为输入口， 读取完之后， 要将其改回输出口；</p>
<p>★在写程序的时候， 建议实现开辟数组（内存空间） 来集中放置 DS1302 的一系列数据， 方便以后扩展键盘输入。</p>
<p>到这里我们就介绍完 DS1302 时钟芯片， 如需更详细的介绍， 请大家参考“\6—开发板芯片资料\开发板芯片数据手册\DS1302 中文手册.pdf” 。</p>
<h4 id="硬件设计-15"><a href="#硬件设计-15" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p>
<p>（1） 动态数码管</p>
<p>（2） DS1302</p>
<p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面我们来看下开发板上 DS1302 时钟模块电路， 如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233452506.png" alt="image-20230621233452506"></p>
<p>从上图中可知， DS1302 芯片的控制管脚接至单片机 P3.4-P3.6 上， 在芯片的X1、 X2 管脚处外接了一个 32.768KHZ 晶振， 为时钟运行提供一个稳定的时钟频率， C2 和 C3 为旁路电容， 目的是消除晶振起振时产生的电感干扰。 对于本开发板无外接备用电池， 如果需要可自行将外部备用电源接入第 8 脚 VCC1。  </p>
<h4 id="软件设计-14"><a href="#软件设计-14" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX”。程序框架如下：</p>
<p>（1） 编写数码管显示功能<br>（2） 编写 DS1302 时钟读写功能<br>（3） 编写主函数</p>
<p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 DS1302 时序的模拟及数据的读写上。 下面我们打开“\4—实验程序\1—基础实验\21-DS1302 时钟实验” 工程， 在 App 工程组中可以看到新添加了 ds1302.c 文件（里面包含了 DS1302 驱动程序） ， 还要包含对应的头文件路径  </p>
<p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p>
<h5 id="DS1302-读写函数"><a href="#DS1302-读写函数" class="headerlink" title="DS1302 读写函数"></a>DS1302 读写函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds1302.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="comment">//---DS1302 写入和读取时分秒的地址命令---//</span></span><br><span class="line"><span class="comment">//---秒分时日月周年 最低位读写位;-------//</span></span><br><span class="line">u8 gREAD_RTC_ADDR[<span class="number">7</span>] = &#123;<span class="number">0x81</span>, <span class="number">0x83</span>, <span class="number">0x85</span>, <span class="number">0x87</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x8d</span>&#125;;</span><br><span class="line">u8 gWRITE_RTC_ADDR[<span class="number">7</span>] = &#123;<span class="number">0x80</span>, <span class="number">0x82</span>, <span class="number">0x84</span>, <span class="number">0x86</span>, <span class="number">0x88</span>, <span class="number">0x8a</span>, <span class="number">0x8c</span>&#125;;</span><br><span class="line"><span class="comment">//---DS1302 时钟初始化 2021 年 5 月 20 日星期四 13 点 51 分 47 秒。 ---//</span></span><br><span class="line"><span class="comment">//---存储顺序是秒分时日月周年,存储格式是用 BCD 码---//</span></span><br><span class="line">u8 gDS1302_TIME[<span class="number">7</span>] = &#123;<span class="number">0x47</span>, <span class="number">0x51</span>, <span class="number">0x13</span>, <span class="number">0x20</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_write_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 写单字节</span></span><br><span class="line"><span class="comment">* 输 入 : addr： 地址/命令</span></span><br><span class="line"><span class="comment">dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_write_byte</span><span class="params">(u8 addr,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">DS1302_RST=<span class="number">0</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 低电平</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_RST=<span class="number">1</span>;<span class="comment">//RST 由低到高变化</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=addr&amp;<span class="number">0x01</span>;</span><br><span class="line">addr&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">&#125;f</span><br><span class="line"><span class="title function_">or</span><span class="params">(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=dat&amp;<span class="number">0x01</span>;</span><br><span class="line">dat&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;D</span><br><span class="line">S1302_RST=<span class="number">0</span>;<span class="comment">//RST 拉低</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_read_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 读单字节</span></span><br><span class="line"><span class="comment">* 输 入 : addr： 地址/命令</span></span><br><span class="line"><span class="comment">* 输 出 : 读取的数据</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds1302_read_byte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">u8 temp=<span class="number">0</span>;</span><br><span class="line">u8 value=<span class="number">0</span>;</span><br><span class="line">DS1302_RST=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 低电平</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_RST=<span class="number">1</span>;<span class="comment">//RST 由低到高变化</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=addr&amp;<span class="number">0x01</span>;</span><br><span class="line">addr&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">&#125;f</span><br><span class="line"><span class="title function_">or</span><span class="params">(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><span class="comment">//循环 8 次， 每次读 1 位， 先读低位再读高位</span></span><br><span class="line">&#123;</span><br><span class="line">temp=DS1302_IO;</span><br><span class="line">value=(temp&lt;&lt;<span class="number">7</span>)|(value&gt;&gt;<span class="number">1</span>);<span class="comment">//先将 value 右移 1 位， 然后 temp 左移 7 位，</span></span><br><span class="line">最后或运算</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;D</span><br><span class="line">S1302_RST=<span class="number">0</span>;<span class="comment">//RST 拉低</span></span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;<span class="comment">//对于实物中， P3.4 口没有外接上拉电阻的， 此处代码需要添加， 使数</span></span><br><span class="line">据口有一个上升沿脉冲。</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_IO = <span class="number">0</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_IO = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_init</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 初始化时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">ds1302_write_byte(<span class="number">0x8E</span>,<span class="number">0X00</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ds1302_write_byte(gWRITE_RTC_ADDR[i],gDS1302_TIME[i]);</span><br><span class="line">&#125;d</span><br><span class="line"><span class="title function_">s1302_write_byte</span><span class="params">(<span class="number">0x8E</span>,<span class="number">0X80</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_read_time</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 读取时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_read_time</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">gDS1302_TIME[i]=ds1302_read_byte(gREAD_RTC_ADDR[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>各函数功能在代码内有详细注释， 大家可以参考注释理解。 程序开头定义了3 个数组： gREAD_RTC_ADDR、 gWRITE_RTC_ADDR 和 gDS1302_TIME。 gREAD_RTC_ADDR和 gWRITE_RTC_ADDR 数组内存储的是 DS1302 写入和读取时分秒的地址命令， 这个可以对照前面介绍的寄存器看。 TIME 数组是用来存储初始化时间， 每个数据对应含义在代码内已做注释。 在使用中主要调用 ds1302_init()函数和ds1302_read_time()函数来初始化 DS1302 时钟数据以及读取 DS1302 时钟数据。在初始化时钟数据时， 首先要禁止写保护即关闭写保护功能， 然后将所需设置的时钟数据写入到对应的时钟寄存器地址内， 最后打开写保护功能， 以防止意外修改 DS1302 内部寄存器。 对于读取时钟数据其实很简单， 只要从对应的时钟寄存器地址内读取数据即可， 然后将读取的数据存储到一个缓存数组中， 方便数据的处理与显示， 这个操作在后面 main.c 文件内会有。  </p>
<h5 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DS1302 时钟实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX”</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds1302.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">u8 time_buf[<span class="number">8</span>];</span><br><span class="line">ds1302_init();<span class="comment">//初始化 DS1302</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ds1302_read_time();</span><br><span class="line">time_buf[<span class="number">0</span>]=gsmg_code[gDS1302_TIME[<span class="number">2</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">1</span>]=gsmg_code[gDS1302_TIME[<span class="number">2</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">time_buf[<span class="number">2</span>]=<span class="number">0x40</span>;</span><br><span class="line">time_buf[<span class="number">3</span>]=gsmg_code[gDS1302_TIME[<span class="number">1</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">4</span>]=gsmg_code[gDS1302_TIME[<span class="number">1</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">time_buf[<span class="number">5</span>]=<span class="number">0x40</span>;</span><br><span class="line">time_buf[<span class="number">6</span>]=gsmg_code[gDS1302_TIME[<span class="number">0</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">7</span>]=gsmg_code[gDS1302_TIME[<span class="number">0</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">smg_display(time_buf,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数代码非常简单， 首先调用外设头文件， 然后初始化 DS1302 并设定好初始时间， 进入 while 循环， 读取 DS1302 时钟数据存储至全局变量数组gDS1302_TIME 中， 最后将读取的数据转换为数码管可显示的段码数据并调用数码管显示函数显示时间  </p>
<p>==细心的朋友可能发现， 在处理 DS1302 读取的数据时， 取高低位是使用除 16和取余 16， 并非之前的除 10 和取余 10。 这是因为写入进 DS1302 时是 BCD 码，读取出的数据也是 BCD 码， 而 BCD 码即是 4 位表示一个十进制数， 类似于一个字节的十六进制数据的高 4 位和低 4 位一样， 所以这里是除 16 和取余 16==。  </p>
<h4 id="实验现象-10"><a href="#实验现象-10" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX” 。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621234048436.png" alt="image-20230621234048436"></p>
<h3 id="红外遥控实验"><a href="#红外遥控实验" class="headerlink" title="红外遥控实验"></a>红外遥控实验</h3><p>在前面章节， 我们介绍的通信， 如 SPI、 IIC 等通信均为有线， 这一章我们来介绍一种无线通信技术—红外遥控通信。 我们开发板标配了一个一体化红外接收头和红外遥控器， 我们来学习如何使用 51 单片机解码红外遥控器的信号。 本章使用 51 单片机的外部中断功能来解码红外遥控器的编码信号。 本章要实现的功能是： 使用外部中断功能将遥控器键值编码数据解码后通过数码管显示。 学习本章可以参考前面的实验章节内容。   </p>
<h4 id="红外遥控介绍"><a href="#红外遥控介绍" class="headerlink" title="红外遥控介绍"></a>红外遥控介绍</h4><h5 id="红外线简介"><a href="#红外线简介" class="headerlink" title="红外线简介"></a>红外线简介</h5><p>人的眼睛能看到的可见光按波长从长到短排列， 依次为红、 橙、 黄、 绿、 青、蓝、 紫。 其中红光的波长范围为 0.62～0.76μ m； 紫光的波长范围为 0.38～0.46μ m。 比紫光波长还短的光叫紫外线， 比红光波长还长的光叫红外线。 红外线遥控就是利用波长为 0.76～1.5μ m 之间的近红外线来传送控制信号的。</p>
<h5 id="红外遥控的原理"><a href="#红外遥控的原理" class="headerlink" title="红外遥控的原理"></a>红外遥控的原理</h5><p>红外遥控是一种无线、 非接触控制技术， 具有抗干扰能力强， 信息传输可靠，功耗低， 成本低， 易实现等显著优点， 被诸多电子设备特别是家用电器广泛采用，并越来越多的应用到计算机系统中。    </p>
<p>由于红外线遥控不具有像无线电遥控那样穿过障碍物去控制被控对象的能力， 所以， 在设计红外线遥控器时， 不必要像无线电遥控器那样， 每套(发射器和接收器)要有不同的遥控频率或编码(否则， 就会隔墙控制或干扰邻居的家用电器)， 所以同类产品的红外线遥控器， 可以有相同的遥控频率或编码， 而不会出 现遥控信号“串门” 的情况。 这对于大批量生产以及在家用电器上普及红外线遥控提供了极大的方便。 由于红外线为不可见光， 因此对环境影响很小， 再由红外光波动波长远小于无线电波的波长， 所以红外线遥控不会影响其他家用电器， 也不会影响临近的无线电设备。  </p>
<p>红外遥控通信系统一般由红外发射装置和红外接收设备两大部分组成。  </p>
<h5 id="红外发射装置"><a href="#红外发射装置" class="headerlink" title="红外发射装置"></a>红外发射装置</h5><p>红外发射装置， 也就是通常我们说的红外遥控器是由键盘电路、 红外编码电路、 电源电路和红外发射电路组成。 红外发射电路的主要元件为红外发光二极管。它实际上是一只特殊的发光二极管； 由于其内部材料不同于普通发光二极管， 因而在其两端施加一定电压时， 它便发出的是红外线而不是可见光。 目前大量的使用的红外发光二极管发出的红外线波长为 940nm 左右， 外形与普通发光二极管相同。 红外发光二极管有透明的， 还有不透明的， 在我们的红外遥控器上可以看到这个红外发光二极管。 红外遥控器和红外发光二极管如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082825945.png" alt="image-20230619082825945"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082840543.png" alt="image-20230619082840543"></p>
<p>通常红外遥控为了提高抗干扰性能和降低电源消耗， 红外遥控器常用载波的方式传送二进制编码， 常用的载波频率为 38kHz， 这是由发射端所使用的 455kHz晶振来决定的。 在发射端要对晶振进行整数分频， 分频系数一般取 12， 所以455kHz÷12≈37.9kHz≈38kHz。 也有一些遥控系统采用 36kHz、 40 kHz、 56 kHz等， 一般由发射端晶振的振荡频率来决定。 所以， 通常的红外遥控器是将遥控信号（二进制脉冲码） 调制在 38KHz 的载波上， 经缓冲放大后送至红外发光二极管， 转化为红外信号发射出去的。  </p>
<p>二进制脉冲码的形式有多种， 其中最为常用的是 NEC Protocol 的 PWM 码(脉冲宽度调制)和 Philips RC-5 Protocol 的 PPM 码(脉冲位置调制码， 脉冲串之间的时间间隔来实现信号调制)。 如果要开发红外接收设备， 一定要知道红外遥控器的编码方式和载波频率， 我们才可以选取一体化红外接收头和制定解码方案。 我们配套的红外遥控器使用的是 NEC 协议， 其特征如下：  </p>
<p>1、 8 位地址和 8 位指令长度；<br>2、 地址和命令 2 次传输（确保可靠性）<br>3、 PWM 脉冲位置调制， 以发射红外载波的占空比代表“0” 和“1” ；<br>4、 载波频率为 38Khz；<br>5、 位时间为 1.125ms 或 2.25ms；</p>
<p>NEC 码的位定义： 一个脉冲对应 560us 的连续载波， 一个逻辑 1 传输需要2.25ms（560us 脉冲+1680us 低电平）， 一个逻辑 0 的传输需要 1.125ms（560us脉冲+560us 低电平） 。 而红外接收头在收到脉冲的时候为低电平， 在没有脉冲的时候为高电平， 这样， 我们在接收头端收到的信号为： 逻辑 1 应该是 560us 低+1680us 高， 逻辑 0 应该是 560us 低+560us 高。 所以可以通过计算高电平时间判断接收到的数据是 0 还是 1。 NEC 码位定义时序图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082956754.png" alt="image-20230619082956754"></p>
<p>NEC 遥控指令的数据格式为： 引导码、 地址码、 地址反码、 控制码、 控制反码。 引导码由一个 9ms 的低电平和一个 4.5ms 的高电平组成， 地址码、 地址反码、 控制码、 控制反码均是 8 位数据格式。 按照低位在前， 高位在后的顺序发送。 采用反码是为了增加传输的可靠性（可用于校验） 。 数据格式如下：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083004535.png" alt="image-20230619083004535"></p>
<p>NEC 码还规定了连发码(由 9ms 低电平+2.5m 高电平+0.56ms 低电平+97.94ms 高电平组成)， 如果在一帧数据发送完毕之后， 红外遥控器按键仍然没有放开， 则发射连发码， 可以通过统计连发码的次数来标记按键按下的长短或次数。  </p>
<h5 id="红外接收设备"><a href="#红外接收设备" class="headerlink" title="红外接收设备"></a>红外接收设备</h5><p>红外接收设备是由红外接收电路、 红外解码、 电源和应用电路组成。 红外遥控接收器的主要作用是将遥控发射器发来的红外光信好转换成电信号， 再放大、限幅、 检波、 整形， 形成遥控指令脉冲， 输出至遥控微处理器。 近几年不论是业余制作还是正式产品， 大多都采用成品红外接收头。 成品红外接收头的封装大致有两种： 一种采用铁皮屏蔽； 一种是塑料封装。 均有三只引脚， 即电源正（ VDD）、电源负（GND） 和数据输出（VOUT） 。 其外观实物图如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083101068.png" alt="image-20230619083101068"></p>
<p>正对接收头的凸起处看， 从左至右， 管脚依次是 1： VOUT， 2： GND， 3： VDD。  </p>
<p>由于红外接收头在没有脉冲的时候为高电平， 当收到脉冲的时候为低电平，所以可以通过外部中断的下降沿触发中断， 在中断内通过计算高电平时间来判断接收到的数据是 0 还是 1。 外部中断的相关知识， 大家可以参考前面的“外部中断实验” ， 如果想要更加深入的了解红外遥控通信， 大家可以百度， 网上这方面的资料可谓是铺天盖地  </p>
<h4 id="硬件设计-16"><a href="#硬件设计-16" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管<br>（2） 红外接收头和遥控器</p>
<p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 红外遥控器和接收头是一体的， 内部结构不用去管它。 下面来看下开发板上红外接收模块电路， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083146910.png" alt="image-20230619083146910"></p>
<p>从上图中可知， 红外接收头的输出管脚接至单片机 P3.2 管脚上， 为了保证红外接收头输出管脚默认为高电平， 需外接一个 10K 上拉电阻， 可在上图并没有看到有上拉电阻， 在前面介绍最小系统时已知道， 单片机 IO 口都增加了 10K 上拉电阻， 所以此处可省略。  </p>
<h4 id="软件设计-15"><a href="#软件设计-15" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示红外解码遥控器键值。程序框架如下：  </p>
<p>（1） 编写数码管显示功能<br>（2） 编写红外解码函数<br>（3） 编写主函数</p>
<p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在红外解码上。 下面我们打开“\4—实验程序\1—基础实验\22-红外遥控实验” 工程， 在 App 工程组中可以看到新添加了 ired.c 文件（里面包含了红外解码驱动程序） ， 还要包含对应的头文件路径。</p>
<p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p>
<h5 id="红外初始化函数"><a href="#红外初始化函数" class="headerlink" title="红外初始化函数"></a>红外初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ired_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 红外端口初始化函数， 外部中断 0 配置</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>; <span class="comment">//下降沿触发</span></span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">//打开中断 0 允许</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    IRED=<span class="number">1</span>; <span class="comment">//初始化端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为我们使用外部中断 0 来解码红外遥控数据， 所以需初始化配置外部中断0。 初始化配置在外部中断实验章节已详细介绍， 此处不再重复。  </p>
<h5 id="红外解码函数"><a href="#红外解码函数" class="headerlink" title="红外解码函数"></a>红外解码函数</h5><p>初始化外部中断后， 中断就已经开启了， 当 P32 引脚来一个下降沿， 就会触发一次中断， 在中断内我们可以计算高电平时间， 通过高电平时间判断是否进入引导码及数据 0 和 1。 具体代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ired</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ired_high_time=<span class="number">0</span>;</span><br><span class="line">    u16 time_cnt=<span class="number">0</span>;</span><br><span class="line">    u8 i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(IRED==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">      time_cnt=<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">while</span>((!IRED)&amp;&amp;(time_cnt))<span class="comment">//等待引导信号 9ms 低电平结束， 若超过 10ms强制退出</span></span><br><span class="line">	  &#123;</span><br><span class="line">            delay_10us(<span class="number">1</span>);<span class="comment">//延时约 10us</span></span><br><span class="line">            time_cnt--;</span><br><span class="line">            <span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      <span class="keyword">if</span>(IRED)<span class="comment">//引导信号 9ms 低电平已过， 进入 4.5ms 高电平</span></span><br><span class="line">	  &#123;</span><br><span class="line">        time_cnt=<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">while</span>(IRED&amp;&amp;time_cnt)<span class="comment">//等待引导信号 4.5ms 高电平结束， 若超过 5ms 强制退出</span></span><br><span class="line">		&#123;</span><br><span class="line">                delay_10us(<span class="number">1</span>);</span><br><span class="line">            	time_cnt--;</span><br><span class="line">            	<span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//循环 4 次， 读取 4 个字节数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环 8 次读取每位数据即一个字节</span></span><br><span class="line">			&#123;</span><br><span class="line">				time_cnt=<span class="number">600</span>;</span><br><span class="line">				<span class="keyword">while</span>((IRED==<span class="number">0</span>)&amp;&amp;time_cnt)<span class="comment">//等待数据 1 或 0 前面的 0.56ms结束， 若超过 6ms 强制退出</span></span><br><span class="line">				&#123;</span><br><span class="line">                    delay_10us(<span class="number">1</span>);</span><br><span class="line">                    time_cnt--;</span><br><span class="line">                    <span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                time_cnt=<span class="number">20</span>;</span><br><span class="line">				<span class="keyword">while</span>(IRED)<span class="comment">//等待数据 1 或 0 后面的高电平结束， 若超过 2ms 强制退出</span></span><br><span class="line">				&#123;</span><br><span class="line">                    delay_10us(<span class="number">10</span>);<span class="comment">//约 0.1ms</span></span><br><span class="line">                    ired_high_time++;</span><br><span class="line">                    <span class="keyword">if</span>(ired_high_time&gt;<span class="number">20</span>)<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                gired_data[i]&gt;&gt;=<span class="number">1</span>;<span class="comment">//先读取的为低位， 然后是高位</span></span><br><span class="line">				<span class="keyword">if</span>(ired_high_time&gt;=<span class="number">8</span>)<span class="comment">//如果高电平时间大于 0.8ms， 数据则为1， 否则为 0</span></span><br><span class="line">                gired_data[i]|=<span class="number">0x80</span>;</span><br><span class="line">                ired_high_time=<span class="number">0</span>;<span class="comment">//重新清零， 等待下一次计算时间</span></span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">        <span class="keyword">if</span>(gired_data[<span class="number">2</span>]!=~gired_data[<span class="number">3</span>])<span class="comment">//校验控制码与反码， 错误则返回</span></span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            gired_data[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进入中断函数， 表示以来下降沿， 然后判断管脚是否为低电平， 如果为低电平则首先判断引导信号， 根据前面 NEC 协议可知， 引导信号有 9ms 的低电平和4.5ms 的高电平， 因此通过 time_cnt 赋值 1000， 然后在 while 循环内判断， time_cnt 每递减一次约 10us， 1000 次则为 10ms， 在解码时， 这个时间要适当放宽一点范围， 因为不同传感器性能会有差异， 所以此处以 10ms 的低电平为界限，如果超过 10ms 则强制退出， 防止系统死机。 判断完引导信号的低电平， 接着判断高电平， 实现方法一样。 当引导信号判断完成后进入地址码、 地址反码、 控制码及控制反码共 4 个字节的数据判断， 也就是数据 0 和 1 的判断， 实现方法也是和前面判断引导信号一样， 这里使用到了嵌套循环， 外层循环次数是 4， 表示读取 4 个字节， 内层循环次数是 8， 表示读取每个字节的 8 位。 注意， 红外遥控解码数据是从低位开始， 最后是高位。  </p>
<p>最后将读取的 4 个字节数据存储在全局变量数组 gired_data 中， 外部可直接使用这四个字节。  </p>
<h5 id="主函数-2"><a href="#主函数-2" class="headerlink" title="主函数"></a>主函数</h5><p>打开 main.c 文件， 代码如下  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 红外遥控实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示数码管上显示红外解码遥控器键值</span></span><br><span class="line"><span class="comment">注意事项： 红外接收头凸起处要与 PCB 板接口凸起丝印处对应</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ired.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ired_buf[<span class="number">3</span>];</span><br><span class="line">    ired_init();<span class="comment">//红外初始化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        ired_buf[<span class="number">0</span>]=gsmg_code[gired_data[<span class="number">2</span>]/<span class="number">16</span>];<span class="comment">//将控制码高 4 位转换为数码管段码</span></span><br><span class="line">        ired_buf[<span class="number">1</span>]=gsmg_code[gired_data[<span class="number">2</span>]%<span class="number">16</span>];<span class="comment">//将控制码低 4 位转换为数码管段码</span></span><br><span class="line">        ired_buf[<span class="number">2</span>]=<span class="number">0X76</span>;<span class="comment">//显示 H 的段码</span></span><br><span class="line">        smg_display(ired_buf,<span class="number">6</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数代码很简单， 首先调用使用的外设头文件， 然后初始化红外， 进入while 循环将红外解码数据转换为数码管段码数据， 然后在数码管上显示。  </p>
<h4 id="实验现象-11"><a href="#实验现象-11" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示红外解码遥控器键值。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619084925918.png" alt="image-20230619084925918"></p>
<p>注意： ==红外接收头的凸起位置需对到 PCB 板丝印凸出位置， 否则功能无法正常实现。 出厂时的遥控器电池盖内都有一张绝缘片， 使用时必须将此绝缘片拿掉。 还有键值码不是大家所想的按键上的数字字符码， 这个要区分开==。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619084944057.png" alt="image-20230619084944057">        <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085026365.png" alt="image-20230619085026365"></p>
<p>实验说明： 我们配的遥控器所有键的地址码与反码都是相同的， 不同的是控制码和控制反码， 其实知道了控制码就知道了控制反码， 所以如果要使用红外遥控控制其他设备， 可以通过区分控制码来实现。  </p>
<p>如果程序下载了， 能显示“00H” ， 按键时却没有反应， 首先检查遥控器是否拔下绝缘片。 如果要检查遥控器好坏， 可以在光线暗的地方， 打开手机摄像机，将遥控器前方的发射灯对准手机摄像头， 按下按键， 在手机上是否能看见灯闪，来判断遥控器好坏。  </p>
<h3 id="ADC模数转换实验"><a href="#ADC模数转换实验" class="headerlink" title="ADC模数转换实验"></a>ADC模数转换实验</h3><p>在前面章节， 我们介绍的都是对数字信号的操作也就是 0 和 1 操作， 本章我们就来讲解如何检测外部模拟信号， 因为我们使用的 STC89C5x 单片机内部不含ADC 接口， 所以需要外接一个 ADC 转换芯片将模拟信号转换成数字信号供单片机处理。 我们开发板上集成了一个 ADC 模数转换电路， 选用的 ADC 芯片是 12 位的AD 芯片-XPT2046。 本章要实现的功能是： 通过 ADC 转换电路采集电位器电压值，将采集转换后的 AD 值通过数码管显示。  </p>
<h4 id="ADC介绍"><a href="#ADC介绍" class="headerlink" title="ADC介绍"></a>ADC介绍</h4><p>我们知道 51 单片机系统内部运算时用的全部是数字量， 即 0 和 1， 因此对单片机系统而言， 无法直接操作模拟量， 必须将模拟量转换成数字量。 所谓数字量， 就是用一系列 0 和 1 组成的二进制代码表示某个信号大小的量。 用数字量表示同一个模拟量时， 数字位数可以多也可以少， 位数越多则表示的精度越高，位数越少表示的精度就越低。  </p>
<h4 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h4><p>ADC（analog to digital converter） 也称为模数转换器， 是指一个将模拟信号转变为数字信号。 单片机在采集模拟信号时， 通常都需要在前端加上 A/D 芯片。  </p>
<p>下面我们看下 ADC 的主要技术指标：  </p>
<p>（1） 分辨率  </p>
<p>ADC 的分辨率是指对于允许范围内的模拟信号， 它能输出离散数字信号值的个数。 这些信号值通常用二进制数来存储， 因此分辨率经常用比特作为单位， 且这些离散值的个数是 2 的幂指数。  </p>
<p>例如： 12 位 ADC 的分辨率就是 12 位， 或者说分辨率为满刻度的 1/(2^12)。一个 10V 满刻度的 12 位 ADC 能分辨输入电压变化最小值是</p>
<p>​                                    10V× 1/(212 )=2.4mV  </p>
<p>（2） 转换误差  </p>
<p>转换误差通常是以输出误差的最大值形式给出。 它表示 A/D 转换器实际输出的数字量和理论上的输出数字量之间的差别。 常用最低有效位的倍数表示。 例如给出相对误差≤±LSB/2， 这就表明实际输出的数字量和理论上应得到的输出数字量之间的误差小于最低位的半个字。  </p>
<p>（3） 转换速率  </p>
<p>ADC 的转换速率是能够重复进行数据转换的速度， 即每秒转换的次数。 而完成一次 A/D 转换所需的时间（包括稳定时间） ， 则是转换速率的倒数  </p>
<h4 id="ADC-转换原理"><a href="#ADC-转换原理" class="headerlink" title="ADC 转换原理"></a>ADC 转换原理</h4><p>AD 转换器（ADC） 将模拟量转换为数字量通常要经过 4 个步骤： 采样、 保持、量化和编码。 所谓采样即是将一个时间上连续变化的模拟量转换为时间上离散变化的模拟量。 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085326801.png" alt="image-20230619085326801"></p>
<p>将采样结果存储起来， 直到下次采样， 这个过程叫做保持。 一般采样器和保持电路一起总称为采样保持电路。 将采样电平归化为与之接近的离散数字电平，这个过程叫做量化。 将量化后的结果按照一定数制形式表示就是编码。 将采样电平（模拟值） 转换为数字值时， 主要有两类方法： 直接比较型与间接比较型。  </p>
<p>—直接比较型： 就是将输入模拟信号直接与标准的参考电压比较， 从而得到数字量。 常见的有并行 ADC 和逐次比较型 ADC。  </p>
<p>—间接比较型： 输入模拟量不是直接与参考电压比较， 而是将二者变为中间的某种物理量在进行比较， 然后将比较所得的结果进行数字编码。 常见的有双积分型 ADC。  </p>
<p>下面就以常用的逐次比较型 ADC 和双积分型 ADC 介绍其工作原理。  </p>
<p>（1） 逐次逼近型 ADC  </p>
<p>采用逐次逼近法的 AD 转换器是有一个比较器、 DA 转换器、 缓冲寄存器和控制逻辑电路组成， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085416215.png" alt="image-20230619085416215"></p>
<p>基本原理是： 从高位到低位逐次试探比较， 就像用天平秤物体， 从重到轻逐级增减砝码进行试探。 逐次逼近法的转换过程是： 初始化时将逐次逼近寄存器各位清零， 转换开始时， 先将逐次逼近寄存器最高位置 1， 送入 DA 转换器， 经 DA转换后生成的模拟量送入比较器， 称为 U0， 与送入比较器的待转换的模拟量 Ux进行比较， 若 U0&lt;Ux， 该位 1 被保留， 否则被清除。 然后再将逐次逼近寄存器次高位置 1， 将寄存器中新的数字量送 DA 转换器， 输出的 U0 再与 Ux 比较， 若 U0&lt;Ux，该位 1 被保留， 否则被清除。 重复此过程， 直至逼近寄存器最低位。 转换结束后，将逐次逼近寄存器中的数字量送入缓冲寄存器， 得到数字量的输出。 逐次逼近的操作过程是在一个控制电路的控制下进行的。  </p>
<p>（2） 双积分型 ADC  </p>
<p>采用双积分法的 AD 转换器由电子开关、 积分器、 比较器和控制逻辑等部件组成。 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085438807.png" alt="image-20230619085438807"></p>
<p>其基本原理： 将输入电压变换成与其平均值成正比的时间间隔， 再把此时间间隔转换成数字量， 属于间接转换。 双积分法 AD 转换的过程是： 先将开关接通待转换的模拟量 Vi， Vi 采样输入到积分器， 积分器从零开始进行固定时间 T 的正向积分， 时间 T 到后， 开关再接通与 Vi 极性相反的基准电压 Vref， 将 Vref输入到积分器， 进行反向积分， 直到输出为 0V 时停止积分。 Vi 越大， 积分器输出电压越大， 反向积分时间也越长。 计数器在反向积分时间内所计的数值， 就是输入模拟电压 Vi 所对应的数字量， 实现了 AD 转换。  </p>
<h4 id="XPT2046芯片介绍"><a href="#XPT2046芯片介绍" class="headerlink" title="XPT2046芯片介绍"></a>XPT2046芯片介绍</h4><p>XPT2046 是一款 4 线制电阻式触摸屏控制器， 内含 12 位分辨率 125KHz转换速率逐步逼近型 A/D 转换器。 XPT2046 支持从 1.5V 到 5.25V 的低电压I/O 接口。 XPT2046 能通过执行两次 A/D 转换查出被按的屏幕位置， 除此之外，还可以测量加在触摸屏上的压力。 内部自带 2.5V 参考电压， 可以作为辅助输入、温度测量和电池监测之用， 电池监测的电压范围可以从 0V 到 6V。 XPT2046 片内集成有一个温度传感器。 在 2.7V 的典型工作状态下， 关闭参考电压， 功耗可小于 0.75mW。 XPT2046 采用微小的封装形式： TSSOP-16,QFN-16 和 VFBGA－48。工作温度范围为-40℃～+85℃。 与 ADS7846、 TSC2046、 AK4182A 完全兼容。  </p>
<p>（1） 主要特性<br>①工作电压范围为 1.5V～5.25V<br>②支持 1.5V～5.25V 的数字 I/O 口<br>③内建 2.5V 参考电压源<br>④电源电压测量（ 0V~6V）<br>⑤内建结温测量功能</p>
<p>⑥触摸压力测量<br>⑦采用 3 线制 SPI 通信接口<br>⑧具有自动省电功能</p>
<p>（2） 芯片管脚说明  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085544095.png" alt="image-20230619085544095">    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085549687.png" alt="    "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085614968.png" alt="image-20230619085614968"></p>
<p>XPT2046 是一种典型的逐次逼近型模数转换器（SAR ADC） ， 包含了采样/保持、 模数转换、 串口数据 输出等功能。 同时芯片集成有一个 2.5V 的内部参考电压源、 温度检测电路， 工作时使用外部时钟。 XPT2046 可以单电源供电， 电源电压范围为 2.7V～5.5V。 参考电压值直接决定 ADC 的输入范围， 参考电压可以使用内部参考电压， 也可以从外部直接输入 1V～VCC 范围内的参考电压（要求外部参考电压源输出阻抗低） 。 X、 Y、 Z、 VBAT、 Temp 和 AUX 模拟信号经过片内的控制寄存器选择后进入 ADC， ADC 可以配置为单端或差分模式。 选择 VBAT、 Temp和 AUX 时应该配置为单端模式； 作为触摸屏应用时， 应该配置为差分模式， 这可有效消除由于驱动开关的寄生电阻及外部的干扰带来的测量误差， 提高转换精度。 单端和差分模式输入配置如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085635113.png" alt="image-20230619085635113"></p>
<p>XPT2046 数据接口是串行接口， 其典型工作时序如下图所示， 图中展示的信号来自带有基本串行接口的单片机或数据信号处理器。 处理器和转换器之间的的通信需要 8 个时钟周期， 可采用 SPI、 SSI 和 Microwire 等同步串行接口。 一次完整的转换需要 24 个串行同步时钟（DCLK） 来完成。  </p>
<p>前 8 个时钟用来通过 DIN 引脚输入控制字节。 当转换器获取有关下一次转换的足够信息后， 接着根据获得的信息设置输入多路选择器和参考源输入， 并进入采样模式， 如果需要， 将启动触摸面板驱动器。 3 个多时钟周期后， 控制字节设置完成， 转换器进入转换状态。 这时， 输入采样－保持器进入保持状态， 触摸面板驱动器停止工作（单端工作模式） 。 接着的 12 个时钟周期将完成真正的模数转换。 如果是度量比率转换方式（SER/DFR＝0） ， 驱动器在转换过程中将一直工作， 第 13 个时钟将输出转换结果的最后一位。 剩下的 3 个多时钟周期将用来完成被转换器忽略的最后字节（DOUT 置低） 。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085655240.png" alt="image-20230619085655240"></p>
<p>在对 XPT2046 进行控制时， 控制字节由 DIN 输入的控制字命令格式如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085704132.png" alt="image-20230619085704132"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085707280.png" alt="image-20230619085707280"></p>
<p>至此， 我们就对 ADC 的基本原理及 XPT2046 芯片介绍完， 大家如果想要更详细的了解其工作原理， 可以查看资料“\6—开发板芯片资料\开发板芯片数据手册\xpt2046 中文.pdf” 。  </p>
<h4 id="硬件设计-17"><a href="#硬件设计-17" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管<br>（2） ADC 模块</p>
<p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面来看下开发板上 ADC 模块电路， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085743661.png" alt="image-20230619085743661"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085746616.png" alt="image-20230619085746616"></p>
<p>从上图中可以看出， 该电路是集成的， XPT2046 芯片的控制管脚接至单片机P3.4~P3.7 管脚上， XPT2046 芯片的 ADC 输入转换通道分别接入了 AD1 电位器、NTC1 热敏传感器、 GR1 光敏传感器， 还有一个外接通道 AIN3 接在 DAC（PWM） 模块的 J52 端子上供外部模拟信号检测。  </p>
<p>注意： 上图中 XPT2046 的 DOUT 脚与 DS18B20 温度传感器均连接到单片机的P3.7， 因此该两个外设资源不能同时使用， 可以分时复用。  </p>
<h4 id="软件设计-16"><a href="#软件设计-16" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示 AD 模块采集电位器的电压值。程序框架如下：  </p>
<p>（1） 编写数码管显示功能<br>（2） 编写 ADC 转换函数<br>（3） 编写主函数</p>
<p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 XPT2046 读写数据上。   这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p>
<h5 id="ADC读写函数"><a href="#ADC读写函数" class="headerlink" title="ADC读写函数"></a>ADC读写函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xpt2046.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_wirte_data</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 写数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xpt2046_wirte_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次传输一位， 共一个字节</span></span><br><span class="line">    &#123;</span><br><span class="line">    DIN = dat &gt;&gt; <span class="number">7</span>;<span class="comment">//先传高位再传低位</span></span><br><span class="line">    dat &lt;&lt;= <span class="number">1</span>;<span class="comment">//将低位移到高位</span></span><br><span class="line">    CLK = <span class="number">1</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">    _nop_();</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_read_data</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 读数据</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : XPT2046 返回 12 位数据</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u16 <span class="title function_">xpt2046_read_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u16 dat=<span class="number">0</span>;</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)<span class="comment">//循环 12 次， 每次读取一位， 大于一个字节数， 所以返回值类型是 u16</span></span><br><span class="line">   &#123;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        CLK = <span class="number">1</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">        CLK = <span class="number">0</span>; <span class="comment">//CLK 由高到低产生一个下降沿， 从而读取数据</span></span><br><span class="line">        _</span><br><span class="line">        <span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">        dat |= DOUT;<span class="comment">//先读取高位， 再读取低位。</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_read_adc_value</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 读 AD 数据</span></span><br><span class="line"><span class="comment">* 输 入 : cmd： 指令</span></span><br><span class="line"><span class="comment">* 输 出 : XPT2046 返回 AD 值</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u16 <span class="title function_">xpt2046_read_adc_value</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u16 adc_value=<span class="number">0</span>;</span><br><span class="line">    CLK = <span class="number">0</span>;<span class="comment">//先拉低时钟</span></span><br><span class="line">    CS = <span class="number">0</span>;<span class="comment">//使能 XPT2046</span></span><br><span class="line">    xpt2046_wirte_data(cmd);<span class="comment">//发送命令字</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">6</span>; i&gt;<span class="number">0</span>; i--);<span class="comment">//延时等待转换结果</span></span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    CLK = <span class="number">1</span>;<span class="comment">//发送一个时钟， 清除 BUSY</span></span><br><span class="line">    _nop_();</span><br><span class="line">    adc_value=xpt2046_read_data();</span><br><span class="line">    CS = <span class="number">1</span>;<span class="comment">//关闭 XPT2046</span></span><br><span class="line">    <span class="keyword">return</span> adc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面 XPT2046 时序图可知， XPT2046 完成一个完整的转换需要 24 个串行时钟， 也就是需要 3 个字节的 SPI 时钟。 XPT2046 前 8 个串行时钟， 是接收 1 个字节的转换命令， 接收到转换命令了之后， 然后使用 1 个串行时钟的时间来完成数据转换（当然在编写程序的时候， 为了得到精确的数据， 你可以适当的延时一下） ， 然后返回 12 个字节长度（12 个字节长度也计时 12 个串行时钟） 的转换结果。 然后最后 4 个串行时钟返回 4 个无效数据， 可以忽略。xpt2046_read_adc_value 函数就是按照这个时序实现。 至于xpt2046_wirte_data 和 xpt2046_read_data 函数是 IO 口模拟的 SPI 读写时序，与 DS1302 的读写是一样的。  </p>
<p>上述代码使用的管脚在 xpt2046 头文件已定义， 这里就不列出。  </p>
<h5 id="主函数-3"><a href="#主函数-3" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： ADC 模数转换实验--电位器电压采集</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示 AD 模块采集电位器的电压值</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xpt2046.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 adc_value=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> adc_vol;<span class="comment">//ADC 电压值</span></span><br><span class="line">    u8 adc_buf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        adc_value=xpt2046_read_adc_value(<span class="number">0x94</span>);<span class="comment">//测量电位器</span></span><br><span class="line">        adc_vol=<span class="number">5.0</span>*adc_value/<span class="number">4096</span>;<span class="comment">//将读取的 AD 值转换为电压</span></span><br><span class="line">        adc_value=adc_vol*<span class="number">10</span>;<span class="comment">//放大 10 倍， 即保留小数点后一位</span></span><br><span class="line">        adc_buf[<span class="number">0</span>]=gsmg_code[adc_value/<span class="number">10</span>]|<span class="number">0x80</span>;</span><br><span class="line">        adc_buf[<span class="number">1</span>]=gsmg_code[adc_value%<span class="number">10</span>];</span><br><span class="line">        adc_buf[<span class="number">2</span>]=<span class="number">0x3e</span>;<span class="comment">//显示单位 V</span></span><br><span class="line">        smg_display(adc_buf,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数代码非常简单， 首先调用外设头文件， 然后定义一些变量存储 AD 值和电压值， 进入 while 循环， 读取电位器的 AD 值， 根据 XPT2046 单端模式输入配置表可知， 要采集 X+脚通道的信号， 则配置值为 0X94。 得到 AD 值后， 可按照如下公式计算电压值： Vref*ADC_Value/分辨率。  </p>
<p>其中 Vref 是参考电压， XPT2046 接入的是 5V， ADC_Value 是读取的 AD 值，分辨率是 ADC 的位数（212=4096） 。  </p>
<p>经过公式计算后会得到小数， 所以定义了一个 float 型变量 adc_vol 存储，然后将该值放大 10 倍， 目的是保留小数后一位。 最后将得到的电压值转换为数码管段码数据显示。  </p>
<h4 id="实验现象-12"><a href="#实验现象-12" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示 AD 模块采集电位器的电压值。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619090932392.png" alt="image-20230619090932392"></p>
<p>注意： 调节电位器 AD1 时， 数码管上显示的电压值也将变化。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619090943449.png" alt="image-20230619090943449"></p>
<p>对于光敏电阻和热敏电阻以及 AIN3 外部采集通道实验， 大家可以直接打开实验工程， 它们与电位器电压采集程序相比仅仅是配置命令不同而已。  </p>
<p>==电位器对应的采集通道命令： 0X94==<br>==光敏电阻对应的采集通道命令： 0XA4==<br>==热敏电阻对应的采集通道命令： 0XD4==<br>==外部输入 AIN3 对应的采集通道命令： 0XE4==</p>
<h3 id="DAC数模转换实验"><a href="#DAC数模转换实验" class="headerlink" title="DAC数模转换实验"></a>DAC数模转换实验</h3><p>在前面章节， 我们介绍了如何使用 51 单片机来采集外部模拟信号， 这一章来介绍下如何使用 51 单片机输出模拟信号， 要让 51 单片机输出模拟信号， 同样需要相应的转换器， 这种转换器我们称之为 DAC 数模转换器， 但 DAC 专用芯片价格是比较高的， 在实际应用中通常使用 PWM 技术来模拟 DAC 输出。 我们开发板上集成了一个 DAC(PWM)模块电路， 通过单片机 IO 口生成 PWM 波来模拟 DAC 输出。本章要实现的功能是： 系统运行时， DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果，由暗变亮再由亮变暗。 学习本章可以参考前面的实验章节内容。   </p>
<h4 id="DAC介绍"><a href="#DAC介绍" class="headerlink" title="DAC介绍"></a>DAC介绍</h4><h5 id="DAC简介"><a href="#DAC简介" class="headerlink" title="DAC简介"></a>DAC简介</h5><p>DAC（Digital to analog converter） 即数字模拟转换器， 它可以将数字信号转换为模拟信号。 它的功能与 ADC 相反。 在常见的数字信号系统中， 大部分传感器信号被转化成电压信号， 而 ADC 把电压模拟信号转换成易于计算机存储、处理的数字编码， 由计算机处理完成后， 再由 DAC 输出电压模拟信号， 该电压模拟信号常常用来驱动某些执行器件， 使人类易于感知。 如音频信号的采集及还原就是这样一个过程。</p>
<p>DAC 的主要技术指标如下：</p>
<p>（1）分辨率</p>
<p>DAC 的分辨率是输入数字量的最低有效位（LSB） 发生变化时， 所对应的输出模拟量（电压或电流） 的变化量。 它反映了输出模拟量的最小变化值。 分辨率与输入数字量的位数有确定的关系， 可以表示成 FS /（2^n） 。 FS 表示满量程输入值， n 为二进制位数。 对于 5V 的满量程， 采用８ 位的 DAC 时， 分辨率为 5V/256 ＝19.5mV； 当采用 12 位的 DAC 时， 分辨率则为 5V/4096＝1.22mV。 显然， 位数越多分辨率就越高。  </p>
<p>（2）线性度</p>
<p>线性度（也称非线性误差） 是实际转换特性曲线与理想直线特性之间的最大偏差。 常以相对于满量程的百分数表示。 如±１ ％是指实际输出值与理论值之差在满刻度的±１ ％以内。  </p>
<p>（3）绝对精度和相对精度  </p>
<p>绝对精度（简称精度） 是指在整个刻度范围内， 任一输入数码所对应的模拟量实际输出值与理论值之间的最大误差。 绝对精度是由 DAC 的增益误差（当输入数码为全 1 时， 实际输出值与理想输出值之差） 、 零点误差（数码输入为全０ 时， DAC 的非零输出值） 、 非线性误差和噪声等引起的。 绝对精度（即最大误差） 应小于 1 个 LSB。 相对精度与绝对精度表示同一含义， 用最大误差相对于满刻度的百分比表示。</p>
<p>（4）建立时间</p>
<p>建立时间是指输入的数字量发生满刻度变化时， 输出模拟信号达到满刻度值的± 1/2LSB 所需的时间。 是描述 D/A 转换速率的一个动态指标。 根据建立时间的长短， 可以将 DAC 分成超高速（＜1μ S)、 高速（10～1μ S） 、 中速（100～10 μ S） 、 低速（≥100μ S） 几档。  </p>
<h5 id="DAC工作原理"><a href="#DAC工作原理" class="headerlink" title="DAC工作原理"></a>DAC工作原理</h5><p>了解了 DAC 基本概念及特性后， 再来看下其工作原理， 下面以Ｔ 型电阻网络DAC 来介绍。 其内部结构图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623113905674.png" alt="image-20230623113905674"></p>
<p>​                                DAC 输出电压计算公式： V0=Vref*z/256  </p>
<p>公式中的 z 表示单片机给的数字量， vref 为参考电压， 通常我们是接在系统电源上， 即 5V， 数值 256 表示 DAC 精度为 8 位。  </p>
<p>DAC 主要由数字寄存器、 模拟电子开关、 位权网络、 求和运算放大器和基准电压源（或恒流源） 组成。 用存于数字寄存器的数字量的各位数码， 分别控制对应位的模拟电子开关， 使数码为 1 的位在位权网络上产生与其位权成正比的电流值， 再由运算放大器对各电流值求和， 并转换成电压值。  </p>
<p>上述的模拟电子开关都分别接着一个分压的器件， 比如说电阻。 模拟开关的个数取决于 DAC 的精度。 那么 N 个电子开关就把基准电压分为 N 份（并不是平均分哦） ， 而这些开关根据输入的二进制每一位数据对应开启或者关闭， 把分压的器件上的电压引入输出电路中。  </p>
<h4 id="PWM介绍"><a href="#PWM介绍" class="headerlink" title="PWM介绍"></a>PWM介绍</h4><p>出于成本考虑， 在实际开发应用中， 使用较多的是通过 PWM 来模拟 DAC 输出。下面就先来了解下 PWM 相关概念。  </p>
<p>PWM 是 Pulse Width Modulation 的缩写， 中文意思就是脉冲宽度调制， 简称脉宽调制。 它是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术， 其控制简单、 灵活和动态响应好等优点而成为电力电子技术最广泛应用的控制方式， 其应用领域包括测量， 通信， 功率控制与变换， 电动机控制、 伺服控制、 调光、 开关电源， 甚至某些音频放大器， 因此学习 PWM 具有十分重要的现实意义。  </p>
<p>其实我们也可以这样理解， PWM 是一种对模拟信号电平进行数字编码的方法。 通过高分辨率计数器的使用， 方波的占空比被调制用来对一个具体模拟信号的电平进行编码。 PWM 信号仍然是数字的， 因为在给定的任何时刻， 满幅值的直流供电要么完全有(ON)， 要么完全无(OFF)。 电压或电流源是以一种通(ON)或断(OFF)的重复脉冲序列被加到模拟负载上去的。 通的时候即是直流供电被加到负载上的时候， 断的时候即是供电被断开的时候。 只要带宽足够， 任何模拟值都可以使用 PWM 进行编码。  </p>
<p>PWM 对应模拟信号的等效图， 如下图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114011095.png" alt="image-20230623114011095"></p>
<p>从图中可以看到， 上图 a 是一个正弦波即模拟信号， b 是一个数字脉冲波形即数字信号。 我们知道在计算机系统中只能识别是 1 和 0， 对于 51 单片机芯片， 要么输出高电平（5V） ， 要么输出低电平（0） ， 假如要输出 1.5V 的电压， 那么就必须通过相应的处理， 比如本章所要讲解的 PWM 输出， 其实从上图也可以看到， 只要保证数字信号脉宽足够就可以使用 PWM 进行编码， 从而输出1.5V的电压。</p>
<p>PWM 的输出其实就是对外输出脉宽可调（即占空比调节） 的方波信号， 信号频率是由 T 的值决定， 占空比由 C 的值决定。 其示意图如图所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114107284.png" alt="image-20230623114107284"></p>
<p>从上图中可以看到， PWM 输出频率是不变的， 改变的是 C 的值， 此值的改变将导致 PWM 输出信号占空比的改变。 占空比其实就是一个周期内高电平时间与周期的比值。 而频率的话可以使用 51 单片机的定时器确定。  </p>
<h4 id="硬件设计-18"><a href="#硬件设计-18" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） DAC(PWM)模块<br>下面来看下开发板上 DAC(PWM)模块电路， 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114148609.png" alt="image-20230623114148609"></p>
<p>从上图中可知， PWM 输出控制管脚接在单片机 P2.1 管脚上， DAC1 为 PWM 输出信号， 将其连接一个 LED， 这样可以通过指示灯的状态直观的反映出 PWM 输出电压值变化。 LM358 芯片与这些电容电阻构成了一个跟随电路， 即输入是多少，输出即为多大电压， 输出电压范围是 0-5V。 输出信号由 J52 端子的 DAC1 引出，在其端子上还有一个 AIN3 脚， 它是上一章介绍 ADC 时的外部模拟信号输入通道。  </p>
<p>如果使用短接片将 DAC1 和 AIN3 短接， 这样就可以使用 XPT2046 芯片采集检测PWM 输出信号。  </p>
<h4 id="软件设计-17"><a href="#软件设计-17" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗。  </p>
<p>程序框架如下：<br>（1） 编写 PWM 函数<br>（2） 编写主函数</p>
<p>本章软件的重点是如何让单片机 IO 口输出 PWM。 下面我们打开“\4—实验程序\1—基础实验\24-DAC 数模转换实验” 工程， 在 App 工程组中可以看到新添加了 pwm.c 文件（里面包含了 PWM 驱动程序） ， 还要包含对应的头文件路径。</p>
<p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p>
<h5 id="PWM实现函数"><a href="#PWM实现函数" class="headerlink" title="PWM实现函数"></a>PWM实现函数</h5><p>PWM 的实现均在 pwm.c 文件中， 代码如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"><span class="comment">//全局变量定义</span></span><br><span class="line">u8 gtim_h=<span class="number">0</span>;<span class="comment">//保存定时器初值高 8 位</span></span><br><span class="line">u8 gtim_l=<span class="number">0</span>;<span class="comment">//保存定时器初值低 8 位</span></span><br><span class="line">u8 gduty=<span class="number">0</span>;<span class="comment">//保存 PWM 占空比</span></span><br><span class="line">u8 gtim_scale=<span class="number">0</span>;<span class="comment">//保存 PWM 周期=定时器初值*tim_scale</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : pwm_init</span></span><br><span class="line"><span class="comment">* 函数功能 : PWM 初始化函数</span></span><br><span class="line"><span class="comment">* 输 入 : tim_h： 定时器高 8 位</span></span><br><span class="line"><span class="comment">tim_l： 定时器低 8 位</span></span><br><span class="line"><span class="comment">tim_scale： PWM 周期倍数： 定时器初值*tim_scale</span></span><br><span class="line"><span class="comment">duty： PWM 占空比（要小于等于 tim_scale）</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm_init</span><span class="params">(u8 tim_h,u8 tim_l,u16 tim_scale,u8 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    gtim_h=tim_h;<span class="comment">//将传入的初值保存在全局变量中， 方便中断函数继续调用</span></span><br><span class="line">    gtim_l=tim_l;</span><br><span class="line">    gduty=duty;</span><br><span class="line">    gtim_scale=tim_scale;</span><br><span class="line">    TMOD|=<span class="number">0X01</span>; <span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">    TH0 = gtim_h; <span class="comment">//定时初值设置</span></span><br><span class="line">    TL0 = gtim_l;</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : pwm_set_duty_cycle</span></span><br><span class="line"><span class="comment">* 函数功能 : PWM 设置占空比</span></span><br><span class="line"><span class="comment">* 输 入 : duty： PWM 占空比（要小于等于 tim_scale）</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm_set_duty_cycle</span><span class="params">(u8 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    gduty=duty;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm</span><span class="params">(<span class="type">void</span>)</span> interrupt 1 <span class="comment">//定时器 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 time=<span class="number">0</span>;</span><br><span class="line">    TH0 = gtim_h; <span class="comment">//定时初值设置</span></span><br><span class="line">    TL0 = gtim_l;</span><br><span class="line">    time++;</span><br><span class="line">    <span class="keyword">if</span>(time&gt;=gtim_scale)<span class="comment">//PWM 周期=定时器初值*gtim_scale， 重新开始计数</span></span><br><span class="line">    time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(time&lt;=gduty)<span class="comment">//占空比</span></span><br><span class="line">    PWM=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    PWM=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述代码主要是基于定时器实现 PWM 输出， PWM 初始化实际上为定时器 0 初始化， pwm_init 函数有 4 个入口参数， tim_h 和 tim_l 为定时器定时初值， 即进入中断时间； tim_scale 参数为 PWM 的周期倍数， 使用该值乘以定时器初值可得出 PWM 的周期； duty 参数为 PWM 占空比， 即一个周期内高电平所占的时间比例。在 pwm 初始化函数内， 将函数入口参数通过全局变量保存， 方便在后续中断函数内使用 。</p>
<p>pwm_set_duty_cycle 函数是占空比设置函数， 该函数有一个入口参数， 用于设置 PWM 占空比， 注意， 该值不能超过初始化中的 PWM 的周期倍数值。  </p>
<p>最后就是定时器 0 的中断服务函数， 在中断内定义了一个静态变量用于统计进入中断的次数时间， 当进入中断次数时间大于等于 gtim_scale 周期倍数， 则重新开始计数， 表示 PWM 周期为定时器初值*gtim_scale； 然后当计数次数时间小于等于设置的占空比次数时间， 则使对应 IO 输出高电平， 否则输出低电平。  </p>
<h5 id="主函数-4"><a href="#主函数-4" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DAC 模数转换实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 dir=<span class="number">0</span>;<span class="comment">//默认为 0</span></span><br><span class="line">    u8 duty=<span class="number">0</span>;</span><br><span class="line">    pwm_init(<span class="number">0XFF</span>,<span class="number">0XF6</span>,<span class="number">100</span>,<span class="number">0</span>);<span class="comment">//定时时间为 0.01ms， PWM 周期是100*0.01ms=1ms， 占空比为 0%</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dir==<span class="number">0</span>)<span class="comment">//当 dir 为递增方向</span></span><br><span class="line">      &#123;</span><br><span class="line">         duty++;<span class="comment">//占空比递增</span></span><br><span class="line">      <span class="keyword">if</span>(duty==<span class="number">70</span>)dir=<span class="number">1</span>;<span class="comment">//当到达一定值切换方向， 占空比最大能到 100， 但到达 70 左右再递增，</span></span><br><span class="line">    <span class="comment">//肉眼也分辨不出亮度变化</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        duty--;</span><br><span class="line">        <span class="keyword">if</span>(duty==<span class="number">0</span>)dir=<span class="number">0</span>;<span class="comment">//当到达一定值切换方向</span></span><br><span class="line">       &#125; </span><br><span class="line">    pwm_set_duty_cycle(duty);<span class="comment">//设置占空比</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);<span class="comment">//短暂延时， 让呼吸灯有一个流畅的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主函数比较简单， 首先调用外设驱动头文件， 然后进入主函数初始化 PWM，将定时器设置为 0.01ms， 初值为 0XFFF6， 即每隔 0.01ms 进入一次中断。 PWM 周期倍数设置为 100， 即 PWM 周期为 1ms， 占空比设置为 0。 最后进入 while 循环，通过 dir 切换方向实现 duty 值的自增和自减来调节占空比， 将该值传入到占空比调节函数 pwm_set_duty_cycl。 为了使呼吸灯流畅， 每调节占空比短暂延时一下。  </p>
<h4 id="实验现象-13"><a href="#实验现象-13" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114605939.png" alt="image-20230623114605939"></p>
<p>注意： ==实验中可通过 DA1 指示灯观察 PWM 输出， 也可使用万用表测量 DAC 和GND 电压， 观察电压变化==。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114622424.png" alt="image-20230623114622424"></p>
<h3 id="LCD1602-液晶显示实验"><a href="#LCD1602-液晶显示实验" class="headerlink" title="LCD1602 液晶显示实验"></a>LCD1602 液晶显示实验</h3><p>在前面章节， 我们已经学习过几种显示装置， 例如静态数码管、 动态数码管、8*8LED 点阵、 串口通信。 使用它们可以直观显示一些字符数据， 但是它们也有各种局限性， 比如显示字符数据太少， 硬件设计复杂、 代码编写难度大等。 这一章就来介绍一种非常简单且常用的显示装置—LCD1602 液晶显示器， 使用它可以显示更多的字符数字。 我们开发板上集成了一个 LCD1602 液晶显示器接口， 将LCD1602 液晶对应插入即可。 本章要实现的功能是： 系统运行时， 在 LCD1602 液晶上显示字符信息。   </p>
<h4 id="LCD1602-介绍"><a href="#LCD1602-介绍" class="headerlink" title="LCD1602 介绍"></a>LCD1602 介绍</h4><h5 id="LCD1602-简介"><a href="#LCD1602-简介" class="headerlink" title="LCD1602 简介"></a>LCD1602 简介</h5><p>1602 液晶也叫 1602 字符型液晶， 它能显示 2 行字符信息， 每行又能显示 16个字符。 它是一种专门用来显示字母、 数字、 符号的点阵型液晶模块。 它是由若干个 5x7 或者 5x10 的点阵字符位组成， 每个点阵字符位都可以用显示一个字符，每位之间有一个点距的间隔， 每行之间也有间隔， 起到了字符间距和行间距的作用， 正因为如此， 所以它不能很好的显示图片。 其实物图如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204441951.png" alt="image-20230623204441951"></p>
<p>大家手上拿到的 LCD1602 外观可能和上图不一样， 这是由于不同厂家设计所致， 但使用方法是一样的。 在上图中可以看到有 16 个管脚孔， 从左至右管脚编号顺序是 1-16， 其功能定义如下所示：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204454458.png" alt="image-20230623204454458"></p>
<p>下面对几个管脚做下说明：</p>
<p>3 脚： VL， 液晶显示偏压信号， 用于调整 LCD1602 的显示对比度， 一般会外接电位器用以调整偏压信号， 注意此脚电压为 0 时可以得到最强的对比度。</p>
<p>4 脚： RS， 数据/命令选择端， 当此脚为高电平时， 可以对 1602 进行数据字节的传输操作， 而为电平时， 则是进行命令字节的传输操作。 命令字节， 即是用来对 LCD1602 的一些工作方式作设置的字节； 数据字节， 即使用以在 1602 上显示的字节。 值得一提的是， LCD1602 的数据是 8 位的。 </p>
<p>5 脚： R/W， 读写选择端。 当此脚为高电平可对 LCD1602 进行读数据操作，反之进行写数据操作。</p>
<p>6 脚： E， 使能信号， 其实是 LCD1602 的数据控制时钟信号， 利用该信号的上升沿实现对 LCD1602 的数据传输。</p>
<p>7~14 脚： 8 位并行数据口， 而 51 单片机一组 IO 也是 8 位， 使得对 LCD1602的数据读写大为方便。</p>
<p>在 LCD1602 内部含有 80 个字节的 DDRAM， 它是用来寄存显示字符的。 其地址和屏幕的对应关系如下表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204540896.png" alt="image-20230623204540896"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204545684.png" alt="image-20230623204545684"></p>
<p>从上图可知， 不是所有的地址都可以直接用来显示字符数据， 只有第一行中的 00-0F， 第二行中的 40-4F 才能显示， 其他地址只能用于存储。 要显示字符时要先输入显示字符地址， 也就是告诉模块在哪里显示字符， 例如第二行第一个字符的地址是 40H， 那么是否直接写入 40H 就可以将光标定位在第二行第一个字符的位置呢？ 这样不行， 因为写入显示地址时要求最高位 D7 恒定为高电平 1所以实际写入的数据应该是 01000000B(40H） +10000000B(80H)=11000000B(C0H)。 在 1602 中我们就用前 16 个就行了。 第二行也一样用前 16 个地址。  </p>
<h5 id="LCD1602-常用指令"><a href="#LCD1602-常用指令" class="headerlink" title="LCD1602 常用指令"></a>LCD1602 常用指令</h5><p>在使用 LCD1602 时， 我们需要掌握一些常用的指令， 这些指令对于 LCD1602初始化是必须的。  </p>
<p>（1） 清屏指令  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204707058.png" alt="image-20230623204707058"></p>
<p>功能：</p>
<p><1> 清除液晶显示器， 即将 DDRAM 的内容全部填入”空白”的 ASCII 码 20H;</p>
<p><2> 光标归位， 即将光标撤回液晶显示屏的左上方;</p>
<p><3> 将地址计数器(AC)的值设为 0。</p>
<p>（2） 模式设置指令  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204731208.png" alt="image-20230623204731208"></p>
<p>功能：<br>设定每次写入 1 位数据后光标的移位方向， 并且设定每次写入的一个字符是否移动。<br>I/D： 0=写入新数据后光标左移 1=写入新数据后光标右移<br>S： 0=写入新数据后显示屏不移动 1=写入新数据后显示屏整体右移 1 个字符</p>
<p>（3） 显示开关控制指令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204755334.png" alt="image-20230623204755334"></p>
<p>功能：<br>控制显示器开/关、 光标显示/关闭以及光标是否闪烁。</p>
<p>D： 0=显示功能关     1=显示功能开</p>
<p>C： 0=无光标            1=有光标</p>
<p>B： 0=光标闪烁         1=光标不闪烁</p>
<p>（4） 功能设定指令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205053609.png" alt="image-20230623205053609"></p>
<p>功能：<br>设定数据总线位数、 显示的行数及字型。</p>
<p>DL： 0=数据总线为 4 位          1=数据总线为 8 位<br>N：   0=显示 1 行                     1=显示 2 行<br>F：   0=5× 7 点阵/每字符         1=5× 10 点阵/每字符</p>
<h5 id="LCD1602-使用"><a href="#LCD1602-使用" class="headerlink" title="LCD1602 使用"></a>LCD1602 使用</h5><p>要使用 LCD1602， 首先需要对其初始化， 即通过写入一些特定的指令实现。然后选择要在 LCD1602 的哪个位置显示并将所要显示的数据发送到 LCD 的DDRAM。 使用 LCD1602 通常都是用于写数据进去， 很少使用读功能。 LCD1602 操作步骤如下所示  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） 初始化</span><br><span class="line">（2） 写命令（RS=L） ， 设置显示坐标</span><br><span class="line">（3） 写数据（RS=H）</span><br></pre></td></tr></table></figure>
<p>在此， 不需要读出它的数据的状态或者数据本身。 所以只需要看两个写时序：  </p>
<p>①当要写指令字， 设置 LCD1602 的工作方式时： 需要把 RS 置为低电平， RW置为低电平， 然后将数据送到数据口 D0~D7， 最后 E 引脚一个高脉冲将数据写入。  </p>
<p>②当要写入数据字， 在 1602 上实现显示时： 需要把 RS 置为高电平， RW 置为低电平， 然后将数据送到数据口 D0~D7， 最后 E 引脚一个高脉冲将数据写入。  </p>
<p>写指令和写数据， 差别仅仅在于 RS 的电平不一样而已。 以下是 LCD1602 的时序图：  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205825355.png" alt="image-20230623205825355"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205830257.png" alt="image-20230623205830257"></p>
<p>从上图可以看到， 以上给的时间参数全部是 ns 级别的， 而 51 单片机的机器周期是 1us， 指令周期是 2-4 个机器周期， 所以即便在程序里不加延时程序， 也可以很好的配合 LCD1602 的时序要求了。  </p>
<p>当要写命令字节的时候， 时间由左往右， RS 变为低电平， R/W 变为低电平，注意看是 RS 的状态先变化完成。 然后这时， DB0~DB7 上数据进入有效阶段， 接着 E 引脚有一个整脉冲的跳变， 接着要维持时间最小值为 tpw=400ns 的 E 脉冲宽度。然后E引脚负跳变， RS电平变化， R/W 电平变化。这样便是一个完整的LCD1602写命令的时序。  </p>
<p>注意： 这里介绍的是 8 位 LCD1602， 现在某些公司为简化引脚数， 使用 4 位LCD1602。 使用 4 位 LCD1602 时， 应该多看手册， 找到不同点， 对原有程序加以修改。 我们例程也做了 4 位和 8 位 LCD1602 的兼容， 具体后面会介绍。  </p>
<p>至此， 我们就把 LCD1602 介绍完了， 大家如果想要更详细的了解它， 可以查看资料“\6—芯片资料\开发板芯片数据手册\LCD1602 液晶完整中文资料.pdf”。  </p>
<h4 id="硬件设计-19"><a href="#硬件设计-19" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：</p>
<p>（1） LCD1602 液晶</p>
<p>开发板上集成了一个 LCD1602 液晶接口， 下面来看下开发板上 LCD1602 液晶接口电路， 如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623210233002.png" alt="image-20230623210233002"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623210237507.png" alt="image-20230623210237507"></p>
<p>从上图中可知， LCD1602 的 8 位数据口 DB0-DB7 与单片机的 P0.0-P0.7 管脚连接， LCD1602 的 RS、 RW、 E 脚与单片机的 P2.6、 P2.5、 P2.7 管脚连接。 RJ1是一个电位器， 用来调节 LCD1602 对比度即显示亮度。  </p>
<p>注意： 这里原理图是使用的 8 位 LCD1602 接口设计， 是可以兼容 4 位 LCD1602的。 对于非标准接口的 LCD1602， 我们也会通过转接板将其转接为对应开发板接口的。 对于 4 位 LCD1602 在传输数据的时候需要将 8 位的数据截成两段， 先发送高四位， 在发送低四位。 其它引脚操作方法不变。  </p>
<h4 id="软件设计-18"><a href="#软件设计-18" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 在 LCD1602 液晶上显示字符信息。<br>程序框架如下：<br>（1） 编写 LCD1602 显示函数<br>（2） 编写主函数</p>
<p>本章软件的重点是如何对 LCD1602 进行写命令和数据。 下面我们打开“\4—实验程序\1—基础实验\25-LCD1602 液晶显示实验” 工程， 在 App 工程组中可以看到新添加了 lcd1602.c 文件（里面包含了 LCD1602 驱动程序） ， 还要包含对应的头文件路径。</p>
<p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p>
<h5 id="LCD1602-驱动函数"><a href="#LCD1602-驱动函数" class="headerlink" title="LCD1602 驱动函数"></a>LCD1602 驱动函数</h5><p>打开lcd1602.c文件，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_write_cmd</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 写命令</span></span><br><span class="line"><span class="comment">* 输 入 : cmd： 指令</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_cmd</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">0</span>;<span class="comment">//选择命令</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=cmd;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//4 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_cmd</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">0</span>;<span class="comment">//选择命令</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=cmd;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">    LCD1602_DATAPORT=cmd&lt;&lt;<span class="number">4</span>;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_write_data</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 写数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">1</span>;<span class="comment">//选择数据</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=dat;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">1</span>;<span class="comment">//选择数据</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=dat;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">    LCD1602_DATAPORT=dat&lt;&lt;<span class="number">4</span>;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_init</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 初始化</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x38</span>);<span class="comment">//数据总线 8 位， 显示 2 行， 5*7 点阵/字符</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x0c</span>);<span class="comment">//显示功能开， 无光标， 光标闪烁</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x06</span>);<span class="comment">//写入新数据后光标右移， 显示屏不移动</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x28</span>);<span class="comment">//数据总线 4 位， 显示 2 行， 5*7 点阵/字符</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x0c</span>);<span class="comment">//显示功能开， 无光标， 光标闪烁</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x06</span>);<span class="comment">//写入新数据后光标右移， 显示屏不移动</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_clear</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 清屏</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_show_string</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 显示字符</span></span><br><span class="line"><span class="comment">* 输 入 : x,y： 显示坐标， x=0~15， y=0~1;</span></span><br><span class="line"><span class="comment">         str： 显示字符串</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_show_string</span><span class="params">(u8 x,u8 y,u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">   u8 i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(y&gt;<span class="number">1</span>||x&gt;<span class="number">15</span>)<span class="keyword">return</span>;<span class="comment">//行列参数不对则强制退出</span></span><br><span class="line">   <span class="keyword">if</span>(y&lt;<span class="number">1</span>) <span class="comment">//第 1 行显示</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">while</span>(*str!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//字符串是以&#x27;\0&#x27;结尾， 只要前面有内容就显示</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;<span class="number">16</span>-x)<span class="comment">//如果字符长度超过第一行显示范围， 则在第二行继续显示</span></span><br><span class="line">		&#123;</span><br><span class="line">		lcd1602_write_cmd(<span class="number">0x80</span>+i+x);<span class="comment">//第一行显示地址设置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">		lcd1602_write_cmd(<span class="number">0x40</span>+<span class="number">0x80</span>+i+x<span class="number">-16</span>);<span class="comment">//第二行显示地址设置</span></span><br><span class="line">		&#125;</span><br><span class="line">		lcd1602_write_data(*str);<span class="comment">//显示内容</span></span><br><span class="line">		str++;<span class="comment">//指针递增</span></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//第 2 行显示</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">while</span>(*str!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">16</span>-x) <span class="comment">//如果字符长度超过第二行显示范围， 则在第一行继续显示</span></span><br><span class="line">	    &#123;</span><br><span class="line">			lcd1602_write_cmd(<span class="number">0x80</span>+<span class="number">0x40</span>+i+x);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			lcd1602_write_cmd(<span class="number">0x80</span>+i+x<span class="number">-16</span>);</span><br><span class="line">		&#125;</span><br><span class="line">			lcd1602_write_data(*str);</span><br><span class="line">			str++;</span><br><span class="line">			i++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在代码中可以看到有如下格式：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)</span></span><br><span class="line">...（省略内容 <span class="number">1</span>）</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...（省略内容 <span class="number">2</span>）</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这是 C 语言中的条件编译， 如果 LCD1602_4OR8_DATA_INTERFACE 值等于 0，则执行省略内容 1 部分， 否则执行省略内容 2 部分， 这个和 if…else 是类似的。而 LCD1602_4OR8_DATA_INTERFACE 是在 lcd1602.h 中定义好的宏， 用于选择使用的 LCD1602 是 8 位数据口还是 4 位数据口， 通过这个宏就可以兼容 8 位和 4 位 2款 LCD1602 驱动， 非常方便。 如果大家觉得代码过长， 可以将兼容的一块去掉，这样代码就简短明了。  </p>
<p>lcd1602_write_cmd 函数是 LCD1602 写命令， lcd1602_write_data 函数是LCD1602 写数据， 它们之间的区别仅在于控制脚 RS 的值， 如果为 0 则写命令，为 1 则写数据。 对于 8 位数据和 4 位数据口的驱动， 不同之处在于 8 位数据是一次性传输到端口， 而 4 位数据口需要将一个字节数据分两次传输， 高 4 位和低 4位。  </p>
<p>lcd1602_init 函数是 LCD1602 初始化函数， 根据其命令设置相应的值， 开启LCD1602 显示。  </p>
<p>lcd1602_clear 函数是 LCD1602 清屏函数， 实际上也是调用lcd1602_write_cmd 函数写 0X01 命令。  </p>
<p>lcd1602_show_string 函数是 LCD1602 显示字符函数， 该函数有 3 个入口参数， x 和 y 用来确定显示的坐标， x 范围是 0-15， y 范围是 0-1。 str 参数是一个指针类型变量， 用于传递显示的内容。 函数内首先判断 xy 坐标是否有效， 无效则强制退出， 然后根据 xy 值在对应的坐标位置显示内容  </p>
<h5 id="主函数-5"><a href="#主函数-5" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LCD1602 液晶显示实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， LCD1602 上显示字符信息</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_init();<span class="comment">//LCD1602 初始化</span></span><br><span class="line">    lcd1602_show_string(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">//第一行显示</span></span><br><span class="line">    lcd1602_show_string(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;0123456789&quot;</span>);<span class="comment">//第二行显示</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主函数代码非常简单， 首先调用外设驱动头文件， 然后进入 main 函数初始化 LCD1602， 并调用 LCD1602 显示函数让第一行显示”Hello World!”， 第二行显示”0123456789”。  </p>
<p>这里说明下， 在开发中通常会显示数值， 比如温度数据， 程序中我们获取的温度数据通常存储在 float 变量中， 并非字符串， 此时需要想办法将 float 变量中的值转换为字符串， 比如 float temp=31.2， 那么我们可以再定义一个数组temp_buf[]用于保存 temp 中的每一个位， 操作如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp=<span class="number">31.2</span>;</span><br><span class="line">u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">u16 temp_value=temp*<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">temp_buf[<span class="number">0</span>]=temp_value/<span class="number">100</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">1</span>]=temp_value%<span class="number">100</span>/<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">2</span>]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">temp_buf[<span class="number">3</span>]=temp_value%<span class="number">100</span>%<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">4</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">lcd1602_show_string(<span class="number">0</span>,<span class="number">0</span>,temp_buf);</span><br></pre></td></tr></table></figure>
<p>将浮点数转换为整型变量， 然后将整型值的每一个位取出来存储在数组temp_buf 中， 细心的朋友会发现取出的每一位后面加了 0X30， 这个值是将数字0-9 转换为 ASCII 码， 因为液晶是以 ASCII 码显示的。 最后一个数组元素赋值了’ \0’ ， 这是为了让 LCD1602 显示函数知道数组内结束位置。  </p>
<p>根据 C 语言指针的特点， 此时调用 LCD1602 显示函数时， 只需要将数组名传递进去即可， 因为数组名即为该数组的起始地址， 然后显示函数内部通过指针访问数组的每一位。  </p>
<h4 id="实验现象-14"><a href="#实验现象-14" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 在 LCD1602 液晶上显示字符信息。  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623212156893.png" alt="image-20230623212156893"></p>
<p>注意： LCD1602 液晶要正确插入到 LCD1602 接口 J2 位置， 插反或差错都会导致显示不正常。 如果出现显示看不清， 可调节板子 LCD1602 接口下的 RJ1 电位器。 如果 LCD1602 无法显示， 可重启电源或复位  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623212213060.png" alt="image-20230623212213060"></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>普中51单片机</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="http://example.com/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/">http://example.com/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>6+1</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-11-22</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-11-25</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/51%E5%8D%95%E7%89%87%E6%9C%BA/">51单片机</a></div><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、开发板的功能及使用介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%8151%E5%8D%95%E7%89%87%E6%9C%BA%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">二、51单片机介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E7%AE%80%E5%8E%86"><span class="toc-number">2.1.</span> <span class="toc-text">单片机简历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51%E5%8D%95%E7%89%87%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.</span> <span class="toc-text">51单片机简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#STC89Cxx%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">STC89Cxx芯片介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#STC89C51%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">STC89C51芯片简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STC89C51-%E8%8A%AF%E7%89%87%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.2.</span> <span class="toc-text">STC89C51 芯片引脚介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E8%84%9A%E4%BD%8D%E5%88%A4%E6%96%AD"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">单片机脚位判断</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#51-%E5%8D%95%E7%89%87%E6%9C%BA%E8%84%9A%E4%BD%8D%E5%8A%9F%E8%83%BD"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">51 单片机脚位功能</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#STC89C51-%E8%8A%AF%E7%89%87%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">STC89C51 芯片内部结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E4%B8%8EC%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">三、数字电路与C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">电平特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">二进制与十六进制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">二进制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">十六进制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.</span> <span class="toc-text">二进制的逻辑运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C51-%E6%89%A9%E5%85%85%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">C51 扩充数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%8151%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">四、51单片机最小系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#51-%E5%8D%95%E7%89%87%E6%9C%BA%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E6%9E%84%E6%88%90"><span class="toc-number">4.1.</span> <span class="toc-text">51 单片机最小系统构成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%B6%E6%8C%AF%E7%94%B5%E8%B7%AF"><span class="toc-number">4.2.</span> <span class="toc-text">晶振电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E7%94%B5%E8%B7%AF"><span class="toc-number">4.3.</span> <span class="toc-text">复位电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B5%E6%BA%90%E7%94%B5%E8%B7%AF"><span class="toc-number">4.4.</span> <span class="toc-text">电源电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E7%94%B5%E8%B7%AF"><span class="toc-number">4.5.</span> <span class="toc-text">下载电路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%8151%E5%8D%95%E7%89%87%E6%9C%BA%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.</span> <span class="toc-text">五、51单片机工程模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E5%B7%A5%E7%A8%8B%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.</span> <span class="toc-text">单片机工程模板创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">新建工程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9CPU%E5%9E%8B%E5%8F%B7"><span class="toc-number">5.1.2.</span> <span class="toc-text">选择CPU型号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%99%E5%B7%A5%E7%A8%8B%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.3.</span> <span class="toc-text">给工程添加文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%AD%94%E6%9C%AF%E6%A3%92%E9%80%89%E9%A1%B9%E5%8D%A1"><span class="toc-number">5.1.4.</span> <span class="toc-text">配置魔术棒选项卡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reg52-h-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">6.</span> <span class="toc-text">reg52.h 头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED"><span class="toc-number">7.</span> <span class="toc-text">点亮第一个LED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA-GPIO-%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.</span> <span class="toc-text">单片机 GPIO 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GPIO-%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">GPIO 结构框图与工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#P0-%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.2.1.</span> <span class="toc-text">P0 端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P1%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.2.2.</span> <span class="toc-text">P1端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P2%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.2.3.</span> <span class="toc-text">P2端口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P3%E7%AB%AF%E5%8F%A3"><span class="toc-number">7.2.4.</span> <span class="toc-text">P3端口</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED-%E7%AE%80%E4%BB%8B"><span class="toc-number">7.3.</span> <span class="toc-text">LED 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.4.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.5.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">点亮第一个LED</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LED-%E9%97%AA%E7%83%81%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.5.2.</span> <span class="toc-text">LED 闪烁实验</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-KEIL-%E8%BD%AF%E4%BB%B6%E4%BB%BF%E7%9C%9F%E6%9F%A5%E7%9C%8B%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">7.5.3.</span> <span class="toc-text">通过 KEIL 软件仿真查看延时时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LED%E6%B5%81%E6%B0%B4%E7%81%AF%E5%AE%9E%E9%AA%8C"><span class="toc-number">7.5.4.</span> <span class="toc-text">LED流水灯实验</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A7%BB%E4%BD%8D%E5%92%8C%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.5.4.1.</span> <span class="toc-text">使用移位和循环实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B7%A6%E7%A7%BB-crol-%E3%80%81-%E5%8F%B3%E7%A7%BB-cror-%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.4.2.</span> <span class="toc-text">使用左移_crol_、 右移_cror_函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="toc-number">8.</span> <span class="toc-text">蜂鸣器实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9C%82%E9%B8%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.1.</span> <span class="toc-text">蜂鸣器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">8.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">8.3.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">9.</span> <span class="toc-text">静态数码管实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">数码管介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">数码管显示原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E9%9D%99%E6%80%81%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">数码管静态显示原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">9.4.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">9.5.</span> <span class="toc-text">软件设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%A0%81%E7%AE%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">10.</span> <span class="toc-text">动态数码管实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">10.1.</span> <span class="toc-text">数码管介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E4%BD%8D%E6%95%B0%E7%A0%81%E7%AE%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">多位数码管简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.2.</span> <span class="toc-text">数码管动态显示原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#245%E5%92%8C138-%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">10.2.</span> <span class="toc-text">245和138 芯片介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#74HC245-%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B"><span class="toc-number">10.3.</span> <span class="toc-text">74HC245 芯片简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#74HC138-%E8%8A%AF%E7%89%87%E7%AE%80%E4%BB%8B"><span class="toc-number">10.4.</span> <span class="toc-text">74HC138 芯片简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">10.5.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">10.6.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">10.7.</span> <span class="toc-text">实验结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C"><span class="toc-number">11.</span> <span class="toc-text">独立按键实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E9%94%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">按键介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">11.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">11.3.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1"><span class="toc-number">11.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E5%AE%9E%E9%AA%8C"><span class="toc-number">12.</span> <span class="toc-text">矩阵按键实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E6%8C%89%E9%94%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.1.</span> <span class="toc-text">矩阵按键介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">12.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">12.3.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-1"><span class="toc-number">12.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%89%A9%E5%B1%95%EF%BC%88%E4%B8%B2%E8%BD%AC%E5%B9%B6%EF%BC%89-74HC595"><span class="toc-number">13.</span> <span class="toc-text">IO扩展（串转并）-74HC595</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#74HC595%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">13.1.</span> <span class="toc-text">74HC595芯片介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-6"><span class="toc-number">13.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-6"><span class="toc-number">13.3.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-2"><span class="toc-number">13.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LED%E7%82%B9%E9%98%B5%E5%AE%9E%E9%AA%8C"><span class="toc-number">14.</span> <span class="toc-text">LED点阵实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LED%E7%82%B9%E9%98%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">14.1.</span> <span class="toc-text">LED点阵介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-7"><span class="toc-number">14.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-7"><span class="toc-number">14.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LED%E7%82%B9%E9%98%B5%EF%BC%88%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AA%E7%82%B9%EF%BC%89"><span class="toc-number">14.3.1.</span> <span class="toc-text">LED点阵（点亮一个点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E5%AD%97"><span class="toc-number">14.3.2.</span> <span class="toc-text">显示数字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F"><span class="toc-number">14.3.3.</span> <span class="toc-text">显示图像</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-3"><span class="toc-number">14.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">15.</span> <span class="toc-text">直流电机实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.1.</span> <span class="toc-text">直流电机介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ULN2003%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.2.</span> <span class="toc-text">ULN2003芯片介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-8"><span class="toc-number">15.3.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-8"><span class="toc-number">15.4.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-4"><span class="toc-number">15.5.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">16.</span> <span class="toc-text">步进电机实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">16.1.</span> <span class="toc-text">步进电机简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">步进电机工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%9E%81%E6%80%A7%E5%8C%BA%E5%88%86"><span class="toc-number">16.3.</span> <span class="toc-text">步进电机极性区分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%9E%81%E6%80%A7%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-number">16.4.</span> <span class="toc-text">双极性步进电机驱动原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9E%81%E6%80%A7%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-number">16.5.</span> <span class="toc-text">单极性步进电机驱动原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E5%88%86%E9%A9%B1%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-number">16.6.</span> <span class="toc-text">细分驱动原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">16.7.</span> <span class="toc-text">步进电机技术指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">16.7.1.</span> <span class="toc-text">静态技术指标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="toc-number">16.7.2.</span> <span class="toc-text">动态技术指标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28BYJ-48-%E6%AD%A5%E8%BF%9B%E7%94%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">16.8.</span> <span class="toc-text">28BYJ-48 步进电机简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-9"><span class="toc-number">16.9.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-9"><span class="toc-number">16.10.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-5"><span class="toc-number">16.11.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.</span> <span class="toc-text">中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BB%8B%E7%BB%8D"><span class="toc-number">17.1.</span> <span class="toc-text">中断介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">17.2.</span> <span class="toc-text">中断结构及相关寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">17.3.</span> <span class="toc-text">中断相关寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C"><span class="toc-number">18.</span> <span class="toc-text">外部中断实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E4%BB%8B%E7%BB%8D"><span class="toc-number">18.1.</span> <span class="toc-text">外部中断介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E9%85%8D%E7%BD%AE"><span class="toc-number">18.2.</span> <span class="toc-text">外部中断配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-10"><span class="toc-number">18.3.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-10"><span class="toc-number">18.4.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-6"><span class="toc-number">18.5.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">19.</span> <span class="toc-text">定时器中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">19.1.</span> <span class="toc-text">定时器介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">19.1.1.</span> <span class="toc-text">单片机定时器原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">19.1.2.</span> <span class="toc-text">单片机定时&#x2F;计数器结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E5%AE%9A%E6%97%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">19.1.3.</span> <span class="toc-text">单片机定时&#x2F;计数器的工作方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">19.2.</span> <span class="toc-text">定时器配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-11"><span class="toc-number">19.3.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-11"><span class="toc-number">19.4.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-7"><span class="toc-number">19.5.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AE%9E%E9%AA%8C"><span class="toc-number">20.</span> <span class="toc-text">串口通信实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">20.1.</span> <span class="toc-text">通信的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%B9%B6%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">20.1.1.</span> <span class="toc-text">串行通信与并行通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">20.1.2.</span> <span class="toc-text">异步通信与同步通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%B7%A5%E3%80%81%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%B8%8E%E5%85%A8%E5%8F%8C%E5%B7%A5"><span class="toc-number">20.1.3.</span> <span class="toc-text">单工、半双工与全双工</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%80%9F%E7%8E%87"><span class="toc-number">20.1.4.</span> <span class="toc-text">通信速率</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%B2%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">20.2.</span> <span class="toc-text">单片机串口介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">20.2.1.</span> <span class="toc-text">串口通信简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%9B%B8%E5%85%B3%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">20.2.2.</span> <span class="toc-text">串口相关寄存器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">20.3.</span> <span class="toc-text">串口工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F0"><span class="toc-number">20.3.1.</span> <span class="toc-text">方式0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1"><span class="toc-number">20.3.2.</span> <span class="toc-text">方式1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2%E5%92%8C%E6%96%B9%E5%BC%8F3"><span class="toc-number">20.3.3.</span> <span class="toc-text">方式2和方式3</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">20.4.</span> <span class="toc-text">串口的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-number">20.4.1.</span> <span class="toc-text">如何计算波特率</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">20.4.2.</span> <span class="toc-text">串口初始化步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-12"><span class="toc-number">20.5.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-12"><span class="toc-number">20.6.</span> <span class="toc-text">软件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-8"><span class="toc-number">20.7.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I2C-EEPROM-%E5%AE%9E%E9%AA%8C"><span class="toc-number">21.</span> <span class="toc-text">I2C-EEPROM 实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.1.</span> <span class="toc-text">I2C介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">21.2.</span> <span class="toc-text">I2C物理层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I2C%E5%8D%8F%E8%AE%AE%E5%B1%82"><span class="toc-number">21.3.</span> <span class="toc-text">I2C协议层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AT24C02-%E4%BB%8B%E7%BB%8D"><span class="toc-number">21.4.</span> <span class="toc-text">AT24C02 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-13"><span class="toc-number">21.5.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">21.6.</span> <span class="toc-text">实验代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS18B20%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E5%AE%9E%E9%AA%8C"><span class="toc-number">22.</span> <span class="toc-text">DS18B20温度传感器实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DS18B20%E4%BB%8B%E7%BB%8D"><span class="toc-number">22.1.</span> <span class="toc-text">DS18B20介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-14"><span class="toc-number">22.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-13"><span class="toc-number">22.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%A0%81%E7%AE%A1%E6%98%BE%E7%A4%BA%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.1.</span> <span class="toc-text">数码管显示函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DS18B20-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.2.</span> <span class="toc-text">DS18B20 初始化函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E8%AF%BB%E5%8F%96%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.3.</span> <span class="toc-text">温度读取函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0"><span class="toc-number">22.3.4.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-9"><span class="toc-number">22.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DS1302-%E6%97%B6%E9%92%9F%E5%AE%9E%E9%AA%8C"><span class="toc-number">23.</span> <span class="toc-text">DS1302 时钟实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DS1302-%E6%97%B6%E9%92%9F%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">23.1.</span> <span class="toc-text">DS1302 时钟芯片介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DS1302-%E7%AE%80%E4%BB%8B"><span class="toc-number">23.1.1.</span> <span class="toc-text">DS1302 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DS1302-%E4%BD%BF%E7%94%A8"><span class="toc-number">23.1.2.</span> <span class="toc-text">DS1302 使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-15"><span class="toc-number">23.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-14"><span class="toc-number">23.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DS1302-%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">23.3.1.</span> <span class="toc-text">DS1302 读写函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-1"><span class="toc-number">23.3.2.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-10"><span class="toc-number">23.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E5%AE%9E%E9%AA%8C"><span class="toc-number">24.</span> <span class="toc-text">红外遥控实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E4%BB%8B%E7%BB%8D"><span class="toc-number">24.1.</span> <span class="toc-text">红外遥控介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E7%BA%BF%E7%AE%80%E4%BB%8B"><span class="toc-number">24.1.1.</span> <span class="toc-text">红外线简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">24.1.2.</span> <span class="toc-text">红外遥控的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E5%8F%91%E5%B0%84%E8%A3%85%E7%BD%AE"><span class="toc-number">24.1.3.</span> <span class="toc-text">红外发射装置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E6%8E%A5%E6%94%B6%E8%AE%BE%E5%A4%87"><span class="toc-number">24.1.4.</span> <span class="toc-text">红外接收设备</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-16"><span class="toc-number">24.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-15"><span class="toc-number">24.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">24.3.1.</span> <span class="toc-text">红外初始化函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E5%A4%96%E8%A7%A3%E7%A0%81%E5%87%BD%E6%95%B0"><span class="toc-number">24.3.2.</span> <span class="toc-text">红外解码函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-2"><span class="toc-number">24.3.3.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-11"><span class="toc-number">24.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C"><span class="toc-number">25.</span> <span class="toc-text">ADC模数转换实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ADC%E4%BB%8B%E7%BB%8D"><span class="toc-number">25.1.</span> <span class="toc-text">ADC介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADC%E7%AE%80%E4%BB%8B"><span class="toc-number">25.2.</span> <span class="toc-text">ADC简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADC-%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86"><span class="toc-number">25.3.</span> <span class="toc-text">ADC 转换原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XPT2046%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D"><span class="toc-number">25.4.</span> <span class="toc-text">XPT2046芯片介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-17"><span class="toc-number">25.5.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-16"><span class="toc-number">25.6.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ADC%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">25.6.1.</span> <span class="toc-text">ADC读写函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-3"><span class="toc-number">25.6.2.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-12"><span class="toc-number">25.7.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAC%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%AE%9E%E9%AA%8C"><span class="toc-number">26.</span> <span class="toc-text">DAC数模转换实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DAC%E4%BB%8B%E7%BB%8D"><span class="toc-number">26.1.</span> <span class="toc-text">DAC介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DAC%E7%AE%80%E4%BB%8B"><span class="toc-number">26.1.1.</span> <span class="toc-text">DAC简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DAC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">26.1.2.</span> <span class="toc-text">DAC工作原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E4%BB%8B%E7%BB%8D"><span class="toc-number">26.2.</span> <span class="toc-text">PWM介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-18"><span class="toc-number">26.3.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-17"><span class="toc-number">26.4.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#PWM%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0"><span class="toc-number">26.4.1.</span> <span class="toc-text">PWM实现函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-4"><span class="toc-number">26.4.2.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-13"><span class="toc-number">26.5.</span> <span class="toc-text">实验现象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCD1602-%E6%B6%B2%E6%99%B6%E6%98%BE%E7%A4%BA%E5%AE%9E%E9%AA%8C"><span class="toc-number">27.</span> <span class="toc-text">LCD1602 液晶显示实验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LCD1602-%E4%BB%8B%E7%BB%8D"><span class="toc-number">27.1.</span> <span class="toc-text">LCD1602 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LCD1602-%E7%AE%80%E4%BB%8B"><span class="toc-number">27.1.1.</span> <span class="toc-text">LCD1602 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LCD1602-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">27.1.2.</span> <span class="toc-text">LCD1602 常用指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LCD1602-%E4%BD%BF%E7%94%A8"><span class="toc-number">27.1.3.</span> <span class="toc-text">LCD1602 使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1-19"><span class="toc-number">27.2.</span> <span class="toc-text">硬件设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1-18"><span class="toc-number">27.3.</span> <span class="toc-text">软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LCD1602-%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">27.3.1.</span> <span class="toc-text">LCD1602 驱动函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%87%BD%E6%95%B0-5"><span class="toc-number">27.3.2.</span> <span class="toc-text">主函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%8E%B0%E8%B1%A1-14"><span class="toc-number">27.4.</span> <span class="toc-text">实验现象</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2023 🏀 6+1</div><div id="running-time" style="color: #bbbbbb;"><script>setInterval(()=>{let create_time=Math.round(new Date('2023/11/21 08:00:00').getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);
let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=
parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml= 
  '<svg t="1700709558688" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1687" width="200" height="200"><path d="M471.49511147 378.65244479c62.57777813-20.02488853 153.48622187-17.6355552 190.80533333 44.032-27.76177813-2.50311147-55.5235552-5.46133333-83.17155627-8.64711146-1.70666667 2.95822187-5.23377813 8.76088853-6.94044373 11.60533333-41.64266667 3.52711147-77.5964448 26.51022187-103.08266667 58.82311147-12.17422187-34.70222187-9.55733333-71.4524448 2.38933334-105.81333334zM257.59288853 378.19733333c24.00711147-1.8204448 48.01422187-2.95822187 71.90755627-4.20977814 10.69511147 10.24 21.39022187 20.36622187 32.1991104 30.4924448-2.61688853 24.3484448-8.07822187 48.24177813-15.01866667 71.68-7.3955552-3.52711147-22.3004448-10.4675552-29.696-13.88088853-44.48711147-25.71377813-97.28-29.4684448-147.00088853-20.59377813 13.19822187-38.6844448 65.19466667-31.40266667 87.60888853-63.488z" fill="#FDFEFA" p-id="1688"></path><path d="M506.88 470.69866666c32.5404448-26.96533333 75.88977813-30.26488853 116.39466667-30.83377813-39.02577813 35.95377813-38.912 101.26222187 3.75466666 133.6888896-39.936-4.096-84.42311147-2.16177813-118.10133333-27.53422294-25.8275552-15.5875552-27.07911147-58.48177813-2.048-75.32088853zM116.05333333 521.78488853c10.24-51.65511147 62.6915552-65.3084448 107.7475552-69.0631104-32.88177813 38.57066667-28.4444448 92.04622187 0.7964448 131.2995552-43.46311147-3.64088853-89.65688853-19.11466667-108.544-62.2364448zM238.93333333 465.69244479c8.4195552 0.11377813 25.3724448 0.45511147 33.792 0.56888854 1.70666667 5.00622187 5.12 14.79111147 6.71288854 19.6835552-11.83288853 3.18577813-23.66577813 6.25777813-35.49866667 9.32977813l-5.00622187-29.58222187zM654.67733333 587.43466666c23.09688853-4.77866667 45.73866667-11.37777813 68.608-17.29422187 65.7635552 7.73688853 133.46133333 16.04266667 190.80533334 51.88266667 1.024 13.88088853 1.8204448 27.76177813 2.73066666 41.64266667 3.52711147 37.31911147-18.2044448 70.4284448-34.5884448 102.17244373-30.4924448 58.1404448-79.53066667 103.08266667-130.5031104 142.9048896-15.01866667 7.9644448-29.80977813 16.27022187-44.37333333 24.8035552-23.66577813 10.12622187-47.44533333 19.91111147-71.2248896 29.9235552-135.168 39.48088853-287.63022187 11.0364448-396.5155552-78.848-49.60711147-44.37333333-96.82488853-96.59733333-116.16711147-161.67822187-6.3715552-25.14488853-13.19822187-50.176-19.9111104-75.20711146 68.26666667-9.67111147 116.62222187 42.09777813 173.5111104 68.608 19.56977813 35.95377813 52.4515552 60.416 89.6568896 75.88977813-5.80266667 13.42577813-8.76088853 28.672-18.432 40.04977813-44.48711147 19.00088853-88.51911147-7.85066667-129.5928896-22.528 18.54577813 25.03111147 41.87022187 48.9244448 73.84177814 54.95466667 64.7395552 13.42577813 132.096 12.288 197.8595552 6.5991104 54.61333333-4.096 101.71733333-53.93066667 95.0044448-110.13688853-16.95288853 22.7555552-26.51022187 53.13422187-51.54133334 68.608-54.0444448 23.7795552-132.096 23.3244448-162.24711146-36.18133334 36.6364448-16.49777813 67.01511147-42.89422187 90.6808896-75.20711146 68.49422187-31.40266667 114.34666667-97.96266667 187.50577706-120.0355552 1.2515552-2.73066667 3.64088853-8.192 4.8924448-10.92266667M526.67733333 931.83999999c-54.38577813 12.288-109.68177813-1.70666667-163.38488853-11.15022186 5.12 42.2115552 48.46933333 28.672 76.45866667 36.75022186 25.8275552 26.05511147 65.7635552 17.52177813 98.07644373 12.40177814 38.6844448-12.62933333 79.98577813-33.22311147 93.7528896-75.09333334-35.72622187 10.4675552-69.51822187 26.05511147-104.90311147 37.0915552z" fill="#FDFEFA" p-id="1689"></path><path d="M799.63022187 8.53333333h16.1564448c28.21688853 22.7555552 55.86488853 47.9004448 70.76977813 81.80622186 34.36088853 72.9315552 55.86488853 154.96533333 45.62488853 235.97511147-7.168 36.75022187 11.60533333 70.54222187 21.16266667 105.01688853 55.63733333 179.4275552-19.6835552 388.096-172.8284448 495.50222294-105.2444448 76.34488853-244.05333333 106.04088853-370.80177707 75.43466666-109.568-25.6-210.37511147-91.3635552-273.63555626-184.8888896-82.7164448-117.87377813-108.99911147-277.04888853-56.5475552-412.672 42.7804448-91.70488853-5.80266667-190.35022187-19.56977814-283.0791104-8.9884448-43.2355552 37.54666667-77.36888853 77.48266667-70.08711146 66.7875552 8.30577813 119.35288853 52.67911147 174.76266667 86.47111146 44.14577813-10.80888853 85.44711147-32.31288853 131.18577813-37.31911146 73.728-13.88088853 148.7075552-0.7964448 220.04622187 18.77333333C709.06311147 83.05777813 735.80088853 15.13244479 799.63022187 8.53333333m-30.37866667 38.00177813c-28.10311147 37.0915552-57.5715552 73.728-92.84266667 104.22044373-28.78577813 2.61688853-55.75111147-13.42577813-83.85422186-18.20444373-96.93866667-16.72533333-199.68-3.2995552-286.26488854 44.60088853-54.38577813-49.60711147-120.14933333-92.84266667-195.92533333-96.71111146-8.53333333 9.32977813-17.06666667 18.54577813-25.48622293 27.87555626 19.456 62.80533333 32.5404448 127.54488853 40.27733333 192.7395552 13.88088853-15.92888853 27.19288853-32.31288853 40.16355627-49.03822186 7.85066667 0 23.66577813-0.2275552 31.63022186-0.22755627-22.3004448 45.62488853-60.87111147 81.6924448-77.5964448 130.38933333-52.11022187 112.29866667-43.008 242.80177813-4.096 357.48977814l8.192-16.72533334C142.79111147 788.02488853 190.00888853 840.24888853 239.616 884.62222186c108.88533333 89.8844448 261.3475552 118.32888853 396.5155552 78.848 23.7795552-10.0124448 47.55911147-19.79733333 71.2248896-29.9235552 14.5635552-8.53333333 29.35466667-16.83911147 44.37333333-24.8035552 50.9724448-39.82222187 100.01066667-84.7644448 130.5031104-142.9048896 16.384-31.744 38.1155552-64.85333333 34.5884448-102.17244373l20.02488854-0.7964448c-0.34133333-70.4284448 9.78488853-142.22222187-7.96444374-211.28533334-14.79111147-65.3084448-49.3795552-124.1315552-90.6808896-176.01422186-1.59288853-38.79822187-35.49866667-59.50577813-62.9191104-80.78222294 14.22222187-39.36711147 28.55822187-79.41688853 28.1031104-121.96977706 22.98311147 40.39111147 41.1875552 83.28533333 53.248 128.2275552 1.47911147 37.888 8.4195552 80.6684448 47.21777814 98.0764448-0.68266667-79.872-19.2284448-163.84-66.44622187-229.60355627-14.79111147-24.3484448-42.89422187-25.03111147-68.1528896-22.9831104z" fill="#9F4B06" p-id="1690"></path><path d="M469.10577813 484.46577813c25.48622187-32.31288853 61.44-55.296 103.08266667-58.82311147 56.43377813-2.73066667 128.11377813-10.92266667 170.09777707 35.38488853 29.35466667 34.70222187 15.47377813 83.85422187-19.00088854 109.1128896-22.86933333 5.9164448-45.51111147 12.5155552-68.608 17.29422187-55.75111147 3.52711147-121.0595552 7.28177813-165.54666666-32.88177813-20.93511147-17.1804448-19.79733333-45.62488853-20.02488854-70.0871104m37.77422187-13.76711147c-25.03111147 16.83911147-23.7795552 59.73333333 2.048 75.32088853 33.67822187 25.3724448 78.16533333 23.43822187 118.10133333 27.53422294-42.66666667-32.42666667-42.7804448-97.73511147-3.75466666-133.6888896-40.50488853 0.56888853-83.85422187 3.8684448-116.39466667 30.83377813m143.01866667 2.16177813c14.90488853 4.77866667 29.80977813 4.55111147 44.71466666-0.5688896-0.56888853-16.04266667-16.83911147-21.39022187-27.30666666-30.1511104-8.53333333 8.87466667-22.528 15.92888853-17.408 30.72zM101.83111147 533.39022186c-9.89866667-44.8284448 31.9715552-76.34488853 68.15288853-91.70488853 49.72088853-8.87466667 102.51377813-5.12 147.00088853 20.59377813 21.2764448 27.98933333 36.864 70.08711147 7.85066667 98.7591104-58.70933333 60.07466667-186.5955552 54.272-223.00444373-27.648m14.22222186-11.60533333c18.88711147 43.12177813 65.08088853 58.5955552 108.544 62.2364448-29.24088853-39.25333333-33.67822187-92.72888853-0.7964448-131.2995552-45.056 3.75466667-97.5075552 17.408-107.7475552 69.0631104M238.93333333 465.69244479l5.00622187 29.58222187c11.83288853-3.072 23.66577813-6.144 35.49866667-9.32977813-1.59288853-4.8924448-5.00622187-14.67733333-6.71288854-19.6835552-8.4195552-0.11377813-25.3724448-0.45511147-33.792-0.56888854zM325.29066667 671.40266666c48.69688853-0.7964448 118.89777813-12.74311147 136.9884448 46.99022187-23.66577813 32.31288853-54.0444448 58.70933333-90.6808896 75.20711146 30.15111147 59.50577813 108.20266667 59.96088853 162.24711146 36.18133334 25.03111147-15.47377813 34.5884448-45.8524448 51.54133334-68.608 6.71288853 56.20622187-40.39111147 106.04088853-95.0044448 110.13688853-65.7635552 5.68888853-133.12 6.82666667-197.8595552-6.5991104-31.9715552-6.03022187-55.296-29.9235552-73.84177814-54.95466667 41.07377813 14.67733333 85.10577813 41.52888853 129.5928896 22.528 9.67111147-11.37777813 12.62933333-26.624 18.432-40.04977813-37.20533333-15.47377813-70.08711147-39.936-89.6568896-75.88977813 11.94666667-14.5635552 23.89333333-29.12711147 35.95377814-43.69066667 2.048 9.4435552 6.25777813 28.4444448 8.4195552 37.888 0.91022187-9.78488853 2.8444448-29.35466667 3.8684448-39.1395552z" fill="#9F4B06" p-id="1691"></path><path d="M769.2515552 46.53511146c25.25866667-2.048 53.36177813-1.36533333 68.1528896 22.9831104 47.21777813 65.7635552 65.7635552 149.7315552 66.44622187 229.60355627-38.79822187-17.408-45.73866667-60.1884448-47.21777814-98.0764448-12.0604448-44.94222187-30.26488853-87.8364448-53.248-128.2275552 0.45511147 42.55288853-13.88088853 82.60266667-28.1031104 121.96977706 27.4204448 21.2764448 61.32622187 41.984 62.9191104 80.78222294 41.30133333 51.88266667 75.88977813 110.70577813 90.6808896 176.01422186 17.74933333 69.06311147 7.62311147 140.85688853 7.96444374 211.28533334l-20.02488854 0.7964448c-0.91022187-13.88088853-1.70666667-27.76177813-2.73066666-41.64266667-57.344-35.84-125.04177813-44.14577813-190.80533334-51.88266667 34.47466667-25.25866667 48.3555552-74.41066667 19.00088854-109.1128896-41.984-46.3075552-113.664-38.1155552-170.09777707-35.38488853 1.70666667-2.8444448 5.23377813-8.64711147 6.94044373-11.60533333 27.648 3.18577813 55.40977813 6.144 83.17155627 8.64711146-37.31911147-61.6675552-128.2275552-64.05688853-190.80533333-44.032-11.94666667 34.36088853-14.5635552 71.11111147-2.38933334 105.81333334 0.2275552 24.46222187-0.91022187 52.90666667 20.02488854 70.0871104 44.48711147 40.1635552 109.7955552 36.40888853 165.54666666 32.88177813-1.2515552 2.73066667-3.64088853 8.192-4.8924448 10.92266667-73.15911147 22.07288853-119.0115552 88.63288853-187.50577706 120.0355552-18.09066667-59.73333333-88.2915552-47.78666667-136.9884448-46.99022187-1.024 9.78488853-2.95822187 29.35466667-3.8684448 39.1395552-2.16177813-9.4435552-6.3715552-28.4444448-8.4195552-37.888-12.0604448 14.5635552-24.00711147 29.12711147-35.95377814 43.69066667-56.88888853-26.51022187-105.2444448-78.27911147-173.5111104-68.608 6.71288853 25.03111147 13.5395552 50.06222187 19.9111104 75.20711146l-8.192 16.72533334c-38.912-114.688-48.01422187-245.19111147 4.096-357.48977814 16.72533333-48.69688853 55.296-84.7644448 77.5964448-130.38933333-7.9644448 0-23.7795552 0.2275552-31.63022186 0.22755627A1108.13866667 1108.13866667 0 0 1 125.1555552 301.05599999c-7.73688853-65.19466667-20.82133333-129.93422187-40.27733333-192.7395552 8.4195552-9.32977813 16.95288853-18.54577813 25.48622293-27.87555626 75.776 3.8684448 141.5395552 47.104 195.92533333 96.71111146 86.58488853-47.9004448 189.32622187-61.32622187 286.26488854-44.60088853 28.10311147 4.77866667 55.0684448 20.82133333 83.85422186 18.20444373 35.27111147-30.4924448 64.7395552-67.12888853 92.84266667-104.22044373M257.59288853 378.19733333c-22.41422187 32.08533333-74.41066667 24.8035552-87.60888853 63.488-36.18133333 15.36-78.0515552 46.8764448-68.15288853 91.70488853 36.40888853 81.92 164.29511147 87.72266667 223.00444373 27.648 29.01333333-28.672 13.42577813-70.76977813-7.85066667-98.7591104 7.3955552 3.41333333 22.3004448 10.35377813 29.696 13.88088853 6.9404448-23.43822187 12.40177813-47.3315552 15.01866667-71.68-10.80888853-10.12622187-21.504-20.2524448-32.1991104-30.4924448-23.89333333 1.2515552-47.9004448 2.38933333-71.90755627 4.20977814z" fill="#FEE173" p-id="1692"></path><path d="M649.89866667 472.86044479c-5.12-14.79111147 8.87466667-21.84533333 17.408-30.72 10.4675552 8.76088853 26.73777813 14.1084448 27.30666666 30.1511104-14.90488853 5.12-29.80977813 5.3475552-44.71466666 0.5688896zM526.67733333 931.83999999c35.38488853-11.0364448 69.17688853-26.624 104.90311147-37.0915552-13.76711147 41.87022187-55.0684448 62.464-93.7528896 75.09333334-32.31288853 5.12-72.24888853 13.65333333-98.07644373-12.40177814-27.98933333-8.07822187-71.33866667 5.46133333-76.45866667-36.75022186 53.70311147 9.4435552 108.99911147 23.43822187 163.38488853 11.15022186z" fill="#FEE173" p-id="1693"></path></svg> 已经活了 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script defer src="/js/fomal.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="//at.alicdn.com/t/c/font_4341224_thz0gklagdp.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script async src="/js/title.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script async type="text/javascript" src="https://jsd.onmicrosoft.cn/npm/izitoast@1.4.0/dist/js/iziToast.min.js"></script><script>
    document.body.oncopy = function () {
        iziToast.info({
            timeout: 4000, // 关闭弹窗的时间
          // icon: 'Fontawesome', // 图标类别
            closeOnEscape: 'true', // 允许使用Esc键关闭弹窗
            transitionIn: 'bounceInLeft', // 弹窗打开动画
            transitionOut: 'fadeOutRight', // 弹窗关闭动画
            displayMode: 'replace', // 替换已经打开的弹窗
            layout: '2', // Medium模式
            position: 'topLeft', // 弹窗位置
            //icon: 'fad fa-copy', // 图标类名
            iconUrl:'https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E6%98%9F%E6%98%9F.svg',
            backgroundColor: 'rgb(179, 182, 180)', // 弹窗背景色
            title: '复制成功', // 通知标题
            message: '😝好好学习，天天向上😝' // 通知消息内容
        });
    }
</script>
<script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.6.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num9.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt="">STM32HAL库</a><div class="blog-slider__text">HAL库</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/STM32HAL库/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt="">STM32标准库</a><div class="blog-slider__text">标准库</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/江科大STM32/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/num11.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-11-18</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt="">FreeRTOS</a><div class="blog-slider__text">单片机操作系统</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/11/18/FreeRTOS/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('pagination');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__rotateInDownLeft');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>