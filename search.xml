<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>硬件基础</title>
      <link href="/2023/12/21/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/12/21/%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>1</p>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言入门</title>
      <link href="/2023/11/22/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2023/11/22/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>跟着浙江大学翁恺老师学的</p><h2 id="vscode配置C语言环境"><a href="#vscode配置C语言环境" class="headerlink" title="vscode配置C语言环境"></a>vscode配置C语言环境</h2><p>vsCode下载和安装</p><p>  vsCode官网下载</p><p> vsCode配置c/c++</p><p>下载c/c++插件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162557778.png" alt="image-20231022162557778"></p><p>下载完成后重启vsCode</p><h3 id="MinGW编译器下载和配置"><a href="#MinGW编译器下载和配置" class="headerlink" title="MinGW编译器下载和配置"></a>MinGW编译器下载和配置</h3><hr><h3 id="下载MinGW"><a href="#下载MinGW" class="headerlink" title="下载MinGW"></a>下载MinGW</h3><p>MingW官网下载</p><p><a href="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">MinGW-w64 - for 32 and 64 bit Windows - Browse /mingw-w64/mingw-w64-release at SourceForge.net</a></p><p>在线安装——下载MinGW-W64-install.exe（速度慢）<br>下载压缩包——×86_64-posix-sjlj（速度快）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/098ba46f59256da8b7cf7ac63e24aa8e.png#pic_center" alt="img"></p><p>下载后放到自己方便的目录，并复制文件里bin目录的路径（后面用得到）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022161220333.png" alt="image-20231022161220333"></p><hr><h3 id="配置path变量"><a href="#配置path变量" class="headerlink" title="配置path变量"></a>配置path变量</h3><p>右键我的电脑——属性</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022161805614.png" alt="image-20231022161805614"></p><p>我的是Win10，划到下面点击高级系统设置</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022161854206.png" alt="image-20231022161854206"></p><p>点击环境变量</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022161943434.png" alt="image-20231022161943434"></p><p>找到Path,点击编辑</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162113076.png" alt="image-20231022162113076"></p><p>新建，这个是我的文件路径，你把你的文件路径弄上去就行</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162147342.png" alt="image-20231022162147342"></p><p><strong>检查是否配置成功</strong></p><p>Win+R</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162306383.png" alt="image-20231022162306383"></p><p>打开cmd,输入输入gcc -v或gcc -v或g++ -v</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162521216.png" alt="image-20231022162521216"></p><hr><h3 id="配置调试功能"><a href="#配置调试功能" class="headerlink" title="配置调试功能"></a>配置调试功能</h3><p>新建文件夹</p><p>在Code文件夹下创建一个<code>.vscode</code>文件夹并创建4个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c_cpp_properties.json</span><br><span class="line">launch.json</span><br><span class="line">settings.json</span><br><span class="line">tasks.json</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022162642986.png" alt="image-20231022162642986"></p><p>c_cpp_properties.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win64&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span> <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span> <span class="string">&quot;_UNICODE&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;windowsSdkVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.0.18362.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/MinGW/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gcc-x64&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意compilerPath这一项要把路径改成刚才g++的安装路径：找到刚刚的安装文件夹-&gt;MinGW-&gt;bin-&gt;g++,exe ,然后复制或者手动把g++.exe的路径敲上去，格式要跟上面代码段一样</p><p>launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Launch&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意miDebuggerPath这一项也要把路径改成刚才g++的安装路径：找到刚刚的安装文件夹-&gt;MinGW-&gt;bin-&gt;gdb,exe ,然后复制或者手动把gdb.exe的路径敲上去，格式要跟上面代码段一样</p><p>settings.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;files.associations&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;*.py&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;iostream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;*.tcc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;string&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;unordered_map&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;vector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ostream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;new&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;typeinfo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;deque&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;initializer_list&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;iosfwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fstream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sstream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;map&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stdio.h&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;algorithm&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;atomic&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;bit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cctype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;clocale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cmath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;compare&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;concepts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cstddef&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cstdint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cstdio&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cstdlib&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ctime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;cwchar&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;exception&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;ios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;istream&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;iterator&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;limits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;memory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;random&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;set&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stdexcept&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;streambuf&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;system_error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tuple&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type_traits&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;utility&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xfacet&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xiosbase&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xlocale&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xlocinfo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xlocnum&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xmemory&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xstddef&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xstring&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xtr1common&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xtree&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;xutility&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stdlib.h&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;string.h&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.suggest.snippetsPreventQuickSuggestions&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;aiXcoder.showTrayIcon&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tasks.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;g++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;fileLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;relative&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;severity&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>测试是否成功</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022163109677.png" alt="image-20231022163109677"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按F5运行</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022163154846.png" alt="image-20231022163154846"></p><p>不喜欢小黑框就注释掉那两行代码</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022163644805.png" alt="image-20231022163644805"></p><p>一定要先创建一个.vscode文件夹，记住前面有一个点，这个文件夹用来存放3个json配置文件，记住3个json文件要放进.vscode里面！！！</p><p>最后<strong>记住，文件目录一定要根据自己电脑的来设置！！！</strong></p><hr><h2 id="关于C语言中-与-＞的区别详解"><a href="#关于C语言中-与-＞的区别详解" class="headerlink" title="关于C语言中.与-＞的区别详解"></a>关于C语言中.与-＞的区别详解</h2><p><code>-&gt;</code> 前是指针，而 <code>.</code> 前是结构体变量</p><blockquote><p>简单点说就是：<br>1、A-&gt;a表示A是指向结构体的指针<br>2、A.a表示A是结构体<br>3、A-&gt;a等效于(*A).a</p><p>4、A.B则A为对象或者结构体；</p><p>5、A-&gt;B则A为指针，-&gt;是成员提取，A-&gt;B是提取A中的成员B，A只能是指向类、结构、联合的指针；</p><p>6、<code>(*a).b</code> 等价于 a-&gt;b。”.”一般情况下读作”的”； “-&gt;”一般读作”指向的结构体的”。也就是说在结构中，运算符-&gt;是运算符*和运算符.的结合</p><p>7、“-&gt;”是指向结构体成员运算符。“.”是断点符号，不属于运算符。</p><p>8、“-&gt;”所指向的是结构体或对象的首地址。“.”所指向的是结构体或对象。</p><p>9、“-&gt;”的用处是使用一个指向以便访问结构体或对象其内成员。“.”的用处是使用一个指向以便访问结构体或对象。</p></blockquote><hr><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>代码只是参考，主要的是思路，实现的方法有很多种，不一定要跟我一样</p><h3 id="最小值换位置"><a href="#最小值换位置" class="headerlink" title="最小值换位置"></a>最小值换位置</h3><p>输入5个整数，找出其中最小值并将其与数组中最后一个元素交换位置，然后输出交换后的数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">5</span>];           <span class="comment">// 声明一个长度为5的整型数组用于存储输入的数字</span></span><br><span class="line">    <span class="type">int</span> min_index = <span class="number">0</span>;     <span class="comment">// 存储最小值的下标，默认为0</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入 5 个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 5 个数：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;nums[i]);   <span class="comment">// 逐个输入数字并存储到数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找出最小值的下标</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[min_index])   <span class="comment">// 如果当前数字比最小值小，则更新最小值的下标</span></span><br><span class="line">        &#123;</span><br><span class="line">            min_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最小值并交换位置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最小值为：%d\n&quot;</span>, nums[min_index]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp = nums[min_index];</span><br><span class="line">    nums[min_index] = nums[<span class="number">4</span>];   <span class="comment">// 将最小值与最后一个数字交换位置</span></span><br><span class="line">    nums[<span class="number">4</span>] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出最终结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后的数组为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nums[i]);   <span class="comment">// 逐个输出交换后的数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="计算时间差"><a href="#计算时间差" class="headerlink" title="计算时间差"></a>计算时间差</h3><ul><li>输入两个时间，每个时间分别输入小时和分钟的值，然后输出两个时间之间的差也以几小时几分表示</li></ul><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022232002561.png" alt="image-20231022232002561"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hour1, minute1; <span class="comment">// 定义变量hour1和minute1，表示第一个时间的小时和分钟</span></span><br><span class="line">    <span class="type">int</span> hour2, minute2; <span class="comment">// 定义变量hour2和minute2，表示第二个时间的小时和分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;hour1, &amp;minute1); <span class="comment">// 输入第一个时间的小时和分钟</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;hour2, &amp;minute2); <span class="comment">// 输入第二个时间的小时和分钟</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t1 = hour1 * <span class="number">60</span> + minute1; <span class="comment">// 将第一个时间转换为分钟数</span></span><br><span class="line">    <span class="type">int</span> t2 = hour2 * <span class="number">60</span> + minute2; <span class="comment">// 将第二个时间转换为分钟数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = t2 - t1; <span class="comment">// 计算两个时间之间的分钟数差</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;时间差是%d小时%d分。&quot;</span>, t / <span class="number">60</span>, t % <span class="number">60</span>); <span class="comment">// 输出时间差</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序，等待用户按下任意键继续执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数位数的算法"><a href="#数位数的算法" class="headerlink" title="数位数的算法"></a>数位数的算法</h3><blockquote><ol><li>用户输入x;</li><li>初始化n为0;</li><li>x=x/10，去掉个位;</li><li>n ++;</li><li>如果x&gt;0，回到3;</li><li>否则n就是结果。</li></ol></blockquote><p>while</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,n=<span class="number">0</span>;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"></span><br><span class="line">   n++;</span><br><span class="line">   x =x/<span class="number">10</span>;   </span><br><span class="line">   <span class="keyword">while</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       n++;</span><br><span class="line">       x =x/<span class="number">10</span>;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br></pre></td></tr></table></figure><p>do - while</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,n=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x /=<span class="number">10</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (x&gt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br></pre></td></tr></table></figure><h3 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h3><h4 id="计算机随机输出数"><a href="#计算机随机输出数" class="headerlink" title="计算机随机输出数"></a>计算机随机输出数</h4><blockquote><ul><li>让计算机来想一个数，然后让用户来猜用户每输入一个数，就告诉它是大了还是小了，直到用户猜中为止，最后还要告诉用户它猜了多少次。</li><li>因为需要不断重复让用户猜，所以需要用到循环</li><li>在实际写出程序之前，我们可以先用文字描述程序的思路</li><li>核心重点是循环的条件</li></ul><ol><li><p>计算机随机想一个数，记在变量number里;</p></li><li><p>一个负责计次数的变量count初始化为0;</p></li><li>让用户输入一个数字a;</li><li>count递增(加一);</li><li>判断a和number的大小关系，如果a大，就输出大”;如果a小就输出“小”;</li><li>如果a和number是不相等的 (无论大还是小)，程序转回到第3步;<br> 否则，程序输出“猜中”和次数，然后结束。</li></ol></blockquote><ul><li>每次召唤<mark>rand()</mark>就得到一个随机的整数</li></ul><p>x % n的结果是[0,n-1]的一个整数</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// 用当前时间初始化随机数种子</span></span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>; <span class="comment">// 生成1到100之间的随机数</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, a = <span class="number">0</span>; <span class="comment">// 定义计数器count和猜测的数a</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我已经想好了一个1到100之间的数。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请猜这个1到100之间的数：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); <span class="comment">// 输入猜测的数</span></span><br><span class="line">        count++; <span class="comment">// 计数器加1</span></span><br><span class="line">        <span class="keyword">if</span> (a &gt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你猜的数大了。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;你猜的数小了。\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (a != number); <span class="comment">// 如果猜测的数不等于随机数，则继续循环</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;太好了，你用了%d次就猜到了\n&quot;</span>, count); <span class="comment">// 输出猜测次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="算平均数"><a href="#算平均数" class="headerlink" title="算平均数"></a>算平均数</h3><blockquote><p>让用户输入一系列的正整数，最后输入-1表示输入结束，然后程序计算出这些数字的平均数，输出输入的数字的个数和平均数</p><ul><li>一个记录读到的整数的变量</li><li>平均数要怎么算?<ul><li>只需要每读到一个数，就把它加到一个累加的变量里，到全部数据读完，再拿它去除读到的数的个数就可以了</li></ul></li><li>一个变量记录累加的结果，一个变量记录读到的数的个数</li></ul><blockquote><blockquote><blockquote><p>算法</p></blockquote></blockquote></blockquote><ol><li>初始化变量sum和count为0;</li><li>读入number;</li><li>如果number不是-1，则将number加入sum，并将count加1，回到2</li><li>如果number是-1，则计算和打印出sum / count(注意换成浮点来计算)。</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>  number; <span class="comment">// 定义输入的数</span></span><br><span class="line">    <span class="type">int</span>  sum = <span class="number">0</span>; <span class="comment">// 定义累加和</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 定义计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number); <span class="comment">// 输入第一个数</span></span><br><span class="line">    <span class="keyword">while</span> (number != <span class="number">0</span>)  <span class="comment">// 当输入的数不为0时，继续循环   //想结束是什么就不等于什么，比如我这里是0，我最后输入0就是结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += number; <span class="comment">// 累加每次输入的数</span></span><br><span class="line">        count++; <span class="comment">// 计数器加1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;number); <span class="comment">// 继续输入下一个数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,<span class="number">1.0</span>*sum/count); <span class="comment">// 输出平均值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数的逆序"><a href="#数的逆序" class="headerlink" title="数的逆序"></a>数的逆序</h3><blockquote><blockquote><blockquote><blockquote><p>整数的分解</p></blockquote></blockquote></blockquote><ul><li>一个整数是由1至多位数字组成的，如何分解出整数的各个位上的数字，然后加以计算</li><li>对一个整数做%10的操作，就得到它的个位</li><li>数对一个整数做/10的操作，就去掉了它的个位数</li><li>然后再对2的结果做%10，就得到原来数的十位数了</li><li>依此类推。</li></ul></blockquote><ul><li>输入一个正整数，输出逆序的数</li><li>结尾的0的处理</li></ul><h4 id="不保留0"><a href="#不保留0" class="headerlink" title="不保留0"></a>不保留0</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 输入一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> digit;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>; <span class="comment">// 初始化反转后的结果为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) <span class="comment">// 当输入的整数大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = x % <span class="number">10</span>;         <span class="comment">// 取出x的个位数</span></span><br><span class="line">        ret = ret * <span class="number">10</span> + digit; <span class="comment">// 将取出的个位数加入到反转后的结果中</span></span><br><span class="line">        x /= <span class="number">10</span>;                <span class="comment">// 去掉x的个位数，将x缩小10倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret &gt; <span class="number">0</span>) <span class="comment">// 当反转后的结果大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = ret % <span class="number">10</span>;    <span class="comment">// 取出ret的个位数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, digit); <span class="comment">// 输出该位数字</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 如果ret大于9，输出空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret /= <span class="number">10</span>; <span class="comment">// 去掉ret的个位数，将ret缩小10倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    <span class="comment">// 输出换行符</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>格式与保留0一样 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 输入一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> digit;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>; <span class="comment">// 初始化反转后的结果为0</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) <span class="comment">// 当输入的整数大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = x % <span class="number">10</span>;         <span class="comment">// 取出x的个位数</span></span><br><span class="line">        ret = ret * <span class="number">10</span> + digit; <span class="comment">// 将取出的个位数加入到反转后的结果中</span></span><br><span class="line">        x /= <span class="number">10</span>;                <span class="comment">// 去掉x的个位数，将x缩小10倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = ret;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) <span class="comment">// 当输入的整数大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = x % <span class="number">10</span>;         <span class="comment">// 取出x的个位数</span></span><br><span class="line">        ret = ret * <span class="number">10</span> + digit; <span class="comment">// 将取出的个位数加入到反转后的结果中</span></span><br><span class="line">        x /= <span class="number">10</span>;                <span class="comment">// 去掉x的个位数，将x缩小10倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ret &gt; <span class="number">0</span>) <span class="comment">// 当反转后的结果大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = ret % <span class="number">10</span>;    <span class="comment">// 取出ret的个位数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, digit); <span class="comment">// 输出该位数字</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 如果ret大于9，输出空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret /= <span class="number">10</span>; <span class="comment">// 去掉ret的个位数，将ret缩小10倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 输出换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="保留0"><a href="#保留0" class="headerlink" title="保留0"></a>保留0</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">// 输入一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> digit; <span class="comment">// 定义变量digit，用于保存每一位的数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        digit = x % <span class="number">10</span>; <span class="comment">// 取x的个位数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,digit); <span class="comment">// 输出该位数字</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 如果x大于9，输出空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        x /= <span class="number">10</span>; <span class="comment">// x除以10，去掉个位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 输出换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整数分解"><a href="#整数分解" class="headerlink" title="整数分解"></a>整数分解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 输入一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">1</span>; <span class="comment">// 初始化为1，用于计算最高位的位置</span></span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">9</span>) <span class="comment">// 循环计算次方的值，直到t小于等于9</span></span><br><span class="line">    &#123;</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">// 将t除以10，缩小10倍</span></span><br><span class="line">        mask *= <span class="number">10</span>; <span class="comment">// 更新次方的值，扩大10倍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (mask &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = x / mask; <span class="comment">// 计算x除以mask的商，得到当前位的数字</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d); <span class="comment">// 输出当前位的数字</span></span><br><span class="line">        <span class="keyword">if</span> (mask &gt; <span class="number">9</span>) <span class="comment">// 如果mask大于9，则输出一个空格</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x %= mask; <span class="comment">// 将x对mask取余，得到去掉当前位后的新值</span></span><br><span class="line">        mask /= <span class="number">10</span>; <span class="comment">// 缩小mask10倍，准备处理下一位</span></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 输出换行符</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="念数字"><a href="#念数字" class="headerlink" title="念数字"></a>念数字</h3><blockquote><p>输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出”fu”字。</p><p>输入格式</p><p>输入在一行中给出一个整数，如:1234。<br>提示:整数包括负数、零和正数</p><p>输出格式</p><p>在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 yier san si</p><p>输入样例:</p><p>-600</p><p>输出样例:<br>fu liu ling ling</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 从标准输入读取一个整数x</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="comment">// 如果x小于0，输出&quot;fu &quot;表示负数，并将x取绝对值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fu &quot;</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mask = <span class="number">1</span>; <span class="comment">// 用于计算位数的掩码，初始为1</span></span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">9</span>) <span class="comment">// 计算x的位数</span></span><br><span class="line">    &#123;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">        mask *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> <span class="comment">// 逐位转换并输出</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> d = x / mask; <span class="comment">// 取出当前位的数字</span></span><br><span class="line">        <span class="keyword">switch</span> (d)        <span class="comment">// 根据数字选择对应的中文读法输出</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;ling&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;yi&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;er&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;san&quot;</span>);  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;si&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">&quot;wu&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">&quot;liu&quot;</span>);  <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">&quot;qi&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">&quot;ba&quot;</span>);   <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">&quot;jiu&quot;</span>);  <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mask &gt; <span class="number">9</span>) <span class="comment">// 输出数字之间的空格，除最后一位外都需要输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        x %= mask;  <span class="comment">// 去掉已经处理过的高位</span></span><br><span class="line">        mask /= <span class="number">10</span>; <span class="comment">// 缩小掩码，处理下一位</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (mask &gt; <span class="number">0</span>); <span class="comment">// 当掩码大于0时继续循环</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><blockquote><ul><li>n!=1×2×3×4×…×n</li><li>写一个程序，让用户输入n，然后计算输出n!</li><li>变量<ul><li>显然读用户的输入需要一个int的n，然后计算的结果需要用一个变量保存，可以是int的factor，在计算中需要有一个变量不断地从1递增到n，那可以是int的i</li></ul></li></ul></blockquote><p>做求和的程序时，记录结果的变量应该初始化为0，而做求积的变量时，记录结果的变量应该初始化为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="type">int</span> fact = <span class="number">1</span>; <span class="comment">// 初始化阶乘为1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入n的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 循环n次</span></span><br><span class="line">    &#123;</span><br><span class="line">        fact = fact * i; <span class="comment">// 计算阶乘，每次将当前数乘以累积的阶乘值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d!=%d\n&quot;</span>, n, fact); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><ul><li>只能被1和自己整除的数，不包括1</li><li>2，3，5，7，11，13，17，19……</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 从用户输入读取一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> isPrime = <span class="number">1</span>; <span class="comment">// 假设x是素数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; x; i++) <span class="comment">// 从2开始遍历到x-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 如果x可以被i整除，则x不是素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            isPrime = <span class="number">0</span>; <span class="comment">// 将isPrime置为0，表示x不是素数</span></span><br><span class="line">            <span class="keyword">break</span>;       <span class="comment">// 跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPrime == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d是素数&quot;</span>, x); <span class="comment">// 如果isPrime为1，表示x是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不是素数&quot;</span>, x); <span class="comment">// 否则，x不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="100以内的素数"><a href="#100以内的素数" class="headerlink" title="100以内的素数"></a>100以内的素数</h4><ul><li>如何写程序输出100以内的素数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">2</span>; x &lt;= <span class="number">100</span>; x++) <span class="comment">// 遍历2到100之间的每个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> isPrime = <span class="number">1</span>; <span class="comment">// 假设x是素数d</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; x; i++) <span class="comment">// 从2开始遍历到x-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 如果x可以被i整除，则x不是素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                isPrime = <span class="number">0</span>; <span class="comment">// 将isPrime置为0，表示x不是素数</span></span><br><span class="line">                <span class="keyword">break</span>;       <span class="comment">// 跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPrime == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x); <span class="comment">// 如果isPrime为1，表示x是素数，输出x</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="输出50个素数"><a href="#输出50个素数" class="headerlink" title="输出50个素数"></a>输出50个素数</h4><ul><li>输出50个素数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录已经输出的素数个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">50</span>) <span class="comment">// 循环输出前50个素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> isPrime = <span class="number">1</span>; <span class="comment">// 假设x是素数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; x; i++) <span class="comment">// 从2开始遍历到x-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 如果x可以被i整除，则x不是素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                isPrime = <span class="number">0</span>; <span class="comment">// 将isPrime置为0，表示x不是素数</span></span><br><span class="line">                <span class="keyword">break</span>;       <span class="comment">// 跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPrime == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, x); <span class="comment">// 如果isPrime为1，表示x是素数，输出x</span></span><br><span class="line">            cnt++;             <span class="comment">// 已输出的素数个数加1</span></span><br><span class="line">            <span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)  <span class="comment">// 每输出5个素数，换行</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        x++; <span class="comment">// 继续判断下一个数是否为素数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="统计素数并求和"><a href="#统计素数并求和" class="headerlink" title="统计素数并求和"></a>统计素数并求和</h4><blockquote><p>本题要求统计给定整数M和N区间内素数的个数并对它们求和<br>输入格式:<br>输入在一行中给出2个正整数M和N(1&lt;=M&lt;=N&lt;=500)<br>输出格式<br>在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔<br>输入样例:<br>10 31<br>输出样例:<br>7 143</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录素数个数</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 记录素数的和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n); <span class="comment">// 从标准输入读取两个整数m和n，表示要求解的区间范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">1</span>) <span class="comment">// 如果m小于等于1，则将m设置为2，因为2是最小的素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        m = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = m; i &lt;= n; i++) <span class="comment">// 遍历从m到n的每个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> isPrime = <span class="number">1</span>; <span class="comment">// 假设当前数i是素数</span></span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">2</span>; k &lt; i - <span class="number">1</span>; k++) <span class="comment">// 判断i是否为素数，从2到i-1进行除法运算</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % k == <span class="number">0</span>) <span class="comment">// 如果存在除数能够整除i，则i不是素数</span></span><br><span class="line">            &#123;</span><br><span class="line">                isPrime = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPrime == <span class="number">1</span>) <span class="comment">// 如果i是素数，则更新计数器cnt和累加器sum</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, cnt, sum); <span class="comment">// 输出素数个数和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="构造素数表"><a href="#构造素数表" class="headerlink" title="构造素数表"></a>构造素数表</h4><blockquote><ul><li>欲构造n以内的素数表<ol><li>令x为2</li><li>将2x、3x、4x直至ax&lt;n的数标记为非素数</li><li>令x为下一个没有被标记为非素数的数，重复2;直到所有的数都已经尝试完毕</li></ol></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义要判断的最大数值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> maxNumber = <span class="number">25</span>;</span><br><span class="line">    <span class="comment">// 定义一个数组，用于记录每个数是否为素数</span></span><br><span class="line">    <span class="type">int</span> isPrime[maxNumber];</span><br><span class="line">    <span class="comment">// 定义循环计数器</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录素数的个数</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组，所有数都被标记为素数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; maxNumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        isPrime[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用筛法进行素数判断</span></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">2</span>; x &lt; maxNumber; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果当前数x是素数，则将其倍数标记为非素数</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">2</span>; i * x &lt; maxNumber; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                isPrime[i * x] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出素数的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d以下的素数有：\n&quot;</span>, maxNumber);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; maxNumber; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出素数的个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n素数一共有%d个\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="凑硬币"><a href="#凑硬币" class="headerlink" title="凑硬币"></a>凑硬币</h3><p>如何用1角、2角和5角的硬币凑出10元以下的金额呢?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, one, two, five;</span><br><span class="line">    <span class="type">int</span> exit = <span class="number">0</span>; <span class="comment">// 用于控制循环退出的标志变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10元以下的金额：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">10</span>) <span class="comment">// 判断输入金额是否在有效范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (one = <span class="number">1</span>; one &lt; x * <span class="number">10</span>; one++) <span class="comment">// 遍历一角的数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (two = <span class="number">1</span>; two &lt; x * <span class="number">10</span> / <span class="number">2</span>; two++) <span class="comment">// 遍历两角的数量</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (five = <span class="number">1</span>; five &lt; x * <span class="number">10</span> / <span class="number">5</span>; five++) <span class="comment">// 遍历五角的数量</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (one + two * <span class="number">2</span> + five * <span class="number">5</span> == x * <span class="number">10</span>) <span class="comment">// 判断是否满足金额条件</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;可以用%d个一角加%d个两角加%d个五角得到%d元\t\n&quot;</span>, one, two, five, x);</span><br><span class="line">                        </span><br><span class="line">                         <span class="keyword">goto</span> out; <span class="comment">//跳转到标签out处执行后续的代码。 跳出多层循环</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// exit = 1; // 设置标志变量为1，表示找到了满足条件的组合</span></span><br><span class="line">                        <span class="comment">// break;    // 跳出当前循环</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*  if (exit == 1) // 如果标志变量为1，则跳出当前循环</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    break;</span></span><br><span class="line"><span class="comment">                &#125; */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*   if (exit == 1) // 如果标志变量为1，则跳出当前循环</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125; */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out: <span class="comment">//标签out</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>goto</code> 语句在编程中具有一些好处和坏处。下面是它们的一些常见优点和缺点：</p><p>优点：</p><ol><li>灵活性：<code>goto</code> 语句可以使程序跳转到指定的标签处，从而在需要的地方执行特定的代码，从而实现灵活的控制流程。</li><li>简洁性：在某些情况下，使用 <code>goto</code> 语句可以使代码更加简洁、清晰，避免嵌套和重复的代码。</li><li>跳出多层循环：<code>goto</code> 语句可以用于跳出多层嵌套循环，避免使用复杂的标志变量或其他控制结构。</li></ol><p>缺点：</p><ol><li>可读性差：过多使用 <code>goto</code> 语句可能会导致代码逻辑混乱，可读性降低，使代码难以理解和维护。</li><li>难以调试：使用 <code>goto</code> 语句可能会增加代码的复杂性，使得程序的调试变得更加困难，特别是在跳转较多的情况下。</li><li>破坏结构化编程：<code>goto</code> 语句可能破坏结构化编程的原则，使得程序的控制流程难以追踪和理解，增加代码的错误风险。</li></ol><p>总结起来，虽然 <code>goto</code> 语句在某些情况下可能有其用处，但过度使用它可能会导致代码的可读性和可维护性下降。在实际开发中，应尽量避免滥用 <code>goto</code>，而是通过合理设计循环、条件语句和函数等结构化编程技巧来实现控制流程的控制。</p><h3 id="n项求和"><a href="#n项求和" class="headerlink" title="n项求和"></a>n项求和</h3><h4 id="全加"><a href="#全加" class="headerlink" title="全加"></a>全加</h4><p>这段代码实现了一个数学函数 f(n) 的计算，其中 f(n) 的定义为：</p><p>f(n) = 1 + 1/2 + 1/3 + … + 1/n</p><p>这段代码通过一个循环来计算 f(n)，将每一项的值加入累加和中。最终输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>; <span class="comment">// 初始化累加和为0.0</span></span><br><span class="line">    <span class="type">double</span> sing = <span class="number">1.0</span>; <span class="comment">// 初始化符号为正</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入n的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 循环n次</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += sing / i; <span class="comment">// 累加每一项</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f\n&quot;</span>, n, sum); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一加一减"><a href="#一加一减" class="headerlink" title="一加一减"></a>一加一减</h4><p>这段代码计算了一个数学函数 f(n)，其中 f(n) 的定义为：</p><p>f(n) = 1 - 1/2 + 1/3 - 1/4 + … + (-1)^(n-1)/n</p><p>通过循环将每一项的值加入累加和中，并且每隔一项改变一次符号。最后输出结果。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024164407277.png" alt="image-20231024164407277"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>; <span class="comment">// 初始化累加和为0.0</span></span><br><span class="line">    <span class="type">double</span> sing = <span class="number">1.0</span>; <span class="comment">// 初始化符号为正</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入n的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 循环n次</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += sing / i; <span class="comment">// 累加每一项</span></span><br><span class="line">        sing = -sing; <span class="comment">// 修改符号，使得每一项的符号交替变化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;f(%d)=%f\n&quot;</span>, n, sum); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><blockquote><ul><li>输入两个数a和b，输出它们的最大公约数</li><li>输入: 12  18</li><li>输出: 6</li></ul></blockquote><p><mark>推荐使用辗转相除法</mark></p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><blockquote><ol><li>设t为2;</li><li>如果u和v都能被t整除，则记下这个t</li><li>t加1后重复第2步，直到t等于u或v;<br> 那么，曾经记下的最大的可以同时整除u和v的t就是gcd</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>; <span class="comment">// 初始化最大公约数为0</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b); <span class="comment">// 输入两个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a &amp;&amp; i &lt;= b; i++) <span class="comment">// 从1到a和1到b之间遍历每个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) <span class="comment">// 如果i能同时整除a和b</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = i; <span class="comment">// 更新最大公约数的值为i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d和%d的最大公约数是%d。\n&quot;</span>, a, b, ret); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h4><blockquote><ol><li>如果b等于0，计算结束，a就是最大公约数否则;</li><li>计算a除以b的余数，让a等于b，而b等于那个余数;</li><li>回到第一步。</li></ol></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024194121897.png" alt="image-20231024194121897"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b); <span class="comment">// 输入两个整数</span></span><br><span class="line"></span><br><span class="line">    c = a; <span class="comment">// 保存原始的a值，用于输出结果</span></span><br><span class="line">    d = b; <span class="comment">// 保存原始的b值，用于输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = a % b; <span class="comment">// 计算a除以b的余数</span></span><br><span class="line">        a = b;     <span class="comment">// 将b赋值给a</span></span><br><span class="line">        b = t;     <span class="comment">// 将余数赋值给b</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d和%d的最大公约数是%d。\n&quot;</span>, c, d, a); <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停控制台窗口以便查看输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求符合给定条件的整数集"><a href="#求符合给定条件的整数集" class="headerlink" title="求符合给定条件的整数集"></a>求符合给定条件的整数集</h3><blockquote><p>给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。<br>输入格式:<br>输入在一行中给出A。<br>输出格式:<br>输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行未不能有多余空格。</p><p>输入样例：<br>2</p><p>输出祥例:</p><p>234 235 243 245 253 254<br>324 325 342 345 352 354<br>423 425 432 435 452 453<br>523 524 532 534 542 543</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 计数器，用于控制每行输出的数字数量</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个不超过6的正整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); <span class="comment">// 从标准输入读取一个整数a</span></span><br><span class="line">    <span class="keyword">if</span>(a&gt;=<span class="number">0</span> &amp;&amp; a&lt;=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = a; i &lt;= a + <span class="number">3</span>; i++) <span class="comment">// 第一个数字的取值范围为a到a+3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = a; j &lt;= a + <span class="number">3</span>; j++) <span class="comment">// 第二个数字的取值范围为a到a+3</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = a; k &lt;= a + <span class="number">3</span>; k++) <span class="comment">// 第三个数字的取值范围为a到a+3</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != j &amp;&amp; i != k &amp;&amp; j != k) <span class="comment">// 如果三个数字都不相等</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        cnt++;                     <span class="comment">// 计数器加1</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d&quot;</span>, i, j, k); <span class="comment">// 输出三个数字</span></span><br><span class="line">                        <span class="keyword">if</span> (cnt == <span class="number">6</span>)              <span class="comment">// 如果已经输出了6个数字</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">                            cnt = <span class="number">0</span>;      <span class="comment">// 重置计数器</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 输出空格</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h3><blockquote><p> 水仙花数是指一个N位正整数(N&gt;=3)，它的每个位上的数字的N次之和等于它本身。例 如:153=1³+5³＋3³ 本题要求编写程序<br> 计算所有N位水仙花数。</p><p> 输入格式:<br> 输入在一行中给出一个正整数N(3&lt;=N&lt;=7)<br> 输出格式:<br> 按递增顺序输出所有N位水仙花数，每个数字占一行</p><p> 输入样例:<br> 3<br> 输出样例:<br> 153<br> 370<br> 371</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 从标准输入读取一个整数n，表示要求解的水仙花数的位数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        first *= <span class="number">10</span>; <span class="comment">// 计算第一个n位数，将first乘以10，每次循环增加一位数的值</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    i = first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从第一个n位数开始遍历到最后一个n位数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; first * <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = i;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> d = t % <span class="number">10</span>; <span class="comment">// 取出t的个位数字</span></span><br><span class="line">            t /= <span class="number">10</span>;        <span class="comment">// 去掉t的个位数字</span></span><br><span class="line">            <span class="type">int</span> p = d;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                p *= d; <span class="comment">// 计算每个数字的n次方</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += p;    <span class="comment">// 将每个数字的n次方相加得到sum</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t &gt; <span class="number">0</span>); <span class="comment">// 当t大于0时，继续循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum == i) <span class="comment">// 如果sum等于i，则i是水仙花数，输出i</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="九九乘法表"><a href="#九九乘法表" class="headerlink" title="九九乘法表"></a>九九乘法表</h3><p>下面是一个完整的下三角九九口诀表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">5</span>=<span class="number">5</span>   <span class="number">2</span>*<span class="number">5</span>=<span class="number">10</span>  <span class="number">3</span>*<span class="number">5</span>=<span class="number">15</span>  <span class="number">4</span>*<span class="number">5</span>=<span class="number">20</span>  <span class="number">5</span>*<span class="number">5</span>=<span class="number">25</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">6</span>=<span class="number">6</span>   <span class="number">2</span>*<span class="number">6</span>=<span class="number">12</span>  <span class="number">3</span>*<span class="number">6</span>=<span class="number">18</span>  <span class="number">4</span>*<span class="number">6</span>=<span class="number">24</span>  <span class="number">5</span>*<span class="number">6</span>=<span class="number">30</span>  <span class="number">6</span>*<span class="number">6</span>=<span class="number">36</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">7</span>=<span class="number">7</span>   <span class="number">2</span>*<span class="number">7</span>=<span class="number">14</span>  <span class="number">3</span>*<span class="number">7</span>=<span class="number">21</span>  <span class="number">4</span>*<span class="number">7</span>=<span class="number">28</span>  <span class="number">5</span>*<span class="number">7</span>=<span class="number">35</span>  <span class="number">6</span>*<span class="number">7</span>=<span class="number">42</span>  <span class="number">7</span>*<span class="number">7</span>=<span class="number">49</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">8</span>=<span class="number">8</span>   <span class="number">2</span>*<span class="number">8</span>=<span class="number">16</span>  <span class="number">3</span>*<span class="number">8</span>=<span class="number">24</span>  <span class="number">4</span>*<span class="number">8</span>=<span class="number">32</span>  <span class="number">5</span>*<span class="number">8</span>=<span class="number">40</span>  <span class="number">6</span>*<span class="number">8</span>=<span class="number">48</span>  <span class="number">7</span>*<span class="number">8</span>=<span class="number">56</span>  <span class="number">8</span>*<span class="number">8</span>=<span class="number">64</span>  </span><br><span class="line"><span class="number">1</span>*<span class="number">9</span>=<span class="number">9</span>   <span class="number">2</span>*<span class="number">9</span>=<span class="number">18</span>  <span class="number">3</span>*<span class="number">9</span>=<span class="number">27</span>  <span class="number">4</span>*<span class="number">9</span>=<span class="number">36</span>  <span class="number">5</span>*<span class="number">9</span>=<span class="number">45</span>  <span class="number">6</span>*<span class="number">9</span>=<span class="number">54</span>  <span class="number">7</span>*<span class="number">9</span>=<span class="number">63</span>  <span class="number">8</span>*<span class="number">9</span>=<span class="number">72</span>  <span class="number">9</span>*<span class="number">9</span>=<span class="number">81</span>  </span><br></pre></td></tr></table></figure><blockquote><p> 本题要求对任意给定的一位正整数N，输出从1 <em> 1到N</em>N的部分口诀表。</p><p> 输入格式：<br> 输入在一行中给出一个正整数N（1≤N≤9）。</p><p> 输出格式：<br> 输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。</p><p> 输入样例：<br> 4<br> 输出样例：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">2</span>=<span class="number">2</span>   <span class="number">2</span>*<span class="number">2</span>=<span class="number">4</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">3</span>=<span class="number">3</span>   <span class="number">2</span>*<span class="number">3</span>=<span class="number">6</span>   <span class="number">3</span>*<span class="number">3</span>=<span class="number">9</span>   </span><br><span class="line"><span class="number">1</span>*<span class="number">4</span>=<span class="number">4</span>   <span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>   <span class="number">3</span>*<span class="number">4</span>=<span class="number">12</span>  <span class="number">4</span>*<span class="number">4</span>=<span class="number">16</span> </span><br></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 从标准输入读取一个整数n，表示要输出的乘法表的最大数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 外层循环控制行数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) <span class="comment">// 内层循环控制每一行的列数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d*%d=%d&quot;</span>, j, i, j * i); <span class="comment">// 输出乘法表中的一项</span></span><br><span class="line">            <span class="keyword">if</span> (i * j &lt; <span class="number">10</span>)                  <span class="comment">// 如果乘积小于10，输出三个空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 否则输出两个空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 每输出完一行，换行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求序列前N项和"><a href="#求序列前N项和" class="headerlink" title="求序列前N项和"></a>求序列前N项和</h3><blockquote><p>本题要求编写程序,计算序列2/1+3/2+5/3+8/5+… 的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。</p><p>输入格式:<br>输入在一行中给出一个正整数N。</p><p>输出格式:<br>在一行中输出部分和的值，精确到小数点后2位。题目保证计算结果不超过双精度范围</p><p>输入样例:<br>20</p><p>输出样例:<br>32.66</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> dividend, divisor; <span class="comment">// 分子和分母</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0.0</span>;         <span class="comment">// 和的累加器</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> t; <span class="comment">// 临时变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 从标准输入读取一个整数n，表示要计算斐波那契数列的前n项和</span></span><br><span class="line"></span><br><span class="line">    dividend = <span class="number">2</span>;            <span class="comment">// 初始化分子为2</span></span><br><span class="line">    divisor = <span class="number">1</span>;             <span class="comment">// 初始化分母为1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">// 循环计算前n项和</span></span><br><span class="line">    &#123;</span><br><span class="line">        sum += dividend / divisor; <span class="comment">// 将当前项的值累加到和中</span></span><br><span class="line">        t = dividend;              <span class="comment">// 交换分子和分母的值，使下一项的分子等于上一项的分子加上分母</span></span><br><span class="line">        dividend = dividend + divisor;</span><br><span class="line">        divisor = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, sum); <span class="comment">// 输出前n项和，保留两位小数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约分最简分式"><a href="#约分最简分式" class="headerlink" title="约分最简分式"></a>约分最简分式</h3><blockquote><p>分数可以表示为“分子/分母”的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8;而当分子分母相等时，仍然表达为1/1的分数形式</p><p>输入格式:</p><p>输入在一行中给出一个分数，分子和分母中间以斜杠”分隔，如:12/34 表示34分之12分子和分母都是正整数(不包含0如果不清楚正整数的定义的话)</p><p>提示:在scanf的格式字符串中加A”/”，让scanf来处理这个斜杠</p><p>输出格式:</p><p>在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用“分子/分母”的形式表示分数。如 5/6表示6分之5.</p><p>输入样例:</p><p>60/120</p><p>输出样例：</p><p>1/2</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> dividend, divisor;               <span class="comment">// 分子和分母</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d/%d&quot;</span>, &amp;dividend, &amp;divisor); <span class="comment">// 从标准输入读取一个分数，格式为分子/分母</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = dividend; <span class="comment">// 将分子保存到变量a中</span></span><br><span class="line">    <span class="type">int</span> b = divisor;  <span class="comment">// 将分母保存到变量b中</span></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) <span class="comment">// 使用辗转相除法求最大公约数</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d/%d\n&quot;</span>, dividend / a, divisor / a); <span class="comment">// 输出化简后的分数，分子除以最大公约数，分母除以最大公约数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="求a的连续和"><a href="#求a的连续和" class="headerlink" title="求a的连续和"></a>求a的连续和</h3><blockquote><p>输入两个整数a和n，a的范用是[0,9],n的范用是[1,8]，求数列之和S = a+aataaa+…taaa..a(n个a)。如a为2、n为8时输出的<br>2+22+222+…+22222222的和。</p><p>输入格式:<br>输入在一行中给出两个整数，先后表示a和n。</p><p>输出格式:<br>在一行中输出要求的数列之和</p><p>输入样例:<br>24<br>输出样例:</p><p>2468</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;n); <span class="comment">// 从标准输入读取两个整数a和n</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 用于存储等比数列的和</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 用于计算每一项的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">// 循环n次，计算每一项的值并累加到sum中</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = t * <span class="number">10</span> + a;  <span class="comment">// 计算当前项的值，每一项都是前一项乘以10再加上a</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, t); <span class="comment">// 输出当前项的值</span></span><br><span class="line">        <span class="keyword">if</span> (i != n - <span class="number">1</span>)  <span class="comment">// 如果不是最后一项，输出&quot;+&quot;符号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; + &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i == n - <span class="number">1</span>) <span class="comment">// 如果是最后一项，输出&quot;=&quot;符号</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; = &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += t; <span class="comment">// 累加当前项的值到sum中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum); <span class="comment">// 输出等比数列的和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="井字棋"><a href="#井字棋" class="headerlink" title="井字棋"></a>井字棋</h3><blockquote><ul><li>读入一个3X3的矩阵，矩阵中的数字为1表示该位置上有一个X，为0表示为O</li><li>程序判断这个矩阵中是否有获胜的一方输出表示获胜一方的字符X或O，或输出无人获胜</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> board[size][size]; <span class="comment">// 定义一个3x3的棋盘数组</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> numofX, numofO;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取玩家在棋盘上下的棋子位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;board[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查行是否有一方获胜</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size &amp;&amp; result == <span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        numofO = numofX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                numofX++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                numofO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numofO == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>; <span class="comment">// O方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numofX == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">1</span>; <span class="comment">// X方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果行没有获胜者，检查列是否有一方获胜</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size &amp;&amp; result == <span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            numofO = numofX = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    numofX++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    numofO++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (numofO == size)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="number">0</span>; <span class="comment">// O方获胜</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numofX == size)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="number">1</span>; <span class="comment">// X方获胜</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果行和列都没有获胜者，检查主对角线是否有一方获胜</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        numofO = numofX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][i] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                numofX++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                numofO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numofO == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>; <span class="comment">// O方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numofX == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">1</span>; <span class="comment">// X方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果行、列和主对角线都没有获胜者，检查副对角线是否有一方获胜</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        numofO = numofX = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][size - i - <span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                numofX++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                numofO++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (numofO == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">0</span>; <span class="comment">// O方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numofX == size)</span><br><span class="line">        &#123;</span><br><span class="line">            result = <span class="number">1</span>; <span class="comment">// X方获胜</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据判断结果输出胜利者信息</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;O wins\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;X wins\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No winner\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p>代码只是参考，有很多实现方式，主要是思路</p><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><blockquote><p><strong>题目内容：</strong></p><p>请输出一行，内容为</p><p>Hello World</p><p>请注意大小写。</p><p><strong>输入格式:</strong></p><p>无输入</p><p><strong>输出格式：</strong></p><p>一行文</p><p><strong>输入样例：</strong></p><p>无</p><p><strong>输出样例：</strong></p><p>Hello World</p><p>时间限制：500ms内存限制：32000kb</p></blockquote><p>我的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);   <span class="comment">// 打印输出&quot;Hello World&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序的三位数"><a href="#逆序的三位数" class="headerlink" title="逆序的三位数"></a>逆序的三位数</h3><blockquote><p><strong>题目内容：</strong></p><p>逆序的三位数：</p><p>程序每次读入一个正三位数，然后输出逆序的数字。注意，当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。</p><p>提示：用%10可以得到个位数，用/100可以得到百位数…。将这样得到的三个数字合起来：百位<em>100+十位</em>10+个位，就得到了结果。</p><p><strong><em>注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求输出逆序的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。</em></strong></p><p><strong>输入格式:</strong></p><p>每个测试是一个3位的正整数。</p><p><strong>输出格式：</strong></p><p>输出逆序的数。</p><p><strong>输入样例：</strong></p><p>123</p><p><strong>输出样例：</strong></p><p>321</p><p>时间限制：500ms内存限制：32000kb</p></blockquote><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 从用户输入读取一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt; <span class="number">999</span>) <span class="comment">// 判断输入是否在合法范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果不在合法范围内，程序直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> digit;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) <span class="comment">// 当x大于0时执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        digit = x % <span class="number">10</span>; <span class="comment">// 取x的个位数字</span></span><br><span class="line">        ret = ret * <span class="number">10</span> + digit; <span class="comment">// 将digit添加到ret的末尾，当十位百位是0时则会清除0</span></span><br><span class="line">        x /= <span class="number">10</span>; <span class="comment">// 将x除以10，去掉个位数字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ret); <span class="comment">// 输出逆序后的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="时间换算"><a href="#时间换算" class="headerlink" title="时间换算"></a>时间换算</h3><blockquote><p>题目内容：</p><p>UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。</p><p>有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。</p><p>你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。</p><p>提醒：要小心跨日的换算。</p><p><strong>输入格式:</strong></p><p>一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。</p><p><strong>输出格式：</strong></p><p>一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；如果小时是0而分小于10分的，则不需要保留十位上的0。</p><p><strong>输入样例：</strong></p><p>803</p><p><strong>输出样例：</strong></p><p>3</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> BJT = <span class="number">0</span>, UTC = <span class="number">0</span>, h = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;BJT); <span class="comment">// 输入北京时间</span></span><br><span class="line"></span><br><span class="line">    h = BJT / <span class="number">100</span>; <span class="comment">// 提取小时部分</span></span><br><span class="line">    m = BJT % <span class="number">100</span>; <span class="comment">// 提取分钟部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((h &gt;= <span class="number">0</span> &amp;&amp; h &lt;= <span class="number">23</span>) &amp;&amp; (m &gt;= <span class="number">0</span> &amp;&amp; m &lt;= <span class="number">59</span>)) <span class="comment">// 判断输入是否合法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt; <span class="number">8</span>) <span class="comment">// 如果小时小于8</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = <span class="number">24</span> + (h - <span class="number">8</span>);  <span class="comment">// 转换为UTC时间，加上24小时</span></span><br><span class="line">            UTC = h * <span class="number">100</span> + m; <span class="comment">// 根据转换后的小时和分钟计算UTC时间</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, UTC); <span class="comment">// 输出UTC时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h == <span class="number">8</span>) <span class="comment">// 如果小时等于8</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = h - <span class="number">8</span>;         <span class="comment">// 转换为UTC时间，不需要加上额外的小时数</span></span><br><span class="line">            UTC = h * <span class="number">100</span> + m; <span class="comment">// 根据转换后的小时和分钟计算UTC时间</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, UTC); <span class="comment">// 输出UTC时间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h &gt; <span class="number">8</span>) <span class="comment">// 如果小时大于8</span></span><br><span class="line">        &#123;</span><br><span class="line">            h = h - <span class="number">8</span>;         <span class="comment">// 转换为UTC时间，减去8个小时</span></span><br><span class="line">            UTC = h * <span class="number">100</span> + m; <span class="comment">// 根据转换后的小时和分钟计算UTC时间</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, UTC); <span class="comment">// 输出UTC时间</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分队列"><a href="#分队列" class="headerlink" title="分队列"></a>分队列</h3><blockquote><p><strong>题目内容：</strong></p><p>班级第一次列队，通常老师会让同学按身高排成一列，然后1、2报数，喊到1的同学向前一 步，就这样，队伍就变成两列了。假设现在一个班级有n个同学，并且他们已经按身高排成 了一列，同学按身高从1到n编号，你能告诉我最后哪些编号的同学站在了第一列么? </p><p><strong>输入格式:</strong></p><p>输入一个正整数n，表示班级的人数。</p><p><strong>输出格式：</strong></p><p>按顺序输出所有在第一列的同学对应的编号，每两个编号之间用一个空格隔开，最后一个编号后面没有空格。</p><p><strong>输入样例：</strong></p><p>11</p><p><strong>输出样例：</strong></p><p>1 3 5 7 9 11</p></blockquote><p>这是别人的，写的很好，推荐使用这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n, count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入班级人数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">// 判断编号是否为奇数</span></span><br><span class="line">        &#123;</span><br><span class="line">            count++; <span class="comment">// 记录输出的数字个数</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) <span class="comment">// 第一个数字前没有空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 其他数字前有一个空格</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 读入班级人数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否为最后一个数字，如果是，则不再输出空格</span></span><br><span class="line">        <span class="keyword">if</span> (i == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">// 如果是奇数，直接输出</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 如果是偶数，不输出任何字符</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是最后一个数字，按照题目要求输出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">// 如果是奇数，直接输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 如果是偶数，输出一个空格</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="奇偶个数"><a href="#奇偶个数" class="headerlink" title="奇偶个数"></a>奇偶个数</h3><blockquote><p> <strong>题目内容：</strong></p><p> 你的程序要读入一系列正整数数据，输入-1表示输入结束，-1本身不是输入的数据。程序输出读到的数据中的奇数和偶数的个数。</p><p> <strong>输入格式:</strong></p><p> 一系列正整数，整数的范围是（0,100000）。如果输入-1则表示输入结束。</p><p> <strong>输出格式：</strong></p><p> 两个整数，第一个整数表示读入数据中的奇数的个数，第二个整数表示读入数据中的偶数的个数。两个整数之间以空格分隔。</p><p> <strong>输入样例：</strong></p><p> 9 3 4 2 5 7 －1 </p><p> <strong>输出样例：</strong></p><p> 4 2</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, odd = <span class="number">0</span>, even = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 读取第一个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">100000</span>) <span class="comment">// 对第一个整数进行范围判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">-1</span>) <span class="comment">// 当整数不等于-1时继续循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                even++; <span class="comment">// 偶数计数器加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                odd++; <span class="comment">// 奇数计数器加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 读取下一个整数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, odd, even); <span class="comment">// 输出奇数和偶数的个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字特征值"><a href="#数字特征值" class="headerlink" title="数字特征值"></a>数字特征值</h3><blockquote><p><strong>题目内容：</strong></p><p>对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。</p><p>这里的计算可以用下面的表格来表示：</p><div class="table-container"><table><thead><tr><th>数字</th><th>3</th><th>4</th><th>2</th><th>3</th><th>1</th><th>5</th></tr></thead><tbody><tr><td>数位</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td></tr><tr><td>数字奇偶</td><td>奇</td><td>偶</td><td>偶</td><td>奇</td><td>奇</td><td>奇</td></tr><tr><td>数位奇偶</td><td>偶</td><td>奇</td><td>偶</td><td>奇</td><td>偶</td><td>奇</td></tr><tr><td>奇偶一致</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>二进制位值</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr></tbody></table></div><p>你的程序要读入一个非负整数，整数的范围是[0,1000000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。</p><p>提示：将整数从右向左分解，数位每次加1，而二进制值每次乘2。</p><p><strong>输入格式:</strong></p><p>一个非负整数，整数的范围是[0,1000000]。</p><p><strong>输出格式：</strong></p><p>一个整数，表示计算结果。</p><p><strong>输入样例：</strong></p><p>342315</p><p><strong>输出样例：</strong></p><p>13</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> number;    <span class="comment">// 用户输入的数字</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 数位计数器</span></span><br><span class="line">    <span class="type">int</span> digit;     <span class="comment">// 当前数位</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;   <span class="comment">// 转换结果的累加和</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &gt;= <span class="number">0</span> &amp;&amp; number &lt;= <span class="number">1000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            digit = number % <span class="number">10</span>;          <span class="comment">// 获取当前数位</span></span><br><span class="line">            <span class="keyword">if</span> ((digit + count) % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">// 判断数位和计数器之和的奇偶性</span></span><br><span class="line">            &#123;</span><br><span class="line">                sum = sum + <span class="built_in">pow</span>(<span class="number">2</span>, count - <span class="number">1</span>); <span class="comment">// 根据规则进行转换并累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            count++;      <span class="comment">// 更新计数器</span></span><br><span class="line">            number /= <span class="number">10</span>; <span class="comment">// 去掉最低位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum); <span class="comment">// 输出转换结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><h2 id="程序框架"><a href="#程序框架" class="headerlink" title="程序框架"></a>程序框架</h2><p>c语言基本框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p> 本课程中所有的程序都需要这一段直到学函数之前，我们的代码都只是在这个框架中间</p></blockquote><p>vscode小黑框框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);   <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p><code>printf</code>是C语言中的一个标准库函数，用于输出格式化字符串到标准输出设备（一般为控制台或终端窗口）。它可以输出各种数据类型，并支持格式化输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>==” “==  里面的内容叫做 “ 字符串 ”，printf会把==其中的内容原封不动地==输出<br><strong>==\n==</strong> 表示需要在输出的结果后面换一行; 换行符</p></blockquote><h4 id="做计算"><a href="#做计算" class="headerlink" title="做计算"></a>做计算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>，<span class="number">23</span>+<span class="number">43</span>);</span><br></pre></td></tr></table></figure><blockquote><p> ==%d==  说明后面有一个整数要输出在这个位置上</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;23+43=%d\n&quot;</span>，<span class="number">23</span>+<span class="number">43</span>);</span><br></pre></td></tr></table></figure><p>两个代码的运行结果是不一样的</p><p>1                                                                                 2</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022210553658.png" alt="image-20231022210553658">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022210620677.png" alt=""></p><h4 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h4><div class="table-container"><table><thead><tr><th style="text-align:center">四则运算</th><th style="text-align:center">c符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">加</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">减</td></tr><tr><td style="text-align:center">×</td><td style="text-align:center">*</td><td style="text-align:center">乘</td></tr><tr><td style="text-align:center">÷</td><td style="text-align:center">/</td><td style="text-align:center">除</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">%</td><td style="text-align:center">取余</td></tr><tr><td style="text-align:center">()</td><td style="text-align:center">()</td><td style="text-align:center">括号</td></tr></tbody></table></div><blockquote><p>==%==  表示取两个数相除以后的余数</p></blockquote><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p><code>scanf</code>是C语言中的一个标准库函数，用于从标准输入设备（一般为键盘）读取格式化输入并将其存储到指定的变量中。它可以读取各种数据类型，并支持格式化输入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;23+43=%d\n&quot;</span>，<span class="number">23</span>+<span class="number">43</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;100-23=%d\n&quot;</span>，<span class="number">100</span><span class="number">-23</span>);</span><br></pre></td></tr></table></figure><blockquote><p>如何能在程序运行时输入那个数字23，然后计算输出结果?</p><p>需要:<br>1.有地方放输入的数字<br>2.有办法输入数字<br>3.输入的数字能参与计算</p></blockquote><h4 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> price = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> change = <span class="number">100</span> - price;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找你%d元。\n&quot;</span>,change);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022213153815.png" alt="image-20231022213153815"></p><blockquote><p>如何输入</p><ul><li>输入也在终端窗口中</li><li>输入是以行为单位进行的，行的结束标志就是你按下了回车键。在你按下回车之前，你的程序不会读到任何东西</li></ul></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>这一行，定义了一个变量。变量的名字是price，类型是int，初始值是0。</li><li>变量是一个保存数据的地方，当我们需要在程序里保存数据时，比如上面的例子中要记录用户输入的价格，就需要一个变量来保存它。用一个变量保存了数据，它才能参加到后面的计算中，比如计算找零。</li></ul></blockquote><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><blockquote><ul><li>变量定义的一般形式就是:  <ul><li>&lt;类型名称&gt; &lt;变量名称&gt;;</li></ul></li><li>int price;</li><li>int amount;</li><li>int price, amount;</li></ul></blockquote><h3 id="变量的名字"><a href="#变量的名字" class="headerlink" title="变量的名字"></a>变量的名字</h3><ul><li>变量需要一个名字，变量的名字是一种“标识符”，意思是它是用来识别这个和那个的不同的名字。</li><li>标识符有标识符的构造规则。基本的原则是:标识符只能由 ==字母、数字和下划线== 组成，数字不可以出现在第一个位置上，c语言的关键字（有的地方叫它们保留字)不可以用做标识符。</li></ul><p>C语言的保留字</p><p>不需要背诵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>,<span class="keyword">break</span>,<span class="keyword">case</span>,<span class="type">char</span>,<span class="type">const</span>,<span class="keyword">continue</span>,<span class="keyword">default</span>,<span class="keyword">do</span>,<span class="type">double</span>,<span class="keyword">else</span>,<span class="keyword">enum</span>,<span class="keyword">extern</span>,<span class="type">float</span>,<span class="keyword">for</span>,<span class="keyword">goto</span>,<span class="keyword">if</span>,<span class="type">int</span>,<span class="type">long</span>,<span class="keyword">register</span>,<span class="keyword">return</span>,<span class="type">short</span>,<span class="type">signed</span>,<span class="keyword">sizeof</span>,<span class="type">static</span>,<span class="keyword">struct</span>,<span class="keyword">switch</span>,<span class="keyword">typedef</span>,<span class="keyword">union</span>,<span class="type">unsigned</span>,<span class="type">void</span>,<span class="keyword">volatile</span>,<span class="keyword">while</span>,<span class="keyword">inline</span>, restrict,</span><br></pre></td></tr></table></figure><h3 id="赋值和初始化"><a href="#赋值和初始化" class="headerlink" title="赋值和初始化"></a>赋值和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这一行，定义了一个变量。变量的名字是price，类型是int，初始值是0。<br>price=0是一个式子，这里的“=”是一个赋值运算符,表示将“=”右边的值赋给左边的变量。</p><p>==赋值==</p><blockquote><p>和数学不同，a=b在数学中表示关系，即:a和b的值一样; 而在程序设计中，a=b表示要求计算机做一个动作:将b的值赋给a。关系是静态的,而动作是动态的。在数学中，a=b和b=a是等价的，而在程序设计中，两者的意思完全相反</p></blockquote><p>==初始化==</p><blockquote><ul><li>当赋值发生在定义变量的时候，就像程序中的第5行那样，就是变量的初始化。虽然C语言并没有强制要求所有的变量都在定义的地方做初始化，但是所有的变量在第一次被使用(出现在赋值运算符的右边)之前被应该赋值一次</li></ul></blockquote><p>如果没有初始化?</p><p>这是翁恺老师的程序运行结果</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022221109517.png" alt="image-20231022221109517"></p><p>这是我的</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022221218291.png" alt="image-20231022221218291"></p><p>不同的编译环境可能不一样，但是还是需要初始化，这样保证安全；</p><p>我的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    j = i+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><blockquote><ul><li>&lt;类型名称&gt;&lt;变量名称&gt;=&lt;初始值&gt;; </li><li>int price = 0;</li><li>int amount = I00;</li><li>组合变量定义的时候，也可以在这个定义中单独给单个变量赋初值，如:</li><li>int price = 0, amount = l00;</li></ul></blockquote><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><blockquote><ul><li>int price = 0;</li><li>这一行，定义了一个变量。变量的名字是price，类型是int，初始值是0。</li><li>C是一种有类型的语言，所有的变量在使用之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据,变量中只能存放指定类型的数据，程序运行过程中也不能改变变量的类型。</li></ul></blockquote><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>不变的量是常量</p><blockquote><ul><li>int change = l00 - price;</li><li>固定不变的数，是常数。直接写在程序里，我们称作直接量(literal) 。</li><li>更好的方式，是定义一个常量:<ul><li>const int AMOUNT = 100;</li></ul></li></ul></blockquote><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><blockquote><ul><li>const是一个修饰符，加在int的前面，用来给这个变量加上一个const(不变的）的属性。这个const的属性表示这个变量的值一旦初始化，就不能再修改了。<ul><li>int change = AMOUNT - price;</li></ul></li><li>如果你试图对常量做修改,把它放在赋值运算符的左边，就会被编译器发现，指出为一个错误。</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022223021168.png" alt="image-20231022223021168"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> AMOUNT = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> price = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AMOUNT = 90;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入金额（元）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;price);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> change = AMOUNT - price;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找你%d元。\n&quot;</span>,change);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==try==</p><blockquote><ul><li>让用户输入变量AMOUNT的值，而不是使用固定的初始值</li></ul><ul><li>这个变量在哪里定义合适呢?</li></ul></blockquote><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="五尺七寸"><a href="#五尺七寸" class="headerlink" title="五尺七寸"></a>五尺七寸</h3><blockquote><ul><li>美国人固执地使用英制计量单位，他们习惯用几尺几寸(英尺英寸)来报自己的身高。如果遇到一个美国人告诉你他是5英尺7，他的身高应该是一米几呢?</li></ul><ul><li>(5+7÷l2 ) ×0.3048= 1.70I8米</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022224257536.png" alt="image-20231022224257536"></p><p>为什么程序错了</p><p>因为…</p><blockquote><ul><li>因为两个整数的运算的结果只能是整数</li><li>10/3*3=&gt;?</li><li>10和10.0在c中是完全不同的数</li><li>10.0是浮点数</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022224722875.png" alt="image-20231022224722875"></p><p>那我们把10改成10.0呢</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022225018458.png" alt="image-20231022225018458"></p><p>把%d改成%f运行</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022225109981.png" alt="image-20231022225109981"></p><p>在乘上3，现在结果没有问题</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022225154515.png" alt="image-20231022225154515"></p><h3 id="浮点数-1"><a href="#浮点数-1" class="headerlink" title="浮点数"></a>浮点数</h3><blockquote><p>带小数点的数值。浮点这个词的本意就是指小数点是浮动的，是计算机内部表达非整数（包含分数和无理数)的一种方式。另一种方式叫做定点数，不过在C语言中你不会遇到定点数。人们借用浮点数这个词来表达所有的带小数点的数。</p></blockquote><p>double</p><blockquote><ul><li>inch是定义为int类型的变量，如果把int换成double，我们就把它改为double类型的浮点数变量了。</li><li>double的意思是“双”，它本来是“双精度浮点数”的第一个单词，人们用来表示浮点数类型。除了double，还有float (意思就是浮点!) 表示单精度浮点数。</li></ul></blockquote><h3 id="五尺七寸的两种改法"><a href="#五尺七寸的两种改法" class="headerlink" title="五尺七寸的两种改法"></a>五尺七寸的两种改法</h3><p>1</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022230352160.png" alt="image-20231022230352160"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> foot,inch;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;foot,&amp;inch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;身高是%f米。&quot;</span>,((foot + inch /<span class="number">12.0</span>)* <span class="number">0.3048</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022230534818.png" alt="image-20231022230534818"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> foot,inch;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>,&amp;foot,&amp;inch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;身高是%f米。&quot;</span>,((foot + inch /<span class="number">12</span>)* <span class="number">0.3048</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote><ul><li><p>整数</p><ul><li>int</li><li>printf(“%d”….)</li><li>scanf(“%d”,…)</li></ul></li><li><p>带小数点的数</p><ul><li>double</li><li>printf(“%f “,…)</li><li>scanf(“%lf”,….)</li></ul></li></ul><p>注意使用浮点型输入的时候用的是 ==%lf==  输出是 ==%f==</p></blockquote><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h3 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h3><p>一个表达式是一系列运算符和算子的组合用来计算一个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">amount = x*(<span class="number">1</span> + <span class="number">0.033</span>) *(<span class="number">1</span>+<span class="number">0.033</span>) *(<span class="number">1</span> + <span class="number">0.033</span>);</span><br><span class="line">total  = <span class="number">57</span>;</span><br><span class="line">count  = count + <span class="number">1</span>;</span><br><span class="line">value  = (min / <span class="number">2</span>)* lastValue;</span><br></pre></td></tr></table></figure><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote><ul><li>运算符(operator)是指进行运算的动作，比如加法运算符“ + ”，减法运算符” - “。</li><li>算子(operand)是指参与运算的值，这个值可能是常数,也可能是变量，还可能是一个方法的返回值</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231022231438305.png" alt="image-20231022231438305"></p><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><div class="table-container"><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">运算</th><th style="text-align:center">结合关系</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">+</td><td style="text-align:center">单目不变</td><td style="text-align:center">自右向左</td><td style="text-align:center">a*+ b</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">-</td><td style="text-align:center">单目取负</td><td style="text-align:center">自右向左</td><td style="text-align:center">a*- b</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">*</td><td style="text-align:center">乘</td><td style="text-align:center">自左向右</td><td style="text-align:center">a * b</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">/</td><td style="text-align:center">除</td><td style="text-align:center">自左向右</td><td style="text-align:center">a / b</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">%</td><td style="text-align:center">取余</td><td style="text-align:center">自左向右</td><td style="text-align:center">a % b</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">+</td><td style="text-align:center">加</td><td style="text-align:center">自左向右</td><td style="text-align:center">a + b</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">-</td><td style="text-align:center">减</td><td style="text-align:center">自左向右</td><td style="text-align:center">a - b</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">=</td><td style="text-align:center">赋值</td><td style="text-align:center">自右向左</td><td style="text-align:center">a = b</td></tr></tbody></table></div><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><blockquote><ul><li>赋值也是运算，也有结果</li><li>a=6的结果是a被赋予的值，也就是6</li><li>a = b = 6 -&gt; a = (b=6)</li></ul></blockquote><p>“嵌入式赋值”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span> + (b = a)</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>不利于阅读</p></li><li><p>容易产生错误</p><p>  不建议这样赋值</p></li></ul></blockquote><p>结合关系</p><blockquote><ul><li>一般自左向右</li><li>单目+ - 和赋值 = 自右向左</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = a = b = <span class="number">3</span> + c;</span><br><span class="line">result = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样的式子不要写出来</span></span><br><span class="line">result = (result = result *<span class="number">2</span>) *<span class="number">6</span> *(result = <span class="number">3</span> + result);</span><br></pre></td></tr></table></figure><p>这样的表达式大复杂不容易阅读和理解，容易造成程序的误解，所以，要避免写出这样复杂的表达式出来，这个表达式应该被拆成若干个表达式， 然后以明显的正确的顺序来进行计算</p><h2 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h2><h3 id="交换两个变量"><a href="#交换两个变量" class="headerlink" title="交换两个变量"></a>交换两个变量</h3><blockquote><ul><li><p>如果已经有:</p><p>  int a = 6;</p><p>  int b = 5;</p><p>  如何交换a、b两个变量的值?</p></li></ul></blockquote><p>让 a = b , b = a ?</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023101055456.png" alt="image-20231023101055456"></p><p>这样明显是不对的</p><p>程序是按步执行的</p><blockquote><ul><li><p>程序表达的是顺序执行的动作，而不是关系</p><p>  a=b;</p><p>  b=a;</p><p>  是依次执行的，结果使得a和b都得到b原来的值</p></li></ul></blockquote><p>所以需要在添加一个保存数据的变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">t = a;</span><br><span class="line">a = b;</span><br><span class="line">b = t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\nb=%d\n&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><h3 id="vscoedC语言调试方法"><a href="#vscoedC语言调试方法" class="headerlink" title="vscoedC语言调试方法"></a>vscoedC语言调试方法</h3><p>在你需要调试的语句前面点击一下出现红点，然后运行程序就可以调试了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023102310474.png" alt="image-20231023102310474"></p><p>功能非常强大</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023102454232.png" alt="image-20231023102454232"></p><h3 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a>复合赋值</h3><blockquote><ul><li>5个算术运算符，+ - <em> / %，可以和赋值运算符“ = ”结合起来，形成复合赋值运算符:“ += ”、“ -= ”’、“ </em>= ”、“ /= ”和” %= ”<ul><li>total += 5;</li><li>total = total + 5;</li></ul></li><li>注意两个运算符中间不要有空格</li></ul><p>total += (sum+100)/2;<br>total = total + (sum+l00)/2;</p><p>total <em>=  sum +12;<br>total = total </em> (sum+12);</p><p>total /= 12+6;<br>total = total / (12+6);</p></blockquote><p>递增递减运算符</p><blockquote><ul><li><p>“＋＋”和“—“是两个很特殊的运算符，它们是单目运算符，这个算子还必须是变量。这两个运算符分别叫做递增和递减运算符，他们的作用就是给这个变量+1或者-1。</p><ul><li>count++;</li></ul></li></ul><pre><code>    count += 1;- count = count + 1;</code></pre><p>前缀后缀</p><ul><li>＋＋和—可以放在变量的前面，叫做前缀形式，也可以放在变量的后面，叫做后缀形式。</li></ul><ul><li>a++的值是a加1以前的值，而++a的值是加了1以后的值，无论哪个，a自己的值都加了1了。</li></ul></blockquote><p>这就是前缀和后缀的不同</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023104225173.png" alt="image-20231023104225173"></p><div class="table-container"><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:center">运算</th><th style="text-align:center">表达式的值</th></tr></thead><tbody><tr><td style="text-align:center">count++</td><td style="text-align:center">给count加1</td><td style="text-align:center">count原来的值</td></tr><tr><td style="text-align:center">++count</td><td style="text-align:center">给count加1</td><td style="text-align:center">count+1以后的值</td></tr><tr><td style="text-align:center">给count减1</td><td style="text-align:center">count—</td><td style="text-align:center">count原来的值</td></tr><tr><td style="text-align:center">—count</td><td style="text-align:center">给count减1</td><td style="text-align:center">count-1以后的值</td></tr></tbody></table></div><p>++—</p><blockquote><ul><li><p>这两个运算符有其历史来源</p></li><li><p>可以单独使用，但是不要组合进表达式</p><ul><li><p>++i++ —&gt; ?</p></li><li><p>i++++ ——&gt;?</p></li></ul></li><li><p>a = b+ = c++-d+—e/-f</p></li></ul></blockquote><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><p>条件</p><ul><li>计算两个值之间的关系，叫做关系运算</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">==</td><td style="text-align:center">相等</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不相等</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于或等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于或等于</td></tr></tbody></table></div><p>关系运算的结果</p><blockquote><ul><li>当两个值的关系符合关系运算符的预期时关系运算的结果为整数1，否则为整数0 （也就是1为真，0为假）</li></ul><pre><code>- printf(&quot;%d\n&quot;,5==3);- printf(&quot;%d\n&quot;,5&gt;3)- printf(&quot;%d\n&quot;,5&lt;=3);</code></pre></blockquote><p>优先级</p><blockquote><ul><li>所有的关系运算符的优先级比算术运算的低，但是比赋值运算的高<ul><li>7 &gt;= 3+4</li><li>int r = a &gt; 0</li></ul></li></ul><ul><li>判断是否相等的 == 和 != 的优先级比其他的低，而连续的关系运算是从左到右进行的</li></ul><pre><code>- ​    5&gt;3 == 6&gt;4- ​    6 &gt; 5 &gt; 4- ​    a == b == 6- ​    a == b&gt;0</code></pre></blockquote><p>找零计算器</p><blockquote><ul><li>找零计算器需要用户做两个操作: 输入购买的金额，输入支付的票面，而找零计算器则根据用户的输入做出相应的动作:计算并打印找零，或告知用户余额不足以购买。</li></ul><ul><li>从计算机程序的角度看，这就是意味着程序需要读用户的两个输入，然后进行一些计算和判断，最后输出结果。</li></ul></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>​    //</p><ul><li>以两个斜杠“//”开头的语句把程序分成了三个部分:</li></ul><p>   1.初始化</p><p>   2.读入金额和票面</p><p>   3.计算并打印找零</p><p>​    /<em> </em>/</p><ul><li>延续数行的注释，要用多行注释的格式来写。多行注释由一对字符序列“/<em> ”开始，而以“ </em>/” 结束。</li><li>也可以用于一行内的注释<ul><li>int ak=47 / <em> 36 </em>/,y=9</li></ul></li></ul></blockquote><p>比较</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023140943743.png" alt="image-20231023140943743"></p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><blockquote><ul><li>一个基本的if语句由一个关键字if开头，跟上在括号里的一个表示条件的逻辑表达式，然后是一对大括号“ {} ”之间的若干条语句。如果表示条件的逻辑表达式的结果不是零，那么就执行后面跟着的这对大括号中的语句，否则就跳过这些语句不执行，而继续下面的其他语句。</li></ul></blockquote><p>if语句也不是一定要 {} </p><blockquote><p>在C语言中，<code>if</code>语句可以使用花括号<code>&#123;&#125;</code>来将语句组织成一个语句块。语句块中的语句会被视为一个整体，并按顺序依次执行。</p><p>使用花括号可以提高代码的可读性和易于维护性，尤其是在语句块中包含多条语句时，使用花括号更能清晰地表达代码的逻辑。</p><p>但实际上，在<code>if</code>语句中不一定要使用花括号。如果条件所跟的代码只有一条语句，可以省略花括号。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(total &gt; amount)</span><br><span class="line"></span><br><span class="line">total += amount + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><blockquote><p>if语句这一行结束的时候并没有表示语句结束的“ ; ”，而后面的赋值语句写在if的下一行，并且缩进了，在这一行结束的时候有一个表示语句结束的“ ; ”。这表明这条赋值语句是if语句的一部分，if语句拥有和控制这条赋值语句，决定它是否要被执行。</p></blockquote><h4 id="嵌套的判断"><a href="#嵌套的判断" class="headerlink" title="嵌套的判断"></a>嵌套的判断</h4><blockquote><p> 当if的条件满足或者不满足的时候要执行的语句也可以是一条if或if-else语句，这就是嵌套的if语句</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (code == READY)</span><br><span class="line"><span class="keyword">if</span> (count &lt; <span class="number">20</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;一切正常\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;继续等待\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="else的匹配"><a href="#else的匹配" class="headerlink" title="else的匹配"></a>else的匹配</h4><ul><li>else总是和最近的那个if匹配</li></ul><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023154511373.png" alt="image-20231023154511373"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023154536953.png" alt="image-20231023154536953"></p><p>可以看到这个断点这个if并没有else与他匹配</p><p>但是我们可以使用花括号让他们匹配</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023154856507.png" alt="image-20231023154856507"></p><p>缩进</p><ul><li>缩进格式不能暗示else的匹配</li></ul><p>tips</p><blockquote><p>在if或else后面总是用 {}</p><p>即使只有一条语句</p></blockquote><h4 id="if-else-if"><a href="#if-else-if" class="headerlink" title="if-else if"></a>if-else if</h4><p>分段函数</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023160713616.png" alt="image-20231023160713616"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( x &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    f = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    f = <span class="number">2</span> * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch - case 语句"></a>switch - case 语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量: 语句</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量: 语句</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量: 语句</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: 语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>控制表达式只能是整数型的结果</li><li>常量可以是常数，也可以是常数计算的表达式</li></ul><p>==break==</p><blockquote><p>switch语句可以看作是一种基于计算的跳转，计算控制表达式的值后，程序会跳转到相匹配的case (分支标号) 处。分支标号只是说明switch内部位置的路标，在执行完分支中的最后一条语句后如果后面没有break，就会顺序执行到下面的case里去，直到遇到一个break，或者switch结束为止。</p></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023162739000.png" alt="image-20231023162739000"></p><p>运行结果</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023163228691.png" alt="image-20231023163228691"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023163258880.png" alt="image-20231023163258880">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231023163318816.png" alt="image-20231023163318816"></p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;你好\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">&quot;晚上好\n&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">&quot;再见\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;啊，什么啊\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while循环</p><blockquote><p>如果我们把while翻译作“当”，那么一个while循环的意思就是:当条件满足时，不断地重复循环体内的语句。</p><p>循环执行之前判断是否继续循环，所以有可能循环一次也没有被执行;</p><p>条件成立是循环继续的条件</p></blockquote><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do - while循环"></a>do - while循环</h3><blockquote><p>在进入循环的时候不做检查，而是在执行完一轮循环体的代码之后，再来检查循环的条件是否满足，如果满足则继续下一轮循环，不满足则结束循环</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">   &lt;循环体语句&gt;</span><br><span class="line">&#125;</span><br><span class="line">while(&lt;循环条件&gt;);</span><br></pre></td></tr></table></figure><h3 id="两种while循环"><a href="#两种while循环" class="headerlink" title="两种while循环"></a>两种while循环</h3><p>左边是do - while,右边是while</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024085813724.png" alt="image-20231024085813724"></p><blockquote><p>do-while循环和while循环很像，区别是在循环体执行结束的时候才来判断条件。也就是说，无论如何，循环都会执行至少一遍，然后再来判断条件。与while循环相同的是，条件满足时执行循环，条件不满足时结束循环。</p></blockquote><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><blockquote><p>for循环像一个计数循环:设定一个计数器，初始化它，然后在计数器到达某值之前，重复执行循环体而每执行一轮循环，计数器值以一定步进进行调整比如加1或者减1</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for = 对于</p><blockquote><p>for ( count=10;count&gt;0;count— )<br>就读成: 对于一开始的count=10，当count&gt;0时,重复做循环体，每一轮循环在做完循环体内语句后，使得count—。</p></blockquote><ul><li>做求和的程序时，记录结果的变量应该初始化为0，而做求积的变量时，记录结果的变量应该初始化为1</li></ul><p>循环次数</p><blockquote><ul><li>for (i=0;i&lt;n;i++);</li><li>则循环的次数是n，而循环结束以后，i的值是n。循环的控制变量i，是选择从0开始还是从1开始，是判断i&lt;n还是判断i&lt;=n,对循环的次数，循环结束后变量的值都有影响</li></ul><p>for(i=1;i&lt;=5;i++) 和 for (i=0;i&lt;n;i++)</p><p>循环都是5次，但是i的值是不一样的</p></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024110647794.png" alt="image-20231024110647794">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024110713645.png" alt=""></p><blockquote><blockquote><blockquote><blockquote><p>for == while</p></blockquote></blockquote></blockquote><p>for(初始动作;条件;每轮的动作)<br>{</p><p>}</p><ul><li><p>for中的每一个表达式都是可以省略的</p><p> for(;条件;) == while( 条件)</p></li></ul></blockquote><h3 id="三种循环"><a href="#三种循环" class="headerlink" title="三种循环"></a>三种循环</h3><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024111346148.png" alt="image-20231024111346148"></p><blockquote><ul><li>如果有固定次数，用for</li><li>如果必须执行一次，用do - while</li><li>其他情况用while</li></ul></blockquote><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><ul><li>break: 跳出循环</li><li>continue: 跳过循环这一轮剩下的语句进入下一轮</li></ul><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231024121524896.png" alt="image-20231024121524896"></p><h3 id="循环的嵌套"><a href="#循环的嵌套" class="headerlink" title="循环的嵌套"></a>循环的嵌套</h3><ul><li>循环的里面还是循环</li></ul><p>可以查看程序里的素数代码；</p><h3 id="跳出嵌套的循环"><a href="#跳出嵌套的循环" class="headerlink" title="跳出嵌套的循环"></a>跳出嵌套的循环</h3><blockquote><p> break和continue<br> 只能对它所在的那层循环做,也就是跳出一层循环，在多层循环并不能一次跳出</p></blockquote><p>goto 函数可以直接跳出多重循环</p><p><code>goto</code> 是C语言中的一个关键字，它用于无条件地转移到程序中的标签位置。然而，在编程实践中，使用 <code>goto</code> 是被广泛认为是不推荐的，因为它会导致代码变得难以理解和维护。</p><p>以下是一个使用 <code>goto</code> 的简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    loop: <span class="comment">// 标签位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> loop; <span class="comment">// 无条件跳转到标签位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用 <code>goto</code> 实现了一个简单的循环。当 <code>i</code> 小于10时，程序会跳转到标签 <code>loop</code> 处重新执行循环。虽然这个示例很简单，但它展示了 <code>goto</code> 的基本用法。</p><p>然而，在大多数情况下，可以使用循环和条件语句（如 <code>while</code>、<code>for</code>、<code>if</code>）来替代 <code>goto</code>，以提高代码的可读性和可维护性。因此，在实际编程中，应该尽量避免使用 <code>goto</code>。</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><blockquote><p>字节（Byte）：Byte就是字节，bit就是位</p><p>1 Byte = 8 bit</p><p>1 KB = 1024 Byte</p><p>1 MB = 1024 KB</p><p>1 GB = 1024 MB</p></blockquote><p>简单了解字节和位之后，先来看一个最简单的例子，8位-无符号表示的最大最小值。</p><p>其中每一位都可填入0或1，</p><p>1位      二进制最大值为1       最大值就是1          (2^1)-1</p><p>2位     二进制最大值为11      最大值就是3          (2^2)-1</p><p>3位     二进制最大值为111    最大值就是7          (2^3)-1</p><p>……</p><p>所以如果是8位无符号的最大值就是1111 1111，最大值是255，即就是 (2^8)-1。</p><pre><code>然而有符号只是在此基础上让8位中的第一位充当符号位，0代表正数，1代表负数。</code></pre><p>  符号位</p><p>0正、1负</p><p>相当于变成了7位有效位，那么</p><p>8位有符号的最大值就是0111 1111，最大值是+127，即就是 (2^7)-1，</p><p>8位有符号的最小值就是1000 0000，最小值是-128，即就是 -2^7，</p><p>注意：这里为什么是 -2^7，而没有减1，是因为正数方向是从0开始的，0~127，共128个数字；</p><p>而负数方向没有0，因为实际上没有正0和负0的区分，只有一个0，如果负数方向也从0开始就相当于把0算了2次。在计算机中，默认把0归属于正数方向，所以负数方向就是从-1即就是1000 0001开始的，-1 ~ -128，也是128个数字。另外，默认规定1000 0000（负0）就是-128，因为7位有效位不可能表示出128。</p><p>所以有了简单的基础之后，我们如法炮制就可以得出2字节、4字节、8字节分别对应的有符号数的最大值和最小值。</p><div class="table-container"><table><thead><tr><th style="text-align:center">==有符号数：2字节（16位）==</th><th style="text-align:center"></th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">最大值</td><td style="text-align:center">（2^15) -1</td><td style="text-align:center">32767</td><td style="text-align:center">01…1   //0后面15个1</td></tr><tr><td style="text-align:center">最小值</td><td style="text-align:center">- 2^15</td><td style="text-align:center">- 32768</td><td style="text-align:center">10…0   //1后面15个0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">==有符号数：4字节（32位）==</th><th style="text-align:center"></th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">最大值</td><td style="text-align:center">（2^31) -1</td><td style="text-align:center">2147483647</td><td style="text-align:center">01…1   //0后面31个1</td></tr><tr><td style="text-align:center">最小值</td><td style="text-align:center">- 2^31</td><td style="text-align:center">-2147483648</td><td style="text-align:center">10…0   //1后面31个0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">==有符号数：8字节（64位）==</th><th style="text-align:center"></th><th style="text-align:center">十进制</th><th style="text-align:center">二进制</th></tr></thead><tbody><tr><td style="text-align:center">最大值</td><td style="text-align:center">（2^63) -1</td><td style="text-align:center">数字很大</td><td style="text-align:center">01…1 //0后面63个1</td></tr><tr><td style="text-align:center">最小值</td><td style="text-align:center">- 2^63</td><td style="text-align:center">数字很大</td><td style="text-align:center">10…0 //1后面63个0</td></tr></tbody></table></div><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="c是有类型的语言"><a href="#c是有类型的语言" class="headerlink" title="c是有类型的语言"></a>c是有类型的语言</h3><blockquote><ul><li>C语言的变量，必须:</li><li>在使用前定义，并且</li><li>确定类型</li><li>C以后的语言向两个方向发展<ul><li>C++/Java更强调类型，对类型的检查更严格</li><li>JavaScript、Python、PHP不看重类型，甚至不需要事先定义</li></ul></li></ul></blockquote><h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><blockquote><ul><li>支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误</li><li>反对强类型的观点认为过于强调类型迫使程序员面对底层、实现而非事务逻辑</li><li>总的来说，早期语言强调类型，面向底层的语言强调类型</li><li>C语言需要类型，但是对类型的安全检查并不足够</li></ul></blockquote><h3 id="c语言的类型"><a href="#c语言的类型" class="headerlink" title="c语言的类型"></a>c语言的类型</h3><blockquote><ul><li><p>整数</p><ul><li>char、 short、 int、 long、 ==long long==</li></ul></li><li><p>浮点数</p><ul><li>float、 double、 ==long double==</li></ul></li><li><p>逻辑</p><ul><li>==bool==    </li></ul></li><li><p>指针</p><pre><code>- 自定义类型</code></pre></li></ul><p>黄色的是C99类型</p></blockquote><p>类型有何不同</p><blockquote><ul><li>类型名称:<ul><li>int、long、 double</li></ul></li><li>输入输出时的格式化: <ul><li>%d、%ld、%lf</li></ul></li><li>所表达的数的范围:<ul><li>char &lt; short &lt;int &lt; float &lt;double</li></ul></li><li>内存中所占据的大小:<ul><li>1个字节到16个字节</li></ul></li><li>内存中的表达形式:<ul><li>二进制数(补码)、编码</li></ul></li></ul></blockquote><h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><blockquote><ul><li>sizeof 是一个运算符，给出某个类型或变量在内存中所占据的字节数<ul><li>sizeof(int)</li><li>sizeof(i)</li></ul></li></ul><ul><li><p>sizeof 是静态运算符，它的结果在编译时刻就决定了</p></li><li><p>不要在sizeof的括号里做运算，这些运算不会做的</p></li></ul></blockquote><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><blockquote><ul><li>char: 1字节(8比特): -128 ~ 127</li><li>short: 2字节: -32768 ~ 32767</li><li>int: 取决于编译器 (CPU) ，通常的意义是“1个字</li><li>long: 4字节</li><li>long long: 8字节</li></ul><ul><li>计算机内部一切都是二进制。</li><li>18 —&gt; 00010010</li><li>0 —&gt; 00000000</li><li>-18 —&gt; ?</li></ul><p>如何表示负数</p><p>十进制用“ - ”来表示负数，在做计算的时候</p></blockquote><h4 id="二进制负数"><a href="#二进制负数" class="headerlink" title="二进制负数"></a>二进制负数</h4><blockquote><ul><li><p>1个字节可以表达的数</p><ul><li>00000000-11111111(0-255)</li></ul></li></ul><ul><li>三种方案</li></ul><ul><li><p>1.仿照十进制，有一个特殊的标志表示负数</p></li><li><p>2.取中间的数为0，如1000000表示0，比它小的是负数，比它大的是正数</p></li><li><p>前面两种方案对二进制来说都有问题</p></li></ul><ul><li>3.补码</li></ul></blockquote><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><blockquote><ul><li><p>考虑 -1，我们希望-1 + 1一&gt;0。如何能做到?<br>  0 -&gt; 00000000<br>  1 -&gt; 00000001<br>  11111111 + 00000001 -&gt; 100000000</p></li><li><p>因为0 - 1一&gt; -1，所以，-1 =</p><ul><li>(1)00000000 - 00000001 —&gt; 11111111</li><li>11111111被当作纯二进制看待时，是255，被当作补码看待时是 -1 </li></ul></li></ul><p>同理，对于-a，其补码就是0-a，实际是 2^n^- a，n是这种类型的位数</p><p>补码的意义就是拿补码和原码可以加出一个溢出的“零”</p></blockquote><h4 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a>数的范围</h4><blockquote><ul><li><p>对于一个字节(8位)，可以表达的是</p><ul><li>00000000 - 11111111</li></ul></li><li><p>其中</p><ul><li>00000000 -&gt; 0</li><li>11111111~ 10000000-&gt;  -1~ -128</li><li>00000001 ~ 01111111-&gt; 1~127 </li></ul></li></ul></blockquote><h4 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h4><p>char -128~127</p><p>unsigned char 255</p><blockquote><ul><li>如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U</li><li>255U</li><li>用I或L表示long(long)</li><li>*unsigned的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位</li></ul></blockquote><h4 id="整数越界"><a href="#整数越界" class="headerlink" title="整数越界"></a>整数越界</h4><blockquote><ul><li>整数是以纯二进制方式进行计算的，所以<ul><li>11111111+1 -&gt; 100000000 -&gt; 0</li><li>01111111 +1 -&gt; 10000000 -&gt; -128</li><li>10000000 -1 -&gt; 01111111 -&gt; 127</li></ul></li></ul></blockquote><h4 id="整数的输入输出"><a href="#整数的输入输出" class="headerlink" title="整数的输入输出"></a>整数的输入输出</h4><blockquote><ul><li>只有两种形式:int或long long</li><li>%d: int</li><li>%u: unsigned</li><li>%ld: long long</li><li>%lu: unsigned long long</li></ul></blockquote><h4 id="8进制和16进制"><a href="#8进制和16进制" class="headerlink" title="8进制和16进制"></a>8进制和16进制</h4><blockquote><ul><li>一个以0开始的数字字面量是8进制</li><li>一个以0x开始的数字字面量是16进制</li><li>%o用于8进制，%X用于16进制</li><li><p>8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字无关</p></li><li><p>16进制很适合表达二进制数据，因为4位二进制正好是一个16进制位</p></li><li>8进制的一位数字正好表达3位二进制<ul><li>因为早期计算机的字长是12的倍数，而非8</li></ul></li></ul></blockquote><h4 id="选择整数类型"><a href="#选择整数类型" class="headerlink" title="选择整数类型"></a>选择整数类型</h4><blockquote><ul><li>为什么整数要有那么多种?<ul><li>为了准确表达内存，做底层程序的需要</li></ul></li></ul><ul><li>没有特殊需要，就选择int<ul><li>现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，甚至可能更慢</li><li><ul><li>现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)</li></ul></li></ul></li></ul><ul><li>unsigned与否只是输出的不同，内部计算是一样的</li></ul></blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字长</th><th style="text-align:center">范围</th><th style="text-align:center">有效数字</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">$\pm$ (1.20x10^-38^ ~ 3.40 x 10^38^ )<br />0,  $\pm$ inf,nan</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">$\pm$ (2.2x10^-308^ ~ 1.79 x 10^308^ )<br />0,  $\pm$ inf,nan</td><td style="text-align:center">15</td></tr></tbody></table></div><h4 id="浮点的输入输出"><a href="#浮点的输入输出" class="headerlink" title="浮点的输入输出"></a>浮点的输入输出</h4><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">scanf</th><th style="text-align:center">printf</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">%f</td><td style="text-align:center">%f,%e</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">%lf</td><td style="text-align:center">%f,%e</td></tr></tbody></table></div><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231025213550474.png" alt="image-20231025213550474"></p><h4 id="输出精度"><a href="#输出精度" class="headerlink" title="输出精度"></a>输出精度</h4><blockquote><ul><li>在%和f之间加上.n可以指定输出小数点后几位，这样的输出是做4舍5入的</li><li>printf(“%.3fn”,-0.0049)</li><li>printf(“%.30fn”,-0.0049)</li><li>printf(“%.3fn”，-0.00049):</li></ul></blockquote><p>超过范围的浮点数</p><blockquote><ul><li>printf输出inf表示超过范围的浮点数: $\pm$ $\infty$  </li><li>printf输出nan表示不存在的浮点数</li></ul></blockquote><p>浮点运算的精度</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231025214929979.png" alt="image-20231025214929979"></p><h4 id="浮点数的内部表达"><a href="#浮点数的内部表达" class="headerlink" title="浮点数的内部表达"></a>浮点数的内部表达</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231025215100749.png" alt="image-20231025215100749"></p><blockquote><ul><li>浮点数在计算时是由专用的硬件部件实现的</li><li>计算double和float所用的部件是一样的</li></ul></blockquote><h4 id="选择浮点类型"><a href="#选择浮点类型" class="headerlink" title="选择浮点类型"></a>选择浮点类型</h4><blockquote><ul><li>如果没有特殊需要，只使用double</li><li>现代CPU能直接对double做硬件运算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢</li></ul></blockquote><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><ul><li>char是一种整数，也是一种特殊的类型:字符。这是因为:<ul><li>用单引号表示的字符字面量: ‘a’ ，’1’</li><li>‘ ‘ 也是一个字符</li><li>printf和scanf里用%c来输入输出字符</li></ul></li></ul></blockquote><h3 id="字符的输入输出"><a href="#字符的输入输出" class="headerlink" title="字符的输入输出"></a>字符的输入输出</h3><blockquote><ul><li>如何输入1这个字符给char c?<ul><li>scanf(“%c”,&amp;c); -&gt; 1</li><li>scanf(“%d”,&amp;i); c=i ; -&gt; 49</li></ul></li><li>1’的ASCII编码是49，所以当c==49时，它代表 ‘1’<ul><li>printf(“%i %c\n”, c,c );</li></ul></li><li>一个49各自表述!</li></ul></blockquote><h3 id="字符计算"><a href="#字符计算" class="headerlink" title="字符计算"></a>字符计算</h3><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231025220355870.png" alt="image-20231025220355870"></p><blockquote><ul><li>一个字符加一个数字得到ASCI码表中那个数之后的字符</li><li>两个字符的减，得到它们在表中的距离</li></ul><blockquote><blockquote><blockquote><blockquote><blockquote><p>大小写转换</p></blockquote></blockquote></blockquote></blockquote></blockquote><ul><li>字母在ASCII表中是顺序排列的</li><li>大写字母和小写字母是分开排列的，并不在一起</li><li>‘a’ - ‘A’ 可以得到两段之间的距离，于是<ul><li>a+’a’-‘A’可以把一个大写字母变成小写字母，而</li><li>a+’A’-‘a’可以把一个小写字母变成大写字母</li></ul></li></ul></blockquote><h3 id="逃逸字符"><a href="#逃逸字符" class="headerlink" title="逃逸字符"></a>逃逸字符</h3><blockquote><p> 用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“ \ ”开头，后面跟上另一个字符，这两个字符合起来，组成了一个字符</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请分别输入身高的英尺和英寸，如输入\&quot;5 7\&quot;表示5英尺7英寸：&quot;</span>);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">\b</td><td style="text-align:center">回退一格</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">到下一个表格位</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\ “</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">\ ‘</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">\ \</td><td style="text-align:center">反斜杠本身</td></tr></tbody></table></div><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><blockquote><ul><li>当运算符的两边出现不一致的类型时，会自动转换成较大的类型</li><li>大的意思是能表达的数的范围更大</li><li>char -&gt; short -&gt; int -&gt; long -&gt; long long</li><li>int -&gt; float -&gt; double</li></ul><ul><li>对于printf，任何小于int的类型会被转换成int;float会被转换成double</li><li>但是scanf不会，要输入short，需要%hd</li></ul></blockquote><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><blockquote><ul><li>要把一个量强制转换成另一个类型(通常是较小的类，需要<ul><li>(类型)值</li></ul></li></ul><ul><li>比如<ul><li>(int)10.2</li><li>(short)32</li></ul></li></ul><ul><li>注意这时候的安全性，小的变量不总能表达大的量<ul><li>（short)32768</li></ul></li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231026092816495.png" alt="image-20231026092816495"></p><p>强制类型转换的优先级高于四则运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> a = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)a/b; </span><br><span class="line"><span class="type">int</span> i = (<span class="type">int</span>)(a/b); <span class="comment">//这两个运行结果是不一样的</span></span><br></pre></td></tr></table></figure><h2 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h2><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><blockquote><p>添加头文件  <code>#include &lt;stdbool.h&gt;</code></p><p>之后就可以使用 <code>bool</code>和 <code>true</code> <code>false</code></p></blockquote><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><blockquote><ul><li>逻辑运算是对逻辑量进行的运算，结果只有0或1</li><li>逻辑量是关系运算或逻辑运算的结果<br>  优先级</li></ul></blockquote><p>！&gt; &amp;&amp; &gt; ||</p><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">描述</th><th style="text-align:center">示例</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td><td style="text-align:center">!a</td><td style="text-align:center">如果a是true结果就是false如果a是false结果就是true</td></tr><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑与</td><td style="text-align:center">a &amp;&amp; b</td><td style="text-align:center">如果a和b都是true，结果就是true;否则就是false</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">\</td><td style="text-align:center"></td><td style="text-align:center">逻辑或</td><td>a \</td><td>\</td><td>b</td><td>如果a和b有一个是true，结果为true;两个都是false，结果为false</td></tr></tbody></table></div><blockquote><p>如何判断一个字符c是否是大写字母?</p><p>c&gt;=’A’&amp;&amp; c&lt;=’Z’</p></blockquote><p>短路</p><blockquote><ul><li>逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算<ul><li>a == 6 &amp;&amp; b == 1</li><li>a == 6 || b += 1</li></ul></li><li>对于 &amp;&amp; ，左边是false时就不做右边了</li><li>对于 || ，左边是true时就不做右边了</li></ul><p>不要把赋值，包括复合赋值组合进表达式！</p></blockquote><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote><p>逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算;逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。</p></blockquote><p>在for中使用</p><ul><li>for(i=0,j=10;i&lt;j;i++,j—)…… </li></ul><blockquote><ul><li>调用函数时的逗号和逗号运算符怎么区分?</li><li>调用函数时的圆括号里的逗号是标点符号，不是运算符</li><li>f(a,b)</li><li>f((a,b))</li></ul></blockquote><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="什么是函数-？"><a href="#什么是函数-？" class="headerlink" title="什么是函数 ？"></a>什么是函数 ？</h3><blockquote><ul><li>函数是一块代码，接收零个或多个参数做一件事情，并返回零个或一个值</li><li>可以先想像成数学中的函数</li><li>y = f(x)</li></ul></blockquote><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231026103210592.png" alt="image-20231026103210592"></p><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><blockquote><ul><li>函数名(参数值)</li><li>()起到了表示函数调用的重要作用</li><li>即使没有参数也需要()</li><li>如果有参数，则需要给出正确的数量和顺序</li><li>这些值会被按照顺序依次用来初始化函数中的参数</li></ul><ul><li>如果函数有参数，调用函数时必须传递给它数量类型正确的值</li><li>可以传递给函数的值是表达式的结果，这包括<ul><li>字面量</li><li>变量</li><li>函数的返回值</li><li>计算的结果</li></ul></li></ul></blockquote><p>类型不匹配?</p><blockquote><ul><li>调用函数时给的值与参数的类型不匹配是C语言传统上最大的漏洞</li><li>编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的</li><li>后续的语言，C++/Java在这方面很严格</li></ul></blockquote><h4 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h4><p>传过去的是什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这样的代码能交换a和b的值吗？</li></ul><p>c语言在调用函数时，永远只能传值给函数</p><blockquote><ul><li>每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系</li><li>过去，对于函数参数表中的参数，叫做“形式参数”，调用函数时给的值，叫做 “实际参数” </li><li>由于容易让初学者误会实际参数就是实际在函数中进行计算的参数，误会调用函数的时候把变量而不是值传进去了，所以我们不建议继续用这种古老的方式来称呼它们我们认为，</li><li>它们是参数和值的关系</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231026115206249.png" alt="image-20231026115206249"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231026115217745.png" alt="image-20231026115217745"></p><h3 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h3><blockquote><p> 函数知道每一次是哪里调用它，会返回到正确的地方</p></blockquote><h4 id="从函数里返回值"><a href="#从函数里返回值" class="headerlink" title="从函数里返回值"></a>从函数里返回值</h4><blockquote><ul><li>return停止函数的执行，并送回一个值</li><li>return;</li><li>return 表达式:</li></ul><ul><li>可以赋值给变量</li><li>可以再传递给函数</li><li>甚至可以丢弃</li></ul></blockquote><h4 id="没有返回值的函数"><a href="#没有返回值的函数" class="headerlink" title="没有返回值的函数"></a>没有返回值的函数</h4><blockquote><ul><li>void 函数名(参数表)</li><li>不能使用带值的return<ul><li>可以没有return</li></ul></li><li>调用的时候不能做返回值的赋值</li></ul><p>如果函数有返回值，则必须使用带值的return</p></blockquote><h3 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h3><blockquote><ul><li>函数的每次运行，就产生了一个独立的变量空间，在这个空间中的变量，是函数的这次运行所独有的，称作本地变量</li><li>定义在函数内部的变量就是本地变量</li><li>参数也是本地变量</li></ul></blockquote><p>变量的生存期和作用域</p><blockquote><ul><li>生存期:什么时候这个变量开始出现了，到什么时候它消亡了</li><li>作用域: 在(代码的)什么范围内可以访问这个变量(这个变量可以起作用)</li><li>对于本地变量，这两个问题的答案是统一的: <strong>大括号内一块</strong>  { }</li></ul></blockquote><p>本地变量的规则</p><blockquote><ul><li>本地变量是定义在块内的<ul><li>它可以是定义在函数的块内</li><li>也可以定义在语句的块内</li><li>甚至可以随便拉一对大括号来定义变量</li></ul></li><li><p>程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了 </p></li><li><p>块外面定义的变量在里面仍然有效</p></li><li>块里面定义了和外面同名的变量则掩盖了外面的</li><li>不能在一个块内定义同名的变量</li><li>本地变量不会被默认初始化</li><li>参数在进入函数的时候被初始化了</li></ul></blockquote><h3 id="函数的参数和变量"><a href="#函数的参数和变量" class="headerlink" title="函数的参数和变量"></a>函数的参数和变量</h3><p>没有参数时</p><blockquote><ul><li>void f(void);</li><li>还是</li><li>void f();</li><li>在传统C中，它表示f函数的参数表未知，并不代表没有参数</li></ul><blockquote><blockquote><blockquote><p>函数里的函数?</p></blockquote></blockquote></blockquote><p>c语言不允许函数嵌套定义</p><blockquote><blockquote><blockquote><p> 关于main</p></blockquote></blockquote></blockquote><ul><li>int main()也是一个函数</li><li>要不要写成int main(void)?</li><li>return的0有人看吗?<ul><li>Windows: if errorlevel 1 …</li><li>Unix Bash: echo $?</li><li>Csh:echo $status</li></ul></li></ul></blockquote><h3 id="函数先后关系"><a href="#函数先后关系" class="headerlink" title="函数先后关系"></a>函数先后关系</h3><blockquote><ul><li>像这样把sum()写在上面，是因为:</li><li>C的编译器自上而下顺序分析你的代码</li><li>在看到sum(1,10)的时候，它需要知道sum()的样子</li><li>也就是sum()要几个参数，每个参数的类型如何，返回什么类型</li><li>这样它才能检查你对sum()的调用是否正确</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231026130910560.png" alt="image-20231026130910560"></p><blockquote><p> 那是不是函数全都要写在main前面呢？</p><blockquote><blockquote><blockquote><blockquote><p>==函数原型==</p></blockquote></blockquote></blockquote></blockquote><ul><li>函数头，以分号 “ ; ” 结尾，就构成了函数的原型</li><li></li><li>函数原型的目的是告诉编译器这个函数长什么样<ul><li>名称</li><li>参数(数量及类型)</li><li>返回类型</li></ul></li><li>旧标准习惯把函数原型写在调用它的函数里面</li><li>现在一般写在调用它的函数前面</li></ul></blockquote><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>如何写一个程序计算用户输入的数字的平均数，并输出所有大于平均数的数?</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出库的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 包含数学库的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> <span class="comment">// 包含Windows系统库的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 定义整型变量x，用于存储输入的整数</span></span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>; <span class="comment">// 定义双精度浮点型变量sum，用于存储所有输入整数的和</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 定义整型变量cnt，用于存储输入整数的个数</span></span><br><span class="line">    <span class="type">int</span> number[<span class="number">100</span>]; <span class="comment">// 定义整型数组number，用于存储所有输入整数，最多存储100个整数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); <span class="comment">// 读入第一个整数</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span>) <span class="comment">// 如果x不等于-1，则执行循环体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环体开始</span></span><br><span class="line">        number[cnt] = x; <span class="comment">// 将x存入数组number中</span></span><br><span class="line">        sum += x; <span class="comment">// 将x加到sum中</span></span><br><span class="line">        cnt++; <span class="comment">// cnt加1</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 读入下一个整数</span></span><br><span class="line">        <span class="comment">// 循环体结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) <span class="comment">// 如果输入了至少一个整数，则执行if语句块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i; <span class="comment">// 定义整型变量i，用于循环遍历数组number</span></span><br><span class="line">        <span class="type">double</span> average = sum / cnt; <span class="comment">// 计算所有输入整数的平均值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; i++) <span class="comment">// 循环遍历数组number中的所有元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (number[i] &gt; average) <span class="comment">// 如果某个元素大于平均值，则执行if语句块</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number[i]); <span class="comment">// 输出该元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0，表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><blockquote><ul><li>&lt;类型&gt;变量名称[元素数量]<ul><li>int grades[100]</li><li>double weight[20]:</li></ul></li><li>元素数量必须是整数</li><li>C99之前: 元素数量必须是编译时刻确定的字面量</li></ul><blockquote><blockquote><blockquote><blockquote><p>数组</p></blockquote></blockquote></blockquote></blockquote><ul><li>是一种容器(放东西的东西)，特点是</li><li>其中所有的元素具有相同的数据类型</li><li>一旦创建，不能改变大小</li><li>==(数组中的元素在内存中是连续依次排列的)==</li></ul><blockquote><blockquote><blockquote><blockquote><p>int a[10]</p></blockquote></blockquote></blockquote></blockquote><ul><li>一个int的数组</li><li>10个单元</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">a[0]</th><th style="text-align:center">a[1]</th><th style="text-align:center">a[2]</th><th style="text-align:center">a[3]</th><th style="text-align:center">a[4]</th></tr></thead><tbody><tr><td style="text-align:center">a[5]</td><td style="text-align:center">a[6]</td><td style="text-align:center">a[7]</td><td style="text-align:center">a[8]</td><td style="text-align:center">a[9]</td></tr></tbody></table></div><ul><li>每个单元就是一个int类型的变量</li><li>可以出现在赋值的左边或右边</li><li>a[2] = a[1]+6;</li><li>==在赋值左边的叫做左值==</li></ul></blockquote><h3 id="数组的单元"><a href="#数组的单元" class="headerlink" title="数组的单元"></a>数组的单元</h3><blockquote><ul><li>数组的每个单元就是数组类型的一个变量</li><li>使用数组时放在 [ ] 中的数字叫做下标或索引，下标从0开始计数:<ul><li>grades[0]</li><li>grades[99]</li><li>average[5)</li></ul></li></ul><blockquote><blockquote><blockquote><p>有效的下标范围</p></blockquote></blockquote></blockquote><ul><li>编译器和运行环境都不会检查数组下标是否越界，无论是对数组单元做读还是写</li><li>一旦程序运行，越界的数组访问可能造成问题，导致程序崩溃</li><li>segmentation fault</li><li>但是也可能运气好，没造成严重的后果</li><li>所以这是程序员的责任来保证程序只使用有效的下标值:[0,数组的大小-1]</li></ul></blockquote><h3 id="数组代码"><a href="#数组代码" class="headerlink" title="数组代码"></a>数组代码</h3><p>写一个程序，输入数量不确定的[0,9]范围内的整数，统计每一种数字出现的次数，输入-1表示结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出库的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span> <span class="comment">// 包含数学库的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span> <span class="comment">// 包含Windows系统库的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// 主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> number = <span class="number">10</span>; <span class="comment">// 常量，表示数字的范围，本例中为10，即统计0到9的数字出现的次数。</span></span><br><span class="line">    <span class="type">int</span> x, i; <span class="comment">// 定义整型变量x和i，用于循环读入整数和遍历数组</span></span><br><span class="line">    <span class="type">int</span> count[number]; <span class="comment">// 定义整型数组count，用于存储每个数字出现的次数，数组大小为number</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) <span class="comment">// 循环遍历数组count中的所有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>; <span class="comment">// 将每个元素初始化为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 读入第一个整数</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">-1</span>) <span class="comment">// 如果x不等于-1，则执行循环体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环体开始</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">9</span>) <span class="comment">// 如果x在0到9的范围内，则执行if语句块</span></span><br><span class="line">        &#123;</span><br><span class="line">            count[x]++; <span class="comment">// 将对应位置的count数组元素加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 读入下一个整数</span></span><br><span class="line">        <span class="comment">// 循环体结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; number; i++) <span class="comment">// 循环遍历数组count中的所有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>, i, count[i]); <span class="comment">// 输出每个数字及其出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0，表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><blockquote><blockquote><blockquote><blockquote><p>数组的集成初始化</p></blockquote></blockquote></blockquote><ul><li>用[n]在初始化数据中给出定位</li><li>没有定位的数据接在前面的位置后面</li><li>其他位置的值补零</li><li>也可以不给出数组大小，让编译器算</li><li>特别适合初始数据稀疏的数组</li></ul></blockquote><h3 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h3><blockquote><ul><li><p>sizeof给出整个数组所占据的内容的大小，单位是字节</p><p>  ==sizeof(a)/sizeof(a[0])== </p></li><li><p>sizeof(a[0])给出数组中单个元素的大小，于是相除就得到了数组的单元个数</p></li><li><p>这样的代码，一旦修改数组中初始的数据，不需要修改遍历的代码</p></li></ul></blockquote><h3 id="数组的赋值"><a href="#数组的赋值" class="headerlink" title="数组的赋值"></a>数组的赋值</h3><blockquote><p>int a[ ] = {1,2,3,4,5};<br><del>int b[ ] = a;</del></p><p>这样的代码是错误的</p><ul><li>数组变量本身不能被赋值</li><li>要把一个数组的所有元素交给另一个数组，必须采用遍历</li></ul><p>for (i = 0;i&lt;length; i ++)</p><p>{</p><p>​    b[i] = a[i];</p><p>}</p></blockquote><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><blockquote><ul><li>通常都是使用for循环，让循环变量 i 从0到&lt;数组的长度，这样循环体内最大的 i 正好是数组最大的有效下标</li><li>常见错误是</li><li>循环结束条件是&lt;=数组长度， 或:</li><li>离开循环后，继续用i的值来做数组元素的下标!</li></ul><p>数组作为函数参数时，往往必须再用另一个参数来传入数组的大小</p><ul><li>数组作为函数的参数时:</li><li>不能在 [ ] 中给出数组的大小</li><li>不能再利用sizeof来计算数组的元素个数!</li></ul></blockquote><p>在一组给定的数据中，如何找出某个数据是否存在?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[], <span class="type">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">44</span>,<span class="number">32</span>,&#125;;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> loc;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数字：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    loc = <span class="built_in">search</span>(x, a, <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">if</span> (loc != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d在%d个位置上&quot;</span>, x, loc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d不存在&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>); <span class="comment">// 暂停程序的执行，以便查看输出结果（仅适用于Windows系统）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[], <span class="type">int</span> lenght)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lenght; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><blockquote><ul><li>int a [3] [5];</li><li>通常理解为a是一个3行5列的矩阵</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231027202747348.png" alt="image-20231027202747348"></p><p> 二维数组的遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>( j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] = i*j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>a [i] [j] 是一个int</li><li>表示第i行第i列上的单元</li><li>a[ i,j ]是什么?</li></ul></blockquote><p>二维数组的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>列数是必须给出的，行数可以由编译器来数</li><li>每行一个 { } ，逗号分隔</li><li>最后的逗号可以存在，有古老的传统</li><li>如果省略，表示补零</li><li>也可以用定位(*C99 ONLY)</li></ul></blockquote><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="运算符-amp"><a href="#运算符-amp" class="headerlink" title="运算符 &amp;"></a>运算符 &amp;</h3><blockquote><ul><li>scanf(“%d”,&amp;i);里的&amp;</li><li>获得变量的地址，它的操作数必须是变量<ul><li>int i; printf(“%x”,&amp;i)</li></ul></li><li>地址的大小是否与int相同取决于编译器<ul><li>int i; printf(“%p”,&amp;i);</li></ul></li></ul></blockquote><p>&amp;不能取的地址</p><blockquote><ul><li>&amp;不能对没有地址的东西取地址·<ul><li>&amp;(a+b)?</li><li>&amp;(a++)?</li><li>&amp;(++a)?</li></ul></li></ul></blockquote><p>试试这些&amp;</p><blockquote><ul><li>变量的地址</li><li>相邻的变量的地址</li><li>&amp;的结果的sizeof</li><li>数组的地址</li><li>数组单元的地址</li><li>相邻的数组单元的地址</li></ul></blockquote><h3 id="scanf-1"><a href="#scanf-1" class="headerlink" title="scanf"></a>scanf</h3><blockquote><ul><li>如果能够将取得的变量的地址传递给一个函数能否通过这个地址在那个函数内访问这个变量?<ul><li>scanf(“%d”,&amp;i);</li></ul></li><li>scanf()的原型应该是怎样的?我们需要一个参数能保存别的变量的地址，如何表达能够保存地址的变量?</li></ul><blockquote><blockquote><blockquote><blockquote><p>指针</p></blockquote></blockquote></blockquote></blockquote><ul><li>就是保存地址的变量</li><li>int i;</li><li>int* p = &i;</li></ul><p>两个表达式都是 *p</p><ul><li>int*  p,q;</li><li>int  *p,q;</li></ul></blockquote><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><blockquote><ul><li>变量的值是内存的地址</li><li>普通变量的值是实际的值</li><li>指针变量的值是具有实际值的变量的地址</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231028224952455.png" alt="image-20231028224952455"></p><p>作为参数的指针</p><blockquote><ul><li>void f(int *p):</li><li>在被调用的时候得到了某个变量的地址<ul><li>int i=0, f(&amp;i)</li></ul></li><li>在函数里面可以通过这个指针访问外面的这个i</li></ul></blockquote><p>访问那个地址上的变量*</p><blockquote><ul><li>*是一个单目运算符，用来访问指针的值所表示的地址上的变量</li><li>可以做右值也可以做左值</li><li>int k = *p;</li><li>*p=k+1;</li></ul></blockquote><p>==左值之所以叫左值==</p><blockquote><ul><li>是因为出现在赋值号左边的不是变量，而是值，是表达式计算的结果:<ul><li>a[0] = 2;</li><li>*p=3</li></ul></li><li>是特殊的值，所以叫做左值</li></ul></blockquote><p>指针的运算符 &amp;*</p><blockquote><ul><li>互相反作用<ul><li><em>&amp;yptr -&gt; </em> (&amp;yptr) -&gt; *(yptr的地址) -&gt;  得到那个地址上的变量 -&gt; yptr</li><li>&amp;  <em>yptr -&gt; &amp;( </em>yptr) -&gt; &amp;(y) -&gt; 得到y的地址，也就是yptr -&gt; yptr</li></ul></li></ul></blockquote><p>传入地址</p><blockquote><ul><li>为什么int i; <ul><li>scanf(“%d”, i);</li></ul></li><li>编译没有报错?</li></ul><p>编译不一定会报错，但是运行一定出错</p></blockquote><h3 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h3><p>指针应用场景一</p><ul><li>交换两个变量的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *pa,<span class="type">int</span> *pb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针应用场景二</p><blockquote><ul><li>函数返回多个值，某些值就只能通过指针返回</li><li>传入的参数实际上是需要保存带回的结果的变量</li></ul></blockquote><p> 指针应用场景二b</p><blockquote><ul><li>函数返回运算的状态，结果通过指针返回</li><li>常用的套路是让函数返回特殊的不属于有效范围内的值来表示出错</li><li>-1或0(在文件操作会看到大量的例子)</li><li>但是当任何数值都是有效的可能结果时，就得分开返回了</li></ul></blockquote><p>指针常见的错误</p><blockquote><p>定义了指针变量，还没有指向任何变量，就开始使用指针</p></blockquote><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>传入函数的数组 成了什么？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> knownPrimes[]，<span class="type">int</span> numberOfKnownPrimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;numberOfKnownPrimes; i++ ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x%knownPrimes[i] ==<span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>函数参数表中的数组实际上是指针</li><li>sizeof(a) == sizeof(int *)</li><li>但是可以用数组的运算符[ ]进行运算</li></ul></blockquote><p>数组参数</p><blockquote><ul><li>以下的四种函数原型是等价的</li><li>int sum(int *ar,int n);</li><li>int sum(int *,int);</li><li>int sum(int ar[ ],int n);</li><li>int sum(int [ ],int n);</li></ul></blockquote><h4 id="数组变量是特殊的指针"><a href="#数组变量是特殊的指针" class="headerlink" title="数组变量是特殊的指针"></a>数组变量是特殊的指针</h4><blockquote><ul><li>数组变量本身表达地址，所以</li><li>int a[10];int * p=a;  // 无需用&amp;取地址</li><li>但是数组的单元表达的是变量，需要用&amp;取地址</li><li>a == &amp;a[0]</li><li>[ ]运算符可以对数组做，也可以对指针做</li><li>p[0] &lt;==&gt; a[0]</li><li>*运算符可以对指针做，也可以对数组做</li><li>*a=25;</li><li>数组变量是const的指针，所以不能被赋值</li><li>int a[ ] &lt; ==&gt; int * const a =….</li></ul></blockquote><h3 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与const</h3><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231029131353880.png" alt="image-20231029131353880"></p><p>指针是const</p><blockquote><p>表示一旦得到了某个变量的地址，不能再指向其他变量</p><p>int * const q = &i; //q是const</p><p>*q = 26; //OK</p><p>q++; //ERROR</p></blockquote><p>所指是const</p><blockquote><p>表示不能通过这个指针去修改那个变量(并不能使得那个变量成为const)</p><p>const int *p = &i;</p><p><em>p = 26; //ERROR!  ( </em>p )是const</p><p>i= 26；//OK</p><p>p = &j; //OK</p></blockquote><p>这些是什么意思?</p><blockquote><p>int i;</p><p>const int* p1 =  &i;</p><p>int const* p2 = &i;</p><p>int *const p3 = &i; </p><p>判断哪个被const了的标志是const在*的前面还是后面</p><p>const在*的前面表示==指针指向的东西不能修改==</p><p>const在*的后面表示==指针不能修改==</p></blockquote><p>转换</p><blockquote><ul><li><p>总是可以把一个非const的值转换成const的</p><p>  void f (const int* x);<br>  int a = 15;<br>  f(&amp;a);  //ok<br>  const int b = a;</p><p>  f(&amp;b);  //ok<br>  b = a+1;  //Error!</p></li><li><p>当要传递的参数的类型比地址大的时候，这是常用的手既:能用比较少的字节数传递值给参数，又能避免函数对外置的变量的修改</p></li></ul></blockquote><p>const 数组</p><blockquote><ul><li>const int a[] = {1,2,3,4,5,6,};</li><li>数组变量已经是const的指针了，这里的const表明数组的每个单元都是const int</li><li>所以必须通过初始化进行赋值</li></ul></blockquote><p>保护数组值</p><blockquote><ul><li>因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值</li><li>为了保护数组不被函数破坏，可以设置参数为const</li><li>int sum(const int a[ ],int length);</li></ul></blockquote><h3 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h3><p>1+1=2？</p><blockquote><ul><li>给一个指针加1表示要让指针指向下一个变量</li><li>int a[l0];</li><li>int*p =a;</li><li>*(p+l)-&gt;a[1]</li><li>如果指针不是指向一片连续分配的空间,如数组，则这种运算没有意义</li></ul></blockquote><p>指针计算</p><blockquote><ul><li>这些算术运算可以对指针做</li><li><p>给指针加、减一个整数(+,+=,-,-=)</p></li><li><p>递增递减(++/—)</p></li><li>两个指针相减</li></ul></blockquote><p>*p++</p><blockquote><ul><li>取出p所指的那个数据来，完事之后顺便把p移到下一个位置去</li><li>*的优先级虽然高，但是没有++高</li><li>常用于数组类的连续空间操作</li><li>在某些CPU上，这可以直接被翻译成一条汇编指令</li></ul></blockquote><p>指针比较</p><blockquote><ul><li>&lt;,&lt;=,==,&gt;,&gt;=,!= 都可以对指针做</li><li>比较它们在内存中的地址</li><li>数组中的单元的地址肯定是线性递增的</li></ul></blockquote><p>0地址</p><blockquote><ul><li>当然你的内存中有0地址，但是0地址通常是个不能随便碰的地址</li><li>所以你的指针不应该具有0值</li><li>因此可以用0地址来表示特殊的事情</li><li>返回的指针是无效的</li><li>指针没有被真正初始化 (先初始化为0)</li><li>NULL是一个预定定义的符号，表示0地址</li><li>有的编译器不愿意你用0来表示0地址</li></ul></blockquote><p>指针的类型</p><blockquote><ul><li>无论指向什么类型，所有的 指针的大小都是一样的，因为都是地址</li><li>但是指向不同类型的指针是不能直接互相赋值的</li><li>这是为了避免用错指针</li></ul></blockquote><p>指针的类型转换</p><blockquote><ul><li>void* 表示不知道指向什么东西的指针</li><li>计算时与char*相同(但不相通)</li><li>指针也可以转换类型<ul><li>int<em> p = &i; void</em> q =(void*)p;</li></ul></li><li>这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量</li><li>我不再当你是int啦，我认为你就是个void!</li></ul></blockquote><p>用指针来做什么</p><blockquote><ul><li>需要传入较大的数据时用作参数</li><li>传入数组后对数组做操作</li><li>函数返回不止一个结果<ul><li>需要用函数来修改不止一个变量</li></ul></li><li>动态申请的内存…</li></ul></blockquote><h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>输入数据</p><blockquote><ul><li>如果输入数据时，先告诉你个数，然后再输入，要记录每个数据</li><li>C99可以用变量做数组定义的大小，C99之前呢?</li><li>int  <em> a =(int</em> )malloc(n*sizeof(int));</li></ul></blockquote><p><mark>malloc </mark></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><blockquote><ul><li>向malloc申请的空间的大小是以字节为单位的D:\My_C_code\Code\C\Test\Test.c</li><li>返回的结果是void * ，需要类型转换为自己需要的类型<ul><li>(int<em> )malloc(n</em>sizeof(int))</li></ul></li></ul></blockquote><p>没空间了？</p><blockquote><ul><li>如果申请失败则返回0，或者叫做NULL</li><li>你的系统能给你多大的空间?</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((p = <span class="built_in">malloc</span>(<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;分配了%d00MB的空间\n&quot;</span>, cnt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>free()</p><blockquote><ul><li>把申请得来的空间还给“系统’</li><li>申请过的空间，最终都应该要还</li><li>混出来的，迟早都是要还的</li><li>只能还申请来的空间的首地址</li></ul></blockquote><p>常见问题</p><blockquote><ul><li>申请了没free-&gt;长时间运行内存逐渐下降</li><li>新手:忘了</li><li>老手:找不到合适的free的时机</li><li>free过了在free</li><li>地址变过了，直接去free</li></ul></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><blockquote><p>char word[ ] ={‘H’,’e’,’l’,’l’,’o’,’!’};</p><p>这不是C语言的字符串，因为不能用字符串的方式做计算</p><p>他还是字符数组，但是他是字符串了，他可以用字符串的方式做计算</p><p>char word[ ] ={‘H’,’e’,’l’,’l’,’o’,’!’,’\0’};</p></blockquote><p>字符串</p><blockquote><ul><li>以0(整数0) 结尾的一串字符<ul><li><strong>0 或 ‘\0’ 是一样的，但是和 ‘0’ 不同</strong></li></ul></li><li>0标志字符串的结束，但它不是字符串的一部分<ul><li>计算字符串长度的时候不包含这个0</li></ul></li><li>字符串以数组的形式存在，以数组或指针的形式访问<ul><li>更多的是以指针的形式</li></ul></li><li>string.h 里有很多处理字符串的函数</li></ul></blockquote><p>字符串变量</p><blockquote><ul><li>char *str = “Hello”;</li><li>char word[ ] = “Hello”;</li><li>char line[10] = “Hello”;</li></ul></blockquote><p>字符串常量</p><blockquote><ul><li>“Hello”</li><li>”He11o”会被编译器变成一个字符数组放在某处，这个数组的长度是6，结尾还有表示结束的0</li><li>两个相邻的字符串常量会被自动连接起来</li></ul><ul><li>C语言的字符串是以字符数组的形态存在的\</li><li>不能用运算符对字符串做运算</li><li>通过数组的方式可以遍历字符串</li><li>唯一特殊的地方是字符串字面量可以用来初始化字符数组</li><li>以及标准库提供了一系列字符串函数</li></ul></blockquote><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><blockquote><p>char* s =”Hello，world!”</p><ul><li><p>s 是一个指针，初始化为指向一个字符串常量。</p><ul><li>由于这个常量所在的地方，所以实际上s是 const char* s，但是由于历史的原因，编译器接受不带const的写法</li><li>但是试图对s所指的字符串做写入会导致严重的后果</li></ul></li><li><p>如果需要修改字符串，应该用数组:</p></li></ul><p>​     char s [ ] =”Hello，world!”；</p></blockquote><p>指针还是数组？</p><blockquote><ul><li>char *str = “Hello”;</li><li>char word[ ] = “Hello”;</li><li>数组:这个字符串在这里<ul><li>作为本地变量空间自动被回收</li></ul></li><li>指针:这个字符串不知道在哪里<ul><li>处理参数</li><li>动态分配空间</li></ul></li><li>如果要构造一个字符串-&gt;数组</li><li>如果要处理一个字符串-&gt;指针</li></ul></blockquote><p>char * 是字符串?</p><blockquote><ul><li>字符串可以表达为char * 的形式</li><li>char * 不一定是字符串</li><li>本意是指向字符的指针，可能指向的是字符的数组(就像int *一样)</li><li>只有它所指的字符数组有结尾的0，才能说它所指的是字符串</li></ul></blockquote><h3 id="字符串的输入输出"><a href="#字符串的输入输出" class="headerlink" title="字符串的输入输出"></a>字符串的输入输出</h3><blockquote><p>char string[8];</p><p>scanf(“%s”,string);</p><p>printf(“%s”,string);</p><ul><li>scanf读入一个单词（到空格、tab或回车为止）</li><li>scanf是不安全的，因为不知道要读入的内容的长度</li></ul></blockquote><p>安全的输入</p><blockquote><p>char string[8];<br>scanf(“%7s”,string);</p><ul><li>在%和s之间的数字表示最多允许读入的字符的数量，这个数字应该比数组的大小 小1</li><li>下一次scanf从哪里开始?</li></ul></blockquote><p>常见错误</p><blockquote><ul><li>char * string;</li><li>scanf(“%s”,string);</li><li>以为char*是字符串类型，定义了一个字符串类型的变量string就可以直接使用了</li><li>由于没有对string初始化为0，所以不一定每次运行都出错</li></ul></blockquote><p>空字符串</p><blockquote><ul><li>char buffer[100]=” “;<ul><li>这是一个空的字符串，buffer[0] == ‘\0’</li></ul></li><li>char buffer[ ]=” “;<ul><li>这个数组的长度只有1！</li></ul></li></ul></blockquote><h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><blockquote><ul><li>char <em> </em>a </li><li>a是一个指针，指向另一个指针，那个指针指向一个字符 (串)</li><li>char a [ ] [ ]</li></ul></blockquote><p>程序参数</p><blockquote><ul><li>int main(int argc, char const *argvl[ ])</li><li>argv[0]是命令本身</li><li>当使用Unix的符号链接时，反映符号链接的名字</li></ul></blockquote><h3 id="单字符的输入输出"><a href="#单字符的输入输出" class="headerlink" title="单字符的输入输出"></a>单字符的输入输出</h3><p>putchar</p><blockquote><ul><li>int putchar(int c);</li><li>向标准输出写一个字符</li><li>返回写了几个字符，EOF (-1) 表示写失败</li></ul></blockquote><p>getchar</p><blockquote><ul><li>int getchar(void):</li><li>从标准输入读入一个字符</li><li>返回类型是int是为了返回EOF (-1)</li><li>Windows-&gt;Ctrl-Z</li><li>Unix-&gt;Ctrl-D</li></ul></blockquote><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>strlen</li><li>strcmp</li><li>strcpy</li><li>strcat</li><li>strchr</li><li>strstr</li></ul></blockquote><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><blockquote><ul><li>size_t strlen(const char *s)</li><li>返回s的字符串长度 (不包括结尾的0)</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">mylen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[idx] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> line[ ] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mylen=%lu\n&quot;</span>,<span class="built_in">mylen</span>(line));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;strlen=%lu\n&quot;</span>,<span class="built_in">strlen</span>(line));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof=%lu\n&quot;</span>,<span class="built_in">sizeof</span>(line));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><blockquote><ul><li>int strcmp(const char <em>s1, const char </em>s2)</li><li>比较两个字符串，返回:</li><li>0:s1==s2</li><li>1:s1&gt;s2</li><li>-1:s1&lt;s2</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mycmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( *s1 == *s2 &amp;&amp; *s1 != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s1++;</span><br><span class="line">        s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1-*s2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;strcmp=%d\n&quot;</span>,<span class="built_in">strcmp</span>(s1,s2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mycmp=%d\n&quot;</span>,<span class="built_in">mycmp</span>(s1,s2));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h4><blockquote><ul><li>char <em>strcpy(char </em>restrict dst, const char *restrict src);</li><li><code>strcpy</code> 函数会将源字符串 <code>src</code> 的内容复制到目标字符串 <code>dst</code> 中，并返回指向目标字符串 <code>dst</code> 的指针。</li><li>把 <code>dst</code>的字符串拷贝到<code>dst</code><ul><li><code>restrict</code>表明<code>src</code>和<code>dst</code>不重叠 (C99)</li></ul></li><li>返回dst<ul><li>为了能链起代码来</li></ul></li></ul></blockquote><p>复制一个字符串</p><blockquote><p>char <em>dst = (char </em>)malloc(strlen(src)+1);</p><p>strcpy(dst,src);</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">mycpy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *ret = dst;        <span class="comment">// 保存目标字符串起始位置的指针</span></span><br><span class="line">    <span class="keyword">while</span> (*dst++ = *src++) <span class="comment">// 通过循环逐个复制源字符串的字符到目标字符串，直到遇到源字符串的结束符 &#x27;\0&#x27;</span></span><br><span class="line">        ;</span><br><span class="line">    *dst = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在目标字符串的末尾添加结束符 &#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回指向目标字符串起始位置的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[] = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line">    <span class="type">char</span> s2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line">    <span class="built_in">mycpy</span>(s1, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符串搜索函数"><a href="#字符串搜索函数" class="headerlink" title="字符串搜索函数"></a>字符串搜索函数</h3><blockquote><p>==字符串中找字符==</p><ul><li>char <em> strchr(const char </em>s,int c);</li></ul><p>用于在字符串 <code>s</code> 中查找字符 <code>c</code> 的第一次出现的位置，并返回该位置的指针。如果未找到字符 <code>c</code>，则返回空指针</p><ul><li>char <em> strrchr(const char </em>s, int c)</li></ul><p>与 <code>strchr</code> 函数类似，但它在字符串 <code>s</code> 中从后往前查找字符 <code>c</code> 第一次出现的位置，并返回该位置的指针。同样，如果未找到字符 <code>c</code>，则返回空指针。这个函数在处理需要逆向查找的字符串操作时非常有帮助。</p><ul><li>返回NULL表示没有找到</li><li>如何寻找第2个?</li></ul><p>==字符串中找字符串==</p><p>用于在字符串 <code>s1</code> 中查找第一次出现字符串 <code>s2</code> 的位置，并返回该位置的指针。</p><ul><li>char <em> strstr(const char </em>s1, const char *s2)</li></ul><p>函数参数 <code>s1</code> 是要被搜索的字符串，而参数 <code>s2</code> 则是要搜索的目标子字符串。函数会从 <code>s1</code> 中开始搜索，找到第一个与 <code>s2</code> 相匹配的子串，并返回指向该子串的指针。如果没有找到匹配的子串，则返回空指针。</p><ul><li>char <em> strcasestr(const char </em>s1,const char *s2)</li></ul><p>和 <code>strstr</code> 不同的是，<code>strcasestr</code> 函数会忽略字符大小写，在搜索时不区分大小写。这意味着，无论目标子字符串 <code>s2</code> 在 <code>s1</code> 中的大小写形式如何，只要字符序列相同，<code>strcasestr</code> 都能够找到匹配的子串。</p></blockquote><p>需要用到自己去使用，不展开讲</p><h2 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h2><p>常量符号化</p><blockquote><p>用符号而不是具体的数字来表示程序中的数字</p><p>用枚举而不是定义独立的const int变量</p></blockquote><p>枚举</p><blockquote><ul><li>枚举是一种用户定义的数据类型，它用关键字 <code>enum</code>以如下语法来声明:<ul><li><code>enum 枚举类型名字 &#123;名字0,..., 名字n&#125;;</code></li></ul></li><li>枚举类型名字通常并不真的使用，要用的是在大括号里的名字因为它们就是就是常量符号，它们的类型是int，值则依次从0到n。如:<ul><li><code>enum colors &#123;red, yellow, green &#125;;</code></li></ul></li><li>就创建了三个常量，red的值是0，yellow是1，而green是2</li><li>当需要一些可以排列起来的常量值时，定义枚举的意义就是给了这些常量值名字。</li></ul><ul><li>枚举量可以作为值</li><li>枚举类型可以跟上enum作为类型</li><li>但是实际上是以整数来做内部计算和外部输入输出的</li></ul></blockquote><p>自动计数的枚举</p><blockquote><p>这样需要遍历所有的枚举量或者需要建立一个用枚举量做下标的数组的时候就很方便了</p></blockquote><p>枚举量</p><blockquote><p>声明枚举量的时候可以指定值</p><p>enum COLOR{RED=1, YELLOW,GREEN = 5};</p></blockquote><p>枚举只是int</p><blockquote><ul><li><p>即使给枚举类型的变量赋不存在的整数值也没有任何<br>  warning或error</p></li><li><p>虽然枚举类型可以当作类型使用，但是实际上很(bu)少(hao)用</p></li><li>如果有意义上排比的名字，用枚举比const int 方便</li><li>枚举比宏(macro) 好，因为枚举有 int 类型</li></ul></blockquote><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="声明结构类型"><a href="#声明结构类型" class="headerlink" title="声明结构类型"></a>声明结构类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">date</span> &#123;</span><br><span class="line"> <span class="type">int</span> month;</span><br><span class="line"> <span class="type">int</span> day;</span><br><span class="line"> <span class="type">int</span> year;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>和本地变量一样，在函数内部声明的结构类型只能在函数内部使用</li><li>所以通常在函数外部声明结构类型这样就可以被多个函数所使用了</li></ul></blockquote><p>声明结构的形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> pl, p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pI和p2都是point里面有x和y的值</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> pl, p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p1和p2都是一种无名结构，里面有x和y</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>  <span class="title class_">point</span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;p1,p2;</span><br><span class="line"><span class="comment">//p1和p2都是point里面有x和y的值t</span></span><br></pre></td></tr></table></figure><p>结构成员</p><blockquote><ul><li>结构和数组有点像</li><li>数组用 [ ] 运算符和下标访问其成员</li><li>a[0] = 10;</li><li>结构用 <code>.</code> 运算符和名字访问其成员</li><li>today.day</li><li>student.firstName</li><li>pl.x</li><li>pl.y</li></ul></blockquote><p>结构运算</p><blockquote><ul><li>要访问整个结构，直接用结构变量的名字</li><li>对于整个结构，可以做赋值、取地址，也可以传递给函数参数</li><li>p1 =(struct point){5,!0};   // 相当于p1.x =5,p1.y =10;</li><li>p1 = p2;// 相当于p1.x =p2.x;p1.y = p2.y</li></ul><p>数值无法做这两种运算</p></blockquote><p>结构指针</p><blockquote><ul><li>和数组不同，结构变量的名字并不是结构变量的地址，必须使用&amp;运算符</li><li>struct date *pDate = &today;</li></ul></blockquote><h3 id="结构与函数"><a href="#结构与函数" class="headerlink" title="结构与函数"></a>结构与函数</h3><p>结构作为函数参数</p><p>int numberOfdays(struct date d)</p><blockquote><ul><li>整个结构可以作为参数的值传入函数</li><li>这时候是在函数内新建一个结构变量，并复制调用者的结构的值</li><li>也可以返回一个结构</li><li>这与数组完全不同</li></ul></blockquote><p>输入结构</p><blockquote><ul><li>没有直接的方式可以一次scanf一个结构</li><li>如果我们打算写一个函数来读入结构</li><li>但是读入的结构如何送回来呢?</li><li>记住C在函数调用时是传值的</li><li>所以函数中的p与main中的y是不同的</li><li>在函数读入了p的数值之后，没有任何东西回到main，所以y还是{0,0}</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231109101428881.png" alt="image-20231109101428881"></p><p>解决的方案</p><blockquote><ul><li>之前的方案，把一个结构传入了函数，然后在函数中操作，但是没有返回回去</li><li>问题在于传入函数的是外面那个结构的克隆体，而不是指针<br>  传</li><li>入结构和传入数组是不同的</li><li>在这个输入函数中，完全可以创建一个临时的结构变量然后把这个结构返回给调用者</li></ul></blockquote><p>指向结构的指针</p><blockquote><p>用-&gt;表示指针所指的结构变量中的成员</p></blockquote><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">date</span> dates[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">date</span> dates[] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2005</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">2005</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构中的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dateAndTime</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">date</span> sdate;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">time</span> stime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>嵌套的结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231109102953180.png" alt="image-20231109102953180"></p><blockquote><ul><li>如果有变量定义<ul><li>struct rectangle r, *rp;</li><li>rp = &r;</li></ul></li><li>那么下面的四种形式是等价的<ul><li>r.pt1.x</li><li>rp-&gt;pt1.x</li><li>(r.pt1).x</li><li>(rp-&gt;pt1).x</li></ul></li><li>但是没有rp-&gt;pt1-&gt;x(因为pt1不是指针)</li></ul></blockquote><h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>自定义数据类型 <code>typedef</code></p><blockquote><p> C语言提供了一个叫做 <code>typedef</code>的功能来声明一个已有的数据类型的新名字。比如:<br> typedef int Length;<br> 使得 Length 成为 int 类型的别名<br> 这样，Length 这个名字就可以代替int出现在变量定义和参数声明的地方了:<br> Length a, b,len ;<br> Length numbers[10] </p><p>声明新的类型的名字</p><ul><li>新的名字是某种类型的别名</li><li>改善了程序的可读性</li></ul></blockquote><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231109111405723.png" alt="image-20231109111405723"></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> month;</span><br><span class="line"><span class="type">int</span> day;</span><br><span class="line"><span class="type">int</span> year;</span><br><span class="line">&#125; Data;</span><br></pre></td></tr></table></figure><h2 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h2><p>联合</p><blockquote><ul><li>存储<ul><li>所有的成员共享一个空间</li><li>同一时间只有一个成员是有效的</li><li>union的大小是其最大的成员</li></ul></li><li>初始化<ul><li>对第一个成员做初始化</li></ul></li></ul></blockquote><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h3><blockquote><ul><li>定义在函数外面的变量是全局变量</li><li>全局变量具有全局的生存期和作用域。<ul><li>它们与任何函数都无关</li><li>在任何函数内部都可以使用它们</li></ul></li></ul></blockquote><p>全局变量初始化</p><blockquote><ul><li>没有做初始化的全局变量会得到0值</li><li>指针会得到NULL值</li><li>只能用编译时刻已知的值来初始化全局变量。</li><li>它们的初始化发生在main函数之前</li></ul></blockquote><h3 id="静态本地变量"><a href="#静态本地变量" class="headerlink" title="静态本地变量"></a>静态本地变量</h3><blockquote><ul><li>在本地变量定义时加上static修饰符就成为静态本地变量</li><li>当函数离开的时候，静态本地变量会继续存在并保持其值</li><li><p>静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值</p></li><li><p>静态本地变量实际上是特殊的全局变量</p></li><li>它们位于相同的内存区域</li><li>静态本地变量具有全局的生存期，函数内的局部作用域</li><li>static在这里的意思是局部作用域 (本地可访问)</li></ul></blockquote><h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="*返回指针的函数"></a>*返回指针的函数</h3><blockquote><ul><li>返回本地变量的地址是危险的</li><li>返回全局变量或静态本地变量的地址是安全的</li><li>返回在函数内malloc的内存是安全的，但是容易造成问题</li><li>最好的做法是返回传入的指针</li></ul></blockquote><p>tips</p><blockquote><ul><li>不要使用全局变量来在函数间传递参数和结果</li><li>尽量避免使用全局变量</li><li>丰田汽车的案子</li><li><mark>使用全局变量和静态本地变量的函数是线程不安全的</mark></li></ul></blockquote><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><h3 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h3><blockquote><p><code>#</code>开头的是编译预处理指令</p><p>它们不是C语言的成分，但是C语言程序离不开它们</p><p><code>#define</code>用来定义一个宏</p></blockquote><p><code>#define</code></p><blockquote><ul><li><code>#define &lt;名字&gt;&lt;值&gt;</code></li><li>注意没有结尾的分号，因为不是C的语句</li><li>名字必须是一个单词，值可以是各种东西</li><li>在C语言的编译器开始编译之前，编译预处理程序(cpp) 会把程序中的名字换成值</li><li>完全的文本替换</li><li>gcc-save-temps</li></ul></blockquote><ul><li>宏</li></ul><blockquote><ul><li>如果一个宏的值中有其他的宏的名字，也是会被替换的</li><li>如果一个宏的值超过一行，最后一行之前的行末需要加 <code>\</code></li><li>宏的值后面出现的注释不会被当作宏的值的一部分</li></ul></blockquote><ul><li>没有值的宏</li></ul><blockquote><ul><li><code>#define_DEBUG</code></li><li>这类宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了</li></ul></blockquote><ul><li>预定义的宏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_</span><br><span class="line">_FILE_</span><br><span class="line">_DATE_</span><br><span class="line">_TIME_</span><br><span class="line">_STDC_</span><br></pre></td></tr></table></figure><h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> cude(x) ((x)*(x)*(x))</span></span><br></pre></td></tr></table></figure><p>宏可以带参数</p><p>错误定义的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG(x) (x*57.29578)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG(x) (x)*57.29578</span></span><br></pre></td></tr></table></figure><p>带参数的宏的原则</p><blockquote><ul><li>一切都要括号</li><li>整个值都要括号</li><li>参数出现的每个地方都要括号</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RADTODEG(x) ((X) * 57.29578)</span></span><br></pre></td></tr></table></figure><p>带参数的宏</p><blockquote><ul><li>可以带多个参数<ul><li><code>#define MIN(a,b) ((a)&gt;(b)?(b):(a))</code></li></ul></li><li>也可以组合（嵌套）使用其他宏</li></ul></blockquote><p>分号？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRETTY_PRINT(msg) printf(msg);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line"><span class="built_in">PRETTY_PRINT</span>(<span class="string">&quot;n is less than 10&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">PRETTY_PRINT</span>(<span class="string">&quot;n is at least 10&quot;</span>);</span><br></pre></td></tr></table></figure><p>带参数的宏</p><blockquote><ul><li>在大型程序的代码中使用非常普遍。</li><li>可以非常复杂，如“产生”函数<ul><li>在<code>#</code>和<code>##</code>这两个运算符的帮助下</li></ul></li><li>存在中西方文化差异</li><li>部分宏会被inline函数替代</li></ul></blockquote><p>其他编译预处理指令</p><blockquote><ul><li>条件编译</li><li>error</li><li>……</li></ul></blockquote><h2 id="多个源代码文件"><a href="#多个源代码文件" class="headerlink" title="多个源代码文件"></a>多个源代码文件</h2><h3 id="多个-c文件"><a href="#多个-c文件" class="headerlink" title="多个.c文件"></a>多个.c文件</h3><blockquote><ul><li>main()里的代码太长了适合分成几个函数</li><li>一个源代码文件太长了适合分成几个文件</li><li>两个独立的源代码文件不能编译形成可执行的程序</li></ul></blockquote><p>项目</p><blockquote><ul><li>在Dev C++中新建一个项目，然后把几个源代码文件加入进去</li><li>对于项目，Dev C++的编译会把一个项目中所有的源代码文件都编译后，链接起来</li><li>有的IDE有分开的编译和构建两个按钮，前者是对单个源代码文件编译，后者是对整个项目做链接</li></ul></blockquote><p>编译单元</p><blockquote><ul><li>一个.c文件是一个编译单元</li><li>编译器每次编译只处理一个编译单元</li></ul></blockquote><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><blockquote><p>把函数原型放到一个头文件 (以.h结尾) 中，在需要调用这个函数的源代码文件 (c文件) 中<code>#include</code>这个头文件，就能让编译器在编译的时候知道函数的原型</p></blockquote><p><code>#include</code></p><blockquote><ul><li><code>#include</code>是一个编译预处理指令，和宏一样，在编译之前就处理了</li><li>它把那个文件的全部文本内容原封不动地插入到它所在的地方</li><li>所以也不是一定要在.c文件的最前面<code>#include</code></li></ul></blockquote><p>“ “ 还是 &lt; &gt;</p><blockquote><ul><li><code>#include</code>有两种形式来指出要插入的文件<ul><li><code>“”</code>要求编译器首先在当前目录 (c文件所在的目录)寻找这个文件，如果没有，到编译器指定的目录去找</li><li><code>&lt;&gt;</code>让编译器只在指定的目录去找</li></ul></li><li>编译器自己知道自己的标准库的头文件在哪里</li><li>环境变量和编译器命令行参数也可以指定寻找头文件的目录</li></ul></blockquote><p><code>#include</code>的误区</p><blockquote><ul><li><code>#include</code>不是用来引入库的</li><li><code>stdio.h</code>里只有<code>printf</code>的原型，<code>printf</code>的代码在另外的地方，某个.lib(Windows)或.a(Unix)中</li><li>现在的C语言编译器默认会引入所有的标准库</li><li><code>#include &lt;stdio.h&gt;</code>只是为了让编译器知道<code>printf</code>函数的原型，保证你调用时给出的参数值是正确的类型</li></ul></blockquote><p>头文件</p><blockquote><ul><li>在使用和定义这个函数的地方都应该<code>#include</code>这个头文件</li><li>一般的做法就是任何.c都有对应的同名的.h，把所有对外公开的函数的原型和全局变量的声明都放进去</li></ul></blockquote><p>不对外公开的函数</p><blockquote><ul><li>在函数前面加上<code>static</code>就使得它成为只能在所在的编译单元中被使用的函数</li><li>在全局变量前面加上<code>static</code>就使得它成为只能在所在的编译单元中被使用的全局变量</li></ul></blockquote><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>  变量的声明</p><blockquote><ul><li><code>int i;</code>是变量的定义</li><li><code>extern int i;</code>是变量的声明</li></ul></blockquote><p>声明和定义</p><blockquote><ul><li>声明是不产生代码的东西<ul><li>函数原型</li><li>变量声明</li><li>结构声明</li><li>宏声明</li><li>枚举声明</li><li>类型声明</li><li>inline函数</li></ul></li><li>定义是产生代码的东西</li></ul></blockquote><p>头文件</p><blockquote><ul><li>只有声明可以被放在头文件中<ul><li>是规则不是法律</li></ul></li><li>否则会造成一个项目中多个编译单元里有重名的实体</li><li><mark>某些编译器允许几个编译单元中存在同名的函数或者用weak修饰符来强调这种存在</mark></li></ul></blockquote><p>重复声明</p><blockquote><ul><li>同一个编译单元里，同名的结构不能被重复声明</li><li>如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被<code>#include</code>多次</li><li>所以需要“标准头文件结构”</li></ul></blockquote><p>标准头文件结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __X_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __X_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code */</span>   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><ul><li>运用条件编译和宏，保证这个头文件在一个编译单元中只会被<code>#include</code>一次</li><li><code>#pragma once</code>也能起到相同的作用但是不是所有的编译器都支持</li></ul></blockquote><h2 id="格式化的输入输出"><a href="#格式化的输入输出" class="headerlink" title="格式化的输入输出"></a>格式化的输入输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf</span><br><span class="line">%[flags][width][.prec][hIL]type</span><br><span class="line">scanf</span><br><span class="line">%[flag]type</span><br></pre></td></tr></table></figure><h3 id="printf-1"><a href="#printf-1" class="headerlink" title="printf"></a>printf</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Flag</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">左对齐</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">在前面放+ 或 -</td></tr><tr><td style="text-align:center">(space)</td><td style="text-align:center">正数留空</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0填充</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">width 或 prec</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">number</td><td style="text-align:center">最小字符数</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">下一个参数是字符数</td></tr><tr><td style="text-align:center">.number</td><td style="text-align:center">小数点后的位数</td></tr><tr><td style="text-align:center">.*</td><td style="text-align:center">下一个参数是小数点后的位数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">类型修饰</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">hh</td><td style="text-align:center">单个字节</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">ll</td><td style="text-align:center">long long</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">long double</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">用于</th><th style="text-align:center">type</th><th style="text-align:center">用于</th></tr></thead><tbody><tr><td style="text-align:center">i 或 d</td><td style="text-align:center">int</td><td style="text-align:center">g</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">unsigned int</td><td style="text-align:center">G</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">八进制</td><td style="text-align:center">a 或 A</td><td style="text-align:center">十六进制浮点</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">十六进制</td><td style="text-align:center">c</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">字母大写的十六进制</td><td style="text-align:center">s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">f 或 F</td><td style="text-align:center">float,6</td><td style="text-align:center">p</td><td style="text-align:center">指针</td></tr><tr><td style="text-align:center">e 或 E</td><td style="text-align:center">指数</td><td style="text-align:center">n</td><td style="text-align:center">读入/写出的个数</td></tr></tbody></table></div><h3 id="scanf-2"><a href="#scanf-2" class="headerlink" title="scanf"></a>scanf</h3><div class="table-container"><table><thead><tr><th style="text-align:center">Flag</th><th style="text-align:center">含义</th><th style="text-align:center">Flag</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">跳过</td><td style="text-align:center">l</td><td style="text-align:center">long,double</td></tr><tr><td style="text-align:center">数字</td><td style="text-align:center">最大字符数</td><td style="text-align:center">ll</td><td style="text-align:center">long long</td></tr><tr><td style="text-align:center">hh</td><td style="text-align:center">char</td><td style="text-align:center">L</td><td style="text-align:center">long double</td></tr><tr><td style="text-align:center">h</td><td style="text-align:center">short</td><td style="text-align:center"></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">type</th><th style="text-align:center">用于</th><th style="text-align:center">type</th><th style="text-align:center">用于</th></tr></thead><tbody><tr><td style="text-align:center">d</td><td style="text-align:center">int</td><td style="text-align:center">s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center">整数，可能为十六进制或八进制</td><td style="text-align:center">[…]</td><td style="text-align:center">所允许的字符</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">unsigned int</td><td style="text-align:center">p</td><td style="text-align:center">指针</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">八进制</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">十六进制</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">字母大写的十六进制</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">a,e,f,g</td><td style="text-align:center">float</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">char</td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><blockquote><ul><li>读入的项目数</li><li>输出的字符数</li><li>在要求严格的程序中，应该判断每次调用<code>scanf</code>或<code>printf</code>的返回值，从而了解程序运行中是否存在问题</li></ul></blockquote><h2 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h2><div class="table-container"><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">按位与</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">按位或</td></tr><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">按位取反</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">按位的异或</td></tr><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td></tr></tbody></table></div><p>按位与 <code>&amp;</code></p><blockquote><ul><li>如果 (x) == 1并且(y) == 1，那么 (x &amp; y) == 1</li><li>否则的话 (x &amp; y) == 0</li><li>按位与常用于两种应用<ul><li><code>让某一位或某些位为0</code>: x &amp; 0XFE</li><li><code>取一个数中的一段</code>: x &amp; 0XFE</li></ul></li></ul></blockquote><p>按位或 <code>|</code></p><blockquote><ul><li>如果 (x) == 1并且(y) == 1，那么 (x | y) == 1</li><li>否则的话 (x | y) == 0</li><li>按位或常用于两种应用<ul><li>使得一位或几个位为1: x | 0x01</li><li>把两个数拼起来: 0x00FF | 0XFF00</li></ul></li></ul></blockquote><p>按位取反<code>~</code></p><blockquote><ul><li>(~x) = 1 - (x)</li><li>把1位变0，0位变1</li><li>想得到全部位为1的数:~0</li><li>7的二进制是0111，x | 7使得低3位为1</li><li>而x &amp; ~7，就使得低3位为0</li></ul></blockquote><p>逻辑运算vs按位运算</p><blockquote><ul><li>对于逻辑运算，它只看到两个值: 0和1</li><li>可以认为逻辑运算相当于把所有非0值都变成1，然后做按位运算</li><li>5 &amp; 4 -&gt; 4 而5 &amp;&amp; 4 -&gt; 1 &amp; 1 -&gt; 1</li><li>5 | 4 -&gt; 5 而5 || 4 -&gt;1 | 1 -&gt; 1</li><li>~4 -&gt; 3 而!4 -&gt; !1 -&gt; 0</li></ul></blockquote><p>按位异或<code>^</code></p><blockquote><ul><li>如果 (x)  == (y) , 那么 (x ^ y)  == 0</li><li>否则的话，(x ^ y)  == 1</li><li>如果两个位相等，那么结果为0;不相等，结果为1</li><li>如果x和y相等，那么x^y的结果为0</li><li>对一个变量用同一个值异或两次，等于什么也没做<ul><li><code>x ^ y ^ y -&gt; X</code></li></ul></li></ul></blockquote><p>x<sub>i</sub></p><h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><p>左移 <code>&lt;&lt;</code></p><blockquote><ul><li>i &lt;&lt; j</li><li>i中所有的位向左移动j个位置，而右边填入0</li><li>所有小于int的类型，移位以int的方式来做，结果是int</li><li>x &lt;&lt;= 1 等价于 x *= 2</li><li>x &lt;&lt;= n 等价于 x *= 2<sup>n</sup></li></ul></blockquote><p>右移 <code>&gt;&gt;</code></p><blockquote><ul><li>i &gt;&gt; j</li><li>所有小于int的类型，移位以int的方式来做，结果是int</li><li>对于unsigned的类型，左边填入0</li><li>对于signed的类型，左边填入原来的最高位（保持符号不变）</li><li>x &gt;&gt;= 1 等价于 x /= 2</li><li>x &gt;&gt;= n 等价于 x /= 2<sup>n</sup></li></ul><p>移位的位数不要用负数，这是没有定义的行为</p><p>x &lt;&lt; -2    // !! NO !!</p></blockquote><p>位段</p><p>把一个int的若干位组合成一个结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> leading: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG1: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> FLAG2: <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> trailing: <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>可以直接用位段的成员名称来访问<ul><li>比移位、与、或还方便</li></ul></li><li>编译器会安排其中的位的排列，不具有可移植性</li><li>当所需的位超过一个int时会采用多个int</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32智能小车</title>
      <link href="/2023/11/22/STM32%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/"/>
      <url>/2023/11/22/STM32%E6%99%BA%E8%83%BD%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p><strong><em>对应视频合集链接:</em></strong></p><p>【STM32智能小车V3-STM32入门教程-STM32项目-STM32循迹小车 避障 蓝牙遥控 课设 毕设 电赛 嵌入式学习 PID控制算法 编码器电机  跟随】 <a href="https://www.bilibili.com/video/BV16x4y1M7EN/?p=2&amp;share_source=copy_web&amp;vd_source=f5d5850ab773377dff308188468fbc77">https://www.bilibili.com/video/BV16x4y1M7EN/?p=2&amp;share_source=copy_web&amp;vd_source=f5d5850ab773377dff308188468fbc77</a></p><p><strong>项目完整资料(包含PCB与源码):</strong></p><p><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.11.7f004ab4xxrqip&amp;id=698097521244&amp;ns=1&amp;abbucket=10#detail">https://item.taobao.com/item.htm?spm=a230r.1.14.11.7f004ab4xxrqip&amp;id=698097521244&amp;ns=1&amp;abbucket=10#detail</a></p><p><strong>项目硬件购买:</strong></p><p><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.11.7f004ab4xxrqip&amp;id=698097521244&amp;ns=1&amp;abbucket=10#detail">https://item.taobao.com/item.htm?spm=a230r.1.14.11.7f004ab4xxrqip&amp;id=698097521244&amp;ns=1&amp;abbucket=10#detail</a></p><h1 id="第一章-硬件"><a href="#第一章-硬件" class="headerlink" title="第一章-硬件"></a>第一章-硬件</h1><h2 id="1-1-元件选型"><a href="#1-1-元件选型" class="headerlink" title="1.1-元件选型"></a>1.1-元件选型</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230203225615383.png" alt="image-20230203225615383"></p><h2 id="1-2-原理图与PCB"><a href="#1-2-原理图与PCB" class="headerlink" title="1.2-原理图与PCB"></a>1.2-原理图与PCB</h2><p>底板原理图</p><p>各个模块的供电电压?</p><p>模块接口引脚顺序？</p><p>如何确定使用单片机那个引脚？</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221202195108446.png" alt="image-20221202195108446"></p><p>STM32F103C8T6核心板原理图(可能使用不同核心板略有差异)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715153616072.png" alt="image-20220715153616072"></p><p>PCB顶层截图</p><p>不同类型线粗细</p><p>布局总线方式</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227210621750.png" alt="image-20221227210621750"></p><h2 id="1-3-焊接"><a href="#1-3-焊接" class="headerlink" title="1.3-焊接"></a>1.3-焊接</h2><p>PCB正面</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221231144357465.png" alt="image-20221231144357465"></p><p>PCB背面</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221231144233002.png" alt="image-20221231144233002"></p><p>然后插上元件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221231144943159.png" alt="image-20221231144943159"></p><h2 id="1-4-结构与组装"><a href="#1-4-结构与组装" class="headerlink" title="1.4-结构与组装"></a>1.4-结构与组装</h2><p>这是组装好的车体照片</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221231150645127.png" alt="image-20221231150645127"></p><p>然后小车安装PCB</p><p>注意电机和红外对管不要插错</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221231155644678.png" alt="image-20221231155644678"></p><h2 id="1-5-测试"><a href="#1-5-测试" class="headerlink" title="1.5-测试"></a>1.5-测试</h2><p>使用万用表 上电前测试一下</p><h1 id="第二章-GPIO与中断"><a href="#第二章-GPIO与中断" class="headerlink" title="第二章-GPIO与中断"></a>第二章-GPIO与中断</h1><h2 id="2-0-新建工程"><a href="#2-0-新建工程" class="headerlink" title="2.0-新建工程"></a>2.0-新建工程</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203140147942.png" alt="image-20221203140147942"></p><p>建议选择和我一样的版本</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203135524319.png" alt="image-20221203135524319"></p><p>新建一个工程</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715154436669.png" alt="image-20220715154436669" style="zoom:33%;" /></p><p>选择芯片</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715154552489.png" alt="image-20220715154552489" style="zoom:33%;" /></p><p>选择时钟源</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715154653642.png" alt="image-20220715154653642"></p><p>配置时钟树</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715155004533.png" alt="image-20220715155004533"></p><p>选择调试</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715155046118.png" alt="image-20220715155046118"></p><p>勾选生成独立的文件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715155302764.png" alt="image-20220715155302764"></p><p>设置保存地址</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715155657378.png" alt="image-20220715155657378"></p><p>勾选这个不添加没有使用库文件可以减小工程文件大小(也可以不勾选，保持默认设置)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230112223312210.png" alt="image-20230112223312210"></p><p>MDK打开工程，调低优化等级</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203142727527.png" alt="image-20221203142727527"></p><p>以上是每次新建工程要做的</p><p>以后我们不在新建工程，使用之间的工程即可</p><h2 id="2-1-点灯"><a href="#2-1-点灯" class="headerlink" title="2.1-点灯"></a>2.1-点灯</h2><p>这里我们点亮PC13连接的小灯</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715154319943.png" alt="image-20220715154319943"></p><p>配置PC13</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220715160123821.png" alt="image-20220715160123821"></p><p>生成代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716155929888.png" alt="image-20220716155929888"></p><p>生成代码后，使用MDK打开工程</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716160106728.png" alt="image-20220716160106728"></p><p>先编译一下，没有报错、没有问题</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716160157185.png" alt="image-20220716160157185" style="zoom:50%;" /></p><p>在BEGIN和END添加代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716160451492.png" alt="image-20220716160451492"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br></pre></td></tr></table></figure><p>根据自己的芯片选择</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716162757551.png" alt="image-20220716162757551"></p><h3 id="烧录程序-必看-使用其中一个方法"><a href="#烧录程序-必看-使用其中一个方法" class="headerlink" title="烧录程序(必看 使用其中一个方法)"></a>烧录程序(必看 使用其中一个方法)</h3><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227230705273.png" alt="image-20221227230705273"></p><h4 id="方法一：使用DAP-LINK"><a href="#方法一：使用DAP-LINK" class="headerlink" title="方法一：使用DAP LINK"></a>方法一：使用DAP LINK</h4><p><strong>接线图</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221229210725895.png" alt="image-20221229210725895"></p><p>DAP 在Win 10 免驱动的</p><p>然后根据自己使用的工具在MDK中设置下载工具</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716160642306.png" alt="image-20220716160642306"></p><p>设置下载算法</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716163120042.png" alt="image-20220716163120042"></p><p>然后下载程序，复位小灯闪烁</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716163318393.png" alt="image-20220716163318393"></p><p>烧录后现象</p><p>小灯每0.5秒闪烁一次</p><h4 id="方法二：使用stlink"><a href="#方法二：使用stlink" class="headerlink" title="方法二：使用stlink"></a>方法二：使用stlink</h4><p><strong>接线图</strong></p><p>STlink不要接3.3V </p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221229211513383.png" alt="image-20221229211513383"></p><p>使用Stlink 前先安装驱动</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227225436767.png" alt="image-20221227225436767"></p><p>双击运行</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227225603998.png" alt="image-20221227225603998"></p><p>选择ST-Link</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227224923189.png" alt="image-20221227224923189"></p><p>选择算法</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227225802761.png" alt="image-20221227225802761"></p><p>然后点击编译，烧录</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221227230419753.png" alt="image-20221227230419753"></p><p>烧录后现象</p><p>小灯每0.5秒闪烁一次</p><h3 id="补充可能遇到的失败情况"><a href="#补充可能遇到的失败情况" class="headerlink" title="补充可能遇到的失败情况"></a>补充可能遇到的失败情况</h3><h4 id="使用DAP-LINK"><a href="#使用DAP-LINK" class="headerlink" title="使用DAP-LINK"></a>使用DAP-LINK</h4><p>如果我们芯片IDCODE是0x2 开头的那么我们需要替换一下Keil 的器件包</p><p>(如果你是0x1 开头的，如果能下载可以不替换)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729142306116.png" alt="image-20220729142306116"></p><p>STM32小车相关资料V3.3.0\04使用的软件\中科芯CKS芯片支持包</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729142706246.png" alt="image-20220729142706246"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729142753531.png" alt="image-20220729142753531"></p><p>下面这个算法就会自动切换</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729142828921.png" alt="image-20220729142828921"></p><h4 id="使用stlink"><a href="#使用stlink" class="headerlink" title="使用stlink"></a>使用stlink</h4><h2 id="2-2-按键"><a href="#2-2-按键" class="headerlink" title="2.2-按键"></a>2.2-按键</h2><p>先看原理图</p><p>PB4—KEY1      单片机设置下拉输入-、上降沿触发</p><p>PA12—KEY2    单片机设置上拉输入、下降沿触发</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716164000681.png" alt="image-20220716164000681"  /></p><p>开始配置</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716165737010.png" alt="image-20220716165737010"></p><p>使能外部中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727203928114.png" alt="image-20220727203928114"></p><p>然后生成代码</p><p>重新实现中断回调函数、编写按键检测程序</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220716170830949.png" alt="image-20220716170830949"></p><p>在gpio.c 中我们编写该函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727204139553.png" alt="image-20220727204139553"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)&#123;<span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);<span class="comment">//切换LED GPIO状态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY2_Pin)&#123;<span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);<span class="comment">//切换LED GPIO状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把main中控制闪烁注释掉</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727204442003.png" alt="image-20220727204442003"></p><p>烧录后的现象</p><p>按下KEY1 或者KEY2可以切换LED灯开关状态</p><h1 id="第三章-OLED使用"><a href="#第三章-OLED使用" class="headerlink" title="第三章-OLED使用"></a>第三章-OLED使用</h1><h2 id="3-1-资料准备"><a href="#3-1-资料准备" class="headerlink" title="3.1-资料准备"></a>3.1-资料准备</h2><p>我们先去下载这个OLED模块的资料</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727205105383.png" alt="image-20220727205105383" style="zoom:33%;" /></p><p>这里我们下载:<strong>优信电子—0.96寸 OLED显示液晶屏模块 IIC液晶屏  四引脚</strong></p><p>淘宝链接:</p><p><a href="https://item.taobao.com/item.htm?spm=a230r.1.14.16.504611e6WA3Clv&amp;id=562145367495&amp;ns=1&amp;abbucket=3#detail">https://item.taobao.com/item.htm?spm=a230r.1.14.16.504611e6WA3Clv&amp;id=562145367495&amp;ns=1&amp;abbucket=3#detail</a></p><p>OLED资料链接:</p><p><strong>0.96寸（4管脚）资料下载链接：</strong></p><p><a href="https://pan.baidu.com/s/1J57Izsv-PKmbwVrA2ynDzg">https://pan.baidu.com/s/1J57Izsv-PKmbwVrA2ynDzg</a>            提取码：vktz</p><p>找到我们要的历程—中景园电子0.96OLED显示屏_STM32F103C8_IIC_V1.0</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727210815907.png" alt="image-20220727210815907"></p><h2 id="3-2-相关知识"><a href="#3-2-相关知识" class="headerlink" title="3.2-相关知识"></a>3.2-相关知识</h2><p>这个OLED是IIC协议，很多都是单片机模拟IIC和模块通信的，这个也是模拟IIC控制OLED的</p><p>我们先看一下这个历程</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727210946103.png" alt="image-20220727210946103"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727211027636.png" alt="image-20220727211027636"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727211352797.png" alt="image-20220727211352797"></p><p>所谓我们移植的时候替换相关初始化内容和GPIO置为函数就行</p><h2 id="3-3-解决一些错误"><a href="#3-3-解决一些错误" class="headerlink" title="3.3-解决一些错误"></a>3.3-解决一些错误</h2><p>把OLED文件复制过去</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727212108337.png" alt="image-20220727212108337"></p><p>添加组和包含文件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727213102694.png" alt="image-20220727213102694" style="zoom:33%;" /></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727213054063.png" alt="image-20220727213054063" style="zoom: 33%;" /></p><p>选择添加路径</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727213257813.png" alt="image-20220727213257813" style="zoom: 25%;" /></p><p>编译一下—找不到sys.h 删掉sys.h </p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727213408708.png" alt="image-20220727213408708" style="zoom: 25%;" /></p><p>编译一下—把所有的u8都替换成uint8_t u32 替换成uint32_t</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727214626867.png" alt="image-20220727214626867"></p><p>编译报错 找不到uint8_t  包含一下#include “main.h”      解决</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727214254871.png" alt="image-20220727214254871"></p><p>有警告 声明加上void</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727214420870.png" alt="image-20220727214420870" style="zoom:25%;" /></p><p>下面是一些GPIO的错误，我要解决初始化问题了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727214806261.png" alt="image-20220727214806261"></p><h2 id="3-4-开始初始化OLED"><a href="#3-4-开始初始化OLED" class="headerlink" title="3.4-开始初始化OLED"></a>3.4-开始初始化OLED</h2><p>先看原理图  <strong>SDA-PB12  SCL-PA15</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727215225137.png" alt="image-20220727215225137" style="zoom:25%;" /></p><p>然后我们开始初始两个GPIO为输出模式—上拉输出模式</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727224538128.png" alt="image-20220727224538128"></p><p>然后我们生成代码，更改一下IIC协议的GPIO设置，和初始化部分</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727230824437.png" alt="image-20220727230824437"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCLK_Clr() HAL_GPIO_WritePin(OLED_SCL_GPIO_Port, OLED_SCL_Pin, GPIO_PIN_RESET)<span class="comment">//设置SCL低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SCLK_Set() HAL_GPIO_WritePin(OLED_SCL_GPIO_Port, OLED_SCL_Pin, GPIO_PIN_SET)<span class="comment">//设置SCL高电平</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDIN_Clr() HAL_GPIO_WritePin(OLED_SDA_GPIO_Port,OLED_SDA_Pin,GPIO_PIN_RESET)<span class="comment">//设置SDA低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_SDIN_Set() HAL_GPIO_WritePin(OLED_SDA_GPIO_Port,OLED_SDA_Pin,GPIO_PIN_SET)<span class="comment">//设置SDA高电平</span></span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727231448989.png" alt="image-20220727231448989"></p><p>下面delay函数出现报错 我们替换成HAL_Delay</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727231848062.png" alt="image-20220727231848062"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727232059531.png" alt="image-20220727232059531"></p><p>编译没有报错了，我们在主函数添加初始化和测试代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727233213431.png" alt="image-20220727233213431"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OLED_Init();<span class="comment">//初始化OLED  </span></span><br><span class="line">OLED_Clear(); </span><br><span class="line"></span><br><span class="line">OLED_ShowCHinese(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//中</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">18</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//景</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">36</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//园</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">54</span>,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//电</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">72</span>,<span class="number">0</span>,<span class="number">4</span>);<span class="comment">//子</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">90</span>,<span class="number">0</span>,<span class="number">5</span>);<span class="comment">//科</span></span><br><span class="line">OLED_ShowCHinese(<span class="number">108</span>,<span class="number">0</span>,<span class="number">6</span>);<span class="comment">//技</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>烧录下载 现象OLED屏幕显示-中景园电子科技</p><h1 id="第四章-串口实验-简单输出"><a href="#第四章-串口实验-简单输出" class="headerlink" title="第四章-串口实验(简单输出)"></a>第四章-串口实验(简单输出)</h1><p>这里我们先初始化串口一、实现数据输出。</p><h2 id="4-1-串口编写"><a href="#4-1-串口编写" class="headerlink" title="4.1-串口编写"></a>4.1-串口编写</h2><p>软件初始化</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727234545569.png" alt="image-20220727234545569"></p><p>然后我们实现串口数据输出</p><p>方法一：</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728210913655.png" alt="image-20220728210913655"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> c_Data[] = <span class="string">&quot;串口输出测试:好家伙VCC\r\n&quot;</span>;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,c_Data,<span class="keyword">sizeof</span>(c_Data),<span class="number">0xFFFF</span>);</span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>方法二:实现printf函数</p><p>打开微库</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728211333083.png" alt="image-20220728211333083"></p><p>重定向fputc</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728211730782.png" alt="image-20220728211730782"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief 重定向printf (重定向fputc)，</span></span><br><span class="line"><span class="comment">使用时候记得勾选上魔法棒-&gt;Target-&gt;UseMicro LIB </span></span><br><span class="line"><span class="comment">可能需要在C文件加typedef struct __FILE FILE;</span></span><br><span class="line"><span class="comment">包含这个文件#include &quot;stdio.h&quot;</span></span><br><span class="line"><span class="comment">* @param </span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *stream)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,( <span class="type">uint8_t</span> *)&amp;ch,<span class="number">1</span>,<span class="number">0xFFFF</span>);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有错误</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728211515588.png" alt="image-20220728211515588"></p><p>在usart.c添加这个typedef struct __FILE FILE;</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728211651598.png" alt="image-20220728211651598"></p><p>添加一下测试(记得包含”stdio.h”)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728213124409.png" alt="image-20220728213124409"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;printf:好家伙VCC测试\r\n&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="4-2-串口实验"><a href="#4-2-串口实验" class="headerlink" title="4.2-串口实验"></a>4.2-串口实验</h2><h3 id="接线图"><a href="#接线图" class="headerlink" title="接线图"></a>接线图</h3><p>先烧录好，再连接串口查看现象</p><p>连接串口 可以使用  USB转TTL如CH340模块 或者 用DAP的串口功能</p><p><strong>使用USB转TTL如CH340模块</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221229214107521.png" alt="image-20221229214107521"></p><p><strong>使用DAP</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221229214655460.png" alt="image-20221229214655460"></p><p>然后我们打开串口助手，选择串口端口和波特率，就可以看到输出</p><p>蓝牙模块使用 </p><p>蓝牙模式使用在后面章节讲解</p><h1 id="第五章-PWM控制电机"><a href="#第五章-PWM控制电机" class="headerlink" title="第五章-PWM控制电机"></a>第五章-PWM控制电机</h1><h2 id="5-1-认识PWM"><a href="#5-1-认识PWM" class="headerlink" title="5.1-认识PWM"></a>5.1-认识PWM</h2><p>参数如何描述PWM</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729093044088.png" alt="image-20220729093044088" style="zoom:33%;" /></p><h2 id="5-2-PWM配置"><a href="#5-2-PWM配置" class="headerlink" title="5.2-PWM配置"></a>5.2-PWM配置</h2><p>根据我们小车原理图我们知道是 <strong>PA11和PA8</strong>两个引脚要设置为PWM输出</p><p>这里为什么小车原理图要这样设计那?</p><ol><li>根据A4950的使用要求</li><li>根据STM32F103C8T6的定时器复用功能重映射</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729102313833.png" alt="image-20220729102313833" style="zoom:33%;" /></p><p>我们这先介绍原因:</p><p>原因1：介绍电机驱动后，我们会说明</p><p>原因2: 因为<strong>STM32中文参考手册</strong>介绍了，TIM1_CH1和TIM1_CH4可以复用功能重映射到PA8和PA11</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729102920289.png" alt="image-20220729102920289" style="zoom:67%;" /></p><p>我们使用软件配置 <strong>PA11和PA8</strong>这里配置</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729104029766.png" alt="image-20220729104029766" style="zoom:50%;" /></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729105524572.png" alt="image-20220729105524572"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729105741439.png" alt="image-20220729105741439"></p><p>然后我们生成代码</p><p>PWM输出的配置就已经完成了，但是不能输出产生PWM波，因为Cube在生成代码时，有很多外设初始化完后默认是关闭的，需要我们手动开启。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729110142345.png" alt="image-20220729110142345" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_1);<span class="comment">//开启定时器1 通道1 PWM输出</span></span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim1,TIM_CHANNEL_4);<span class="comment">//开启定时器1 通道4 PWM输出</span></span><br></pre></td></tr></table></figure><p>我们软件仿真一下、查看PA11与PA8波形</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729164150949.png" alt="image-20220729164150949"></p><p>那么频率就是 1/0.002 = 500HZ</p><p>这就是我们要设置的</p><p>我们可以使用这个宏来修改占空比</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, <span class="number">40</span>);</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729170905026.png" alt="image-20220729170905026"></p><h2 id="5-3-PWM测试方法"><a href="#5-3-PWM测试方法" class="headerlink" title="5.3-PWM测试方法"></a>5.3-PWM测试方法</h2><p>上面我们生成了PWM下面我们测试一下</p><h3 id="KEIL软件仿真方法"><a href="#KEIL软件仿真方法" class="headerlink" title="KEIL软件仿真方法:"></a>KEIL软件仿真方法:</h3><p>软件模拟仿真不需要任何硬件-下面是官方介绍</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729145446106.png" alt="image-20220729145446106"></p><p>选择软件仿真</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729150059613.png" alt="image-20220729150059613"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DARMSTM.DLL</span><br><span class="line">-pSTM32F103C8</span><br></pre></td></tr></table></figure><p>设置时钟频率-板子外部晶振8Mhz 这里我们选择8Mhz</p><p>(新版的keil5里没有那个设置频率的功能)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729162145332.png" alt="image-20220729162145332"></p><p>开启仿真</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729150321775.png" alt="image-20220729150321775"></p><p>打开逻辑分析仪器</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729150442778.png" alt="image-20220729150442778"></p><p>添加要观察的引脚</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729151057941.png" alt="image-20220729151057941"></p><p>点击全速运行</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729151216082.png" alt="image-20220729151216082"></p><h3 id="使用仿真器硬件仿真"><a href="#使用仿真器硬件仿真" class="headerlink" title="使用仿真器硬件仿真"></a>使用仿真器硬件仿真</h3><p>选择仿真器仿真-检测已经识别出芯片ID</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203144038645.png" alt="image-20221203144038645"></p><p>一样的可以开启仿真</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729162843082.png" alt="image-20220729162843082"></p><p>但是硬件仿真好像目前还不能使用过逻辑分析仪、但是硬件仿真是在硬件上跑的，可以向硬件输入数据或者由硬件输出数据、比如按键仿真的时候就可以使用硬件仿真。</p><h3 id="使用示波器工具测量波形-非重点"><a href="#使用示波器工具测量波形-非重点" class="headerlink" title="使用示波器工具测量波形(非重点)"></a>使用示波器工具测量波形(非重点)</h3><h1 id="第六章-电机驱动和PWM"><a href="#第六章-电机驱动和PWM" class="headerlink" title="第六章-电机驱动和PWM"></a>第六章-电机驱动和PWM</h1><h2 id="6-1-认识电机驱动"><a href="#6-1-认识电机驱动" class="headerlink" title="6.1-认识电机驱动"></a>6.1-认识电机驱动</h2><p>示波器、硬件仿真、软件仿真</p><p>项目使用电机驱动芯片为A4950、下面是电机驱动的相关介绍</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728215212236.png" alt="image-20220728215212236" style="zoom: 50%;" /></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728215543547.png" alt="image-20220728215543547" style="zoom:50%;" /></p><p>我们按照这种使用方法</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220728215220067.png" alt="image-20220728215220067" style="zoom: 50%;" /></p><p>这我们使用一个图介绍</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220730173302397.png" alt="image-20220730173302397"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230101164812094.png" alt="image-20230101164812094"></p><h2 id="6-2-使用电机驱动-独立工程"><a href="#6-2-使用电机驱动-独立工程" class="headerlink" title="6.2-使用电机驱动(独立工程)"></a>6.2-使用电机驱动(独立工程)</h2><h3 id="分析和编写代码"><a href="#分析和编写代码" class="headerlink" title="分析和编写代码"></a>分析和编写代码</h3><p>综合电机使用方法、C8T6单片机硬件资源、小车原理图我们要进行如下配置</p><p><strong>PA11-TIM1_CH4 定时器PWM输出-PWMA 前面已经完成</strong></p><p><strong>PB13-GPIO输出-AIN1</strong></p><p><strong>PA8-TIM1_CH1 定时器PWM输出-PWMB  前面已经完成</strong></p><p><strong>PB3-GPIO输出-BIN1</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220730165128928.png" alt="image-20220730165128928" style="zoom:50%;" /></p><p>还有两个管脚没有初始化</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220730175458784.png" alt="image-20220730175458784"></p><p>生成代码</p><p>开始添加控制电机正反转与速度的代码，进行仿真和电机测试，示波器测量</p><p>添加AIN1、BIN1控制代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806092857784.png" alt="image-20220806092857784"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_RESET);<span class="comment">//设置AIN1 PB13为 低电平</span></span><br><span class="line">HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_SET);  <span class="comment">//设置BIN1 PB3为高电平</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//两次会使得电机反向。</span></span><br><span class="line">HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_SET);<span class="comment">//设置AIN1 PB13为 高电平</span></span><br><span class="line">HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_RESET);  <span class="comment">//设置BIN1 PB3为低电平</span></span><br></pre></td></tr></table></figure><h3 id="仿真测试代码"><a href="#仿真测试代码" class="headerlink" title="仿真测试代码"></a>仿真测试代码</h3><p>使用软件仿真</p><p>检测是否软件仿真设置正确</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220730192214904.png" alt="image-20220730192214904"></p><p>开启仿真-添加PB13和PB3到逻辑分析仪</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220730192626969.png" alt="image-20220730192626969"></p><p>全速仿真运行</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220731185432931.png" alt="image-20220731185432931"></p><h3 id="实物测试代码"><a href="#实物测试代码" class="headerlink" title="实物测试代码"></a>实物测试代码</h3><p>如何让电机90%电压转速 旋转</p><p>烧录代码</p><h2 id="6-3-编写电机转速开环控制函数-另外复制工程"><a href="#6-3-编写电机转速开环控制函数-另外复制工程" class="headerlink" title="6.3-编写电机转速开环控制函数(另外复制工程)"></a>6.3-编写电机转速开环控制函数(另外复制工程)</h2><p>新建motor文件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806094030498.png" alt="image-20220806094030498"></p><p>包含文件并添加编译</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806094635879.png" alt="image-20220806094635879"></p><p>为了方便移植和使用，我们GPIO电平控制写成宏</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230101150840270.png" alt="image-20230101150840270"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AIN1_RESET  HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_RESET)<span class="comment">//设置AIN1 PB13为 低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AIN1_SET    HAL_GPIO_WritePin(AIN1_GPIO_Port,AIN1_Pin,GPIO_PIN_SET)<span class="comment">//设置AIN1 PB13为 高电平</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN1_RESET HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_RESET)  <span class="comment">//设置BIN1 PB3为低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIN1_SET    HAL_GPIO_WritePin(BIN1_GPIO_Port,BIN1_Pin,GPIO_PIN_SET)<span class="comment">//设置AIN1 PB13为 高电平</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们编写小车电机方向和速度控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  设置两个电机转速和方向</span></span><br><span class="line"><span class="comment">*  @param  motor1:电机B设置参数、motor2:设置参数</span></span><br><span class="line"><span class="comment">*  @param  motor1: 输入1~100 对应控制B电机正方向速度在1%-100%、输入-1~-100 对应控制B电机反方向速度在1%-100%、motor2同理</span></span><br><span class="line"><span class="comment">*  @return  无</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Set</span> <span class="params">(<span class="type">int</span> motor1,<span class="type">int</span> motor2)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据参数正负 设置选择方向</span></span><br><span class="line"><span class="keyword">if</span>(motor1 &lt; <span class="number">0</span>) BIN1_SET;</span><br><span class="line">   <span class="keyword">else</span>      BIN1_RESET;</span><br><span class="line"><span class="keyword">if</span>(motor2 &lt; <span class="number">0</span>) AIN1_SET;</span><br><span class="line"><span class="keyword">else</span>      AIN1_RESET;</span><br><span class="line"></span><br><span class="line"><span class="comment">//motor1 设置电机B的转速</span></span><br><span class="line"><span class="keyword">if</span>(motor1 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(motor1 &lt; <span class="number">-99</span>) motor1 = <span class="number">-99</span>;<span class="comment">//超过PWM幅值</span></span><br><span class="line"><span class="comment">//负的时候绝对值越小  PWM占空比越大</span></span><br><span class="line"><span class="comment">//现在的motor1      -1   -99</span></span><br><span class="line"><span class="comment">//给寄存器或者函数  99  1 </span></span><br><span class="line"> __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, (<span class="number">100</span>+motor1));<span class="comment">//修改定时器1 通道1 PA8 Pulse改变占空比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(motor1 &gt; <span class="number">99</span>) motor1 = <span class="number">99</span>;</span><br><span class="line"><span class="comment">//现在是   0 1  99</span></span><br><span class="line"><span class="comment">//我们赋值 0 1 99</span></span><br><span class="line"> __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_1, motor1);<span class="comment">//修改定时器1 通道1 PA8 Pulse改变占空比</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//motor2 设置电机A的转速</span></span><br><span class="line"><span class="keyword">if</span>(motor2 &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(motor2 &lt; <span class="number">-99</span>) motor2 = <span class="number">-99</span>;<span class="comment">//超过PWM幅值</span></span><br><span class="line"><span class="comment">//负的时候绝对值越小  PWM占空比越大</span></span><br><span class="line"><span class="comment">//现在的motor2      -1   -99</span></span><br><span class="line"><span class="comment">//给寄存器或者函数   99  1 </span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_4, (<span class="number">100</span>+motor2));<span class="comment">//修改定时器1 通道4 PA11 Pulse改变占空比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(motor2 &gt; <span class="number">99</span>) motor2 = <span class="number">99</span>;</span><br><span class="line"><span class="comment">//现在是   0 1 99</span></span><br><span class="line"><span class="comment">//我们赋值 0 1 99</span></span><br><span class="line"> __HAL_TIM_SET_COMPARE(&amp;htim1, TIM_CHANNEL_4, motor2);<span class="comment">//修改定时器1 通道4 PA11 Pulse改变占空比</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>然后我们连接电机主函数进行测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line">Motor_Set(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="第七章-编码器测速"><a href="#第七章-编码器测速" class="headerlink" title="第七章-编码器测速"></a>第七章-编码器测速</h1><h2 id="7-1-认识编码器"><a href="#7-1-认识编码器" class="headerlink" title="7.1-认识编码器"></a>7.1-认识编码器</h2><p>编码器:一般按照电机尾部、用于测量电机转速、方向、位置。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102003312991.png" alt="image-20230102003312991"></p><p>那么编码器的输出信号具体是什么？我们如何根据输出信号测量转速 和方向？</p><p>转速:  单位时间测量到的脉冲数量(比如根据每秒测量到多少个脉冲来计算转速)</p><p>旋转方向: 两通道信号的相对电平关系</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806200542121.png" alt="image-20220806200542121" style="zoom: 67%;" /></p><h2 id="7-2单片机定时器的编码器功能"><a href="#7-2单片机定时器的编码器功能" class="headerlink" title="7.2单片机定时器的编码器功能"></a>7.2单片机定时器的编码器功能</h2><p>那么我们已经知道编码器输出的波形，我们如何通过单片机读取波形，然后计算出速度那?</p><p>这里STM32单片机的定时器和通用定时器具有<strong>编码器接口模式</strong>、在STM32中文参考手册13章中有详细介绍</p><p>STM32中文参考手册-第200页</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806225827403.png" alt="image-20220806225827403" style="zoom:50%;" /></p><p>STM32中文参考手册-第267页</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807104608031.png" alt="image-20220807104608031"></p><p>STM32中文参考手册-第226页</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806222325272.png" alt="image-20220806222325272" style="zoom:67%;" /></p><p>这个是计数方向与编码器信号的关系、我们拆开来看</p><p>仅在TI1计数、电机正转、对原始数据二倍频</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806222556492.png" alt="image-20220806222556492" style="zoom:67%;" /></p><p>仅在TI1计数、电机反转、对原始数据二倍频</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806222737004.png" alt="image-20220806222737004" style="zoom:67%;" /></p><p>在TI1和TI2都计数</p><p>可以看到这样就对原始数据四倍频了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220806222848485.png" alt="image-20220806222848485" style="zoom:50%;" /></p><p>计数方向</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809144105548.png" alt="image-20220809144105548" style="zoom: 67%;" /></p><h2 id="7-3-获得单位时间计数器值变化量"><a href="#7-3-获得单位时间计数器值变化量" class="headerlink" title="7.3-获得单位时间计数器值变化量"></a>7.3-获得单位时间计数器值变化量</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103004459822.png" alt="image-20230103004459822"></p><p><strong>上一次说的方法：</strong></p><p>这次编码器计数值 = 计数器值+计数溢出次数 * 计数最大器计数最大值</p><p>计数器两次变化值 = 这次编码器计数值 - 上次编码器计数值</p><p>然后根据这个单位变化量计算速度</p><p><strong>还有一种方法：</strong></p><p>计数器变化量 = 当前计数器值</p><p>每次计数值清空</p><p>然后根据这个变化量 计算速度</p><p>然后我们再看具体到哪一款电机和编码器上如何测速</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102161121087.png" alt="image-20230102161121087"></p><p>在STM32中文参考手册-第119页</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807110602314.png" alt="image-20220807110602314"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102235948243.png" alt="image-20230102235948243"></p><p>设置TIM2</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807112130804.png" alt="image-20220807112130804"></p><p>设置ITM2滤波器</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807112239092.png" alt="image-20220807112239092"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807153021728.png" alt="image-20220807153021728"></p><p>同理设置TIM4</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807112807336.png" alt="image-20220807112807336"></p><p>设置TIM4滤波器</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807112858479.png" alt="image-20220807112858479"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807153047276.png" alt="image-20220807153047276"></p><p>设置引脚上拉</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807154059362.png" alt="image-20220807154059362"></p><p>生成代码</p><p>开启定时器和定时中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807162341446.png" alt="image-20220807162341446"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Encoder_Start(&amp;htim2,TIM_CHANNEL_ALL);<span class="comment">//开启定时器2</span></span><br><span class="line">HAL_TIM_Encoder_Start(&amp;htim4,TIM_CHANNEL_ALL);<span class="comment">//开启定时器4</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);<span class="comment">//开启定时器2 中断</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim4);                <span class="comment">//开启定时器4 中断</span></span><br></pre></td></tr></table></figure><p>在定义两个变量保存计数器值</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102225054673.png" alt="image-20230102225054673"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> Encoder1Count = <span class="number">0</span>;<span class="comment">//编码器计数器值</span></span><br><span class="line"><span class="type">short</span> Encoder2Count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>每2ms读取计数器值-&gt;清零计数器</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102231545491.png" alt="image-20230102231545491"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Motor_Set(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//1.保存计数器值</span></span><br><span class="line">Encoder1Count =(<span class="type">short</span>)__HAL_TIM_GET_COUNTER(&amp;htim4);</span><br><span class="line">Encoder2Count =(<span class="type">short</span>)__HAL_TIM_GET_COUNTER(&amp;htim2);</span><br><span class="line"><span class="comment">//2.清零计数器值</span></span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim4,<span class="number">0</span>);</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Encoder1Count:%d\r\n&quot;</span>,Encoder1Count);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Encoder2Count:%d\r\n&quot;</span>,Encoder2Count);</span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>接好电池、烧录代码、串口一连接电脑</p><p>用手转动电机1或者电机2 、串口助手可以看到输出信息了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102232135472.png" alt="image-20230102232135472"></p><h2 id="7-4-主函数周期测量转速"><a href="#7-4-主函数周期测量转速" class="headerlink" title="7.4-主函数周期测量转速"></a>7.4-主函数周期测量转速</h2><p>上面我们测量出来了溢出值，我们再根据当前计数器值就可以测量出计数器变化量，我们通过单位时间变量就可以计算出转速</p><p>下面是电机和编码器的参数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230102161121087.png" alt="image-20230102161121087"></p><p>我们先测试的结论是否有问题？</p><ol><li>编码器计数器会不会在计数时间内溢出？</li><li>车轮旋转一周，单片机编码器计数器计数多少？9.6乘11乘4</li><li>根据计算方法计算电机转速</li></ol><p>定义两个float变量</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103140008234.png" alt="image-20230103140008234"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Motor1Speed = <span class="number">0.00</span>;</span><br><span class="line"><span class="type">float</span> Motor2Speed = <span class="number">0.00</span>;</span><br></pre></td></tr></table></figure><p>下面是代码(一定要把主函数没有用的删除掉)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103140050045.png" alt="image-20230103140050045"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算速度</span></span><br><span class="line">Motor1Speed = (<span class="type">float</span>)Encode1Count*<span class="number">100</span>/<span class="number">9.6</span>/<span class="number">11</span>/<span class="number">4</span>;</span><br><span class="line">Motor2Speed = (<span class="type">float</span>)Encode2Count*<span class="number">100</span>/<span class="number">9.6</span>/<span class="number">11</span>/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor1Speed:%.2f\r\n&quot;</span>,Motor1Speed);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor2Speed:%.2f\r\n&quot;</span>,Motor2Speed);</span><br></pre></td></tr></table></figure><p>编译烧录代码就会输出结果</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103140447001.png" alt="image-20230103140447001"></p><h2 id="7-5-定时器中断定时测量速度"><a href="#7-5-定时器中断定时测量速度" class="headerlink" title="7.5-定时器中断定时测量速度"></a>7.5-定时器中断定时测量速度</h2><p>上面我们实现:在主函数周期，读取计数器值然后计算速度，但是如果函数加入其他内容这个周期时间就很难保证。</p><p>所以这节我们通过定时器，周期读取计数器，计算速度。复制一份工程开始搞!</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103153710421.png" alt="image-20230103153710421"></p><p>我们先开启定时器、2ms进入一次定时器中断，中断回调函数执行咱们的代码即可。</p><p>为什么充分利用单片机 我们使用TIM1</p><ol><li>设置内部时钟源</li><li>使能自动重装载</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809161601774.png" alt="image-20220809161601774"></p><p>开启定义更新中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809161647624.png" alt="image-20220809161647624"></p><p>代码开启定时器1 中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809162038626.png" alt="image-20220809162038626"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_Base_Start_IT(&amp;htim1);                <span class="comment">//开启定时器1 中断</span></span><br></pre></td></tr></table></figure><p>定时器回调函数中添加 速度计算内容</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103151934131.png" alt="image-20230103151934131"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  定时器回调函数</span></span><br><span class="line"><span class="comment">*  @param  </span></span><br><span class="line"><span class="comment">*  @return  </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim == &amp;htim1)<span class="comment">//htim1 500HZ  2ms 中断一次</span></span><br><span class="line">&#123;</span><br><span class="line">TimerCount++;</span><br><span class="line"><span class="keyword">if</span>(TimerCount %<span class="number">5</span> == <span class="number">0</span>)<span class="comment">//每10ms执行一次</span></span><br><span class="line">&#123;</span><br><span class="line">Encode1Count = (<span class="type">short</span>)__HAL_TIM_GET_COUNTER(&amp;htim4);</span><br><span class="line">Encode2Count = (<span class="type">short</span>)__HAL_TIM_GET_COUNTER(&amp;htim2);</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim4,<span class="number">0</span>);</span><br><span class="line">__HAL_TIM_SET_COUNTER(&amp;htim2,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Motor1Speed = (<span class="type">float</span>)Encode1Count*<span class="number">100</span>/<span class="number">9.6</span>/<span class="number">11</span>/<span class="number">4</span>;</span><br><span class="line">Motor2Speed = (<span class="type">float</span>)Encode2Count*<span class="number">100</span>/<span class="number">9.6</span>/<span class="number">11</span>/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">TimerCount=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把之前的变量定义放这里</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103152057663.png" alt="image-20230103152057663"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> Encode1Count = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> Encode2Count = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> Motor1Speed = <span class="number">0.00</span>;</span><br><span class="line"><span class="type">float</span> Motor2Speed = <span class="number">0.00</span>;</span><br><span class="line"><span class="type">uint16_t</span> TimerCount=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>主函数就输出速度大小就可以了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103152344746.png" alt="image-20230103152344746"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor1Speed:%.2f\r\n&quot;</span>,Motor1Speed);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor2Speed:%.2f\r\n&quot;</span>,Motor2Speed);</span><br></pre></td></tr></table></figure><p>把变量需要声明一下</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103152521123.png" alt="image-20230103152521123"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Motor1Speed ;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> Motor2Speed ;</span><br></pre></td></tr></table></figure><p>然后打开串口助手</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103152735931.png" alt="image-20230103152735931"></p><p>注:</p><p>根据电机和实际小车调整速度测量与占空比设置函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103160108176.png" alt="image-20230103160108176"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103160133008.png" alt="image-20230103160133008"></p><h1 id="第八章-PID-速度控制"><a href="#第八章-PID-速度控制" class="headerlink" title="第八章-PID-速度控制"></a>第八章-PID-速度控制</h1><h2 id="8-1-速度控制探索"><a href="#8-1-速度控制探索" class="headerlink" title="8.1-速度控制探索"></a>8.1-速度控制探索</h2><p>前面我们已经能够通过编码器测量出速度值，下面我们来控制速度</p><p>我们先编写一个简单的控制方法</p><p>要求：讲转速控制再2.9-3.1转每秒</p><p>可以把中断里面不重要的输出注释掉</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103163851923.png" alt="image-20230103163851923"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Motor1Speed&gt;<span class="number">3.1</span>) Motor1Pwm--;</span><br><span class="line"><span class="keyword">if</span>(Motor1Speed&lt;<span class="number">2.9</span>) Motor1Pwm++;</span><br><span class="line"><span class="keyword">if</span>(Motor2Speed&gt;<span class="number">3.1</span>) Motor2Pwm--;</span><br><span class="line"><span class="keyword">if</span>(Motor2Speed&lt;<span class="number">2.9</span>) Motor2Pwm++;</span><br><span class="line">Motor_Set(Motor1Pwm,Motor2Pwm);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor1Speed:%.2f Motor1Pwm:%d\r\n&quot;</span>,Motor1Speed,Motor1Pwm);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Motor2Speed:%.2f Motor2Pwm:%d\r\n&quot;</span>,Motor2Speed,Motor2Pwm);</span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>开始实验</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103164021564.png" alt="image-20230103164021564"></p><p>现象就开始电机没有到达3转每秒，PWM占空比逐渐增大，电机<strong>逐渐</strong>达到要求转速、到达要求转速后我们增加阻力，电机<strong>变慢</strong>，阻力大小不边PWM占空比逐渐更大转速<strong>逐渐更大</strong>。</p><p>这样我们就把转速控制到我们想要的范围，但是我们并不满意、能够看出来控制的速度很慢，给电机一些阻力电机至少要2-3秒能够调整过来，这在一些场景是不允许的。</p><p>我们理想的控制效果是：在电机转速很慢的是时候能快速调整，在电机一直转的不能达到要求时候能够更快速度调整</p><h2 id="8-2-准备工作-匿名上位机曲线显示速度波形方便观察数据"><a href="#8-2-准备工作-匿名上位机曲线显示速度波形方便观察数据" class="headerlink" title="8.2-准备工作-匿名上位机曲线显示速度波形方便观察数据"></a>8.2-准备工作-匿名上位机曲线显示速度波形方便观察数据</h2><p>为了方便观察电机速度数据，我们通过上位机曲线显示一下。</p><p>这里我们使用的上位机是匿名上位机-大佬写的非常稳定功能也很多</p><p>我使用的版本是:<strong>匿名上位机V7.2.2.8版本</strong>推荐大家和我使用一样</p><p>匿名上位机官方下载链接:<a href="http://www.anotc.com/wiki/%E5%8C%BF%E5%90%8D%E4%BA%A7%E5%93%81%E8%B5%84%E6%96%99/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB">http://www.anotc.com/wiki/%E5%8C%BF%E5%90%8D%E4%BA%A7%E5%93%81%E8%B5%84%E6%96%99/%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%E6%B1%87%E6%80%BB</a></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220818223304266.png" alt="image-20220818223304266" style="zoom: 25%;" /></p><p>我们要把STM32数据发送到匿名上位机，就要满足匿名上位机的数据协议要求</p><p>在匿名上位机资料下载链接，可以下载到协议介绍</p><ul><li>匿名上位机V7通信协议，20210528发布：<a href="https://pan.baidu.com/s/1nGrIGWj6qr9DWOcGpKR51g">https://pan.baidu.com/s/1nGrIGWj6qr9DWOcGpKR51g</a> 提取码：z8d1</li><li>CSDN <a href="https://blog.csdn.net/qq_44339029">慕羽★</a>大佬写的协议解析教程博客:<a href="https://blog.csdn.net/qq_44339029/article/details/106004997">https://blog.csdn.net/qq_44339029/article/details/106004997</a></li></ul><p><strong>1.先补充一下大小端模式</strong></p><p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么<strong>必然存在着一个如和将多个字节安排的问题</strong>。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。</p><ul><li><p><strong>所谓的大端模式（BE big-endian），是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中（低对高，高对低）；</strong></p></li><li><p><strong>所谓的小端模式（LE little-endian），是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中（低对低，高对高）。</strong></p><h5 id="常见的单片机大小端模式：（1）KEIL-C51中，变量都是大端模式的，而KEIL-MDK中，变量是小端模式的。（2）SDCC-C51是小端寻址，AVRGCC-小端寻址-（3）PC小端，大部分ARM是小端-（4）总起来说51单片机一般是大端模式，32单片机一般是小端模式"><a href="#常见的单片机大小端模式：（1）KEIL-C51中，变量都是大端模式的，而KEIL-MDK中，变量是小端模式的。（2）SDCC-C51是小端寻址，AVRGCC-小端寻址-（3）PC小端，大部分ARM是小端-（4）总起来说51单片机一般是大端模式，32单片机一般是小端模式" class="headerlink" title="常见的单片机大小端模式：（1）KEIL C51中，变量都是大端模式的，而KEIL MDK中，变量是小端模式的。（2）SDCC-C51是小端寻址，AVRGCC 小端寻址.（3）PC小端，大部分ARM是小端 （4）总起来说51单片机一般是大端模式，32单片机一般是小端模式."></a>常见的<a href="https://so.csdn.net/so/search?q=单片机&amp;spm=1001.2101.3001.7020">单片机</a>大小端模式：（1）KEIL C51中，变量都是大端模式的，而KEIL MDK中，变量是小端模式的。（2）SDCC-C51是小端寻址，AVRGCC 小端寻址.（3）PC小端，大部分ARM是小端 （4）总起来说51单片机一般是大端模式，32单片机一般是小端模式.</h5></li></ul><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103211719535.png" alt="image-20230103211719535"></p><p><strong>2.看一下上位机要求的协议</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220818230815447.png" alt="image-20220818230815447" style="zoom: 50%;" /></p><p>灵活格式帧(用户自定义帧)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220818231041314.png" alt="image-20220818231041314" style="zoom:50%;" /></p><p>前面我们好理解</p><p>0xAA:一个字节表示开始</p><p>0xFF:一个字节表示目标地址</p><p>0xF1:一个字节表示发送功能码</p><p>1-40：一个字节表示数据长度</p><p>数据内容有多个字节如何发送</p><p><strong>因为串口每次发送一个字节，但是数据可能是int16_t 16位的数据，或者int32_t 32位数据，每次发送16位数据,先发送数据低八位，还是先发送数据高八位那?</strong></p><p>匿名协议通信介绍给出：<strong>DATA 数据内容中的数据，采用小端模式传送，低字节在前，高字节在后。</strong></p><p>那么就要求，比如我们在发送16位数据0x2314我们要先发送低字节0x14,然后发送高字节0x23</p><p>那么如何解析出低字节或者高字节，就需要知道多字节数据在单片机里面是怎么存的，因为STM32是小端存储，所以低字节就在低位地址中，高字节高位地址中。</p><p>如果使用32单片机 小端模式，0x23高地址，0x14在低地址，所以我们要先发低地址，再发高地址。</p><p>下面就是对16位数据，或者32位数据的拆分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要发送16位,32位数据，对数据拆分，之后每次发送单个字节</span></span><br><span class="line"><span class="comment">//拆分过程：对变量dwTemp 去地址然后将其转化成char类型指针，最后再取出指针所指向的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE0(dwTemp)  (*(char *)(&amp;dwTemp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE1(dwTemp)  (*((char *)(&amp;dwTemp) + 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE2(dwTemp)  (*((char *)(&amp;dwTemp) + 2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE3(dwTemp)  (*((char *)(&amp;dwTemp) + 3))</span></span><br></pre></td></tr></table></figure><p>拆分后我们按照协议要求发送数据就可以了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220819104451257.png" alt="image-20220819104451257"></p><p>niming.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;niming.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usart.h&quot;</span></span></span><br><span class="line"><span class="type">uint8_t</span> data_to_send[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过F1帧发送4个uint16类型的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F1</span><span class="params">(<span class="type">uint16_t</span> _a, <span class="type">uint16_t</span> _b, <span class="type">uint16_t</span> _c, <span class="type">uint16_t</span> _d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> _cnt = <span class="number">0</span>;<span class="comment">//计数值</span></span><br><span class="line">    <span class="type">uint8_t</span> sumcheck = <span class="number">0</span>;  <span class="comment">//和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> addcheck = <span class="number">0</span>; <span class="comment">//附加和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">data_to_send[_cnt++] = <span class="number">0xAA</span>;<span class="comment">//帧头</span></span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xFF</span>;<span class="comment">//目标地址</span></span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xF1</span>;<span class="comment">//功能码</span></span><br><span class="line">    data_to_send[_cnt++] = <span class="number">8</span>; <span class="comment">//数据长度</span></span><br><span class="line"><span class="comment">//单片机为小端模式-低地址存放低位数据，匿名上位机要求先发低位数据，所以先发低地址</span></span><br><span class="line">data_to_send[_cnt++] = BYTE0(_a);       </span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_a);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_b);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_b);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_c);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_c);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_d);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_d);</span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; data_to_send[<span class="number">3</span>]+<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumcheck += data_to_send[i];<span class="comment">//和校验</span></span><br><span class="line">        addcheck += sumcheck;<span class="comment">//附加校验</span></span><br><span class="line">    &#125;</span><br><span class="line">    data_to_send[_cnt++] = sumcheck;</span><br><span class="line">    data_to_send[_cnt++] = addcheck;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1,data_to_send,_cnt,<span class="number">0xFFFF</span>);<span class="comment">//这里是串口发送函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//，通过F2帧发送4个int16类型的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F2</span><span class="params">(<span class="type">int16_t</span> _a, <span class="type">int16_t</span> _b, <span class="type">int16_t</span> _c, <span class="type">int16_t</span> _d)</span>   <span class="comment">//F2帧  4个  int16 参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> _cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> sumcheck = <span class="number">0</span>; <span class="comment">//和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> addcheck = <span class="number">0</span>; <span class="comment">//附加和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> i=<span class="number">0</span>;</span><br><span class="line">   data_to_send[_cnt++] = <span class="number">0xAA</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xFF</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xF2</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">8</span>; <span class="comment">//数据长度</span></span><br><span class="line"><span class="comment">//单片机为小端模式-低地址存放低位数据，匿名上位机要求先发低位数据，所以先发低地址</span></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_a);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_a);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_b);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_b);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_c);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_c);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_d);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_d);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; data_to_send[<span class="number">3</span>]+<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumcheck += data_to_send[i];</span><br><span class="line">        addcheck += sumcheck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = sumcheck;</span><br><span class="line">    data_to_send[_cnt++] = addcheck;</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,data_to_send,_cnt,<span class="number">0xFFFF</span>);<span class="comment">//这里是串口发送函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过F3帧发送2个int16类型和1个int32类型的数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F3</span><span class="params">(<span class="type">int16_t</span> _a, <span class="type">int16_t</span> _b, <span class="type">int32_t</span> _c )</span>   <span class="comment">//F3帧  2个  int16 参数   1个  int32  参数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> _cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> sumcheck = <span class="number">0</span>; <span class="comment">//和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> addcheck = <span class="number">0</span>; <span class="comment">//附加和校验</span></span><br><span class="line">    <span class="type">uint8_t</span> i=<span class="number">0</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xAA</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xFF</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">0xF3</span>;</span><br><span class="line">    data_to_send[_cnt++] = <span class="number">8</span>; <span class="comment">//数据长度</span></span><br><span class="line"><span class="comment">//单片机为小端模式-低地址存放低位数据，匿名上位机要求先发低位数据，所以先发低地址</span></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_a);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_a);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_b);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_b);</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = BYTE0(_c);</span><br><span class="line">    data_to_send[_cnt++] = BYTE1(_c);</span><br><span class="line">    data_to_send[_cnt++] = BYTE2(_c);</span><br><span class="line">    data_to_send[_cnt++] = BYTE3(_c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; data_to_send[<span class="number">3</span>]+<span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sumcheck += data_to_send[i];</span><br><span class="line">        addcheck += sumcheck;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data_to_send[_cnt++] = sumcheck;</span><br><span class="line">    data_to_send[_cnt++] = addcheck;</span><br><span class="line"></span><br><span class="line">HAL_UART_Transmit(&amp;huart1,data_to_send,_cnt,<span class="number">0xFFFF</span>);<span class="comment">//这里是串口发送函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>niming.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span>  NIMING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NIMING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="comment">//需要发送16位,32位数据，对数据拆分，之后每次发送单个字节</span></span><br><span class="line"><span class="comment">//拆分过程：对变量dwTemp 去地址然后将其转化成char类型指针，最后再取出指针所指向的内容</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE0(dwTemp)  (*(char *)(&amp;dwTemp))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE1(dwTemp)  (*((char *)(&amp;dwTemp) + 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE2(dwTemp)  (*((char *)(&amp;dwTemp) + 2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTE3(dwTemp)  (*((char *)(&amp;dwTemp) + 3))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F1</span><span class="params">(<span class="type">uint16_t</span>, <span class="type">uint16_t</span> _b, <span class="type">uint16_t</span> _c, <span class="type">uint16_t</span> _d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F2</span><span class="params">(<span class="type">int16_t</span> _a, <span class="type">int16_t</span> _b, <span class="type">int16_t</span> _c, <span class="type">int16_t</span> _d)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ANO_DT_Send_F3</span><span class="params">(<span class="type">int16_t</span> _a, <span class="type">int16_t</span> _b, <span class="type">int32_t</span> _c )</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加测试代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230103214655364.png" alt="image-20230103214655364"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//电机速度等信息发送到上位机</span></span><br><span class="line"><span class="comment">//注意上位机不支持浮点数，所以要乘100</span></span><br><span class="line">ANO_DT_Send_F2(Motor1Speed*<span class="number">100</span>, <span class="number">3.0</span>*<span class="number">100</span>,Motor2Speed*<span class="number">100</span>,<span class="number">3.0</span>*<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>下面设置上位机-数据解析</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220819192140541.png" alt="image-20220819192140541"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220819191949193.png" alt="image-20220819191949193"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820125740753.png" alt="image-20220820125740753"></p><p>这个是控制效果，并不理想，后面我们介绍PID控制</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820125338506.png" alt="image-20220820125338506"></p><h2 id="8-3-P-I-D-逐个参数理解"><a href="#8-3-P-I-D-逐个参数理解" class="headerlink" title="8.3-P I D 逐个参数理解"></a>8.3-P I D 逐个参数理解</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820173540806.png" alt="image-20220820173540806" style="zoom:50%;" /></p><p>加入的现在 过去 未来概念</p><p>p:现在</p><p>i:过去</p><p>d:未来</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820140658286.png" alt="image-20220820140658286"></p><p>那么我们就开始写PID</p><p>PID的结构体类型变量、里面成员都是浮点类型</p><p>先在pid.h声明一个结构体类型、声明.c中的函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104132732080.png" alt="image-20230104132732080"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PID_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">float</span> target_val;<span class="comment">//目标值</span></span><br><span class="line"><span class="type">float</span> actual_val;<span class="comment">//实际值</span></span><br><span class="line"><span class="type">float</span> err;<span class="comment">//当前偏差</span></span><br><span class="line"><span class="type">float</span> err_last;<span class="comment">//上次偏差</span></span><br><span class="line"><span class="type">float</span> err_sum;<span class="comment">//误差累计值</span></span><br><span class="line"><span class="type">float</span> Kp,Ki,Kd;<span class="comment">//比例，积分，微分系数</span></span><br><span class="line"></span><br><span class="line">&#125; tPid;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">P_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PI_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span>;</span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在pid.c中定义结构体类型变量</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104132821912.png" alt="image-20230104132821912"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pid.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体类型变量</span></span><br><span class="line">tPid pidMotor1Speed;</span><br><span class="line"><span class="comment">//给结构体类型变量赋初值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pidMotor1Speed.actual_val=<span class="number">0.0</span>;</span><br><span class="line">pidMotor1Speed.target_val=<span class="number">0.00</span>;</span><br><span class="line">pidMotor1Speed.err=<span class="number">0.0</span>;</span><br><span class="line">pidMotor1Speed.err_last=<span class="number">0.0</span>;</span><br><span class="line">pidMotor1Speed.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pidMotor1Speed.Kp=<span class="number">0</span>;</span><br><span class="line">pidMotor1Speed.Ki=<span class="number">0</span>;</span><br><span class="line">pidMotor1Speed.Kd=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比例p调节控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">P_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//当前误差=目标值-真实值</span></span><br><span class="line"><span class="comment">//比例控制调节   输出=Kp*当前误差</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err;</span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比例P 积分I 控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PI_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//当前误差=目标值-真实值</span></span><br><span class="line">pid-&gt;err_sum += pid-&gt;err;<span class="comment">//误差累计值 = 当前误差累计和</span></span><br><span class="line"><span class="comment">//使用PI控制 输出=Kp*当前误差+Ki*误差累计值</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err + pid-&gt;Ki*pid-&gt;err_sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PID控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">////当前误差=目标值-真实值</span></span><br><span class="line">pid-&gt;err_sum += pid-&gt;err;<span class="comment">//误差累计值 = 当前误差累计和</span></span><br><span class="line"><span class="comment">//使用PID控制 输出 = Kp*当前误差  +  Ki*误差累计值 + Kd*(当前误差-上次误差)</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err + pid-&gt;Ki*pid-&gt;err_sum + pid-&gt;Kd*(pid-&gt;err - pid-&gt;err_last);</span><br><span class="line"><span class="comment">//保存上次误差: 这次误差赋值给上次误差</span></span><br><span class="line">pid-&gt;err_last = pid-&gt;err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在main中要调用PID_init();函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104132925536.png" alt="image-20230104132925536"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID_init();</span><br></pre></td></tr></table></figure><p><strong>p调节函数</strong>函数只根据当前误差进行控制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比例p调节控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">P_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//目标值减去实际值等于误差值</span></span><br><span class="line"><span class="comment">//比例控制调节</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err;</span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数-可以估算当p=10 就有较好的响应速度</p><p>先看根据p比例控制的效果</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820160006470.png" alt="image-20220820160006470"></p><p>p调节 电机稳态后还是存在误差。</p><p>下面加入i 调节也就是加入历史误差</p><p><strong>pi的控制函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比例P 积分I 控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PI_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//目标值减去实际值等于误差值</span></span><br><span class="line">pid-&gt;err_sum += pid-&gt;err;<span class="comment">//误差累计求和</span></span><br><span class="line"><span class="comment">//使用PI控制</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err + pid-&gt;Ki*pid-&gt;err_sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为实际值1.6的时候误差为1.4 上次偏差1.4和这次偏差1.4相加2.8 我们乘5 等于10点多就会有较好控制效果</p><p>这是pi 调节的控制效果</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220820161527982.png" alt="image-20220820161527982"></p><p><strong>下面是PID调节的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PID控制函数</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">PID_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//目标值减去实际值等于误差值</span></span><br><span class="line">pid-&gt;err_sum += pid-&gt;err;<span class="comment">//误差累计求和</span></span><br><span class="line"><span class="comment">//使用PID控制</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err + pid-&gt;Ki*pid-&gt;err_sum + pid-&gt;Kd*(pid-&gt;err - pid-&gt;err_last);</span><br><span class="line"><span class="comment">//保存上次误差:最近一次 赋值给上次</span></span><br><span class="line">pid-&gt;err_last = pid-&gt;err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-加入cJSON方便上位机调参"><a href="#8-4-加入cJSON方便上位机调参" class="headerlink" title="8.4-加入cJSON方便上位机调参"></a>8.4-加入cJSON方便上位机调参</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104152600270.png" alt="image-20230104152600270"></p><p>调大堆栈</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821142654358.png" alt="image-20220821142654358"></p><p>软件开启中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821141804356.png" alt="image-20220821141804356" style="zoom: 25%;" /></p><p>开启接收中断</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821142200828.png" alt="image-20220821142200828"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__HAL_UART_ENABLE_IT(&amp;huart1,UART_IT_RXNE);<span class="comment">//开启串口1接收中断</span></span><br></pre></td></tr></table></figure><p>中断回调函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821142512762.png" alt="image-20220821142512762"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> Usart1_ReadBuf[<span class="number">256</span>];<span class="comment">//串口1 缓冲数组</span></span><br><span class="line"><span class="type">uint8_t</span> Usart1_ReadCount = <span class="number">0</span>;<span class="comment">//串口1 接收字节计数</span></span><br><span class="line">  <span class="keyword">if</span>(__HAL_UART_GET_FLAG(&amp;huart1,UART_FLAG_RXNE))<span class="comment">//判断huart1 是否读到字节</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(Usart1_ReadCount &gt;= <span class="number">255</span>) Usart1_ReadCount = <span class="number">0</span>;</span><br><span class="line">HAL_UART_Receive(&amp;huart1,&amp;Usart1_ReadBuf[Usart1_ReadCount++],<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>编写函数用于判断串口是否发送完一帧数据</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821143245954.png" alt="image-20220821143245954"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Usart1_ReadBuf[<span class="number">255</span>];<span class="comment">//串口1 缓冲数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> Usart1_ReadCount;<span class="comment">//串口1 接收字节计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断否接收完一帧数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Usart_WaitReasFinish</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> Usart_LastReadCount = <span class="number">0</span>;<span class="comment">//记录上次的计数值</span></span><br><span class="line"><span class="keyword">if</span>(Usart1_ReadCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Usart_LastReadCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//表示没有在接收数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Usart1_ReadCount == Usart_LastReadCount)<span class="comment">//如果这次计数值等于上次计数值</span></span><br><span class="line">&#123;</span><br><span class="line">Usart1_ReadCount = <span class="number">0</span>;</span><br><span class="line">Usart_LastReadCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//已经接收完成了</span></span><br><span class="line">&#125;</span><br><span class="line">Usart_LastReadCount = Usart1_ReadCount;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;<span class="comment">//表示正在接受中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把cJSON库放入工程里面</p><p>下载cJSON新版</p><p>gtihub链接:<a href="https://github.com/DaveGamble/cJSON">https://github.com/DaveGamble/cJSON</a></p><p>百度网盘链接：<a href="https://pan.baidu.com/s/1AcNHtZuv5bokMQ2f6QoG7Q">https://pan.baidu.com/s/1AcNHtZuv5bokMQ2f6QoG7Q</a></p><p>提取码：a422</p><p>和添加其他文件一样，加入工程，然后指定路径</p><p>编写解析指令的函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104173819026.png" alt="image-20230104173819026"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cJSON.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">   cJSON *cJsonData ,*cJsonVlaue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Usart_WaitReasFinish() == <span class="number">0</span>)<span class="comment">//是否接收完毕</span></span><br><span class="line">&#123;</span><br><span class="line">cJsonData  = cJSON_Parse((<span class="type">const</span> <span class="type">char</span> *)Usart1_ReadBuf);</span><br><span class="line"><span class="keyword">if</span>(cJSON_GetObjectItem(cJsonData,<span class="string">&quot;p&quot;</span>) !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cJsonVlaue = cJSON_GetObjectItem(cJsonData,<span class="string">&quot;p&quot;</span>);</span><br><span class="line">    p = cJsonVlaue-&gt;valuedouble;</span><br><span class="line">pidMotor1Speed.Kp = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cJSON_GetObjectItem(cJsonData,<span class="string">&quot;i&quot;</span>) !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cJsonVlaue = cJSON_GetObjectItem(cJsonData,<span class="string">&quot;i&quot;</span>);</span><br><span class="line">    i = cJsonVlaue-&gt;valuedouble;</span><br><span class="line">pidMotor1Speed.Ki = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cJSON_GetObjectItem(cJsonData,<span class="string">&quot;d&quot;</span>) !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cJsonVlaue = cJSON_GetObjectItem(cJsonData,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">    d = cJsonVlaue-&gt;valuedouble;</span><br><span class="line">pidMotor1Speed.Kd = d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cJSON_GetObjectItem(cJsonData,<span class="string">&quot;a&quot;</span>) !=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cJsonVlaue = cJSON_GetObjectItem(cJsonData,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    a = cJsonVlaue-&gt;valuedouble;</span><br><span class="line">pidMotor1Speed.target_val =a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cJsonData != <span class="literal">NULL</span>)&#123;</span><br><span class="line">  cJSON_Delete(cJsonData);<span class="comment">//释放空间、但是不能删除cJsonVlaue不然会 出现异常错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(Usart1_ReadBuf,<span class="number">0</span>,<span class="number">255</span>);<span class="comment">//清空接收buf，注意这里不能使用strlen</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;P:%.3f  I:%.3f  D:%.3f A:%.3f\r\n&quot;</span>,p,i,d,a);</span><br></pre></td></tr></table></figure><p>测试发送cJSON数据就会解析收到数据</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821151428650.png" alt="image-20220821151428650" style="zoom: 33%;" /></p><p>然后我们赋值改变一个电机的PID参数和目标转速</p><p>然后我们通过串口发送命令，就会改变PID的参数了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821163121273.png" alt="image-20220821163121273"></p><h1 id="第九章-PID整定方法"><a href="#第九章-PID整定方法" class="headerlink" title="第九章-PID整定方法"></a>第九章-PID整定方法</h1><h2 id="9-1-调整合适的采样周期和PID调参方法"><a href="#9-1-调整合适的采样周期和PID调参方法" class="headerlink" title="9.1-调整合适的采样周期和PID调参方法"></a>9.1-调整合适的采样周期和PID调参方法</h2><p>正如之前所说，现在我们PID控制函数是在主函数中循环调用，这样的调用方式并不能保证实时性，不能保证周期得到调用</p><p>所以我们要把PID控制函数放到中断里面定时执行，那么如何放到中断里面执行，执行的周期是多少合适那？</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104180752706.png" alt="image-20230104180752706" style="zoom:67%;" /></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230104184558395.png" alt="image-20230104184558395"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(TimerCount %<span class="number">10</span> ==<span class="number">0</span>)<span class="comment">//每20ms一次</span></span><br><span class="line">&#123;</span><br><span class="line">Motor_Set(PID_realize(&amp;pidMotor1Speed,Motor1Speed),<span class="number">0</span>);</span><br><span class="line">    TimerCount=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>烧录测试一下，是否可以改变波形和调整参数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821180525104.png" alt="image-20220821180525104"></p><p><strong>借助上位机调节PID</strong></p><ol><li>调节P  把I=0、D=0先给正值或负值值测试P 正负、然后根据PID函数输入和输出估算P 大小，然后I=0 D=0去测试，调节一个较大值</li><li>调节I  把P等于前面的值 然后测试I给较大正值和负值 测试出I正负，然后I从小值调节，直到没有偏差存在</li><li>一般系统不使用D </li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821205656468.png" alt="image-20220821205656468"></p><p>然后当前系统特点 :I 对于系统更重要</p><p>下面我们调节I</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821211930247.png" alt="image-20220821211930247"></p><p>给一个较小的i 发现 有一个大的超调，我们就减少p 、减小一半p</p><p>下面是减少一半p 的效果</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220821212416979.png" alt="image-20220821212416979"></p><p>这个效果还可以</p><p><strong>整理双电机速度控制</strong></p><p>首先我们的需要是控制两个电机，那么这两个电机的特点不同，他们的P I D 参数不同，要控制不同的目标速度，那么他们的目标值、实际值、偏差等都会不同，所以我们的PID函数就要能够根据输入参数控制电机</p><p>我们增加tPid 类型函数的定义用于控制电机</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220822142131051.png" alt="image-20220822142131051"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tPid pid1_speed;<span class="comment">//电机1的转速控制</span></span><br><span class="line">tPid pid2_speed;<span class="comment">//电机2的转速控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化PID参数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PID_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">pid1_speed.actual_val=<span class="number">0.0</span>;<span class="comment">//初始化电机1转速PID 结构体</span></span><br><span class="line">pid1_speed.target_val=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.err=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.err_last=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.Kp=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.Ki=<span class="number">0.0</span>;</span><br><span class="line">pid1_speed.Kd=<span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">pid2_speed.actual_val=<span class="number">0.0</span>;<span class="comment">//初始化电机2转速PID 结构体</span></span><br><span class="line">pid2_speed.target_val=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.err=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.err_last=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.Kp=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.Ki=<span class="number">0.0</span>;</span><br><span class="line">pid2_speed.Kd=<span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改一下PID函数，这里我们使用结构体作为函数地址</p><p>访问因为是地址，访问结构体变量要用-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">PID_realize</span><span class="params">(tPid * pid,<span class="type">float</span> actual_val)</span></span><br><span class="line">&#123;</span><br><span class="line">pid-&gt;actual_val = actual_val;<span class="comment">//传递真实值</span></span><br><span class="line">pid-&gt;err = pid-&gt;target_val - pid-&gt;actual_val;<span class="comment">//目标值减去实际值等于误差值</span></span><br><span class="line">pid-&gt;err_sum += pid-&gt;err;<span class="comment">//误差累计求和</span></span><br><span class="line"><span class="comment">//使用PID控制</span></span><br><span class="line">pid-&gt;actual_val = pid-&gt;Kp*pid-&gt;err + pid-&gt;Ki*pid-&gt;err_sum + pid-&gt;Kd*(pid-&gt;err - pid-&gt;err_last);</span><br><span class="line"><span class="comment">//保存上次误差:最近一次 赋值给上次</span></span><br><span class="line">pid-&gt;err_last = pid-&gt;err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pid-&gt;actual_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改主函数，对PID函数的使用</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220822143256375.png" alt="image-20220822143256375"></p><p>然后可以分别调节电机1的参数和电机二的参数</p><p>把测试好的PID 参数分别写在PID_init里面</p><h1 id="以上是入门篇"><a href="#以上是入门篇" class="headerlink" title="以上是入门篇"></a>以上是入门篇</h1><p>通过上面的学习与实操，大家对:PWM、电机驱动、PID闭环控制、串口通信等有了一定掌握，如果上面那个章节掌握不好，一定要多看两遍视频，多敲边代码，还有疑惑可以百度查找或者留言问题。</p><p>后面的内容就是偏应用比较简单了。</p><h1 id="下面应用篇"><a href="#下面应用篇" class="headerlink" title="下面应用篇"></a>下面应用篇</h1><h1 id="第10章-小车跑一跑"><a href="#第10章-小车跑一跑" class="headerlink" title="第10章-小车跑一跑"></a>第10章-小车跑一跑</h1><h2 id="如何实现小车的前、后、左、右、停"><a href="#如何实现小车的前、后、左、右、停" class="headerlink" title="如何实现小车的前、后、左、右、停"></a>如何实现小车的前、后、左、右、停</h2><p>控制电机速度就可以控制小车运动</p><p>如何控制电机速度？</p><p>改变小车速度PID的目标值，然后定时器里面的PID控制函数就会计算输占空比然后控制小车。</p><p>代码如下:</p><p>定时器里面有电机控制，我们这里还增加Motor_Set(PID_realize(&amp;pidMotor1Speed,Motor1Speed),PID_realize(&amp;pidMotor2Speed,Motor2Speed));</p><p>是为了提高实时性。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230105131132508.png" alt="image-20230105131132508"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  通过PID控制电机转速</span></span><br><span class="line"><span class="comment">*  @param  Motor1Speed:电机1 目标速度、Motor2Speed:电机2 目标速度</span></span><br><span class="line"><span class="comment">*  @return  无</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">motorPidSetSpeed</span><span class="params">(<span class="type">float</span> Motor1SetSpeed,<span class="type">float</span> Motor2SetSpeed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//改变电机PID参数的目标速度</span></span><br><span class="line">pidMotor1Speed.target_val = Motor1SetSpeed;</span><br><span class="line">pidMotor2Speed.target_val = Motor2SetSpeed;</span><br><span class="line"><span class="comment">//根据PID计算 输出作用于电机</span></span><br><span class="line">Motor_Set(PID_realize(&amp;pidMotor1Speed,Motor1Speed),PID_realize(&amp;pidMotor2Speed,Motor2Speed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易得到一下控制方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//motorPidSetSpeed(1,2);//向右转弯</span></span><br><span class="line"><span class="comment">//motorPidSetSpeed(2,1);//向左转弯</span></span><br><span class="line"><span class="comment">//motorPidSetSpeed(1,1);//前进</span></span><br><span class="line"><span class="comment">//motorPidSetSpeed(-1,-1);//后退</span></span><br><span class="line"><span class="comment">//motorPidSetSpeed(0,0);//停止</span></span><br></pre></td></tr></table></figure><h2 id="向左原地转弯、向原地转弯"><a href="#向左原地转弯、向原地转弯" class="headerlink" title="向左原地转弯、向原地转弯"></a>向左原地转弯、向原地转弯</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230105143208101.png" alt="image-20230105143208101"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//motorPidSetSpeed(-1,1);//右原地旋转</span></span><br><span class="line"><span class="comment">//motorPidSetSpeed(1,-1);//左原地旋转</span></span><br></pre></td></tr></table></figure><h2 id="加速减速函数"><a href="#加速减速函数" class="headerlink" title="加速减速函数"></a>加速减速函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向前加速函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">motorSpeedUp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> MotorSetSpeedUp=<span class="number">0.5</span>;<span class="comment">//静态变量 函数结束 变量不会销毁</span></span><br><span class="line"><span class="keyword">if</span>(MotorSetSpeedUp &lt;= MAX_SPEED_UP) MotorSetSpeedUp +=<span class="number">0.5</span> ;  <span class="comment">//如果没有超过最大值就增加0.5</span></span><br><span class="line">motorPidSetSpeed(MotorSetSpeedUp,MotorSetSpeedUp);<span class="comment">//设置到电机</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向前减速函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">motorSpeedCut</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span>  MotorSetSpeedCut=<span class="number">3</span>;<span class="comment">//静态变量 函数结束 变量不会销毁</span></span><br><span class="line"><span class="keyword">if</span>(MotorSetSpeedCut &gt;=<span class="number">0.5</span>) MotorSetSpeedCut-=<span class="number">0.5</span>;<span class="comment">//判断是否速度太小</span></span><br><span class="line">motorPidSetSpeed(MotorSetSpeedCut,MotorSetSpeedCut);<span class="comment">//设置到电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第11章-OLED速度与历程显示"><a href="#第11章-OLED速度与历程显示" class="headerlink" title="第11章-OLED速度与历程显示"></a>第11章-OLED速度与历程显示</h1><p>这节我们显示两轮速度和里程</p><p>两轮速度很简单 之前已经计算过，那么如何计算里程那？</p><p>里程:小车行驶的路程长度。</p><p>这里我们只要计算出每个单位时间小车行驶的长度然后一直相加，就是这一段时间行驶的总里程长度了。</p><p>我们20ms计算一次,20ms走过了多少距离，然后一直相加，就是走的总距离，就是里程。这里我们使用使用电机1 车轮1进行计算。你也可以电机1 和电机2相加然后除2。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230105235911920.png" alt="image-20230105235911920"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230105221819413.png" alt="image-20230105221819413"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*里程数(cm) += 时间周期（s）*车轮转速(转/s)*车轮周长(cm)*/</span></span><br><span class="line">Mileage += <span class="number">0.02</span>*Motor1Speed*<span class="number">22</span>;</span><br></pre></td></tr></table></figure><p>然后主函数我们通过OLED显示电机速度和小车里程</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230105234102312.png" alt="image-20230105234102312"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot;V1:%.2fV2:%.2f&quot;</span>, Motor1Speed,Motor2Speed);<span class="comment">//显示两个电机的速度</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">0</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot;Mileage:%.2f   &quot;</span>,Mileage);<span class="comment">//显示里程数</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">1</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数</span></span><br></pre></td></tr></table></figure><h1 id="第12章-ADC采集电压和显示"><a href="#第12章-ADC采集电压和显示" class="headerlink" title="第12章-ADC采集电压和显示"></a>第12章-ADC采集电压和显示</h1><p><strong>什么是ADC</strong></p><p>百度百科介绍：</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108210407873.png" alt="image-20221108210407873"></p><p>我们知道万用表 电压表可以测量电池，或者电路电压。那么我们是否可以通过单片机获得电压，方便我 们监控电池状态</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108210425866.png" alt="image-20221108210425866" style="zoom: 33%;" /></p><p>如何测量我们的锂电池电压那？锂电池电压12V左右，单片机ADC最大测量电压3.3V，这里我们需要分 压电路分压。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108211039622.png" alt="image-20221108211039622"></p><p>然后我们通过电阻分压，显而易见 ADC点的电压是VBAT_IN的 五分之一</p><ol><li>软件初始化一下ADC 。</li><li>然后注意调长一点采样时间、这样精度才会更高一点。</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221109232125714.png" alt="image-20221109232125714"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108213505630.png" alt="image-20221108213505630"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108213614198.png" alt="image-20221108213614198"></p><p>在adc.c文件添加ADC相关函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230106230750593.png" alt="image-20230106230750593"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  电池电压测量计算函数</span></span><br><span class="line"><span class="comment">*  @param  无</span></span><br><span class="line"><span class="comment">*  @return 小车电池电压</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">adcGetBatteryVoltage</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_ADC_Start(&amp;hadc2);<span class="comment">//启动ADC转化</span></span><br><span class="line"><span class="keyword">if</span>(HAL_OK == HAL_ADC_PollForConversion(&amp;hadc2,<span class="number">50</span>))<span class="comment">//等待转化完成、超时时间50ms</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">float</span>)HAL_ADC_GetValue(&amp;hadc2)/<span class="number">4096</span>*<span class="number">3.3</span>*<span class="number">5</span>;<span class="comment">//计算电池电压</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main中调用显示函数显示电压</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230106230924860.png" alt="image-20230106230924860"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)OledString, <span class="string">&quot;U:%.2fV&quot;</span>, adcGetBatteryVoltage());</span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">2</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br></pre></td></tr></table></figure><h1 id="第13章-循迹功能"><a href="#第13章-循迹功能" class="headerlink" title="第13章-循迹功能"></a>第13章-循迹功能</h1><h2 id="13-1-非PID循迹功能完成"><a href="#13-1-非PID循迹功能完成" class="headerlink" title="13.1-非PID循迹功能完成"></a>13.1-非PID循迹功能完成</h2><h3 id="先红外对管调试"><a href="#先红外对管调试" class="headerlink" title="先红外对管调试"></a>先红外对管调试</h3><p>我们这里学习一下，如何实现循迹功能</p><p>如何才能让小车沿着黑线运动、要让小车感知到黑线的位置，使用这种传感器就可以反馈黑线是否存在</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221110222632542.png" alt="image-20221110222632542" style="zoom: 80%;" /></p><p>根据传感器特性，我们检测红外对管DO引脚的电压就可以知道，下面有没有黑线</p><p><strong>DO 高电平-&gt;有黑线 小灯灭</strong></p><p><strong>DO低电平-&gt;没有黑线 小灯亮</strong></p><p>这是好多地方对这个产品的说明</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221110153310630.png" alt="image-20221110153310630" style="zoom: 33%;" /></p><p>然后我们组合上面的红外对管，安装到小车上，就可以知道小车是否偏离了黑线，</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107012917946.png" alt="image-20230107012917946"></p><p>下面我们通过单片机读取红外对管DO口的电压，就知道黑线在小车下面的位置了</p><p> <strong>STM32初始化</strong></p><p>先看原理图需要初始化那些引脚</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221110224613242.png" alt="image-20221110224613242" style="zoom:67%;" /></p><p>把<strong>OUT_1-PA5、OUT_2-PA7、OUT_3-PB0、OUT_4-PB1</strong>初始化为输入模式</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221110230859290.png" alt="image-20221110230859290"></p><p>重新生成</p><p>然后我们在gpio.h 添加读取GPIO的宏，使得程序更简洁</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221110232405800.png" alt="image-20221110232405800"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> READ_HW_OUT_1   HAL_GPIO_ReadPin(HW_OUT_1_GPIO_Port,HW_OUT_1_Pin) <span class="comment">//读取红外对管连接的GPIO电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_HW_OUT_2   HAL_GPIO_ReadPin(HW_OUT_2_GPIO_Port,HW_OUT_2_Pin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_HW_OUT_3   HAL_GPIO_ReadPin(HW_OUT_3_GPIO_Port,HW_OUT_3_Pin)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_HW_OUT_4   HAL_GPIO_ReadPin(HW_OUT_4_GPIO_Port,HW_OUT_4_Pin)</span></span><br></pre></td></tr></table></figure><p>根据红外对管状态控制电机速度</p><p>注意：整个主函数不要加入延时，这样实时性更高，可以根据红外对管状态做出及时控制</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107165249367.png" alt="image-20230107165249367"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(READ_HW_OUT_1 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_2 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_3 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_4 == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应该前进\r\n&quot;</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(READ_HW_OUT_1 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_2 == <span class="number">1</span>&amp;&amp;READ_HW_OUT_3 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_4 == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应该右转\r\n&quot;</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">0.5</span>,<span class="number">2</span>);<span class="comment">//右边运动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(READ_HW_OUT_1 == <span class="number">1</span>&amp;&amp;READ_HW_OUT_2 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_3 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_4 == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;快速右转\r\n&quot;</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">0.5</span>,<span class="number">2.5</span>);<span class="comment">//快速右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(READ_HW_OUT_1 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_2 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_3 == <span class="number">1</span>&amp;&amp;READ_HW_OUT_4 == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;应该左转\r\n&quot;</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">2</span>,<span class="number">0.5</span>);<span class="comment">//左边运动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(READ_HW_OUT_1 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_2 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_3 == <span class="number">0</span>&amp;&amp;READ_HW_OUT_4 == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;快速左转\r\n&quot;</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">2.5</span>,<span class="number">0.5</span>);<span class="comment">//快速左转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后测试</p><ol><li>测试红外对管灵敏度，放在有黑线的地上或者纸上，然后把小车黑线比如放到最右边 及第一个红外对管，观察红外对管小灯变化情况和串口输出情况，如果小灯没有灭，就调节红外对管灵敏度和室内灯光，直到每个红外对管都可以感应到小灯。</li><li>然后在黑线上让小车循迹</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107152753253.png" alt="image-20230107152753253"></p><h3 id="然后循迹功能完成"><a href="#然后循迹功能完成" class="headerlink" title="然后循迹功能完成"></a>然后循迹功能完成</h3><p>然后放到地上</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107185627568.png" alt="image-20230107185627568"></p><h2 id="13-2-加入循迹PID"><a href="#13-2-加入循迹PID" class="headerlink" title="13.2-加入循迹PID"></a>13.2-加入循迹PID</h2><p>前面的代码我们对循迹是判断的几个状态，然后PID控制电机不同速度，但是我们可以使用红外对管状态作为PID控制的输入然后再控制电机。</p><p>PID的输入是红外对管状态，我们设计 PID输入是红外对管的状态、然后输出一个速度值，然后左右电机去加或者减这个值，就可以完成根据红外对管输入对电机的差速控制</p><p>主函数添加的</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107210726187.png" alt="image-20230107210726187"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> tPid pidHW_Tracking;<span class="comment">//红外循迹的PID</span></span><br><span class="line"><span class="type">uint8_t</span> g_ucaHW_Read[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//保存红外对管电平的数组</span></span><br><span class="line"><span class="type">int8_t</span> g_cThisState = <span class="number">0</span>;<span class="comment">//这次状态</span></span><br><span class="line"><span class="type">int8_t</span> g_cLastState = <span class="number">0</span>; <span class="comment">//上次状态</span></span><br><span class="line"><span class="type">float</span> g_fHW_PID_Out;<span class="comment">//红外对管PID计算输出速度</span></span><br><span class="line"><span class="type">float</span> g_fHW_PID_Out1;<span class="comment">//电机1的最后循迹PID控制速度</span></span><br><span class="line"><span class="type">float</span> g_fHW_PID_Out2;<span class="comment">//电机2的最后循迹PID控制速度</span></span><br></pre></td></tr></table></figure><p>然后实现PID循迹控制、注意为了更加快，要减少没有必要的程序和优化判断、将没有必要的输出都注释掉</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107210854550.png" alt="image-20230107210854550"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">g_ucaHW_Read[<span class="number">0</span>] = READ_HW_OUT_1;<span class="comment">//读取红外对管状态、这样相比于写在if里面更高效</span></span><br><span class="line">g_ucaHW_Read[<span class="number">1</span>] = READ_HW_OUT_2;</span><br><span class="line">g_ucaHW_Read[<span class="number">2</span>] = READ_HW_OUT_3;</span><br><span class="line">g_ucaHW_Read[<span class="number">3</span>] = READ_HW_OUT_4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该前进\r\n&quot;);//注释掉更加高效，减少无必要程序执行</span></span><br><span class="line">g_cThisState = <span class="number">0</span>;<span class="comment">//前进</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )<span class="comment">//使用else if更加合理高效</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-1</span>;<span class="comment">//应该右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-2</span>;<span class="comment">//快速右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-3</span>;<span class="comment">//快速右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">1</span>;<span class="comment">//应该左转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">2</span>;<span class="comment">//快速左转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    printf(&quot;快速左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">3</span>;<span class="comment">//快速左转</span></span><br><span class="line">&#125;</span><br><span class="line">g_fHW_PID_Out = PID_realize(&amp;pidHW_Tracking,g_cThisState);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"></span><br><span class="line">g_fHW_PID_Out1 = <span class="number">3</span> + g_fHW_PID_Out;<span class="comment">//电机1速度=基础速度+循迹PID输出速度</span></span><br><span class="line">g_fHW_PID_Out2 = <span class="number">3</span> - g_fHW_PID_Out;<span class="comment">//电机1速度=基础速度-循迹PID输出速度</span></span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out1 &gt;<span class="number">5</span>) g_fHW_PID_Out1 =<span class="number">5</span>;<span class="comment">//进行限幅 限幅速度在0-5之间</span></span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out1 &lt;<span class="number">0</span>) g_fHW_PID_Out1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out2 &gt;<span class="number">5</span>) g_fHW_PID_Out2 =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out2 &lt;<span class="number">0</span>) g_fHW_PID_Out2 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_cThisState != g_cLastState)<span class="comment">//如何这次状态不等于上次状态、就进行改变目标速度和控制电机、在定时器中依旧定时控制电机</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(g_fHW_PID_Out1,g_fHW_PID_Out2);<span class="comment">//通过计算的速度控制电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_cLastState = g_cThisState;<span class="comment">//保存上次红外对管状态</span></span><br></pre></td></tr></table></figure><p>在pid.中</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107211037921.png" alt="image-20230107211037921"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tPid pidHW_Tracking;<span class="comment">//红外循迹的PID</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230107211104780.png" alt="image-20230107211104780"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pidHW_Tracking.actual_val=<span class="number">0.0</span>;</span><br><span class="line">pidHW_Tracking.target_val=<span class="number">0.00</span>;<span class="comment">//红外循迹PID 的目标值为0</span></span><br><span class="line">pidHW_Tracking.err=<span class="number">0.0</span>;</span><br><span class="line">pidHW_Tracking.err_last=<span class="number">0.0</span>;</span><br><span class="line">pidHW_Tracking.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pidHW_Tracking.Kp=<span class="number">-1.50</span>;</span><br><span class="line">pidHW_Tracking.Ki=<span class="number">0</span>;</span><br><span class="line">pidHW_Tracking.Kd=<span class="number">0.80</span>;</span><br></pre></td></tr></table></figure><p>然后就可以跑一下试试了。</p><p>可以改进的地方</p><ol><li>红外对管影响差速转向，也影响基础直行的速度 ，会有更好控制效果，所以可以加入每种红外对管状态下对基础速度的影响。</li><li>红外对管的数量越多，效果会越好。</li></ol><h1 id="第14章-手机遥控功能"><a href="#第14章-手机遥控功能" class="headerlink" title="第14章-手机遥控功能"></a>第14章-手机遥控功能</h1><p>我们要实现蓝牙遥控功能，蓝牙遥控功能要使用:1.单片机的串口、2.蓝牙通信模块</p><p>所以我们先调试好:单片机的串口-&gt;蓝牙模块-&gt;接到一起联调</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108094941496.png" alt="image-20230108094941496"></p><h2 id="14-1-电脑控制小车"><a href="#14-1-电脑控制小车" class="headerlink" title="14.1-电脑控制小车"></a>14.1-电脑控制小车</h2><p>完成功能:电脑连接单片机串口三 控制小车前进后退</p><p><strong>先看原理图</strong></p><p>通过原理图可以看出这是使用的串口3 在使用的时候注意把跳线帽，跳线到蓝牙通信位置</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221113145542144.png" alt="image-20221113145542144"></p><p>打开初始化软件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221113161440641.png" alt="image-20221113161440641"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221113162259965.png" alt="image-20221113162259965"></p><p>生成代码</p><p>在main 定义全局变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> g_ucUsart3ReceiveData;  <span class="comment">//保存串口三接收的数据</span></span><br></pre></td></tr></table></figure><p>开启串口三中断接收</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108011852886.png" alt="image-20230108011852886"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HAL_UART_Receive_IT(&amp;huart3,&amp;g_ucUsart3ReceiveData,<span class="number">1</span>);  <span class="comment">//串口三接收数据</span></span><br></pre></td></tr></table></figure><p>在<strong>usart.c</strong> 重新实现串口中断回调函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221113163755469.png" alt="image-20221113163755469"></p><p>然后我们可以在中断回调函数里面中编写遥控命令控制逻辑了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108021416560.png" alt="image-20230108021416560"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串口接收回调函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( huart == &amp;huart3)<span class="comment">//判断中断源</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;A&#x27;</span>) motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;B&#x27;</span>) motorPidSetSpeed(<span class="number">-1</span>,<span class="number">-1</span>);<span class="comment">//后运动</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;C&#x27;</span>) motorPidSetSpeed(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//停止</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;D&#x27;</span>) motorPidSetSpeed(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//右边运动</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;E&#x27;</span>) motorPidSetSpeed(<span class="number">2</span>,<span class="number">1</span>);<span class="comment">//左边运动</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;F&#x27;</span>) motorPidSpeedUp();<span class="comment">//加速</span></span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;G&#x27;</span>) motorPidSpeedCut();<span class="comment">//减速</span></span><br><span class="line"></span><br><span class="line">HAL_UART_Receive_IT( &amp;huart3, &amp;g_ucUsart3ReceiveData, <span class="number">1</span>);<span class="comment">//继续进行中断接收</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在usart.c中声明外部变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> g_ucUsart3ReceiveData;  <span class="comment">//保存串口三接收的数据</span></span><br></pre></td></tr></table></figure><p>然后我们更改一下 主函数内容，把PID红外循迹代码注释掉，然后我们增加串口三的输出，以便我们后面观察数据。</p><p><strong>串口不定长输出</strong></p><p>我们把转速等信息都可以显示在OLED上，那么如何通过串口输出那？</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108115259681.png" alt="image-20230108115259681"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;V1:%.2fV2:%.2f\r\n&quot;</span>,Motor1Speed,Motor2Speed);<span class="comment">//显示两个电机转速 单位：转/秒</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;Mileage%.2f\r\n&quot;</span>,Mileage);<span class="comment">//计算小车里程 单位cm</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;U:%.2fV\r\n&quot;</span>,adcGetBatteryVoltage());<span class="comment">//显示电池电压</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line">HAL_Delay(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>把之前PID初始化时候速度PID目标值改成0</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108113408329.png" alt="image-20230108113408329"></p><p><strong>然后我们测试</strong></p><p><strong>硬件连接</strong></p><p>我们现在使用USB-TTL连接串口三，单片机串口三与电脑通信(<strong>底板不需要插入蓝牙</strong>)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108121744588.png" alt="image-20230108121744588"></p><p> 然后打开软件</p><p>发送指令小车就会对应运动</p><p>在电脑串口软件查看输出信息、发送 指令控制小车运动</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108115952589.png" alt="image-20230108115952589"></p><h2 id="14-2-手机蓝牙控制小车"><a href="#14-2-手机蓝牙控制小车" class="headerlink" title="14.2-手机蓝牙控制小车"></a>14.2-手机蓝牙控制小车</h2><p>功能:蓝牙遥控小车前进、后退、停止、左右转、加速、减速、手机显示数据</p><h3 id="蓝牙模块和电脑通信"><a href="#蓝牙模块和电脑通信" class="headerlink" title="蓝牙模块和电脑通信"></a>蓝牙模块和电脑通信</h3><p><strong>蓝牙模块-硬件介绍</strong></p><p>使用：HC-05 主从机一体蓝牙串口透传模块 </p><p>注意： 供电3.6V-6V(最好5V)</p><p>引脚顺序 VCC GND TXD RXD</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114115307410.png" alt="image-20221114115307410"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114115640083.png" alt="image-20221114115640083"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114115333609.png" alt="image-20221114115333609"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114115624973.png" alt="image-20221114115624973"></p><p><strong>先调试蓝牙模块-设置波特率</strong></p><p>如图先把蓝牙模块通过USB-TTL模块相连接，然后</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108124818109.png" alt="image-20230108124818109"></p><p>如果反复测试不能进入AT模式，可能是新版蓝牙模块，</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108140057987.png" alt="image-20230108140057987"></p><ol><li><p>先连接好蓝牙模块的几根线，然后按住蓝牙模块的按键</p></li><li><p>然后连接电脑，然后几秒后蓝牙小灯慢闪，说明进入AT模式</p></li><li><p>然后串口助手通过38400发送设置指令:AT+UART=115200,0,0</p></li><li><p>然后收到OK数据，说明设置成功。</p></li></ol><p>这个是设置波特率截图</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114120715660.png" alt="image-20221114120715660"></p><ol><li><p>然后重新拔插蓝牙模块(不用按按键)</p></li><li><p>在手机系统蓝牙配对HC-50 密码1234</p></li><li><p>串口助手设置波特率115200，然后打开手机APP发送任意内容测试</p></li></ol><p>这个是后面通信测试截图</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114125011810.png" alt="image-20221114125011810"></p><ol><li>设置按键-按照代码设置按下发送的数据</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108125417623.png" alt="image-20230108125417623"></p><h3 id="蓝牙模块连接单片机"><a href="#蓝牙模块连接单片机" class="headerlink" title="蓝牙模块连接单片机"></a>蓝牙模块连接单片机</h3><p>把蓝牙插入到底板、跳线帽选择蓝牙通信</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114131242210.png" alt="image-20221114131242210"></p><p>按下不同按钮小车会对应控制</p><h1 id="第A章-定位程序异常位置"><a href="#第A章-定位程序异常位置" class="headerlink" title="第A章-定位程序异常位置"></a>第A章-定位程序异常位置</h1><p>参考连接:<a href="https://blog.csdn.net/supermuscleman/article/details/103929606">https://blog.csdn.net/supermuscleman/article/details/103929606</a></p><p>程序功能多 代码较多、可能会出现一些异常，如何锁定程序异常位置非常重要</p><ol><li><p>进入硬件调试-点击全速运行</p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173624343.png" alt="image-20221116173624343"></p><p> 通过LR的值确定当前堆栈使用的PSP或者MSP</p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173713147.png" alt="image-20221116173713147"></p><p> 然后在memory中定位到堆栈地址、然后就找到LR=08000F2D、PC=08000A02</p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173741022.png" alt="image-20221116173741022"></p><p> <strong>Disassembly中,查找定位代码</strong></p><p> 在反汇编窗口中点击右键，选中show disassembly at address 。</p><p> 输入LR地址：为发生异常后调用的下一条指令的地址，可看到发生异常的为</p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173813090.png" alt="image-20221116173813090"></p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173845927.png" alt="image-20221116173845927"></p><p>  输入PC地址：可以定位到发生异常的调用语句</p><p> <img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116173915126.png" alt="image-20221116173915126"></p></li></ol><p>然后我们通过上面的方法就找到了异常位置</p><h1 id="第15章-超声波避障功能"><a href="#第15章-超声波避障功能" class="headerlink" title="第15章-超声波避障功能"></a>第15章-超声波避障功能</h1><h2 id="15-1-超声波测距"><a href="#15-1-超声波测距" class="headerlink" title="15.1-超声波测距"></a>15.1-超声波测距</h2><p>完成超声波测距功能、测量数据显示在OLED屏幕上</p><p><strong>硬件介绍</strong></p><p>使用：HC-SR04 超声波测距模块 </p><p>注意： 绘制PCB注意四个引脚顺序 Vcc Trig Echo Gnd</p><p> 供电3.3V-5V(最好5V)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114164857506.png" alt="image-20221114164857506" style="zoom:50%;" /></p><p>测距原理</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114164920111.png" alt="image-20221114164920111" style="zoom:50%;" /></p><p>不同模式</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114164940804.png" alt="image-20221114164940804" style="zoom:50%;" /></p><p>GPIO模式</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114165014422.png" alt="image-20221114165014422" style="zoom: 67%;" /></p><p> <strong>查看原理图</strong></p><p>通过超声波的硬件介绍我们知道</p><p> MCU给Trig脚一个大于10us的高电平脉冲；然后读取Echo脚的高电平信号时间，通过公式：距离 = T* 声速/2 就可以算出来距离。</p><p>Trig(PB5)我们配置为GPIO输出</p><p>Echo(PA6)我们配置GPIO输入功能</p><p><strong>注：这里大家可能会问，为什么不使用定时器捕获功能？</strong></p><p><strong>原因:</strong></p><ol><li>留一个定时器 方便以后扩展FreeRTOS使用</li><li>或者扩展其他舵机、电机等</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114165508600.png" alt="image-20221114165508600"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108171955643.png" alt="image-20230108171955643" style="zoom: 67%;" /></p><p><strong>软件初始化</strong></p><p>设置PB5输出模式然后起别名</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114195822786.png" alt="image-20221114195822786"></p><p>设置PA6输入模式、</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221114195850027.png" alt="image-20221114195850027"></p><p>然后生成代码</p><p>自己新建HC_SR04.c和HC_SR04.h 然后加入工程，指定路径</p><p>防止溢出 把之前使用的数组调整大一些</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108180914033.png" alt="image-20230108180914033"></p><p>因为我们不适用定时器所以我们需要自己写一个us级延时函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221115164450164.png" alt="image-20221115164450164"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  us级延时</span></span><br><span class="line"><span class="comment">*  @param  usdelay:要延时的us时间</span></span><br><span class="line"><span class="comment">*  @return  </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HC_SR04_Delayus</span><span class="params">(<span class="type">uint32_t</span> usdelay)</span></span><br><span class="line">&#123;</span><br><span class="line">  __IO <span class="type">uint32_t</span> Delay = usdelay * (SystemCoreClock / <span class="number">8U</span> / <span class="number">1000U</span>/<span class="number">1000</span>);<span class="comment">//SystemCoreClock:系统频率</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    __NOP();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (Delay --);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221115165416779.png" alt="image-20221115165416779"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************</span></span><br><span class="line"><span class="comment">*  @brief  HC_SR04读取超声波距离</span></span><br><span class="line"><span class="comment">*  @param  无</span></span><br><span class="line"><span class="comment">*  @return 障碍物距离单位:cm (静止表面平整精度更高) </span></span><br><span class="line"><span class="comment">*注意:两个HC_SR04_Read()函数调用的时间间隔要2ms及以上，测量范围更大 精度更高 </span></span><br><span class="line"><span class="comment">*******************/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">HC_SR04_Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> Distance;</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_SET);<span class="comment">//输出15us高电平</span></span><br><span class="line">HC_SR04_Delayus(<span class="number">15</span>);</span><br><span class="line">HAL_GPIO_WritePin(HC_SR04_Trig_GPIO_Port,HC_SR04_Trig_Pin,GPIO_PIN_RESET);<span class="comment">//高电平输出结束，设置为低电平</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin) == GPIO_PIN_RESET)<span class="comment">//等待回响高电平</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">HC_SR04_Delayus(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">100000</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//超时退出循环、防止程序卡死这里</span></span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(HAL_GPIO_ReadPin(HC_SR04_Echo_GPIO_Port,HC_SR04_Echo_Pin) == GPIO_PIN_SET)<span class="comment">//下面的循环是2us</span></span><br><span class="line">&#123;</span><br><span class="line">i = i+<span class="number">1</span>;</span><br><span class="line">HC_SR04_Delayus(<span class="number">1</span>);<span class="comment">//1us 延时，但是整个循环大概2us左右</span></span><br><span class="line"><span class="keyword">if</span>(i &gt;<span class="number">100000</span>) <span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//超时退出循环</span></span><br><span class="line">&#125;</span><br><span class="line">Distance = i*<span class="number">2</span>*<span class="number">0.033</span>/<span class="number">2</span>;<span class="comment">//这里乘2的原因是上面是2微妙</span></span><br><span class="line"><span class="keyword">return</span> Distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以读距离了、连上蓝牙可以显示数据</p><p><strong>注意:两个HC_SR04_Read()函数调用的时间间隔要2ms及以上，测量范围更大 精度更高</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108182646710.png" alt="image-20230108182646710"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;HC_SR04:%.2fcm\r\n&quot;</span>,HC_SR04_Read());<span class="comment">//显示超声波数据</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">0xFFFF</span>);<span class="comment">//通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后把我们的手机蓝牙和小车蓝牙连接</p><p>手机显示</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230108182544348.png" alt="image-20230108182544348" style="zoom:33%;" /></p><h2 id="15-2-避障逻辑编写"><a href="#15-2-避障逻辑编写" class="headerlink" title="15.2-避障逻辑编写"></a>15.2-避障逻辑编写</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203220125504.png" alt="image-20221203220125504" style="zoom: 67%;" /></p><p>然后我们编写循迹逻辑，我们的逻辑时</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109001446486.png" alt="image-20230109001446486"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**************避障功能********************//</span></span><br><span class="line"><span class="comment">//避障逻辑</span></span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt; <span class="number">25</span>)<span class="comment">//前方无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//前方有障碍物</span></span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//右边运动 原地</span></span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt; <span class="number">25</span>)<span class="comment">//右边无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//右边有障碍物</span></span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//左边运动 原地</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt;<span class="number">25</span>)<span class="comment">//左边无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line"> motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">-1</span>);<span class="comment">//后运动</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//右边运动</span></span><br><span class="line">HAL_Delay(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第16章-超声波跟随功能"><a href="#第16章-超声波跟随功能" class="headerlink" title="第16章-超声波跟随功能"></a>第16章-超声波跟随功能</h1><h2 id="无PID跟随功能"><a href="#无PID跟随功能" class="headerlink" title="无PID跟随功能"></a>无PID跟随功能</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203220330848.png" alt="image-20221203220330848"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109013951233.png" alt="image-20230109013951233"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超声波跟随</span></span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt; <span class="number">25</span>)</span><br><span class="line">&#123;</span><br><span class="line">motorForward();<span class="comment">//前进</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &lt; <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">motorBackward();<span class="comment">//后退</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PID跟随功能"><a href="#PID跟随功能" class="headerlink" title="PID跟随功能"></a>PID跟随功能</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111101326946.png" alt="image-20230111101326946"></p><p>在pid.c中定义一组PID参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tPid pidFollow;    <span class="comment">//定距离跟随PID</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pidFollow.actual_val=<span class="number">0.0</span>;</span><br><span class="line">pidFollow.target_val=<span class="number">22.50</span>;<span class="comment">//定距离跟随 目标距离22.5cm</span></span><br><span class="line">pidFollow.err=<span class="number">0.0</span>;</span><br><span class="line">pidFollow.err_last=<span class="number">0.0</span>;</span><br><span class="line">pidFollow.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pidFollow.Kp=<span class="number">-0.5</span>;<span class="comment">//定距离跟随的Kp大小通过估算PID输入输出数据，确定大概大小，然后在调试</span></span><br><span class="line">pidFollow.Ki=<span class="number">-0.001</span>;<span class="comment">//Ki小一些</span></span><br><span class="line">pidFollow.Kd=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109141345691.png" alt="image-20230109141345691"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**********PID跟随功能***********//</span></span><br><span class="line">    g_fHC_SR04_Read=HC_SR04_Read();<span class="comment">//读取前方障碍物距离</span></span><br><span class="line"><span class="keyword">if</span>(g_fHC_SR04_Read &lt; <span class="number">60</span>)&#123;  <span class="comment">//如果前60cm 有东西就启动跟随</span></span><br><span class="line">g_fFollow_PID_Out = PID_realize(&amp;pidFollow,g_fHC_SR04_Read);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"><span class="keyword">if</span>(g_fFollow_PID_Out &gt; <span class="number">6</span>) g_fFollow_PID_Out = <span class="number">6</span>;<span class="comment">//对输出速度限幅</span></span><br><span class="line"><span class="keyword">if</span>(g_fFollow_PID_Out &lt; <span class="number">-6</span>) g_fFollow_PID_Out = <span class="number">-6</span>;</span><br><span class="line">motorPidSetSpeed(g_fFollow_PID_Out,g_fFollow_PID_Out);<span class="comment">//速度作用与电机上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> motorPidSetSpeed(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//如果前面60cm 没有东西就停止</span></span><br><span class="line">HAL_Delay(<span class="number">10</span>);<span class="comment">//读取超声波传感器不能过快</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109141645038.png" alt="image-20230109141645038"></p><p>然后编译，烧录测试 。</p><h1 id="第17章-用6050走直线和转90度功能"><a href="#第17章-用6050走直线和转90度功能" class="headerlink" title="第17章-用6050走直线和转90度功能"></a>第17章-用6050走直线和转90度功能</h1><h2 id="17-1-6050姿态数据读取"><a href="#17-1-6050姿态数据读取" class="headerlink" title="17.1-6050姿态数据读取"></a>17.1-6050姿态数据读取</h2><h3 id="STM32读取6050数据"><a href="#STM32读取6050数据" class="headerlink" title="STM32读取6050数据"></a>STM32读取6050数据</h3><p>先把我们的参考历程里面的6050文件复制过去</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109185706496.png" alt="image-20230109185706496"></p><p>添加文件</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116231529074.png" alt="image-20221116231529074"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117170521769.png" alt="image-20221117170521769"></p><p>然后在魔术棒添加上面两个的路径，不再截图了。</p><p>简单阅读代码，知道 我们需要设置两个引脚，这两个引脚使用模拟IIC读取6050数据</p><p>1.在<strong>mpuiic.c</strong>延时使用自己写的、引脚需要使用两个先设置推挽输出、高电平</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116232049948.png" alt="image-20221116232049948"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mpuiic_Delayus</span><span class="params">(<span class="type">uint32_t</span> usdelay)</span></span><br><span class="line">&#123;</span><br><span class="line">  __IO <span class="type">uint32_t</span> Delay = usdelay * (SystemCoreClock /<span class="number">8U</span>/<span class="number">1000U</span>/<span class="number">1000</span>);<span class="comment">//SystemCoreClock:系统频率</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    __NOP();<span class="comment">//使用空指令延时、移植不同单片机注意__NOP(); 执行时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (Delay --);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//MPU IIC 延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU_IIC_Delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">mpuiic_Delayus(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化IIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU_IIC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;     </span><br><span class="line"><span class="comment">//  GPIO_InitTypeDef  GPIO_InitStructure;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//先使能外设IO PORTB时钟 </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_11; // 端口配置</span></span><br><span class="line"><span class="comment">//  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  //推挽输出</span></span><br><span class="line"><span class="comment">//  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz</span></span><br><span class="line"><span class="comment">//  GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //根据设定参数初始化GPIO </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  GPIO_SetBits(GPIOB,GPIO_Pin_10|GPIO_Pin_11); //PB10,PB11 输出高</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用软件初始化两个引脚</p><p><strong>6050_SDA—PB9</strong></p><p><strong>6050_SCL—PB8</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116232525601.png" alt="image-20221116232525601" style="zoom: 67%;" /></p><p><strong>PB8-输出模式-起始输出高电平</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117172343943.png" alt="image-20221117172343943"></p><p><strong>PB9 输出模式 起始状态高电平</strong></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117172405281.png" alt="image-20221117172405281"></p><p>生成代码</p><p><strong>打开我们的代码，是通过模拟IIC 读取6050数据的，我们知道SDA是模拟IIC的数据线 所以通信过程中是再输入和输出模式中切换的，但是我们的STM32CubeMX是设置的输出，是在哪里更改的模式那？</strong></p><p><strong>是通过寄存器设置的，在mpuiic.h可以看到</strong></p><p>删除掉#include “sys.h”</p><p>把这个修改了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116233155491.png" alt="image-20221116233155491"></p><p>2.在<strong>mpuiic.h</strong>更改相内容</p><p>改成下面这样的</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109224033045.png" alt="image-20230109224033045"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IO方向设置 设置SDA-PB9为输入或者输出</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_SDA_IN()  &#123;GPIOB-&gt;CRH&amp;=0XFFFFFF0F;GPIOB-&gt;CRH|=8&lt;&lt;4;&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_SDA_OUT() &#123;GPIOB-&gt;CRH&amp;=0XFFFFFF0F;GPIOB-&gt;CRH|=3&lt;&lt;4;&#125;</span></span><br></pre></td></tr></table></figure><ol><li><p>这是通过<strong>按位与后赋值 &amp;=</strong> 和 <strong>按位或后赋值 |=</strong> </p></li><li><p>设置<strong>端口配置高寄存器</strong>指定位。</p></li></ol><p>先看一个例子</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110094443036.png" alt="image-20230110094443036"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110000816677.png" alt="image-20230110000816677"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117133006922.png" alt="image-20221117133006922"></p><p>更改设置SDA与SCL电平的宏</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117143405668.png" alt="image-20221117143405668"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IO操作函数 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_IIC_SCL_Hige    HAL_GPIO_WritePin(SCL_6050_GPIO_Port,SCL_6050_Pin,GPIO_PIN_SET)<span class="comment">//设置SCL高电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_IIC_SCL_Low      HAL_GPIO_WritePin(SCL_6050_GPIO_Port,SCL_6050_Pin,GPIO_PIN_RESET)<span class="comment">//设置SCL低电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_IIC_SDA_Hige        HAL_GPIO_WritePin(SDA_6050_GPIO_Port,SDA_6050_Pin,GPIO_PIN_SET)   <span class="comment">//设置SDA高电平</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_IIC_SDA_Low         HAL_GPIO_WritePin(SDA_6050_GPIO_Port,SDA_6050_Pin,GPIO_PIN_RESET) <span class="comment">//设置SDA低电平</span></span></span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU_READ_SDA            HAL_GPIO_ReadPin(SDA_6050_GPIO_Port,SDA_6050_Pin)    <span class="comment">//读SDA电平</span></span></span><br></pre></td></tr></table></figure><p><strong>更改一下 mupiic.c文件</strong>  </p><p>把</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把之前的MPU_IIC_SDA=1; 换成 MPU_IIC_SDA_Hige;</span></span><br><span class="line"><span class="comment">//MPU_IIC_SDA=0; 换成 MPU_IIC_SDA_Low;</span></span><br><span class="line"><span class="comment">//MPU_IIC_SCL=1;  换成 MPU_IIC_SCL_Hige;</span></span><br><span class="line"><span class="comment">//MPU_IIC_SCL=0;  换成 MPU_IIC_SCL_Low;</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>编译一下、删掉没有用的文件</p><p>把u8 替换为uint8_t</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117144658042.png" alt="image-20221117144658042"></p><p>t替换一下，u8 替换为uint8_t  u32替换为uint32_t </p><p>可以一个文件一个文件的替换掉，如果整个工程替换其他HAL库文件内容也可能改变了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117144918696.png" alt="image-20221117144918696"></p><p>删除多余的库文件</p><p>注释掉</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117164409292.png" alt="image-20221117164409292"></p><p><strong>如果有其他的delay_ms 都替换为HAL_Delay</strong></p><p>还有一个错误</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>) MPU_IIC_SDA_Hige;</span><br><span class="line"><span class="keyword">else</span> MPU_IIC_SDA_Low;</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117164701076.png" alt="image-20221117164701076"></p><p>编译一下 、没有错误和警告</p><p>然后在main.c中定义变量和添加同文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pitch,roll,yaw; <span class="comment">// 俯仰角 横滚角 航向角</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mpu6050.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inv_mpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inv_mpu_dmp_motion_driver.h&quot;</span> </span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117165511717.png" alt="image-20221117165511717"></p><p>替换inv_mpu.h的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f1xx_it.h&quot;</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117165920050.png" alt="image-20221117165920050"></p><p>初始化6050</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HAL_Delay(<span class="number">500</span>);<span class="comment">//延时0.5秒 6050上电稳定后初始化</span></span><br><span class="line">MPU_Init(); <span class="comment">//初始化MPU6050</span></span><br><span class="line"><span class="keyword">while</span>(MPU_Init()!=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(mpu_dmp_init()!=<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109213955121.png" alt="image-20230109213955121"></p><p>我们通过下面的代码获得数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;pitch:%.2f roll:%.2f yaw:%.2f\r\n&quot;</span>,pitch,roll,yaw);<span class="comment">//显示6050数据</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">0xFFFF</span>);<span class="comment">//通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw);//返回值:0,DMP成功解出欧拉角</span></span><br><span class="line">   <span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw)!=<span class="number">0</span>)&#123;&#125;  <span class="comment">//这个可以解决经常读不出数据的问题</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109214556197.png" alt="image-20230109214556197"></p><p>然后我看一下 这个Usart3String 现在发送的大概多大的？</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109215719786.png" alt="image-20230109215719786"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> OledString[<span class="number">50</span>];</span><br><span class="line"><span class="type">uint8_t</span> Usart3String[<span class="number">50</span>];</span><br></pre></td></tr></table></figure><p>编译、烧录、然后就可以连接手机蓝牙，在蓝牙软件查看数据了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230109225000072.png" alt="image-20230109225000072" style="zoom:50%;" /></p><h2 id="17-2-利用6050直线和90度-有代码"><a href="#17-2-利用6050直线和90度-有代码" class="headerlink" title="17.2-利用6050直线和90度(有代码)"></a>17.2-利用6050直线和90度(有代码)</h2><p><strong>为什么小车还是不能走直线</strong></p><p>为什么两个电机转速一样不能走非常正直线，如何控制小车转弯90度。</p><p>当然，我们可以开环控制，但是控制效果可能不好，受外界影响比较大。</p><p>如果我们使用闭环控制，就要使用一个传感器来获得现在小车角度。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221203222808445.png" alt="image-20221203222808445"></p><p><a href="https://www.bilibili.com/video/BV1UV4y1p7Hd/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1UV4y1p7Hd/?spm_id_from=333.337.search-card.all.click</a></p><h3 id="走直线-控制朝一个方向运动"><a href="#走直线-控制朝一个方向运动" class="headerlink" title="走直线(控制朝一个方向运动)"></a>走直线(控制朝一个方向运动)</h3><p>在pid.c中定义一个姿态控制使用的PID</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110160756280.png" alt="image-20230110160756280"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tPid pidMPU6050YawMovement;  <span class="comment">//利用6050偏航角 进行姿态控制的PID</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110163152585.png" alt="image-20230110163152585"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pidMPU6050YawMovement.actual_val=<span class="number">0.0</span>;</span><br><span class="line">pidMPU6050YawMovement.target_val=<span class="number">0.00</span>;<span class="comment">//设定姿态目标值</span></span><br><span class="line">pidMPU6050YawMovement.err=<span class="number">0.0</span>;</span><br><span class="line">pidMPU6050YawMovement.err_last=<span class="number">0.0</span>;</span><br><span class="line">pidMPU6050YawMovement.err_sum=<span class="number">0.0</span>;</span><br><span class="line">pidMPU6050YawMovement.Kp=<span class="number">2</span>;<span class="comment">//定距离跟随的Kp大小通过估算PID输入输出数据，确定大概大小，然后在调试</span></span><br><span class="line">pidMPU6050YawMovement.Ki=<span class="number">0</span>;</span><br><span class="line">pidMPU6050YawMovement.Kd=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>仿照之前红外循迹代码编写姿态控制函数</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110163514918.png" alt="image-20230110163514918"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span>  g_fMPU6050YawMovePidOut = <span class="number">0.00f</span>; <span class="comment">//姿态PID运算输出</span></span><br><span class="line"><span class="type">float</span>  g_fMPU6050YawMovePidOut1 = <span class="number">0.00f</span>; <span class="comment">//第一个电机控制输出</span></span><br><span class="line"><span class="type">float</span>  g_fMPU6050YawMovePidOut2 = <span class="number">0.00f</span>; <span class="comment">//第一个电机控制输出</span></span><br></pre></td></tr></table></figure><p>走直线程序如下(因为上电初始化时候航向角是0、而且pidMPU6050YawMovementPID结构体的目标值target_val 也是0)</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110165825685.png" alt="image-20230110165825685"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*************MPU6050航向角 PID转向控制*****************//</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;pitch:%.2f roll:%.2f yaw:%.2f\r\n&quot;</span>,pitch,roll,yaw);<span class="comment">//显示6050数据 俯仰角 横滚角 航向角</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">0xFFFF</span>);<span class="comment">//通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw);//返回值:0,DMP成功解出欧拉角</span></span><br><span class="line">    <span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw)!=<span class="number">0</span>)&#123;&#125;  <span class="comment">//这个可以解决经常读不出数据的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_fMPU6050YawMovePidOut = PID_realize(&amp;pidMPU6050YawMovement,yaw);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"></span><br><span class="line">g_fMPU6050YawMovePidOut1 = <span class="number">1.5</span> + g_fMPU6050YawMovePidOut;<span class="comment">//基础速度加减PID输出速度</span></span><br><span class="line">g_fMPU6050YawMovePidOut2 = <span class="number">1.5</span> - g_fMPU6050YawMovePidOut;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut1 &gt;<span class="number">3.5</span>) g_fMPU6050YawMovePidOut1 =<span class="number">3.5</span>;<span class="comment">//进行限幅</span></span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut1 &lt;<span class="number">0</span>) g_fMPU6050YawMovePidOut1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut2 &gt;<span class="number">3.5</span>) g_fMPU6050YawMovePidOut2 =<span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut2 &lt;<span class="number">0</span>) g_fMPU6050YawMovePidOut2 =<span class="number">0</span>;</span><br><span class="line">motorPidSetSpeed(g_fMPU6050YawMovePidOut1,g_fMPU6050YawMovePidOut2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后调节PID参数</p><p>顺序 先确定P 正负 然后P大小 </p><p>然后D正负 然后D大小</p><p>最后调节的参数如下</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110170011105.png" alt="image-20230110170011105"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidMPU6050YawMovement.Kp=<span class="number">0.02</span>;<span class="comment">//6050航向角PID运动控制 </span></span><br><span class="line">pidMPU6050YawMovement.Ki=<span class="number">0</span>;</span><br><span class="line">pidMPU6050YawMovement.Kd=<span class="number">0.1</span>;</span><br></pre></td></tr></table></figure><p>然后我们把小车放在地上就可以完成一直朝着初始方向前进，如果往侧面推也会马上矫正。</p><h3 id="转弯90度功能-控制转弯角度"><a href="#转弯90度功能-控制转弯角度" class="headerlink" title="转弯90度功能(控制转弯角度)"></a>转弯90度功能(控制转弯角度)</h3><p>然后我们增加一下，如何旋转90度程序</p><p>在串口接收回调函数表姿态PID的目标值</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110184914912.png" alt="image-20230110184914912"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> tPid pidMPU6050YawMovement;  <span class="comment">//利用6050偏航角 进行姿态控制的PID</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230110185214565.png" alt="image-20230110185214565"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;H&#x27;</span>)<span class="comment">//转向90度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pidMPU6050YawMovement.target_val &lt;= <span class="number">180</span>)pidMPU6050YawMovement.target_val += <span class="number">90</span>;<span class="comment">//目标值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;I&#x27;</span>)<span class="comment">//转回90度</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(pidMPU6050YawMovement.target_val &gt;= <span class="number">-180</span>)pidMPU6050YawMovement.target_val -= <span class="number">90</span>;<span class="comment">//目标值</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>然后我们的蓝牙APP增加两个发送按钮的设置</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221117224841058.png" alt="image-20221117224841058"></p><p>现象 是上电小车向初始方向直行，如果推小车车头方向，小车能够立马矫正。</p><p>然后连接蓝牙发送转90度 小车会转90度，按下 转回90度小车回转回。</p><h1 id="第18章-综合以上功能"><a href="#第18章-综合以上功能" class="headerlink" title="第18章-综合以上功能"></a>第18章-综合以上功能</h1><h2 id="18-按键和app按钮切换功能"><a href="#18-按键和app按钮切换功能" class="headerlink" title="18-按键和app按钮切换功能"></a>18-按键和app按钮切换功能</h2><p>根据上面介绍，我们的模式可以有：</p><p><strong>OLED显示模式: 速度、里程、电压、超声波数据、MPU6050俯仰角、横滚角、航向角 数据显示在OLED上和通过串口发送蓝牙APP </strong> </p><p><strong>PID循迹模式:红外对管PID循迹</strong></p><p><strong>手机遥控普通运动模式:遥控前、后、左、右加速运动</strong></p><p><strong>超声波避障模式</strong></p><p><strong>PID跟随模式:超声波PID定距离跟随</strong></p><p><strong>手机遥控角度闭环模式：MPU6050角度PID控制</strong></p><p>可以设置标志位通过按键改变标志位，以实现功能切换。</p><p>定义一个全局变量，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> g_ucMode = <span class="number">0</span>; </span><br><span class="line"><span class="comment">//小车运动模式标志位 0:显示功能、1:PID循迹模式、2:手机遥控普通运动模式、3.超声波避障模式、4:PID跟随模式、5:遥控角度闭环</span></span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111120620970.png" alt="image-20230111120620970"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> g_ucMode = <span class="number">0</span>; <span class="comment">//小车运动模式标志位</span></span><br></pre></td></tr></table></figure><p>在gpio.h声明一下</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111120725049.png" alt="image-20230111120725049"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> g_ucMode ; <span class="comment">//小车运动模式标志位</span></span><br></pre></td></tr></table></figure><p>按键中断回调函数里面补充按下按键后的处理</p><p>先不进行消抖，如果后面KEY1 KEY2效果不好再消抖</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111123626386.png" alt="image-20230111123626386"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin) <span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">5</span>) g_ucMode = <span class="number">1</span>;<span class="comment">//g_ucMode模式是0 1 2 3 4 5 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">g_ucMode+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY2_Pin) <span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line">g_ucMode=<span class="number">0</span>;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后主函数显示当前处于的模式</p><p>然后判断当前模式 执行不同代码</p><p>方法：一个功能一个功能的添加代码，添加好一个调试测试一下，然后再添加下一个</p><p>下面这个就是我们主函数的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot; g_ucMode:%d&quot;</span>,g_ucMode);<span class="comment">//显示g_ucMode 当前模式</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">6</span>,OledString,<span class="number">12</span>);<span class="comment">//显示在OLED上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot; g_ucMode:%d&quot;</span>,g_ucMode);<span class="comment">//蓝牙APP显示</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//0LED显示功能</span></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)OledString, <span class="string">&quot;V1:%.2fV2:%.2f&quot;</span>, Motor1Speed,Motor2Speed);<span class="comment">//显示速度</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">0</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)OledString, <span class="string">&quot;Mileage:%.2f&quot;</span>, Mileage);<span class="comment">//显示里程</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">1</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)OledString, <span class="string">&quot;U:%.2fV&quot;</span>, adcGetBatteryVoltage());<span class="comment">//显示电池电压</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">2</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot;HC_SR04:%.2fcm\r\n&quot;</span>,HC_SR04_Read());<span class="comment">//显示超声波数据</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">3</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot;p:%.2f r:%.2f \r\n&quot;</span>,pitch,roll);<span class="comment">//显示6050数据 俯仰角 横滚角</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">4</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)OledString,<span class="string">&quot;y:%.2f  \r\n&quot;</span>,yaw);<span class="comment">//显示6050数据  航向角</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">5</span>,OledString,<span class="number">12</span>);<span class="comment">//这个是oled驱动里面的，是显示位置的一个函数，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//蓝牙APP显示</span></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)Usart3String, <span class="string">&quot;V1:%.2fV2:%.2f&quot;</span>, Motor1Speed,Motor2Speed);<span class="comment">//显示速度</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"><span class="comment">//阻塞方式发送可以保证数据发送完毕，中断发送不一定可以保证数据已经发送完毕才启动下一次发送</span></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)Usart3String, <span class="string">&quot;Mileage:%.2f&quot;</span>, Mileage);<span class="comment">//显示里程</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)Usart3String, <span class="string">&quot;U:%.2fV&quot;</span>, adcGetBatteryVoltage());<span class="comment">//显示电池电压</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;HC_SR04:%.2fcm\r\n&quot;</span>,HC_SR04_Read());<span class="comment">//显示超声波数据</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;p:%.2f r:%.2f \r\n&quot;</span>,pitch,roll);<span class="comment">//显示6050数据 俯仰角 横滚角</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;y:%.2f  \r\n&quot;</span>,yaw);<span class="comment">//显示6050数据  航向角</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">50</span>);<span class="comment">//阻塞式发送通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得6050数据</span></span><br><span class="line"><span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw)!=<span class="number">0</span>)&#123;&#125;  <span class="comment">//这个可以解决经常读不出数据的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示模式电机停转</span></span><br><span class="line">motorPidSetSpeed(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///****    红外PID循迹功能******************/</span></span><br><span class="line">g_ucaHW_Read[<span class="number">0</span>] = READ_HW_OUT_1;<span class="comment">//读取红外对管状态、这样相比于写在if里面更高效</span></span><br><span class="line">g_ucaHW_Read[<span class="number">1</span>] = READ_HW_OUT_2;</span><br><span class="line">g_ucaHW_Read[<span class="number">2</span>] = READ_HW_OUT_3;</span><br><span class="line">g_ucaHW_Read[<span class="number">3</span>] = READ_HW_OUT_4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该前进\r\n&quot;);//注释掉更加高效，减少无必要程序执行</span></span><br><span class="line">g_cThisState = <span class="number">0</span>;<span class="comment">//前进</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )<span class="comment">//使用else if更加合理高效</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-1</span>;<span class="comment">//应该右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-2</span>;<span class="comment">//快速右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速右转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">-3</span>;<span class="comment">//快速右转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;应该左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">1</span>;<span class="comment">//应该左转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;快速左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">2</span>;<span class="comment">//快速左转</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g_ucaHW_Read[<span class="number">0</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">1</span>] == <span class="number">0</span>&amp;&amp;g_ucaHW_Read[<span class="number">2</span>] == <span class="number">1</span>&amp;&amp;g_ucaHW_Read[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    printf(&quot;快速左转\r\n&quot;);</span></span><br><span class="line">g_cThisState = <span class="number">3</span>;<span class="comment">//快速左转</span></span><br><span class="line">&#125;</span><br><span class="line">g_fHW_PID_Out = PID_realize(&amp;pidHW_Tracking,g_cThisState);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"></span><br><span class="line">g_fHW_PID_Out1 = <span class="number">3</span> + g_fHW_PID_Out;<span class="comment">//电机1速度=基础速度+循迹PID输出速度</span></span><br><span class="line">g_fHW_PID_Out2 = <span class="number">3</span> - g_fHW_PID_Out;<span class="comment">//电机1速度=基础速度-循迹PID输出速度</span></span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out1 &gt;<span class="number">5</span>) g_fHW_PID_Out1 =<span class="number">5</span>;<span class="comment">//进行限幅 限幅速度在0-5之间</span></span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out1 &lt;<span class="number">0</span>) g_fHW_PID_Out1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out2 &gt;<span class="number">5</span>) g_fHW_PID_Out2 =<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fHW_PID_Out2 &lt;<span class="number">0</span>) g_fHW_PID_Out2 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_cThisState != g_cLastState)<span class="comment">//如何这次状态不等于上次状态、就进行改变目标速度和控制电机、在定时器中依旧定时控制电机</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(g_fHW_PID_Out1,g_fHW_PID_Out2);<span class="comment">//通过计算的速度控制电机</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_cLastState = g_cThisState;<span class="comment">//保存上次红外对管状态</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//***************遥控模式***********************//</span></span><br><span class="line"><span class="comment">//遥控模式的控制在串口三的中断里面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//******超声波避障模式*********************//</span></span><br><span class="line"><span class="comment">////避障逻辑</span></span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt; <span class="number">25</span>)<span class="comment">//前方无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//前方有障碍物</span></span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//右边运动 原地</span></span><br><span class="line">HAL_Delay(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt; <span class="number">25</span>)<span class="comment">//右边无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//右边有障碍物</span></span><br><span class="line">motorPidSetSpeed(<span class="number">1</span>,<span class="number">-1</span>);<span class="comment">//左边运动 原地</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">if</span>(HC_SR04_Read() &gt;<span class="number">25</span>)<span class="comment">//左边无障碍物</span></span><br><span class="line">&#123;</span><br><span class="line"> motorPidSetSpeed(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//前运动</span></span><br><span class="line">HAL_Delay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">-1</span>);<span class="comment">//后运动</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line">motorPidSetSpeed(<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//右边运动</span></span><br><span class="line">HAL_Delay(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//**********PID跟随功能***********//</span></span><br><span class="line">g_fHC_SR04_Read=HC_SR04_Read();<span class="comment">//读取前方障碍物距离</span></span><br><span class="line"><span class="keyword">if</span>(g_fHC_SR04_Read &lt; <span class="number">60</span>)&#123;  <span class="comment">//如果前60cm 有东西就启动跟随</span></span><br><span class="line">g_fFollow_PID_Out = PID_realize(&amp;pidFollow,g_fHC_SR04_Read);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"><span class="keyword">if</span>(g_fFollow_PID_Out &gt; <span class="number">6</span>) g_fFollow_PID_Out = <span class="number">6</span>;<span class="comment">//对输出速度限幅</span></span><br><span class="line"><span class="keyword">if</span>(g_fFollow_PID_Out &lt; <span class="number">-6</span>) g_fFollow_PID_Out = <span class="number">-6</span>;</span><br><span class="line">motorPidSetSpeed(g_fFollow_PID_Out,g_fFollow_PID_Out);<span class="comment">//速度作用与电机上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> motorPidSetSpeed(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//如果前面60cm 没有东西就停止</span></span><br><span class="line">HAL_Delay(<span class="number">10</span>);<span class="comment">//读取超声波传感器不能过快</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//*************MPU6050航向角 PID转向控制*****************//</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)Usart3String,<span class="string">&quot;pitch:%.2f roll:%.2f yaw:%.2f\r\n&quot;</span>,pitch,roll,yaw);<span class="comment">//显示6050数据 俯仰角 横滚角 航向角</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart3,( <span class="type">uint8_t</span> *)Usart3String,<span class="built_in">strlen</span>(( <span class="type">const</span>  <span class="type">char</span>  *)Usart3String),<span class="number">0xFFFF</span>);<span class="comment">//通过串口三输出字符 strlen:计算字符串大小</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw);//返回值:0,DMP成功解出欧拉角</span></span><br><span class="line"><span class="keyword">while</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw)!=<span class="number">0</span>)&#123;&#125;  <span class="comment">//这个可以解决经常读不出数据的问题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_fMPU6050YawMovePidOut = PID_realize(&amp;pidMPU6050YawMovement,yaw);<span class="comment">//PID计算输出目标速度 这个速度，会和基础速度加减</span></span><br><span class="line"></span><br><span class="line">g_fMPU6050YawMovePidOut1 = <span class="number">1.5</span> + g_fMPU6050YawMovePidOut;<span class="comment">//基础速度加减PID输出速度</span></span><br><span class="line">g_fMPU6050YawMovePidOut2 = <span class="number">1.5</span> - g_fMPU6050YawMovePidOut;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut1 &gt;<span class="number">3.5</span>) g_fMPU6050YawMovePidOut1 =<span class="number">3.5</span>;<span class="comment">//进行限幅</span></span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut1 &lt;<span class="number">0</span>) g_fMPU6050YawMovePidOut1 =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut2 &gt;<span class="number">3.5</span>) g_fMPU6050YawMovePidOut2 =<span class="number">3.5</span>;</span><br><span class="line"><span class="keyword">if</span>(g_fMPU6050YawMovePidOut2 &lt;<span class="number">0</span>) g_fMPU6050YawMovePidOut2 =<span class="number">0</span>;</span><br><span class="line">motorPidSetSpeed(g_fMPU6050YawMovePidOut1,g_fMPU6050YawMovePidOut2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以测试上面的代码 然后没有问题后，我们添加一个通过蓝牙APP按钮切换模式代码</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111135256610.png" alt="image-20230111135256610"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;J&#x27;</span>) <span class="comment">//改变模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">5</span>) g_ucMode = <span class="number">1</span>;<span class="comment">//g_ucMode模式是0 1 2 3 4 5 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">g_ucMode+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(g_ucUsart3ReceiveData == <span class="string">&#x27;K&#x27;</span>) g_ucMode=<span class="number">0</span>;<span class="comment">//设置为显示模式</span></span><br></pre></td></tr></table></figure><p>然后对应APP也要添加 按钮设置</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111135837135.png" alt="image-20230111135837135" style="zoom:67%;" /></p><p>我们</p><p>按键没有消抖效果不好，我们消抖一下</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111161916819.png" alt="image-20230111161916819"></p><p>我们增加了 HAL延时和再次判断电平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin) <span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">10</span>);<span class="comment">//延时消抖 主要</span></span><br><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_SET)<span class="comment">//判断KEY1引脚仍为高电平</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line"><span class="keyword">if</span>(g_ucMode == <span class="number">5</span>) g_ucMode = <span class="number">1</span>;<span class="comment">//g_ucMode模式是0 1 2 3 4 5 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">g_ucMode+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY2_Pin) <span class="comment">//判断一下那个引脚触发中断</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay(<span class="number">10</span>);<span class="comment">//延时消抖</span></span><br><span class="line"><span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port, KEY2_Pin) == GPIO_PIN_RESET)<span class="comment">//判断KEY2引脚仍为低电平</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里编写触发中断后要执行的程序</span></span><br><span class="line">g_ucMode=<span class="number">0</span>;</span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是测试不能执行中断，程序异常卡死了</p><p>原因是HAL_Delay使用的是sysTick 中断优先级在软件初始化是默认最低的，比外部中断优先级低，所以HAL_Delay不能在外部中断服务函数中调用。</p><p>所以我们可以通过提高sysTick 中断的优先级，提高的比HAL_Delay高。</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111205153163.png" alt="image-20230111205153163"></p><p>然后我们提高至 如下图</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20230111184656982.png" alt="image-20230111184656982"></p><p>然后编译烧录测试按键是否更加稳定。</p><h1 id="以上是应用篇"><a href="#以上是应用篇" class="headerlink" title="以上是应用篇"></a>以上是应用篇</h1><h1 id="下面19是扩展"><a href="#下面19是扩展" class="headerlink" title="下面19是扩展"></a>下面19是扩展</h1><h1 id="第22章-小车如何查找异常问题"><a href="#第22章-小车如何查找异常问题" class="headerlink" title="第22章-小车如何查找异常问题"></a>第22章-小车如何查找异常问题</h1><p>前面我们已经移植 好了OLED程序，下面我们就直接使用OLED,我们在定时器刷新OLED，我们50ms执行一次</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108162446208.png" alt="image-20221108162446208"></p><p>应该这样写</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108190207208.png" alt="image-20221108190207208"></p><p>显示行进路程累计</p><p>但是发现计算不准确，怀疑中断时间不准确，如何确定中断是否按时到达那？</p><ol><li>使用sysTick统计时间</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108193053984.png" alt="image-20221108193053984"></p><ol><li>在要判断时间的地方反转GPIO通过示波器观察 是否按时中断</li></ol><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108194432504.png" alt="image-20221108194432504"></p><p> 然后示波器测量引脚PC13</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108194541853.png" alt="image-20221108194541853"></p><p>所以调试发现</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108194818938.png" alt="image-20221108194818938"></p><p> 所以更新显示应该放到主函数执行，然后 </p><p>我们的中断函数这样写</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108203833681.png" alt="image-20221108203833681"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span>(EncoderTimer_Count%<span class="number">10</span> == <span class="number">0</span>)  <span class="comment">//每20ms 进入一次</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行PID计算、然后作用于电机</span></span><br><span class="line">Motor_Set(PID_realize(&amp;pid1_speed,Motor1_Speed),PID_realize(&amp;pid2_speed,Motor2_Speed));</span><br><span class="line"><span class="comment">//向上位机发送数据</span></span><br><span class="line">ANO_DT_Send_F2(Motor1_Speed*<span class="number">100</span>, <span class="number">3.0</span>*<span class="number">100</span>,Motor2_Speed*<span class="number">100</span>,<span class="number">3.0</span>*<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);<span class="comment">//切换LED GPIO状态</span></span><br><span class="line"><span class="comment">/*里程数 += 时间周期（s）*车轮转速(转/s)*车轮周长(cm)*/</span></span><br><span class="line">Mileage += <span class="number">0.02</span>*Motor1_Speed*<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">EncoderTimer_Count = <span class="number">0</span>; <span class="comment">//清空计数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后主函数刷新</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221108203929170.png" alt="image-20221108203929170"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)<span class="built_in">string</span>,<span class="string">&quot;V1:%.2fV2:%.2f &quot;</span>,Motor1_Speed,Motor2_Speed);<span class="comment">//显示两个电机转速 单位：转/秒</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">string</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span> *)<span class="built_in">string</span>,<span class="string">&quot;Mileage%.2f  &quot;</span>,Mileage);<span class="comment">//显示两个电机转速 单位：转/秒</span></span><br><span class="line">OLED_ShowString(<span class="number">0</span>,<span class="number">1</span>,<span class="built_in">string</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure><h1 id="一些测试中的坑"><a href="#一些测试中的坑" class="headerlink" title="一些测试中的坑"></a>一些测试中的坑</h1><h2 id="DAP识别芯片无法烧录"><a href="#DAP识别芯片无法烧录" class="headerlink" title="DAP识别芯片无法烧录"></a>DAP识别芯片无法烧录</h2><p>使用这个DAP无法下载这个淘宝核心板</p><p>点击下载出现这个报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not a genuine ST Device! Abort connection</span><br></pre></td></tr></table></figure><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809123109770.png" alt="image-20220809123109770"></p><p><a href="https://blog.csdn.net/chunquqiulailll/article/details/113257923">https://blog.csdn.net/chunquqiulailll/article/details/113257923</a></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220727195345745.png" alt="image-20220727195345745"></p><p>如果这里识别为</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729113616437.png" alt="image-20220729113616437"></p><p>安装过程芯片支持包</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729113514194.png" alt="image-20220729113514194"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729113643543.png" alt="image-20220729113643543"></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729113906766.png" alt="image-20220729113906766"></p><p>这里就会自动切换</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220729113953359.png" alt="image-20220729113953359"></p><h2 id="DAP无法识别芯片"><a href="#DAP无法识别芯片" class="headerlink" title="DAP无法识别芯片"></a><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809124022451.png" alt="image-20220809124022451">DAP无法识别芯片</h2><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220809124049727.png" alt="image-20220809124049727"></p><p>解决方法:</p><p>断电，将板子上的BOOT0用短路帽接入3.3V高电平，重新插入DAP，不出意外可见程序烧录成功，此时将BOOT0接回低电平，后续烧录程序便不会出现SWD/JTAG Communication Failure</p><h3 id="一个DAP可以问题记录"><a href="#一个DAP可以问题记录" class="headerlink" title="一个DAP可以问题记录"></a>一个DAP可以问题记录</h3><p>烧录代码(烧录时候、断掉电池供电、使用DAP给单片机供电)</p><h2 id="stlink下载程序"><a href="#stlink下载程序" class="headerlink" title="stlink下载程序"></a>stlink下载程序</h2><p>下载程序出现错误</p><p>Debugger - Cortex-M ErrorCannot access target.Shutting down debug session.</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116175748401.png" alt="image-20221116175748401"></p><p>取消这个勾选、然后编译</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116180051024.png" alt="image-20221116180051024"></p><p>然后编译一下</p><p>然后再改回来</p><p>反复勾选、编译、取消勾选，然后编译，就可以下载了。</p><p>然后我勾选这，就可以下载了</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221116213433686.png" alt="image-20221116213433686"></p><p>说更新最新的支持包试试</p><p><a href="https://www.keil.com/dd2/Pack/#!#eula-container">https://www.keil.com/dd2/Pack/#!#eula-container</a></p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20220807152834504.png" alt="image-20220807152834504"  /></p><h2 id="其他的记录"><a href="#其他的记录" class="headerlink" title="其他的记录"></a>其他的记录</h2><p>细分更多、注意那么电机占空比控制函数也要变化</p><p><img src="C:/Users/Y/OneDrive/学习笔记/单片机学习笔记/好家伙VCC智能小车笔记/STM32小车V3.1笔记.assets/image-20221210172627483.png" alt="image-20221210172627483"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机C语言基础</title>
      <link href="/2023/11/22/%E5%8D%95%E7%89%87%E6%9C%BAC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/22/%E5%8D%95%E7%89%87%E6%9C%BAC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>1、<code>8位： 单字节</code></p><p>​        char                           0 ~ 127</p><p>​        signed char              -128 ~ 127</p><p>​        unsigned char           0 ~ 255</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>基础理论：</p><p>字符串是由数字、字母、下划线组成的一串字符，以’\0’结尾。</p><p>定义方法：</p><p>1、通过字符数组</p><p>unsigned char str[] = “Hello World”;</p><p>2、通过字符指针</p><p>unsigned char *  P_str  =  “Hello World”;</p><p>3、直接使用字符串常量</p><p>printf     (“Hello World”);</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>2、<code>16位 ： 双字节</code></p><p>​        signed [short] int        -32768 ~ 32767    </p><p>​        unsigned [short] int            0 ~ 65535</p><p>3、<code>32位 ：四字节</code></p><p>​        signed long int         -2147483648 ~ 2147483647</p><p>​         unsigned long int         0 ~ 4294967295</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p><code>四字节</code>       float，精度：6（6位小数），表示的数值范围：-3.4E38 ~ +3.4E38  </p><p>double，精度：15（15位小数），表示的数值范围：2.3E-308 ~ 1.7E+308，存储大小：<code>8字节</code></p><p>long double，精度：19（19位小数），表示的数值范围：3.4E-4932 ~ 1.1E+4932，存储大小：<code>16字节</code></p><p> <strong>==应用举例==</strong></p><p> 有符号的 signed      无符号的  unsigned</p><p>​    signed char        cTemp= -100;</p><p>​    unsigned char        ucTemp = 100;</p><p>​    signed int        sTemp= -1000;</p><p>​    unsigned int    usTemp = 1000;</p><p>​    signed long int    lTemp= -100000;</p><p>​    unsigned long int    ulTemp = 10oeee;</p><p>​    float        fTemp = 2.5; </p><p><code>下面哪些应用正确</code></p><p>signed  char         cTemp = 200;    错</p><p>unsigned  char         ucTemp = 256;  错</p><p>signed  int         sTemp= 65535；  错</p><p>unsigned  int         usTemp = 65536;  错</p><p>float        fTemp = 0;  对</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>int i=10;<br>char b=20;</p><p>如：i=b;//这样赋值没有问题，因为低字节类型转换成高字节类型。<br>如果是b=i;//这样会有问题，b=(char)i;//因为高字体转换为低字节的类型后，若int i当前数值超过127时，会导致溢出，数据缺失。<br>所以。如果高字节类型要强制转换为低字节类型时，要考虑溢出问题。</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span>  ucTemp;    <span class="comment">//无符号整型</span></span><br><span class="line">  <span class="type">signed</span>   <span class="type">char</span>  cTemp;     <span class="comment">//有符号整型</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>   usTemp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> ulTemp;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>          fTemp;   <span class="comment">//浮点型</span></span><br><span class="line">ucTemp = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">   <span class="comment">/*强制类型转换</span></span><br><span class="line"><span class="comment">转换是什么意思</span></span><br><span class="line"><span class="comment">比如说这个数是200 用十六进制来表示就是0xc8但是用ucTemp来打印的话就是十六位数据，进行强制类型转换成一个十六位整型就会变成0x00c8。这样就把8位变成16位了，如果这个地方没有强制类型转换，它打印出来就会变成0xc800，这样就会出错，所以这个地方进行一个强制类型转换，这样就不会出错。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"> </span><br><span class="line">cTemp = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The cTemp = %d\r\n&quot;</span>,(<span class="type">signed</span> <span class="type">int</span>)cTemp);</span><br><span class="line"></span><br><span class="line">usTemp = <span class="number">0xAA55</span>;  <span class="comment">//因为我们这里就是一个十六位的整型的数据，所以就不需要类型转换了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = 0x%x\r\n&quot;</span>,usTemp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = %u\r\n&quot;</span>,usTemp);</span><br><span class="line"></span><br><span class="line">fTemp = <span class="number">0.25</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The fTemp = %.2f\r\n&quot;</span>,fTemp);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">fTemp = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the fTemp = %d/r/n&quot;</span>,(<span class="type">signed</span> <span class="type">int</span>)fTemp);</span><br><span class="line"><span class="comment">//这里打印的话应该是2.1，我们可以通过强制类型转换让它转换为一个整型，当我们把一个浮点型数据转化成整型他会把小数点去掉，2.1就会变成2。</span></span><br></pre></td></tr></table></figure><h3 id="进制数"><a href="#进制数" class="headerlink" title="进制数"></a>进制数</h3><p><code>1、二进制</code>    <strong>逢二进一</strong></p><p>00,01,10,11.. </p><p><code>2、十进制</code>    <strong>逢十进一</strong><br>0,1,2,3,4,5,6,7,8,9,10,11,12…</p><p><code>3、十六进制</code>    <strong>逢十六进一</strong><br>0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0xOA,0xOB,0x0C,0x0D,0xOE,0xOF,0x10,0x11….</p><p><code>4、进制转换</code></p><p>0b11101101 = 2^7^+2^6^ +2^5^+0+2^3^+2^2^+0+2^0^ = 128+64+32+0+8+4+0+1 = 233</p><p>0b1110 1101 = 255 - (2^4^ +2^1^) = 255- 16- 2 = 233</p><p>0b1110 1101 = OXED;</p><p>100 = 0+2^6^+2^5^+0+0+2^2^+0+0= 0b 0110 0100</p><p> 0b 0110 0100 = 0x 64        0110 =6     0100 = 4 </p><p>100 = 16*6+4 = 0x64</p><p>0xAA =16<em>10+10 = 2^4^ </em> ( 2^3^+0+2^1^+0 ) + (2^3^+0+2^1^+0 ) = 2^7^ +0+2^5^+0 +2^3^+0+2^1^+0= 0b1010 1010</p><p>0xAA=16*10+10 =170</p><h3 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h3><p>格式说明由“%”和字符组成，作用是将输出的数据转化为指定的格式输出<br><strong>eg:格式字符有 d,o,x,u,c,s,f,e,g</strong></p><p><code>%d</code>，<code>%i</code> :以有符号十进制整形输出(%i不常用）%-2d数据输出左对齐。</p><p><code>%ld</code>:以长整型输出</p><p><code>%o:</code>以八进制整型输出</p><p><code>%e:</code>以指数形式输出实数，不指定输出数据所占的宽度和数字部分的小数位数</p><p><code>%x:</code>以十六进制整型输出,或者输出字符串的地址（当%X格式输出，就是以大写字母输出）</p><p><code>%u:</code>以十进制无符号整形形式输出</p><p><code>%c</code>:用来输出一个字符（也可以指定域宽（所占列数）eg:%5c）</p><p><code>%s</code>:用来输出一个字符串。</p><p><code>％g</code>:根据大小自动选f格式或e格式，且不输出无意义的零。</p><p><code>f格式符</code>:用来输出（包括单，双精度，长双精度），以小数形式输出。<br>有以下几种用法：</p><ol><li><code>%f</code>:不指定输出数据长度，实数部分全部输出，小数部分输出六位。</li><li><code>%m.nf</code> :例如，%7.2f：指定输出数据占七列，包括2位小数，如果数值长度小于m，则左端补空格<br> 3.<code>%m.ns</code> 输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。</li></ol><p><code>scanf (控制字符，地址列表)</code><br>格式字符的含义同printf函数，地址列表是由若干个地址组成的表列，可以是变量的地址，或字符串的首地址。如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;％d％c％s&quot;</span>,&amp;a,&amp;b,str)；</span><br></pre></td></tr></table></figure><h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><h4 id="ASCII码一览表"><a href="#ASCII码一览表" class="headerlink" title="ASCII码一览表"></a>ASCII码一览表</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607072041066.png" alt="image-20230607072041066"> </p><p> <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607072227601.png" alt="image-20230607072227601"> </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607072306943.png" alt="image-20230607072306943"> </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607072359295.png" alt="image-20230607072359295"> </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607072421705.png" alt="image-20230607072421705"> </p><h4 id="对控制字符的解释"><a href="#对控制字符的解释" class="headerlink" title="对控制字符的解释"></a>对控制字符的解释</h4><p>ASCII 编码中第 0~31 个字符（开头的 32 个字符）以及第 127 个字符（最后一个字符）都是不可见的（无法显示），但是它们都具有一些特殊功能，所以称为控制字符（ Control Character）或者功能码（Function Code）。</p><p>这 33 个控制字符大都与通信、数据存储以及老式设备有关，有些在现代电脑中的含义已经改变了。</p><blockquote><p>有些控制符需要一定的计算机功底才能理解，初学者可以跳过，选择容易的理解即可。</p></blockquote><p>下面列出了部分控制字符的具体功能：</p><h5 id="NUL-0"><a href="#NUL-0" class="headerlink" title="NUL (0)"></a>NUL (0)</h5><p>NULL，空字符。空字符起初本意可以看作为 NOP（中文意为空操作，就是啥都不做的意思），此位置可以忽略一个字符。</p><p>之所以有这个空字符，主要是用于计算机早期的记录信息的纸带，此处留个 NUL 字符，意思是先占这个位置，以待后用，比如你哪天想起来了，在这个位置在放一个别的啥字符之类的。</p><p>后来呢，NUL 被用于C语言中，表示字符串的结束，当一个字符串中间出现 NUL 时，就意味着这个是一个字符串的结尾了。这样就方便按照自己需求去定义字符串，多长都行，当然只要你内存放得下，然后最后加一个\0，即空字符，意思是当前字符串到此结束。</p><h5 id="SOH-1"><a href="#SOH-1" class="headerlink" title="SOH (1)"></a>SOH (1)</h5><p>Start Of Heading，标题开始。如果信息沟通交流主要以命令和消息的形式的话，SOH 就可以用于标记每个消息的开始。</p><p>1963年，最开始 ASCII 标准中，把此字符定义为 Start of Message，后来又改为现在的 Start Of Heading。</p><p>现在，这个 SOH 常见于主从（master-slave）模式的 RS232 的通信中，一个主设备，以 SOH 开头，和从设备进行通信。这样方便从设备在数据传输出现错误的时候，在下一次通信之前，去实现重新同步（resynchronize）。如果没有一个清晰的类似于 SOH 这样的标记，去标记每个命令的起始或开头的话，那么重新同步，就很难实现了。</p><h5 id="STX-2-和-ETX-3"><a href="#STX-2-和-ETX-3" class="headerlink" title="STX (2) 和 ETX (3)"></a>STX (2) 和 ETX (3)</h5><p>STX 表示 Start Of Text，意思是“文本开始”；ETX 表示 End Of Text，意思是“文本结束”。</p><p>通过某种通讯协议去传输的一个数据（包），称为一帧的话，常会包含一个帧头，包含了寻址信息，即你是要发给谁，要发送到目的地是哪里，其后跟着真正要发送的数据内容。</p><p>而 STX，就用于标记这个数据内容的开始。接下来是要传输的数据，最后是 ETX，表明数据的结束。</p><p>而中间具体传输的数据内容，ASCII 并没有去定义，它和你所用的传输协议有关。</p><div class="table-container"><table><thead><tr><th>帧头</th><th>数据或文本内容</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>SOH（表明帧头开始）</td><td>……（帧头信息，比如包含了目的地址，表明你发送给谁等等）</td><td>STX（表明数据开始）</td><td>……（真正要传输的数据）</td><td>ETX（表明数据结束</td></tr></tbody></table></div><h5 id="BEL-7"><a href="#BEL-7" class="headerlink" title="BEL (7)"></a>BEL (7)</h5><p>BELl，响铃。在 ASCII 编码中，BEL 是个比较有意思的东西。BEL 用一个可以听得见的声音来吸引人们的注意，既可以用于计算机，也可以用于周边设备（比如打印机）。</p><p>注意，BEL 不是声卡或者喇叭发出的声音，而是蜂鸣器发出的声音，主要用于报警，比如硬件出现故障时就会听到这个声音，有的计算机操作系统正常启动也会听到这个声音。蜂鸣器没有直接安装到主板上，而是需要连接到主板上的一种外设，现代很多计算机都不安装蜂鸣器了，即使输出 BEL 也听不到声音，这个时候 BEL 就没有任何作用了。</p><h5 id="BS-8"><a href="#BS-8" class="headerlink" title="BS (8)"></a>BS (8)</h5><p>BackSpace，退格键。退格键的功能，随着时间变化，意义也变得不同了。</p><p>退格键起初的意思是，在打印机和电传打字机上，往回移动一格光标，以起到强调该字符的作用。比如你想要打印一个 a，然后加上退格键后，就成了 aBS^。在机械类打字机上，此方法能够起到实际的强调字符的作用，但是对于后来的 CTR 下时期来说，就无法起到对应效果了。</p><p>而现代所用的退格键，不仅仅表示光标往回移动了一格，同时也删除了移动后该位置的字符。</p><h5 id="HT-9"><a href="#HT-9" class="headerlink" title="HT (9)"></a>HT (9)</h5><p>Horizontal Tab，水平制表符，相当于 Table/Tab 键。</p><p>水平制表符的作用是用于布局，它控制输出设备前进到下一个表格去处理。而制表符 Table/Tab 的宽度也是灵活不固定的，只不过在多数设备上制表符 Tab 都预定义为 4 个空格的宽度。</p><p>水平制表符 HT 不仅能减少数据输入者的工作量，对于格式化好的文字来说，还能够减少存储空间，因为一个Tab键，就代替了 4 个空格。</p><h5 id="LF-10"><a href="#LF-10" class="headerlink" title="LF (10)"></a>LF (10)</h5><p>Line Feed，直译为“给打印机等喂一行”，也就是“换行”的意思。LF 是 ASCII 编码中常被误用的字符之一。</p><p>LF 的最原始的含义是，移动打印机的头到下一行。而另外一个 ASCII 字符，CR（Carriage Return）才是将打印机的头移到最左边，即一行的开始（行首）。很多串口协议和 MS-DOS 及 Windows 操作系统，也都是这么实现的。</p><p>而C语言和 Unix 操作系统将 LF 的含义重新定义为“新行”，即 LF 和 CR 的组合效果，也就是回车且换行的意思。</p><p>从程序的角度出发，C语言和 Unix 对 LF 的定义显得更加自然，而 MS-DOS 的实现更接近于 LF 的本意。</p><p>现在人们常将 LF 用做“新行（newline）”的功能，大多数文本编辑软件也都可以处理单个 LF 或者 CR/LF 的组合了。</p><h5 id="VT-11"><a href="#VT-11" class="headerlink" title="VT (11)"></a>VT (11)</h5><p>Vertical Tab，垂直制表符。它类似于水平制表符 Tab，目的是为了减少布局中的工作，同时也减少了格式化字符时所需要存储字符的空间。VT 控制符用于跳到下一个标记行。</p><p>说实话，还真没看到有些地方需要用 VT，因为一般在换行的时候都是用 LF 代替 VT 了。</p><h5 id="FF-12"><a href="#FF-12" class="headerlink" title="FF (12)"></a>FF (12)</h5><p>Form Feed，换页。设计换页键，是用来控制打印机行为的。当打印机收到此键码的时候，打印机移动到下一页。</p><p>不同的设备的终端对此控制符所表现的行为各不同，有些会清除屏幕，有些只是显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^L</span><br></pre></td></tr></table></figure><p>字符，有些只是新换一行而已。例如，Unix/Linux 下的 Bash Shell 和 Tcsh 就把 FF 看做是一个清空屏幕的命令。</p><h5 id="CR-13"><a href="#CR-13" class="headerlink" title="CR (13)"></a>CR (13)</h5><p>Carriage return，回车，表示机器的滑动部分（或者底座）返回。</p><p>CR 回车的原意是让打印头回到左边界，并没有移动到下一行的意思。随着时间的流逝，后来人们把 CR 的意思弄成了 Enter 键，用于示意输入完毕。</p><p>在数据以屏幕显示的情况下，人们按下 Enter 的同时，也希望把光标移动到下一行，因此C语言和 Unix 重新定义了 CR 的含义，将其表示为移动到下一行。当输入 CR 时，系统也常常隐式地将其转换为LF。</p><h5 id="SO-14-和-SI-15"><a href="#SO-14-和-SI-15" class="headerlink" title="SO (14) 和 SI (15)"></a>SO (14) 和 SI (15)</h5><p>SO，Shift Out，不用切换；SI，Shift In，启用切换。</p><p>早在 1960s 年代，设计 ASCII 编码的美国人就已经想到了，ASCII 编码不仅仅能用于英文，也要能用于外文字符集，这很重要，定义 Shift In 和 Shift Out 正是考虑到了这点。</p><p>最开始，其意为在西里尔语和拉丁语之间切换。西里尔语 ASCII（也即 KOI-7 编码）将 Shift 作为一个普通字符，而拉丁语 ASCII（也就是我们通常所说的 ASCII）用 Shift 去改变打印机的字体，它们完全是两种含义。</p><p>在拉丁语 ASCII 中，SO 用于产生双倍宽度的字符（类似于全角），而用 SI 打印压缩的字体（类似于半角）。</p><h5 id="DLE-16"><a href="#DLE-16" class="headerlink" title="DLE (16)"></a>DLE (16)</h5><p>Data Link Escape，数据链路转义。</p><p>有时候我们需要在通信过程中发送一些控制字符，但是总有一些情况下，这些控制字符被看成了普通的数据流，而没有起到对应的控制效果，ASCII 编码引入 DLE 来解决这类问题。</p><p>如果数据流中检测到了 DLE，数据接收端会对数据流中接下来的字符另作处理。但是具体如何处理，ASCII 规范中并没有定义，只是弄了个 DLE 去打断正常的数据流，告诉接下来的数据要特殊对待。</p><h5 id="DC1-17"><a href="#DC1-17" class="headerlink" title="DC1 (17)"></a>DC1 (17)</h5><p>Device Control 1，或者 XON – Transmission on。</p><p>这个 ASCII 控制符尽管原先定义为 DC1， 但是现在常表示为 XON，用于串行通信中的软件流控制。其主要作用为，在通信被控制符 XOFF 中断之后，重新开始信息传输。</p><p>用过串行终端的人应该还记得，当有时候数据出错了，按 Ctrl+Q（等价于XON）有时候可以起到重新传输的效果。这是因为，此 Ctrl+Q 键盘序列实际上就是产生 XON 控制符，它可以将那些由于终端或者主机方面，由于偶尔出现的错误的 XOFF 控制符而中断的通信解锁，使其正常通信。</p><h5 id="DC3-19"><a href="#DC3-19" class="headerlink" title="DC3 (19)"></a>DC3 (19)</h5><p>Device Control 3，或者 XOFF（Transmission off，传输中断）。</p><h5 id="EM-25"><a href="#EM-25" class="headerlink" title="EM (25)"></a>EM (25)</h5><p>End of Medium，已到介质末端，介质存储已满。</p><p>EM 用于，当数据存储到达串行存储介质末尾的时候，就像磁带或磁头滚动到介质末尾一样。其用于表述数据的逻辑终点，即不必非要是物理上的达到数据载体的末尾。</p><h5 id="FS-28"><a href="#FS-28" class="headerlink" title="FS(28)"></a>FS(28)</h5><p>File Separator，文件分隔符。FS 是个很有意思的控制字符，它可以让我们看到 1960s 年代的计算机是如何组织的。</p><p>我们现在习惯于随机访问一些存储介质，比如 RAM、磁盘等，但是在设计 ASCII 编码的那个年代，大部分数据还是顺序的、串行的，而不是随机访问的。此处所说的串行，不仅仅指的是串行通信，还指的是顺序存储介质，比如穿孔卡片、纸带、磁带等。</p><p>在串行通信的时代，设计这么一个用于表示文件分隔的控制字符，用于分割两个单独的文件，是一件很明智的事情。</p><h5 id="GS-29"><a href="#GS-29" class="headerlink" title="GS(29)"></a>GS(29)</h5><p>Group Separator，分组符。</p><p>ASCII 定义控制字符的原因之一就是考虑到了数据存储。</p><p>大部分情况下，数据库的建立都和表有关，表包含了多条记录。同一个表中的所有记录属于同一类型，不同的表中的记录属于不同的类型。</p><p>而分组符 GS 就是用来分隔串行数据存储系统中的不同的组。值得注意的是，当时还没有使用 Excel 表格，ASCII 时代的人把它叫做组。</p><h5 id="RS-30"><a href="#RS-30" class="headerlink" title="RS(30)"></a>RS(30)</h5><p>Record Separator，记录分隔符，用于分隔一个组或表中的多条记录。</p><h5 id="US-31"><a href="#US-31" class="headerlink" title="US(31)"></a>US(31)</h5><p>Unit Separator，单元分隔符。</p><p>在 ASCII 定义中，数据库中所存储的最小的数据项叫做单元（Unit）。而现在我们称其字段（Field）。单元分隔符 US 用于分割串行数据存储环境下的不同单元。</p><p>现在的数据库实现都要求大部分类型都拥有固定的长度，尽管有时候可能用不到，但是对于每一个字段，却都要分配足够大的空间，用于存放最大可能的数据。</p><p>这种做法的弊端就是占用了大量的存储空间，而 US 控制符允许字段具有可变的长度。在 1960s 年代，数据存储空间很有限，用 US 将不同单元分隔开，能节省很多空间。</p><h5 id="DEL-127"><a href="#DEL-127" class="headerlink" title="DEL (127)"></a>DEL (127)</h5><p>Delete，删除。</p><p>有人也许会问，为何 ASCII 编码中其它控制字符的值都很小（即 0~31），而 DEL 的值却很大呢（为 127）？</p><p>这是由于这个特殊的字符是为纸带而定义的。在那个年代，绝大多数的纸带都是用7个孔洞去编码数据的。而 127 这个值所对应的二进制值为111 1111（所有 7 个比特位都是1），将 DEL 用在现存的纸带上时，所有的洞就都被穿孔了，就把已经存在的数据都擦除掉了，就起到了删除的作用。</p><p>也有人将 ASCII 编码分成两部分：</p><ul><li>前 128 个字符称为基本 ASCII，包含常见字符；</li><li>后 128 个字符称为扩展 ASCII，包含一些特殊字符。</li></ul><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><h4 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h4><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值.比如如果是8位二进制:</p><p>[+1]~原~ = 0000 0001  第一位是0表示正数  （0~127）</p><p>[-1]~原~= 1000 0001    第一位是1表示负数  （-127~127）</p><p>第一位是符号位.因为第一位是符号位,所以8位二进制数的取值范围就是:<br>[1111 1111,0111 1111]<br>即<br>[-127,127]</p><h4 id="2-反码"><a href="#2-反码" class="headerlink" title="2.反码"></a>2.反码</h4><p>皮码的表示方法是:<br>正数的反码是其本身<br>负数的反码是在其原码的基础上，符号位不变，其余各个位取反.</p><p>[+1] = [0000 0001]~原~ = [0000 0001]~反~<br>[-1] = [1000 0001]~原~ = [1111 1110]~反~</p><h4 id="3-补码"><a href="#3-补码" class="headerlink" title="3.补码"></a>3.补码</h4><p>补码的表示方法是:正数的补码就是其本身<br>负数的补码是在其原码的基础上,符号位不变,其余各位取反，最后+1.(即在反码的基础上+1)</p><p>[+1] = [0000 0001]~原~ = [0000 0001]~反~ = [0000 0001]~补~<br>[-1] = [1000 0001]~原~ = [1111 1110]~反~ = [1111 1111]~补~</p><p><strong>==补码作用==</strong></p><p>方便计算机用加法的形式计算负数，简化CPU运算。</p><p>-1-2 = (-1) + (-2）= 0x1111 1111(补) + 0x1111 1110(补)= 0x1111 1101(补码)=0x1111 1100(反码)= 0x1000 0011(原码)= -3</p><p>补码的取值范围:<br>-128 ~ 127    对应    0x80 ~ 0x7F<br>-128 = 0x80(补码);<br>-2 = 0xFE(补码);<br>-1 = 0xFF(补码);</p><p>0= 0x00(补码);</p><p>1 = 0x01(补码);</p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>优先级从上到下依次递减，最上面具有最高的优先级，逗号操作符具有最低的优先级。</p><p>相同优先级中，按结合顺序计算。大多数运算是从左至右计算。</p><p>只有三个优先级是从右至左结合的，它们是<code>单目运算符</code>、<code>条件运算符</code>、<code>赋值运算符</code>。</p><p>基本的优先级需要记住：</p><p>指针最优，单目运算优于双目运算。如正负号。</p><p>先乘除（模），后加减。</p><p>先算术运算，后移位运算，最后位运算。</p><p><strong>同一优先级的运算符，运算次序由结合方向所决定。</strong><br><strong>简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</strong></p><p>请特别注意：1 &lt;&lt; 3 + 2 &amp; 7等价于 (1 &lt;&lt; (3 + 2))&amp;7.<br>逻辑运算最后计算。</p><p>i++优先级要大于++i</p><h4 id="单目运算符和双目运算符的区别"><a href="#单目运算符和双目运算符的区别" class="headerlink" title="单目运算符和双目运算符的区别"></a>单目运算符和双目运算符的区别</h4><p>单目运算符和双目运算符的区别只有一个，那就是操作数<code>（变量或[常量]）</code>数量的不同。</p><p>单目运算符只对<code>一个操作数进行[逻辑运算]</code>。</p><p>比如： num ++(自增) , num —（自减） , ! num（取非值） , ~ num（按位取反）。</p><p>双目运算符只对两个操作数进行逻辑运算。</p><p>比如： num1 + num2 , num1 - num2 , num1 &gt; num2 。</p><p><strong>扩展资料：</strong></p><p>除了单目和双目运算符，还有一个[三目运算符]。</p><p>三目运算符就是对三个操作数进行逻辑运算。</p><p>目前三目运算符只有一个：num1 = num1 &gt; 3 ? 1 : 2</p><p>这段程序的意思是：如果变量num1的值，大于3，那么变量num1的值就变为1，否则num1的值就变为2。</p><h4 id="运算符优先级表格"><a href="#运算符优先级表格" class="headerlink" title="运算符优先级表格"></a>运算符优先级表格</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230607131427556.png" alt="image-20230607131427556"></p><p><img src="file://C:/Users/Y/AppData/Roaming/Typora/typora-user-images/image-20230607131506078.png?lastModify=1686275551" alt="image-20230607131506078"></p><h3 id="算法运算符"><a href="#算法运算符" class="headerlink" title="算法运算符"></a>算法运算符</h3><h4 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1.赋值"></a>1.赋值</h4><p>基础理论：</p><p>符号为 <code>=</code> ，将右边的值赋给左边。</p><p>例如：a = 3；</p><p>​      b = a + 1;</p><p>==<strong>应用举例</strong>== </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ucTemp = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span></span><br><span class="line">      <span class="comment">//强制类型转换</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">cTemp = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The cTemp = %d\r\n&quot;</span>,(<span class="type">signed</span> <span class="type">int</span>)cTemp);</span><br><span class="line"></span><br><span class="line">usTemp = <span class="number">0xAA55</span>;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = 0x%x\r\n&quot;</span>,usTemp);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = %u\r\n&quot;</span>,usTemp);</span><br><span class="line"><span class="comment">//%u:以十进制无符号整形形式输出</span></span><br><span class="line">fTemp = <span class="number">0.25</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The fTemp = %.2f\r\n&quot;</span>,fTemp);</span><br></pre></td></tr></table></figure><h4 id="2-加减乘除法"><a href="#2-加减乘除法" class="headerlink" title="2.加减乘除法"></a>2.加减乘除法</h4><p>1、加法符号为 <code>+</code> ，将右边的各项相加，然后赋给左边。</p><p> 例如：a = 1 + 8;</p><p>2、减法符号为 <code>-</code> ，将右边的各项相减，然后赋给左边。</p><p> 例如：a = 8 - 1;</p><p>3、乘法符号为 <code>*</code> ，将右边的各项相乘，然后赋给左边。</p><p> 例如：a = 1 * 8;</p><p>4、除法符号为 <code>/</code> ，将右边的各项相除，然后赋给左边。</p><p> 例如：a = 8 / 3;</p><p>==<strong>Note：</strong>==</p><p> 1、单片机内部都有累加器ALU，做加减法较快，尽量<code>少使用乘除法</code>，以提高CPU的执行效率；</p><p> 2、整数相除时，<code>舍弃余数</code>。 比如：a = 8 / 3 ; a的值为2</p><p>==<strong>应用举例</strong>== </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line">ucTemp = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line">ucTemp = <span class="number">100</span> - <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法</span></span><br><span class="line">usTemp = <span class="number">100</span>*<span class="number">201</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = %u\r\n&quot;</span>,usTemp);</span><br><span class="line">fTemp = <span class="number">0.25</span>*<span class="number">0.18</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The fTemp = %f\r\n&quot;</span>,fTemp);</span><br><span class="line"><span class="comment">//除法</span></span><br><span class="line">usTemp = <span class="number">19</span>/<span class="number">7</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The usTemp = %u\r\n&quot;</span>,usTemp);</span><br><span class="line">fTemp = <span class="number">10</span>/<span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The fTemp = %f\r\n&quot;</span>,fTemp);</span><br></pre></td></tr></table></figure><h4 id="3-取余"><a href="#3-取余" class="headerlink" title="3.取余"></a>3.取余</h4><p>符号为 <code>%</code>，将右边的各项相除后的余数赋给左边。</p><p>例如：a = 8 % 3; a的值为2</p><p><strong>==Note：==</strong></p><p>除法与取余，通过配合使用，方便提取与转换数据。 </p><p>比如数据87，提取十位与个位，87/10 = 8 ,87%10 = 7</p><p>比如数据87，转化为16进制，0x(87/16)(87%16) = 0x57</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取余</span></span><br><span class="line">ucTemp = <span class="number">87</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ucTemp/<span class="number">10</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The gewei of ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ucTemp%<span class="number">10</span>)); <span class="comment">//提取十位与个位</span></span><br><span class="line"> </span><br><span class="line">usTemp = <span class="number">0x1234</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MSB of usTemp = 0x%x\r\n&quot;</span>,(usTemp/<span class="number">256</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The LSB of usTemp = 0x%x\r\n&quot;</span>,(usTemp%<span class="number">256</span>));</span><br><span class="line"><span class="comment">/*提取高字节和低字节</span></span><br><span class="line"><span class="comment">在编程语言中，字符一般是占16位，8位为一字节，所以有高位字节和低位字节。</span></span><br><span class="line"><span class="comment">一个16进制数有两个字节组成，例如：A9。</span></span><br><span class="line"><span class="comment">    高字节就是指16进制数的前8位（权重高的8位），如上例中的A。</span></span><br><span class="line"><span class="comment">低字节就是指16进制数的后8位（权重低的8位），如上例中的9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ulTemp = <span class="number">168752</span>;  <span class="comment">//把168752分别提取出来</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwangwei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ulTemp/<span class="number">100000</span>));<span class="comment">//十万位 直接除除于100000得到1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The wangwei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)((ulTemp%<span class="number">100000</span>)/<span class="number">10000</span>));   <span class="comment">//万位  对168752取余得到68752，再除于10000得到6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The qianwei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)((ulTemp%<span class="number">10000</span>)/<span class="number">1000</span>));   <span class="comment">//千位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The baiwei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)((ulTemp%<span class="number">1000</span>)/<span class="number">100</span>));   <span class="comment">//百位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)((ulTemp%<span class="number">100</span>)/<span class="number">10</span>));   <span class="comment">//十位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The gewei of ulTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ulTemp%<span class="number">10</span>));  <span class="comment">//个位</span></span><br></pre></td></tr></table></figure><h4 id="4-加一减一"><a href="#4-加一减一" class="headerlink" title="4.加一减一"></a>4.加一减一</h4><p>1、加1操作符号为 <code>++</code></p><p>例如：a++； ++a；</p><p><strong>a++优先级要大于++a</strong></p><p>同理：<strong>a—优先级要大于—a</strong></p><p>2、减1操作符号为 <code>--</code></p><p>例如：a—； —a；</p><p><strong>==Note：==</strong></p><p><code>++或--符号在前或在后，a的值最终结果都一样</code>。区别是如果用在判断语句里面，<code>符号在前时，a先加1或减1，再判断</code>；<code>符号在后时，a先判断，再加1或减1。</code></p><p>例如：a = 1；</p><p>if(a—) {括号内语句执行};</p><p>if(—a) {括号内语句不执行};</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加加</span></span><br><span class="line">ucTemp</span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;The shiwei of ucTemp++ = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ucTemp++))</span>; <span class="comment">//打印结果：3   ++在后面的话它是直接打印值，先不加一，所以这个值就是3了</span></span><br><span class="line">ucTemp = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ++ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(++ucTemp)); <span class="comment">//打印节果：4    ++在前面的话它是先加一，在打印，所以这个值就是4</span></span><br><span class="line"> </span><br><span class="line">    ucTemp = <span class="number">3</span>;</span><br><span class="line">ucTemp++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp++ = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp); <span class="comment">//打印结果：4</span></span><br><span class="line"></span><br><span class="line">ucTemp = <span class="number">3</span>;</span><br><span class="line">++ucTemp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ++ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp); <span class="comment">//打印结果：4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不管++在前面还是后面，他们的结果都是一样的，只是过程不一样</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//减减</span></span><br><span class="line">    ucTemp = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp-- = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(ucTemp--)); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp--= %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);  <span class="comment">//第一次打印100 第二次打印99</span></span><br><span class="line"> </span><br><span class="line">    ucTemp = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp-- = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(--ucTemp));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The shiwei of ucTemp-- = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp); <span class="comment">//两次打印结果都是99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不管--在前面还是后面，他们的结果都是一样的，只是过程不一样</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-组合应用"><a href="#5-组合应用" class="headerlink" title="5.组合应用"></a>5.组合应用</h4><p>1、a += 3； 等效于 a = a + 3；</p><p>2、a -= 3； 等效于 a = a - 3；</p><p>3、a <em>= 3； 等效于 a = a </em> 3；</p><p>4、a /= 3； 等效于 a = a / 3；</p><p>5、a %= 3； 等效于 a = a % 3；</p><p>==<strong>应用举例</strong>== </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ucTemp = <span class="number">100</span>;</span><br><span class="line">    ucTemp += <span class="number">50</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line">ucTemp -= <span class="number">50</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line">ucTemp *= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line">ucTemp /= <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line"></span><br><span class="line">ucTemp %= <span class="number">3</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br><span class="line">ucTemp = ((((ucTemp+<span class="number">30</span>)<span class="number">-50</span>)*<span class="number">3</span>)/<span class="number">5</span>)%<span class="number">7</span>;  <span class="comment">//尽管有优先级，但是我们还是可以用括号给它区分开来。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp = %u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucTemp);</span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><h4 id="一、-等于或不等于"><a href="#一、-等于或不等于" class="headerlink" title="一、 等于或不等于"></a>一、 等于或不等于</h4><p>基础理论：</p><p>符号为 <code>==</code> 与 <code>!=</code> </p><p>例如：a = 3；</p><p>​     if(a == 3) { <strong>运行</strong> };</p><p>​     if(a != 3){ <strong>不运行</strong> }; </p><p>Note:注意 == 与 = 的区别，= 号是赋值运算符，== 是关系运算符。 比如，if(a = 3)是错误的表达式，if(a == 3)是正确的表达式。</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// == 与 !=</span></span><br><span class="line">ucTemp = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ucTemp == <span class="number">10</span>) <span class="comment">//判断是不是等于10，是则输出，不是则不输出。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp == 10\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ucTemp != <span class="number">10</span>) <span class="comment">//判断是不是不等于10，是则输出，不是则不输出。</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The ucTemp != 10\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、-大于或大于等于"><a href="#二、-大于或大于等于" class="headerlink" title="二、 大于或大于等于"></a>二、 大于或大于等于</h4><p>基础理论：</p><p>符号为  <code>&gt;</code>  与  <code>&gt;=</code></p><p>例如：a = 3；</p><p>​     if(a &gt;= 3) { <strong>运行</strong> };</p><p>​     if(a &gt; 4){ <strong>不运行</strong> }; </p><h4 id="三、小于或小于等于"><a href="#三、小于或小于等于" class="headerlink" title="三、小于或小于等于"></a>三、小于或小于等于</h4><p>基础理论：</p><p>符号为  <code>&lt;</code>  与  <code>&lt;=</code></p><p>例如：a = 3；</p><p>​     if(a &lt;= 3) { <strong>运行</strong> };</p><p>​     if(a &lt; 3){ <strong>不运行</strong> }; </p><p>==<strong>应用举例</strong>== </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&gt; &gt;= &lt; &lt;=</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> （<span class="number">1</span>）</span><br><span class="line">    &#123;</span><br><span class="line">Delay_ms(<span class="number">1</span>);</span><br><span class="line">ucMiao++;</span><br><span class="line"><span class="keyword">if</span>(ucMiao == <span class="number">60</span>) <span class="comment">//判断是否等于60，是则清0，反之则否。</span></span><br><span class="line">&#123;</span><br><span class="line">ucMiao = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++ucFen &gt; <span class="number">59</span>) <span class="comment">//判断是否大于59，是则清0，反之则否。</span></span><br><span class="line">&#123;</span><br><span class="line">ucFen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(++ucShi &gt;= <span class="number">24</span>)  <span class="comment">//判断是否大于等于等于，是则清0，反之则否。</span></span><br><span class="line">&#123;</span><br><span class="line">ucShi = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The current time is %u:%u:%u\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)ucShi,(<span class="type">unsigned</span> <span class="type">int</span>)ucFen,(<span class="type">unsigned</span> <span class="type">int</span>)ucMiao);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、-三目运算符"><a href="#四、-三目运算符" class="headerlink" title="四、 三目运算符"></a>四、 三目运算符</h4><p>基础理论：</p><p>三目运算符，又称条件运算符，是唯一一个有3个操作数的运算符，有时又称为三元运算符，一般用于赋值语句中。</p><p><strong>==形式：条件表达式1  ?  表达式2  :  表达式3==</strong></p><p>求值规则：<strong>如果表达式1为真，则执行表达式2，并返回表达式2的结果；如果表达式1为假，则执行表达式3，并返回表达式3的结果.</strong></p><p>例如：</p><p>MAX = (a &gt; b) ? a : b</p><p>如果a&gt;b,MAX = a; </p><p>如果a&lt;b,MAX = b; </p><p>如此，MAX取a与b中较大的值。</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求值规则：如果表达式1为真，则执行表达式2，并返回表达式2的结果；如果表达式1为假，则执行表达式3，并返回表达式3的结果.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">100</span>,MAX;</span><br><span class="line">    </span><br><span class="line">MAX = (a&gt;b)?a:b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line">MAX = (a&lt;b)?b:a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line">MAX = (a&gt;=b)?a:b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line">MAX = (a&lt;=b)?b:a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX); </span><br><span class="line">    <span class="comment">//结果都是一样的</span></span><br><span class="line"></span><br><span class="line">MAX = b;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b)</span><br><span class="line">&#123;</span><br><span class="line">MAX = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line"></span><br><span class="line">MAX = a;</span><br><span class="line"><span class="keyword">if</span>(a&lt;b)</span><br><span class="line">&#123;</span><br><span class="line">MAX = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(a&gt;=b)</span><br><span class="line">&#123;</span><br><span class="line">MAX = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">MAX = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The MAX = %u\r\n&quot;</span>,MAX);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><h4 id="一、-逻辑与或非"><a href="#一、-逻辑与或非" class="headerlink" title="一、 逻辑与或非"></a>一、 逻辑与或非</h4><p>基础理论：</p><p>逻辑与或非，运算对象是布尔值(==1或0，真或假==)，类似于数字电路的与门，或门，非门。与关系运算符配合，一般用于选择语句与循环语句中</p><p>1、逻辑与</p><p>符号为 <code>&amp;&amp;</code>。 参与运算的两个表达式都为真时，结果才为真，否则为假。</p><p>例如：</p><p>uint8_t a = 3,b=5;</p><p>if((a == 3) &amp;&amp; (b == 5))</p><p>{执行};</p><p>2、逻辑或</p><p>符号为 <code>||</code> 。 参与运算的两个表达式只要有一个为真，结果就为真；两个表达式都为假时结果才为假。</p><p>例如：</p><p>uint8_t a = 4,b=5;</p><p>if((a == 3) || (b == 5))</p><p>{执行};</p><p>3、逻辑非</p><p>符号为 <code>!</code> 。 参与运算的表达式为真时，结果为假；参与运算的表达式为假时，结果为真。</p><p>例如：</p><p><strong>1为真，0为假</strong></p><p>bit Flag = 0; </p><p>if(!Flag)         <strong>//结果是1，就执行</strong></p><p>{执行};</p><p>bit Flag = 1;</p><p>if(!Flag)         <strong>//结果是0，不执行</strong></p><p>{不执行}; </p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a    = <span class="number">0x10</span>;</span><br><span class="line">bit           Flag = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逻辑与   -&gt;   &amp;&amp;</span></span><br><span class="line"><span class="keyword">if</span>((a == <span class="number">0x10</span>) &amp;&amp; (Flag == <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//逻辑或   -&gt;   ||</span></span><br><span class="line"><span class="keyword">if</span>((a == <span class="number">3</span>) || (Flag == <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//死循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1 = ~P1;</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非   -&gt;   !</span></span><br><span class="line"><span class="keyword">if</span>(!Flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//死循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1 = ~P1;</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与或非组合使用</span></span><br><span class="line"><span class="keyword">if</span>(!(((a == <span class="number">3</span>) &amp;&amp; (Flag == <span class="number">1</span>)) || (a == <span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、-按位与或反"><a href="#二、-按位与或反" class="headerlink" title="二、 按位与或反"></a>二、 按位与或反</h4><p>基础理论：</p><p>按位与或反，运算对象是8位，16位或32位的整型数据，运算数据的每一比特位按逻辑与或非操作。</p><p>1、按位与</p><p>符号为&amp;。参与运算的两个数据按二进制位进行逻辑与操作。</p><p>(1) <code>按位与（AND）：&amp;</code></p><p>==<strong>一定要将&amp;与&amp;&amp;区分开来，后者是逻辑与</strong>== </p><p>（2）按位与的定义是：同一二进制位上的数字都是1的话，&amp;的结果为1，否则为0.</p><p>​        ==0 &amp; 0 = 0==</p><p>​        ==0 &amp; 1 = 0==</p><p>​        ==1 &amp; 1 = 1==</p><p>(3）根据这个特性，==&amp;操作常常用来屏蔽特定的二进制位==。例如：</p><p>  0000 1111 &amp; 0000 0011</p><p>  结果为0000 0011</p><p>可以看见，1111的前两位被屏蔽成为0了。</p><p>所以如果想清空数据，只需要将原二进制数与上0就可以了。0的位数对应原二进制数的位数，对各位进行屏蔽，全部置0.</p><p>相对的，==&amp;可以利用0来屏蔽，也可以用1来读取==。</p><p>​     例如： 一个二进制数 1101 1001，我只想要它的后四位，怎么办呢？</p><p>​     只需要进行如下操作：1101 1001 &amp; 0000 1111即可。</p><p>​     其实该方法是屏蔽和读取的结合，&amp;0保证消除无用位，&amp;1保证有用数据的完整性。</p><pre><code> **==总结：对于原二进制数来说，&amp;0是屏蔽，&amp;1是不变。==**</code></pre><p>例如：</p><p>uint8_t  a = 0xAA   (1010 1010), b=0x55   (0101 0101), c;</p><p>c = a &amp; b = 0x00;   (0000 0000)</p><p>特殊应用：</p><p>==清零指定比特位==</p><p>清零第0位： 运算数据 &amp; 0xFE   //1111 1110   ~(0x01 &lt;&lt; 0)</p><p>清零第1位： 运算数据 &amp; 0xFD  //1111 1101   ~(0x01 &lt;&lt; 1)</p><p>清零第2位： 运算数据 &amp; 0xFB  //1111 1011   ~(0x01 &lt;&lt; 2)</p><p>清零第3位： 运算数据 &amp; 0xF7  //1111 0111   ~(0x01 &lt;&lt; 3)</p><p>清零第4位： 运算数据 &amp; 0xEF  //1110 1111   ~(0x01 &lt;&lt; 4)</p><p>清零第5位： 运算数据 &amp; 0xDB //1101 1111   ~(0x01 &lt;&lt; 5)</p><p>清零第6位： 运算数据 &amp; 0xB7  //1011 1111   ~(0x01 &lt;&lt; 6)</p><p>清零第7位： 运算数据 &amp; 0x7F  //0111 1111   ~(0x01 &lt;&lt; 7)</p><p>2、按位或</p><p>符号是  | 。 参与运算的两个数据按二进制位进行逻辑或操作。</p><p>(1)<code>按位或(OR)：|</code></p><p>==同样，不要将  <strong>“|”</strong>  和  <strong>“||”</strong>  (逻辑或)搞混。==</p><p>（1）定义：只要参与运算的双方其中有一个是1，结果就是1.同0才为0.</p><p>​        ==0 | 0 = 0==</p><p>​        ==0 | 1 = 1==</p><p>​        ==1 | 0 = 1==</p><p>​        ==1 | 1 = 1==</p><p>（2）特殊用处：</p><p>==<strong>将某些特定位置1</strong>==</p><p>例如：1010 0000 | 0000 1111</p><p>结果为 1010 1111</p><p><strong>==总结：对于原二进制数来说，| 0是不变，| 1是置1==</strong></p><p>例如：</p><p>uint8_t  a = 0xAA   (1010 1010), b=0x55  (0101 0101), c;</p><p>c = a | b = 0xFF;   (1111 1111)</p><p>特殊应用：</p><p>==置位指定比特位==</p><p>置位第0位： 运算数据 | 0x01   //0000 0001    (0x01 &lt;&lt; 0)</p><p>置位第1位： 运算数据 | 0x02  //0000 0010    (0x01 &lt;&lt; 1)</p><p>置位第2位： 运算数据 | 0x04  //0000 0100    (0x01 &lt;&lt; 2)</p><p>置位第3位： 运算数据 | 0x08  //0000 1000    (0x01 &lt;&lt; 3)</p><p>置位第4位： 运算数据 | 0x10  //0001 0000    (0x01 &lt;&lt; 4)</p><p>置位第5位： 运算数据 | 0x20  //0010 0000    (0x01 &lt;&lt; 5)</p><p>置位第6位： 运算数据 | 0x40  //0100 0000   (0x01 &lt;&lt; 6)</p><p>置位第7位： 运算数据 | 0x80  //1000 0000    (0x01 &lt;&lt; 7)</p><p>3、按位取反</p><p>符号为 <code>~</code> 。 参与运算的数据按二进制位进行逻辑非操作。</p><p><strong>==对一个二进制数进行取反。1变0，0变1==</strong></p><p>唯一需要注意的一点是，<strong>~ 的优先级是逻辑运算符中最高的，必须优先计算。</strong></p><p>例如：</p><p>uint8_t a = 0xAA, b=0x55,c;</p><p>c = ~a = 0x55;</p><p>c = ~b = 0xAA;</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位与</span></span><br><span class="line">P1 = <span class="number">0xFF</span>;</span><br><span class="line">P1 = P1 &amp; <span class="number">0xFE</span>; <span class="comment">//1111 1110</span></span><br><span class="line">P1 = P1 &amp; <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位或</span></span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line">P1 = P1 | <span class="number">0xAA</span>; <span class="comment">//1010 1010</span></span><br><span class="line">P1 = P1 | <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line">取反</span><br><span class="line">P1 = <span class="number">0xAA</span>;</span><br><span class="line">P1 = ~P1;</span><br><span class="line">P1 = ~P1;</span><br><span class="line">P1 = ~P1;</span><br><span class="line">P1 = ~P1;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、-按位异或"><a href="#三、-按位异或" class="headerlink" title="三、 按位异或"></a>三、 按位异或</h4><p>基础理论：</p><p>符号为 ^ ,参与运算的两个数据按二进制位进行“异或”运算。</p><ol><li><p><code>按位异或：^</code> </p><p>^ 这个符号我们常用来表示次方。不过在计算机中，它代表的就不是次方的意思了。</p></li></ol><p>（1）定义</p><p>只要参与运算的双方互异，结果就为1，否则为0</p><p><mark>0 ^ 1 = 1</mark></p><p><mark>1 ^ 0 = 1</mark></p><p><mark>0 ^ 0 = 0</mark></p><p><mark>1 ^ 1 = 0</mark></p><p>(2).用法</p><p>​       可以通过上面的定义看到，<strong>一个数 ^ 1的话就会0变成1，1变成0，而 ^ 0则不对原数进行改变。所以根据此特性可以对特定位进行0 1 反转。</strong></p><p>例如： 1100 1100 ^ 0000 1100</p><p>结果为 1100  0000.</p><p>同样的，如果对一个数进行^0,代表保留原值。</p><p>==<strong>总结：对于原二进制数来说，^ 0是不变，^ 1是反转。</strong>==</p><p>例如：</p><p>uint8_t a = 0xAA,b=0x55,c;</p><p>c = a^b = 0xFF;</p><p>uint8_t a = 0xFF,b=0xFF,c;</p><p>c = a^b = 0x00;</p><p>==特殊应用==：</p><p>取反指定比特位</p><p>取反第0位： 运算数据 ^ 0x01   //0000 0001    (0x01 &lt;&lt; 0)</p><p>取反第1位： 运算数据 ^ 0x02  //0000 0010   (0x01 &lt;&lt; 1)</p><p>取反第2位： 运算数据 ^ 0x04  //0000 0100   (0x01 &lt;&lt; 2)</p><p>取反第3位： 运算数据 ^ 0x08  //0000 1000   (0x01 &lt;&lt; 3) </p><p>取反第4位： 运算数据 ^ 0x10  //0001 0000   (0x01 &lt;&lt; 4)</p><p>取反第5位： 运算数据 ^ 0x20  //0010 0000   (0x01 &lt;&lt; 5)</p><p>取反第6位： 运算数据 ^ 0x40  //0100 0000   (0x01 &lt;&lt; 6)</p><p>取反第7位： 运算数据 ^ 0x80  //1000 0000   (0x01 &lt;&lt; 7)</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或</span></span><br><span class="line">P1 = <span class="number">0xFF</span>;</span><br><span class="line">P1 = P1 ^ <span class="number">0x01</span>; <span class="comment">//取反第0位</span></span><br><span class="line">P1 = P1 ^ <span class="number">0x01</span>;</span><br><span class="line">P1 = P1 ^ <span class="number">0x01</span>;</span><br><span class="line">P1 = P1 ^ <span class="number">0x01</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#123;</span><br><span class="line">P1 = <span class="number">0x00</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1 = P1 ^ <span class="number">0x01</span>; <span class="comment">//0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">P1 = P1 ^ <span class="number">0x02</span>; <span class="comment">//0000 0010</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">P1 = P1 ^ <span class="number">0x04</span>; <span class="comment">//0000 0100</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">P1 = P1 ^ <span class="number">0x08</span>; <span class="comment">//0000 1000</span></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、左移与右移"><a href="#四、左移与右移" class="headerlink" title="四、左移与右移"></a>四、左移与右移</h4><p>基础理论：</p><p>符号为 &lt;&lt; 与 &gt;&gt; ,运算对象是8位，16位或32位的整型数据， 把数据向左或向右移动若干位。<code>向左移动时，高位溢出，低位补0；向右移动时，低位溢出，高位补0,。</code></p><p><code>左移  &lt;&lt;</code>   <code>右移  &gt;&gt;</code>               </p><p>左移与右移比较类似，是将目标二进制数字向左/右移动相应的位数。</p><p>左移补0：1111 1111 &lt;&lt;1 == 1111 1110,换算十进制的话是原来数值的2倍。</p><p> 右移看情况：负数补1，正数补0 <code>需要看符号位</code>。同样，换算为十进制数值变为原来的1/2</p><p><code>左移不用看符号位</code>：因为左移定义是，每个移出的位进入进位标志，右边填充0，无论是有符号数还是无符号数都这么操作，这是规定。那么，这样的操作对有符号数和无符号数的结果都是一样的，所以左移不分有符号数还是无符号数。</p><p><strong>左移、右移其实就是乘或除2，这个不影响符号，所以==负数的右移补符号位，保证是负数==。</strong></p><p>==<strong>总结：左乘右除</strong>==</p><p>例如：</p><p>uint8_t a = 0xCB, c;   (1100 1011)  </p><p>c = a &lt;&lt; 5 = 0x60;    左移五位  结果为 （0110 0000）</p><p>c = a &gt;&gt; 3 = 0x19；  右移三位  结果为（0001 1001）</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">P1 = <span class="number">0xFF</span>; <span class="comment">// 1111 1111</span></span><br><span class="line"><span class="comment">//移位  &gt;&gt;  &lt;&lt;  流水灯</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P1 &lt;&lt;= <span class="number">1</span>; <span class="comment">//1111 1110</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &lt;&lt;= <span class="number">1</span>; <span class="comment">//1111 1100</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &lt;&lt;= <span class="number">1</span>; <span class="comment">//1111 1000</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &lt;&lt;= <span class="number">1</span>; <span class="comment">//1111 0000</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &gt;&gt;= <span class="number">1</span>; <span class="comment">//0111 1000</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &gt;&gt;= <span class="number">1</span>; <span class="comment">//0011 1100</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &gt;&gt;= <span class="number">1</span>; <span class="comment">//0001 1110</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">P1 &gt;&gt;= <span class="number">1</span>; <span class="comment">//0000 1111</span></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h3><h4 id="一、基本语句"><a href="#一、基本语句" class="headerlink" title="一、基本语句"></a>一、基本语句</h4><p>1、表达式语句，以分号<code>&quot;;&quot;</code>结束。</p><p>例如：</p><p>语句1：a += 2；</p><p>语句2：printf(“Hello world”)；</p><p>2、复合语句，由若干个表达式语句组成，用大括号<code>&quot;&#123;&#125;&quot;</code>组合起来而形成的功能块。 复合语句不需要以分号<code>&quot;;&quot;</code>结束，但内部的表达式语句需要以分号<code>&quot;;&quot;</code>结束</p><p>例如：</p><p>{  </p><p>  语句1；</p><p>  语句2；</p><p>   ……</p><p>}</p><h4 id="二、选择语句"><a href="#二、选择语句" class="headerlink" title="二、选择语句"></a>二、选择语句</h4><p>基础理论：</p><p>1、if语句</p><p>if(条件表达式)</p><p>{</p><p>  语句</p><p>}</p><p>执行过程：==<strong>如果条件表达式为真，执行语句；为假，不执行语句</strong>==</p><p>2、if - else语句</p><p>if(条件表达式)</p><p>{</p><p>  语句1</p><p>}</p><p>else</p><p>{</p><p>   语句2</p><p>}</p><p>执行过程：==<strong>如果条件表达式为真，执行语句1；为假，执行语句2</strong>==</p><p>3、if嵌套语句</p><p>嵌套一：</p><p>if(条件表达式1)</p><p>{</p><p>  if(条件表达式2)</p><p>  {</p><p>​     if(条件表达式3)</p><p>​     {</p><p>​      。。。</p><p>​     }</p><p>  }</p><p>}</p><p>嵌套二：</p><p>if(条件表达式1)</p><p>{  </p><p>  if(条件表达式2)</p><p>  {</p><p>  }</p><p>  else  </p><p>  {</p><p>  }</p><p>}</p><p>嵌套三：</p><p>if(条件表达式1)</p><p>{ </p><p>  if(条件表达式2)</p><p>  {</p><p>  }</p><p>}  </p><p>else</p><p>{  </p><p>  if(条件表达式3)</p><p>  {</p><p>  }</p><p>}</p><h4 id="三、开关语句"><a href="#三、开关语句" class="headerlink" title="三、开关语句"></a>三、开关语句</h4><p>基础理论：</p><p>开关语句是一种<code>多分支选择语句</code>，通常用于状态机编程中，形式如下：</p><p>switch(条件表达式)</p><p>{</p><p>  case 常量表达式1： 语句1；</p><p>  case 常量表达式2： 语句2；</p><p>  。。。</p><p>  case 常量表达式n： 语句n;</p><p>  default: 语句d;</p><p>}</p><p>执行过程：<strong>将条件表达式与case后面各个常量表达式的值逐个进行比较，若相等，则执行相应case后面的语句(包括后面的case与default分支语句)，若全部不相等，则执行default后面的语句。</strong> </p><p>==Note==:</p><p>1、==<strong>case分支语句通常以break语句结尾，确保只执行一个分支；</strong>==</p><p>2、==break语句通常用在循环语句和开关语句中。==</p><p>（1） <strong>循环语句</strong>一般是for循环，while循环，do-while循环。当break语句用于这些循环语句中，可使程序终止循环而执行循环后面的语句，通常break语句总是与if语句连在一起，即满足条件时便跳出循环</p><p>（2）<strong>开关语句</strong>一般是switch语句。当break用于开关语句switch语句中时，可使程序跳出switch而执行switch以后的语句；若没有break语句，则就会从匹配的标签开始执行到switch末尾。</p><p>3、case分支语句为复合语句时，可以加大括号”{}”，也可以不加。</p><p>switch(条件表达式)</p><p>{</p><p>  case 常量表达式1： 语句1；break；</p><p>  case 常量表达式2： 语句2；break</p><p>  。。。</p><p>  case 常量表达式n： {语句n；break;}</p><p>  default: 语句d;</p><p>}</p><p>应用于状态机：</p><p>switch(状态机状态)</p><p>{  </p><p>  case STA1： 状态机状态 = STA2;break；</p><p>  case STA2： 状态机状态 = STA3;break</p><p>  case STA3： 状态机状态 = STA4;break</p><p>  。。。</p><p>  case STAn： 状态机状态 = STA1;break；</p><p>  default: 语句d;</p><p>}</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(uSTA_Status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STA1: <span class="built_in">printf</span>(<span class="string">&quot;The STA machine in STA1\r\n&quot;</span>);uSTA_Status = STA3;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA2: <span class="built_in">printf</span>(<span class="string">&quot;The STA machine in STA2\r\n&quot;</span>);uSTA_Status = STA4;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA3: <span class="built_in">printf</span>(<span class="string">&quot;The STA machine in STA3\r\n&quot;</span>);uSTA_Status = STA2;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA4: <span class="built_in">printf</span>(<span class="string">&quot;The STA machine in STA4\r\n&quot;</span>);uSTA_Status = STA5;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA5: <span class="built_in">printf</span>(<span class="string">&quot;The STA machine in STA5\r\n&quot;</span>);uSTA_Status = STA1;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:uSTA_Status = STA1;</span><br><span class="line">&#125;</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="四、while-循环语句"><a href="#四、while-循环语句" class="headerlink" title="四、while 循环语句"></a>四、while 循环语句</h4><p>基础理论：</p><p>1、while循环语句</p><p>while(表达式)</p><p>{</p><p>  语句；</p><p>}</p><p>==<strong>执行过程：</strong>==</p><p>1、若表达式为真，执行语句</p><p>2、反复判断表达式，若为真，反复执行语句</p><p>3、若表达式为假，则退出循环，继续往下执行</p><p>死循环：</p><p>while(1)</p><p>{</p><p>  语句；</p><p>}</p><p>==Note==：</p><p>==while循环通常可与break，continue等语句配合使用==</p><p>break:退出循环体</p><p>continue：中断语句，中断本次循环</p><p>break与continue的对比：break 用来结束所有循环，循环语句不再有执行的机会；continue 用来结束本次循环，直接跳到下一次循环，如果循环条件成立，还会继续循环。</p><p>可以退出的死循环：</p><p>while(1)</p><p>{</p><p>  语句；</p><p>  if(条件表达式)</p><p>  {</p><p>​    break; //退出循环</p><p>  }</p><p>}</p><p>计算1到100的偶数和。</p><p>unsigned char i;</p><p>unsigned int sum = 0;</p><p>i = 1;</p><p>while(i&lt;=100)</p><p>{</p><p>  if((i%2) == 1)</p><p>  {</p><p>​    i++;</p><p>​    continue; //中断本次循环，从新判断表达式</p><p>  }</p><p>  sum += i++;  </p><p>}</p><p>2、do - while语句循环语句</p><p>do</p><p>{</p><p>  语句；</p><p>}</p><p>while(表达式);</p><p>==执行过程：==</p><p>1、执行语句；</p><p>2、反复判断表达式，若为真，反复执行语句；</p><p>3、若表达式为假，则退出循环，继续往下执行。</p><p>特殊应用，只执行一次的循环：</p><p>do</p><p>{</p><p>  语句；</p><p>}</p><p>while(0); </p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循序  -  1到100的和</span></span><br><span class="line">i   = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of sum: %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)sum);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//while循序  -  1到100的偶数和</span></span><br><span class="line">i   = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((i%<span class="number">2</span>) == <span class="number">1</span>) <span class="comment">//如果i为奇数</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">continue</span>;  <span class="comment">//中断本次循环，从新判断表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum += i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of sum: %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)sum);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//do - while循序  -  1到100的和</span></span><br><span class="line">i   = <span class="number">1</span>;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of sum: %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)sum);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><code>sum += i; i++;</code> 和 <code>sum += i++;</code> 的结果是相同的，因为它们都是累加变量 i 的值到sum中，并且在执行完这个操作后，将 i 的值加1。</p><p>在第一种情况下，先执行了<code>sum += i;</code>的操作，然后才执行<code>i++;</code>的操作。而在第二种情况下，<code>i++</code>操作被包含在<code>sum += i++;</code>中，所以先累加 i 的值到sum中，然后再将 i 的值加1。</p><p>注意，这两种写法虽然结果一样，但意义上还是有区别的。在第一种写法中，先将 i 的值累加到sum中，然后再对 i 的值进行加1操作；而在第二种写法中，是先将 i 的值加1，然后再将其累加到sum中。所以，在实际编程中，我们需要根据代码逻辑的需求选择正确的写法。</p><h4 id="五、for-循环语句"><a href="#五、for-循环语句" class="headerlink" title="五、for 循环语句"></a>五、for 循环语句</h4><p>基础理论：</p><p>==语句结构==：</p><p>for([初值设定表达式]; [循环条件表达式]; [更新表达式])</p><p>{</p><p>  语句；</p><p>}</p><p>==执行过程==：</p><p>1、初值设定表达式；</p><p>2、判断循环条件表达式，为真，执行语句；为假，退出循环；</p><p>3、执行更新表达式；</p><p>4、重复步骤2与步骤3，直到循环条件表达式为假，退出循环。</p><p>举例：</p><p>计算1到100的和。</p><p>unsigned char i;</p><p>unsigned int sum = 0;</p><p>for(i=1;i&lt;=100;i++)</p><p>{</p><p>  sum += i;</p><p>}</p><p>for(i=1;i&lt;=100;)</p><p>{</p><p>  sum += i;</p><p>  i++;</p><p>}</p><p><code>死循环</code></p><p>for(;;)</p><p>{</p><p>  语句； </p><p>}</p><p><code>可以退出的死循环</code></p><p>for(;;)</p><p>{</p><p>  语句；</p><p>  if(条件表达式)</p><p>  {</p><p>​    break; //退出循环</p><p>  }</p><p>}</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环  -  1到100的和</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>,sum=<span class="number">0</span>; i&lt;= <span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The value of sum: %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)sum);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h4><p>形式参数（Formal Parameter），简称形参，是指函数或方法定义中用于接收调用者传入的参数的参数列表中的参数。在函数或方法被调用之后，实参（实际参数）通过这些形参来传递给函数或方法。</p><p>举个例子，下面是一个求两个整数之和的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>a</code>和<code>b</code>就是形参。在函数被调用时，我们需要传入两个整数作为实参，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，1和2就是实参，它们会传递给函数中的形参a和b，然后函数计算结果并返回。</p><p>形参在函数定义时就已经确定了，它们的作用域仅限于函数内部，在函数外部无法访问。使用形参能让函数更加灵活、通用，因为函数可以接受不同类型和数量的参数，并据此进行相应的操作。</p><h4 id="一、函数的定义"><a href="#一、函数的定义" class="headerlink" title="一、函数的定义"></a>一、函数的定义</h4><p>函数是一段可以重复使用的功能代码，用来独立地完成某个功能。</p><p>==作用：==</p><p>简化代码，方便阅读</p><p>重复利用，提高效率</p><p>函数定义的一般形式：</p><p>函数类型 函数名(形参列表)</p><p>{</p><p>  函数体；</p><p>}</p><p>1、函数类型</p><p>函数的返回值类型。</p><p><code>void</code>:空类型，无返回值</p><p><code>unsigned char</code>：返回无符号字符型</p><p><code>float</code>：返回浮点型</p><p><code>unsigned int*</code> ：返回指向无符号整型的指针</p><p>2、函数名</p><p>==函数的名字，需要根据功能规范命名。==</p><p>LED_ON</p><p>LED_OFF</p><p>Delay_ms</p><p>System_Init</p><p>3、形参列表</p><p>==函数被调用时，传递的参数，可以没有，也可以多个。==</p><p>(void):空类型，无传递参数 </p><p>(unsigned char LEN,float ADC):2个形参</p><p>(float* pfADC):指针形参</p><p>4、函数体</p><p>函数的具体功能实现</p><p>形式如下:</p><p>{</p><p>  [局部变量定义] </p><p>  复合语句</p><p>  [return 返回值]</p><p>}</p><p>补充：</p><p>==全局变量:作用范围为全部，一般为整个c文件==</p><p>==局部变量:作用范围为局部，一般为内部函数==</p><p>尽量使用局部变量，让代码可移植性更高</p><p>在编写程序时，尽量使用局部变量的主要原因是为了减少不必要的内存消耗和减小程序的复杂度。下面是一些具体的原因：</p><ol><li><strong>节省内存</strong>: 使用局部变量可以减少内存占用，因为程序在函数调用完成后会自动释放局部变量，而全局变量、静态变量等则会一直存在于内存中，导致内存占用量增加。</li><li><strong>避免命名冲突</strong>: 局部变量的作用域仅在其定义的代码块中，不会影响其他函数或模块的变量，避免了不同变量之间的命名冲突。</li><li><strong>提高代码可读性</strong>: 通过使用局部变量，可以将变量的作用域限制在函数范围内，从而使函数的功能更加清晰。</li><li><strong>提高代码健壮性</strong>: 局部变量只在函数中使用，不受外界干扰，因此更容易维护和调试，也更符合程序设计的单一职责原则。</li><li><strong>提高程序效率</strong>: 局部变量的生命周期比较短，因此在函数调用结束后会自动释放，减少了内存的使用和分配，从而提高了程序的效率。</li></ol><p>总之，尽量使用局部变量可以减少程序的内存占用、提高代码可读性和健壮性，优化代码执行效率等方面有着重要的作用。但也需要注意，在需要大量访问的变量上适当使用全局变量和静态变量</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">* @name   Sum</span></span><br><span class="line"><span class="comment">* @brief  求和</span></span><br><span class="line"><span class="comment">* @param  Value    -&gt; 计算1到Value的和</span></span><br><span class="line"><span class="comment">* @retval Temp_Sum -&gt; 计算结果      </span></span><br><span class="line"><span class="comment"> ************************************************/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//局部变量定义</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Temp_Sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,Temp_Sum=<span class="number">0</span>; i&lt;=Value; i++)</span><br><span class="line">&#123;</span><br><span class="line">Temp_Sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">return</span> Temp_Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二-函数调用与声明"><a href="#二-函数调用与声明" class="headerlink" title="二 函数调用与声明"></a>二 函数调用与声明</h4><p>基础理论：</p><p>1、函数调用</p><p>调用形式如下：</p><p>函数名(实际参数表)</p><p><code>无返回值的函数，直接调用：</code></p><p>Delay_ms(100); //延时100ms</p><p>LED_ON(); //打开LED</p><p><code>有返回值的函数，可以用于表达式或作为其他函数的形参:</code></p><p>a = Sum(100); //计算1到100的和，然后赋给a</p><p>Temperature = Lookup_Table(Get_ADC(ADC1)) //查表获取温度</p><p>2、函数声明</p><p>1、被调用的函数位于调用函数的后面；</p><p>2、被调用的函数位于其他C文件</p><p>==声明形式如下==：</p><p>[extern] void LED_ON(void);</p><p>[extern] void Delay_ms(uisigned int);</p><p>[extern] unsigned int Sum(unsigned char);</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Delay_ms</span></span><br><span class="line"><span class="comment">* @brief  毫秒延时函数</span></span><br><span class="line"><span class="comment">* @param  ms -&gt; 需要延时的时间</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ms;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1575</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************</span></span><br><span class="line"><span class="comment">* @name   Sum</span></span><br><span class="line"><span class="comment">* @brief  求和</span></span><br><span class="line"><span class="comment">* @param  Value    -&gt; 计算1到Value的和</span></span><br><span class="line"><span class="comment">* @retval Temp_Sum -&gt; 计算结果      </span></span><br><span class="line"><span class="comment"> ************************************************/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//局部变量定义</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Temp_Sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数体</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,Temp_Sum=<span class="number">0</span>; i&lt;=Value; i++)</span><br><span class="line">&#123;</span><br><span class="line">Temp_Sum += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="keyword">return</span> Temp_Sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*Sys_LED_ON();</span></span><br><span class="line"><span class="comment">Delay_ms(100); </span></span><br><span class="line"><span class="comment">Sys_LED_OFF();</span></span><br><span class="line"><span class="comment">Delay_ms(100);*/</span>  <span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">Sys_LED_ON();</span><br><span class="line">Delay_ms(Sum(<span class="number">10</span>));</span><br><span class="line">Sys_LED_OFF();</span><br><span class="line">Delay_ms(Sum(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、内部函数与外部函数"><a href="#三、内部函数与外部函数" class="headerlink" title="三、内部函数与外部函数"></a>三、内部函数与外部函数</h4><p>基础理论：</p><p> 1、内部函数</p><p>用<code>static</code>声明，不能被外部函数调用  (起到保护作用)</p><p>2、外部函数</p><p>用<code>extern</code>声明，可以被外部函数(其他C文件)调用。</p><p>Note：</p><p>函数默认为extern</p><p>调用外部函数时，需要进行声明，一般用==头文件声明==</p><p><code>.h</code> 生成头文件</p><p>#include <Public.h></p><p>#include <LED.h> </p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> Count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The count = %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Count++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment">没有static 输出结果为0；</span></span><br><span class="line"><span class="comment">每次调用形参都会重新初始化，重新分配内存，所以为0</span></span><br><span class="line"><span class="comment"> *****************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> Count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The count = %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)Count++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****************************************</span></span><br><span class="line"><span class="comment">当我们加入static，那么会给这个变量 分配具体内存，</span></span><br><span class="line"><span class="comment">只会初始化一次，这个值就会累加，不会等于0了</span></span><br><span class="line"><span class="comment"> *****************************************/</span></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Test();</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、标准库函数"><a href="#四、标准库函数" class="headerlink" title="四、标准库函数"></a>四、标准库函数</h4><p>基础理论：</p><p>1、编译软件自带的库文件</p><p>2、单片机厂商提供的库文件</p><p>调用方法：利用关键字<code>include</code>引用。</p><p><code># 预编译</code></p><p>#include <STC8.h>  </p><p>//STC8头文件，包含STC8单片机的所有寄存器定义</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <intrins.h></h1><p>//主要包含空指令函数，循环移位函数等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_nop_()      空操作<span class="number">8051</span> NOP 指令</span><br><span class="line">_crol_()      字符循环左移 </span><br><span class="line">_cror_() 字符循环右移 </span><br><span class="line">_irol_() 整数循环左移 </span><br><span class="line">_iror_() 整数循环右移 </span><br><span class="line">_lrol_() 长整数循环左移 </span><br><span class="line">_lror_() 长整数循环右移 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>#include <string.h></p><p>//主要包含字符串处理函数</p><p>#include “stdio.h”</p><p>//主要包含标准I/O功能函数，比如printf打印输出</p><p>#include “stdlib.h”</p><p>//主要包含随机数，申请与释放内存等函数。</p><p>Note:</p><p><code>&quot; &quot;</code>: 先在工程路径查找，再系统路径查找</p><p><code>&lt; &gt;</code>:先在系统路径查找，再在工程路径查找</p><h4 id="五、中断服务函数"><a href="#五、中断服务函数" class="headerlink" title="五、中断服务函数"></a>五、中断服务函数</h4><p>基础理论：</p><p>单片机产生中断时，调用的函数。</p><p>STC系列单片机中断函数定义如下：</p><p>void 函数名() `nterrupt 中断号</p><p>{</p><p>  函数体</p><p>}</p><p><code>interrupt :标识符，表明此函数为中断函数</code></p><p>中断号： 中断入口</p><p>举例：</p><p>void INT0_isr()   interrupt 0</p><p>{</p><p>}</p><p>void INT1_isr()   interrupt 1</p><p>{</p><p>}</p><p>void UART1_isr() interrupt 4</p><p>{</p><p>}</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EX1  = <span class="number">1</span>;             <span class="comment">//打开外部中断1</span></span><br><span class="line">IT1  = <span class="number">1</span>;             <span class="comment">//下降沿触发</span></span><br><span class="line"></span><br><span class="line">EA  =  <span class="number">1</span>;       <span class="comment">//打开总中断</span></span><br><span class="line"><span class="comment">/* Private variables-----------------------*/</span></span><br><span class="line">bit TX_Busy_Flag = <span class="number">0</span>; <span class="comment">//串口发送忙碌标志位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   INT1_isr</span></span><br><span class="line"><span class="comment">* @brief  外部中断1服务函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT1_ISR</span><span class="params">()</span> interrupt  2</span><br><span class="line">&#123;</span><br><span class="line">Sys_LED = ~ Sys_LED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   UART1_isr</span></span><br><span class="line"><span class="comment">* @brief  串口1中断服务函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART1_isr</span><span class="params">()</span> interrupt 4  using 3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(RI)</span><br><span class="line">&#123;</span><br><span class="line">RI = (bit)<span class="number">0</span>; <span class="comment">//清除接收中断标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(TI)</span><br><span class="line">&#123;</span><br><span class="line">TI = (bit)<span class="number">0</span>;       <span class="comment">//清除发送中断标志</span></span><br><span class="line">TX_Busy_Flag = <span class="number">0</span>;  <span class="comment">//清忙碌标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="一、指针的定义"><a href="#一、指针的定义" class="headerlink" title="一、指针的定义"></a>一、指针的定义</h4><p>1、指针定义</p><p>指针是一种<code>保存变量地址</code>的变量。</p><p>在51单片机里，指针占3个字节，两个字节存放地址，一个字节存放数据类型</p><p>深入理解：</p><p>① 定义一个变量a，系统分配内存。</p><p>unsigned char a = 10；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfDBOlre5aI2HJLzsvHK2CxuVyFuHFlicWzEysKjHtITcRkJyuCibByG4ZWUB37BibZ1xEKJxiaMmJj6w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&amp;a = 0x80;  //&amp;：取址符</p><p>a   = 10； </p><p>② 定义一个指针P，系统分配内存。</p><p>unsigned char *P = NULL；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfDBOlre5aI2HJLzsvHK2Cx38GpJicz8F1FpB9k7824soCYicd3IibpjGYnwBbscAtQibMe4QYberKdtQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&amp;P = 0x55；</p><p>P  = NULL</p><p>③将指针P指向变量a</p><p>P = &amp;a；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfDBOlre5aI2HJLzsvHK2Cx2aYWCw9IDUibqH79KpQMIdvBQ59W8ZM5LqDLXVPtAac5DvA8S4rGqcw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>a = 100；</p><p>*P = 100； //通过指针访问变量a</p><p>上面两个公式，效果一样。</p><p>2、为什么使用指针</p><p>在C语言中，指针的使用非常广泛，因为使用指针往往可以生成更高效、更紧凑的代码。总的来说，使用指针有如下好处：</p><p>① 指针的使用使得不同区域的代码可以轻易的共享内存数据，这样可以使程序更为快速高效；</p><p>② C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等；</p><p>③ C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用。</p><h4 id="二、数据指针的定义"><a href="#二、数据指针的定义" class="headerlink" title="二、数据指针的定义"></a>二、数据指针的定义</h4><p>基础理论：</p><p>指针变量的定义与一般变量的定义类似，一般形式如下：</p><p>数据类型 *标识符；</p><p>1、数据类型</p><p>void ，unsigned char，signed int，float，结构体</p><p>2、<code>*</code></p><p>表示定义的变量为指针</p><p>3、标识符</p><p>指针变量名</p><p>举例：</p><p>1、void *P；</p><p>定义了<code>空类型</code>指针，赋值之前，需要通过<code>强制类型转换</code>符进行转换</p><p>2、unsigned char *P；</p><p>3、signed int *P；</p><p>4、float *P</p><p>Note：</p><p>定义指针后，如果没有初始化或赋值，此时指针为野指针，不可对其进行操作，否则，会引发不可预测的后果。  如果暂时不赋值，可以初始化为NULL。</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  *Ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">float</span>         *Ptr3 = <span class="literal">NULL</span>;   </span><br><span class="line"><span class="type">void</span>          *Ptr4 = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;x; <span class="comment">// 定义一个指向x的数据指针</span></span><br><span class="line">*p = <span class="number">20</span>;     <span class="comment">// 修改x的值为20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、数据指针的应用"><a href="#三、数据指针的应用" class="headerlink" title="三、数据指针的应用"></a>三、数据指针的应用</h4><p>基础理论：</p><p>定义指针并赋值后，此时指针指向变量，可以通过指针操作变量，</p><p>操作格式为：(<code>*</code>指针标识符)</p><p>1、基本赋值应用</p><p>unsigned char a；</p><p>unsigned char *P = &amp;a；</p><p>此时，<code>指针P存放的是变量a的地址，也就是指针P指向了变量a</code>。</p><p>a = 100；</p><p>(*P) = 100;</p><p>效果是一样的。</p><p>2、函数传递应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a[<span class="number">8</span>] = &#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Water_LED(<span class="type">unsigned</span> <span class="type">char</span> *P)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line"></span><br><span class="line">    P1 = *(P+i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用形式：</p><p>Water_LED(a);</p><p>Water_LED(&amp;a[0]);</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针的赋值应用</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针的函数传递</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">8</span>] =&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *P_str = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Water_LED</span></span><br><span class="line"><span class="comment">* @brief  流水灯</span></span><br><span class="line"><span class="comment">* @param  P -&gt; 指针</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *P)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P1 = *(P+i);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Water_LED(P_str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、函数指针的定义"><a href="#四、函数指针的定义" class="headerlink" title="四、函数指针的定义"></a>四、函数指针的定义</h4><p>基础理论：</p><p>如果在程序中定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，这段存储空间的首地址称为这个函数的地址，函数名表示的就是这个地址。既然是地址，我们就可以定义一个指针变量来存放，这个指针变量就叫作函数指针变量，简称函数指针。</p><p>有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样。</p><p>定义函数指针的一般形式为：</p><p>数据类型 （*标识符）([形参列表])</p><p>1、数据类型 : 说明函数的返回类型</p><p>2、(*标识符）:括号不能省，括号改变了运算符的优先级。若省略整体则成为一个函数说明，说明了一个返回的数据类型是指针的函数</p><p>3、形参列表 ：表示指针变量指向的函数所带的参数列表</p><p>举例：</p><p>int func(int x);  // 声明一个函数 </p><p>int (*f) (int x);  //声明一个函数指针</p><p>f=func;      //将func函数的首地址赋给指针f </p><p>Note：</p><p>==指针函数与函数指针==</p><p>1、指针函数</p><p>返回值是指针的函数，即本质是一个函数。</p><p>其定义格式如下所示:</p><p>数据类型* 函数名称 ([形式参数表])</p><p>2、函数指针</p><p>指向函数的指针，其本质是一个指针。</p><p>数据类型 （*标识符）([形参列表])</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义指针函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="type">void</span> (*f_ptr)(<span class="type">unsigned</span> <span class="type">char</span>) = fun</span><br></pre></td></tr></table></figure><h4 id="五、函数指针的运用"><a href="#五、函数指针的运用" class="headerlink" title="五、函数指针的运用"></a>五、函数指针的运用</h4><p>基础理论：</p><p>定义函数指针并赋值后，此时函数指针指向了函数入口，可以通过函数指针调用函数。</p><p>调用格式：</p><p>1、(*P)();     //无返回值，无形参</p><p>2、(*P)(unsigned char a);      //无返回值，有形参</p><p>3、b = (*P)(unsigned char a);     //有返回值，有形参</p><p>高级应用：</p><p>1、回调函数</p><p>   将函数指针作为参数传递，后续课程可以进一步学习</p><p>2、面向对象的结构体编程</p><p>   通过结构体封装变量，数据指针，函数指针，后续课程可以进一步学习</p><p>==<strong>应用举例</strong>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>)</span>;</span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="type">void</span> (*f_ptr)(<span class="type">unsigned</span> <span class="type">char</span>) = fun;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Water_LED</span></span><br><span class="line"><span class="comment">* @brief  流水灯</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Temp = <span class="number">0x01</span>;</span><br><span class="line"></span><br><span class="line">i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">while</span>(i--)</span><br><span class="line">&#123;</span><br><span class="line">P1 = Temp;</span><br><span class="line">Temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Water_LED();</span></span><br><span class="line">        (*Fun_Ptr)();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组与结构体"><a href="#数组与结构体" class="headerlink" title="数组与结构体"></a>数组与结构体</h3><h4 id="一、数组的定义"><a href="#一、数组的定义" class="headerlink" title="一、数组的定义"></a>一、数组的定义</h4><p>基础理论：</p><p>数组是一组同一种数据类型的数据的集合；</p><p>数组分为一维数组与二维数组； </p><p>数组必须先定义，然后才能使用，定义时可以初始化。</p><p>1、一维数组</p><p>定义：</p><p>数据类型 数组名[数组长度] = [{数组初始化}] ;</p><p>数据类型：字符型，整型，浮点型，指针等</p><p>数组名：  数组的名称，也是数组的首地址</p><p>数组长度：必须为常量</p><p>数组初始化：可以初始化，也可以不初始化</p><p>例如：</p><p>unsigned char Arr [5] = {0x00,0x01};</p><p>2、二维数组</p><p>定义：</p><p>数据类型 数组名[行长度][列长度] = [{数组初始化}] ;</p><p>数据类型：字符型，整型，浮点型，指针等</p><p>数组名：  数组的名称，也是数组的首地址</p><p>数组长度：必须为常量</p><p>数组初始化：可以初始化，也可以不初始化</p><p>例如：</p><p>unsigned char Arr [2] [3]  = </p><p>{</p><p>  {0x01,0x02,0x03},</p><p>  {0x10,0x20,0x30}</p><p>};</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Public variables----------------------------------------*/</span></span><br><span class="line"><span class="comment">//定义一维数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Arr1[<span class="number">20</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">float</span>  Arr2[<span class="number">5</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr_Arr[<span class="number">5</span>] = &#123;Arr1,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二维数组</span></span><br><span class="line"><span class="comment">//unsigned char Arr3[3][2] = &#123;&#123;0,1&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Arr3[<span class="number">3</span>][<span class="number">2</span>] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes-----------------------------*/</span></span><br></pre></td></tr></table></figure><h4 id="二、数组的应用"><a href="#二、数组的应用" class="headerlink" title="二、数组的应用"></a>二、数组的应用</h4><p>基础理论：</p><p>1、一维数组</p><p>方法一： 数组名 [索引号]  Arr [0]</p><p>方法二： 数据指针调用 </p><p>unsigned char Ptr = Arr</p><p>*(Ptr + 1) = Arr [1];</p><p>2、二维数组</p><p>方法一： 数组名[行索引号] [列索引号]  Arr [0] [2] = 0x03;</p><p>方法二： 数据指针调用，计算地址麻烦，很少用</p><p>Note：</p><p>索引号从0开始，0 至 数组长度-1</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Public variables----------------------------------------*/</span></span><br><span class="line"><span class="comment">//定义一维数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Arr[<span class="number">8</span>] = &#123;<span class="number">0x01</span>,<span class="number">0x04</span>,<span class="number">0x10</span>,<span class="number">0x40</span>,<span class="number">0x0F</span>,<span class="number">0xF0</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *P_LED_Arr = LED_Arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二维数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Arr2[<span class="number">2</span>][<span class="number">4</span>] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">0x01</span>,<span class="number">0x04</span>,<span class="number">0x10</span>,<span class="number">0x40</span>&#125;,</span><br><span class="line">&#123;<span class="number">0x0F</span>,<span class="number">0xF0</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Water_LED</span></span><br><span class="line"><span class="comment">* @brief  流水灯</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P1 = LED_Arr[i];</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Water_LED</span></span><br><span class="line"><span class="comment">* @brief  流水灯</span></span><br><span class="line"><span class="comment">* @param  Ptr_Arr: 指向无符号字符型的指针</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *Ptr_Arr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">P1 = *(Ptr_Arr + i);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Water_LED</span></span><br><span class="line"><span class="comment">* @brief  流水灯</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">P1 = LED_Arr2[i][j];</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Water_LED(LED_Arr);</span><br><span class="line">Water_LED(P_LED_Arr);</span><br><span class="line">Water_LED();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes----------------------------*/</span></span><br></pre></td></tr></table></figure><h4 id="三、结构体的定义"><a href="#三、结构体的定义" class="headerlink" title="三、结构体的定义"></a>三、结构体的定义</h4><p>基础理论：</p><p>结构体是一组相同或不同数据类型构成的新的数据类型</p><p>数据类型可以是字符型，整型，浮点型，数据指针，函数指针</p><p>结构体需要先声明类型，再定义变量，然后才能使用，定义时尽量初始化。</p><p>结构体类型定义：</p><p>struct 结构体名称 = {结构体元素表};</p><p>==<strong>结构体的定义方法：</strong>==</p><p>typedef struct </p><p>{</p><p>  基础数据变量；</p><p>  数据指针变量；</p><p>  函数指针变量；</p><p>} 结构体名_t;</p><p>Note:</p><p>typedef关键字，<code>数据类型重命名</code></p><p>typedef uint8_t  unsigned char</p><p>typedef uint16_t unsigned short int</p><p>typedef uint32_t unsigned long int</p><p>1、基础数据变量  </p><p>字符型，整型，浮点型等</p><p>2、数据指针变量</p><p>一般用来指向数组</p><p>3、函数指针变量</p><p>用来指向函数</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ucTx_Flag;</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>  *pucSendBufffer；</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*Send_Array)(<span class="type">unsigned</span> <span class="type">char</span> *,<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">&#125; UART_t;</span><br></pre></td></tr></table></figure><p>Note：</p><p>1、外设一般由变量，数组，函数组成， 通过上面定义的结构体变量，可将外设进行封装；</p><p>2、通过结构体访问外设，编程更加方便、程序可读性更好、方便移植；</p><p>3、此方法即为单片机实战课程的面向对象编程思维，结构体编程。</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体类型 定义类型不能赋值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucTx_Flag;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucRx_Flag;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *puc_Send_Buffer;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *puc_Rec_Buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*Send_Array)(<span class="type">unsigned</span> <span class="type">char</span>*,<span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">&#125; UART_t;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四、结构体的应用"><a href="#四、结构体的应用" class="headerlink" title="四、结构体的应用"></a>四、结构体的应用</h4><p>基础理论：</p><p>前面一讲，我们定义了结构体类型，此时系统并未分配内存，不可调用。在c文件中，通过结构体类型定义结构体变量后，方可调用结构体。</p><p>常规应用方法：</p><p>1、.h文件中定义结构体类型</p><p>2、.c文件中定义结构体变量</p><p>3、.h文件中声明结构体变量为外部变量</p><p>4、其他.c文件即可调用结构体变量</p><p>==调用方法：==</p><p>结构体名称<code>.</code>元素</p><p>==<strong>结构体的应用方法：</strong>==</p><p>结构体名_t 结构体 =<br>{<br>        定义变量，</p><p>​        定义变量，</p><p>​        定义变量</p><p>};</p><p>例如：</p><p>定义结构体变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> ucSendBuffer[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">UART1_Send_Array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *,<span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UART_t UART1 = </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  ucSendBuffer,</span><br><span class="line"></span><br><span class="line">  UART1_Send_Array</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用结构体变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UART1.ucTx_Flag = <span class="number">1</span>；</span><br><span class="line"></span><br><span class="line">*(UART1.pucSendBufffer + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">UART1.Send_Array(Ptr_Arr,LEN);</span><br></pre></td></tr></table></figure><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Water_LENGTH;  <span class="comment">//变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr_LED;      <span class="comment">//数据指针</span></span><br><span class="line"><span class="type">void</span> (*Water_LED)(<span class="type">unsigned</span> <span class="type">char</span> *); <span class="comment">//函数指针</span></span><br><span class="line">&#125; Water_LED_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> Water_LED_t LED;</span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体变量</span></span><br><span class="line">Water_LED_t LED = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">8</span>,</span><br><span class="line">LED_Arr,</span><br><span class="line">Water_LED</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED.Water_LED(LED.Ptr_LED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、结构体指针"><a href="#五、结构体指针" class="headerlink" title="五、结构体指针"></a>五、结构体指针</h4><p>基础理论：</p><p>通过结构体指针，不仅可以访问结构体变量，同时，也可以作为函数的实参进行传递，实现更多灵活多变的功能。</p><p>1、定义结构体指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UART_t *Ptr_UART_t = &amp;UART1;</span><br></pre></td></tr></table></figure><p>2、通过结构体指针调用结构体变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ptr_UART_t -&gt; ucTx_Flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">*(Ptr_UART_t -&gt; pucSendBufffer + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Ptr_UART_t -&gt; Send_Array(Ptr_Arr,LEN);</span><br></pre></td></tr></table></figure><p>3、结构体指针作为函数形参传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Protocol_Analysis</span><span class="params">(UART_t *UART )</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  UART_t* <span class="type">const</span>  COM = UART；<span class="comment">//定义实参</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//调用结构体</span></span><br><span class="line"></span><br><span class="line">  COM -&gt; ucTx_Flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  *(COM -&gt;pucSendBufffer + <span class="number">1</span>) = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  COM -&gt; (Ptr_Arr,LEN);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"></span><br><span class="line">Protocol_Analysis(&amp;UART1);</span><br></pre></td></tr></table></figure><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.h</span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Water_LENGTH;  <span class="comment">//变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr_LED;      <span class="comment">//数据指针</span></span><br><span class="line"><span class="type">void</span> (*Water_LED)(<span class="type">void</span>);      <span class="comment">//函数指针</span></span><br><span class="line">&#125; Water_LED_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> Water_LED_t LED; </span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> LED_Arr[<span class="number">8</span>] = &#123;<span class="number">0x02</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x0F</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">void</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体变量</span></span><br><span class="line">Water_LED_t LED = </span><br><span class="line">&#123;</span><br><span class="line"><span class="number">8</span>,</span><br><span class="line">LED_Arr,</span><br><span class="line">Water_LED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体指针并初始化</span></span><br><span class="line">Water_LED_t  *Ptr_Water_LED = &amp;LED; </span><br></pre></td></tr></table></figure><h3 id="枚举-联合体与预编译"><a href="#枚举-联合体与预编译" class="headerlink" title="枚举 联合体与预编译"></a>枚举 联合体与预编译</h3><h4 id="一、枚举的定义与应用"><a href="#一、枚举的定义与应用" class="headerlink" title="一、枚举的定义与应用"></a>一、枚举的定义与应用</h4><p>基础理论：</p><p>枚举是集合若干个整型常量构成的新的数据类型</p><p>枚举类型定义：</p><p>enum 枚举名 {枚举值列表} 变量列表;</p><p><strong>实战课程的定义方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> [枚举名]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  枚举值列表</span><br><span class="line"></span><br><span class="line">&#125; 枚举名<span class="type">_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  FALSE = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  TRUE = !FALSE</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">bool_t</span></span><br></pre></td></tr></table></figure><p>==Note:==</p><p>1、枚举值列表不赋值，默认第一项取值为0，第二项自动加1，依次类推；</p><p>   建议：实战编程中，尽量赋值，不偷懒。</p><p>2、定义枚举类型后，此时系统并不会分配内存，但可以将枚举类型列表中当常量进行使用，相等于宏定义#define；</p><p>3、通过枚举类型定义枚举变量后，系统分配内存，<code>枚举变量取值范围仅限于枚举类型列表</code>。</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.h  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __Sys_LED_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Sys_LED_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LED_ON   = <span class="number">1</span>,</span><br><span class="line">LED_OFF  = <span class="number">0</span></span><br><span class="line">&#125;LED_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P54 = LED_ON;</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">P54 = LED_OFF;</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="二、联合体的定义与应用"><a href="#二、联合体的定义与应用" class="headerlink" title="二、联合体的定义与应用"></a>二、联合体的定义与应用</h4><p>基础理论：</p><p>联合体是若干个数据元素共用内存构成的新的数据类型</p><p>联合体类型定义：</p><p>union 联合体名称 {成员列表} 变量列表;</p><p><strong>实战课程的定义方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">union</span> [联合体名称]</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    成员列表；</span><br><span class="line"></span><br><span class="line">&#125; 联合体名<span class="type">_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> a；</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b；</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">char</span> c；</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">temp_t</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>==Note:==</p><p>1、联合体类型与结构体类型的定义方法很相似，只是将关键字struct改为union。 但是它们在<code>内存分配</code>上有着本质的区别，<code>结构体变量所占用的内存长度是所有元素所占用内存的总和</code>，<code>而联合体变量占用的内存长度是其中最长元素的长度</code>；</p><p>结构体占用7个字节    联合体占用4个。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230609204100893.png" alt="image-20230609204100893"> </p><p>==需要注意联合体是共用内存==</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230609205327530.png" alt="image-20230609205327530"></p><p>​                                 <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230609205838699.png" alt="image-20230609205838699"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x 00AA</span></span><br><span class="line">ui = <span class="number">170</span> ；</span><br><span class="line">uc = <span class="number">0</span>；</span><br><span class="line"><span class="comment">//0x 01AA</span></span><br><span class="line">        ui = <span class="number">426</span> ;</span><br><span class="line">uc = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个就是内存共用，当我们改变里面任何一个元素的值，另外的一个值也会跟着改变。</p><p>2、联合体类型提供了一种<code>能够在同一内存内处理不同类型数据的方法</code>，适当使用联合体空类型可以<code>节约内存</code>空间；</p><p>3、与结构体一样，联合体也需要先定义数据类型，再定义变量，方可引用元素</p><p>4、与结构体一样，联合体引用元素的方法为 联合体变量名<code>.</code>联合体元素</p><p>5、与结构体一样，也可以定义联合体指针进行元素引用，联合体指针名 -&gt; 联合体元素</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Public variables--------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  ulTemp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucTemp;</span><br><span class="line">&#125; Test_t;</span><br><span class="line"></span><br><span class="line">Test_t union_test = &#123;<span class="number">0xAA</span>&#125;;</span><br><span class="line"></span><br><span class="line">union_test.ucTemp = <span class="number">0x01</span>;</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ulTemp = %d\r\n&quot;</span>,union_test.ulTemp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ucTemp = %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)union_test.ucTemp);</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、预编译介绍"><a href="#三、预编译介绍" class="headerlink" title="三、预编译介绍"></a>三、预编译介绍</h4><p>基础理论：</p><p>预处理指令是以<code>#</code>号开头的代码行，#号必须是该行除了任何空白字符外的第一个字符。#后是指令关键字，整行语句构成了一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换。下面是部分预处理指令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">指令                 用途                                       </span><br><span class="line">#                   <span class="comment">//空指令，无任何效果</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>            <span class="comment">//包含一个头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>             <span class="comment">//定义宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>              <span class="comment">//取消已定义的宏</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>                 <span class="comment">//如果给定条件为真，则编译下面代码            </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>              <span class="comment">//如果宏己经定义，则编译下面代码         </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>             <span class="comment">//如果宏没有定义，则编译下面代码 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span>               <span class="comment">//如果前面的#if给定条件不为真，当前条件为真，则编译下面代码                </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>              <span class="comment">//结束一个#if....else条件编译块             </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span>              <span class="comment">//停止编译并显示错误信息         </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//标准IO口头文件。 printf打印函数位于此       </span></span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>1、预编译应用于头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __Water_LED_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __Water_LED_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> Water_LENGTH;  <span class="comment">//变量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *Ptr_LED;      <span class="comment">//数据指针</span></span><br><span class="line"><span class="type">void</span> (*Water_LED)(<span class="type">unsigned</span> <span class="type">char</span> *); <span class="comment">//函数指针</span></span><br><span class="line">&#125; Water_LED_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> Water_LED_t LED;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>2、预编译应用于编程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//标准IO口头文件。 printf打印函数位于此  </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Hardware_Simulation</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//串口打印信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="四、预编译关键字-include-与-define"><a href="#四、预编译关键字-include-与-define" class="headerlink" title="四、预编译关键字  include 与 define"></a>四、预编译关键字  include 与 define</h4><p>基础理论：</p><p>1、#include &lt;头文件名.h&gt;</p><p>包含一个头文件</p><p>2、#define 定义宏</p><p>例如：</p><p>#define UART_Tx_LEN  10</p><p>#define LED_ON       P54 = 1   //灯亮</p><p>#define LED_OFF       P54 = 0   //灯灭</p><p>在 C 语言中，宏是一种预处理指令，它允许我们将一个标识符定义为一个字符串或表达式。宏与常规函数的区别在于，宏并不会进行函数调用，而是在程序编译前就被替换掉。</p><p>一般情况下，通过定义宏可以简化代码并提高代码的可读性。宏的定义通常使用 <code>#define</code> 来实现，其语法格式为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 宏名称 宏值</span></span><br></pre></td></tr></table></figure><p>其中，宏名称是一个标识符，宏值可以是数字、字符串、表达式等。</p><p>例如，假设我们需要定义一个用来计算圆面积的宏，我们可以这样定义它：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AREA(r) (PI * (r) * (r))</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了一个 <code>PI</code> 宏，并将其值设置为 <code>3.1415926</code>。然后，我们定义了一个 <code>AREA</code> 宏，它使用 <code>r</code> 作为半径参数来计算圆的面积。注意，这里我们使用括号来确保表达式的正确性。</p><p>在程序中使用宏时，我们只需要在需要使用该宏的地方将宏名称作为标识符进行替换即可，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r = <span class="number">2.5</span>;</span><br><span class="line"><span class="type">double</span> area = AREA(r);</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用 <code>AREA</code> 宏来计算半径为 2.5 的圆的面积，并将计算结果赋给 <code>area</code> 变量。在该代码中，<code>AREA(r)</code> 会被替换为 <code>(PI * (r) * (r))</code>，即 <code>area</code> 的值将为 <code>3.1415926 * 2.5 * 2.5 = 19.63495</code>。</p><p>作用：</p><p>1、提高代码可读性；</p><p>2、方便代码修改；</p><p>3、方便代码移植；</p><p><strong>==应用举例==</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h3><h4 id="一、常用关键字"><a href="#一、常用关键字" class="headerlink" title="一、常用关键字"></a>一、常用关键字</h4><p>基础理论：</p><p> 1、数据类型声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">空类型      - <span class="type">void</span></span><br><span class="line">有符号字符型 - <span class="type">signed</span> <span class="type">char</span></span><br><span class="line">无符号字符型 - <span class="type">unsigned</span> <span class="type">char</span></span><br><span class="line">有符号短整型 - <span class="type">signed</span> [<span class="type">short</span>] <span class="type">int</span></span><br><span class="line">无符号短整型 - <span class="type">unsigned</span> [<span class="type">short</span>] <span class="type">int</span></span><br><span class="line">有符号长整型 - <span class="type">signed</span> <span class="type">long</span> <span class="type">int</span></span><br><span class="line">无符号长整型 - <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span></span><br><span class="line">    </span><br><span class="line"><span class="type">float</span>      - 单精度浮点型</span><br><span class="line"><span class="type">double</span>     - 双精度浮点型</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了代码的可移植性和可读性，通常会采用 uint_ 类型定义来替代 unsigned </span></span><br><span class="line"></span><br><span class="line">uint_8    <span class="number">8</span>  位无符号整数 （即单字节）        </span><br><span class="line">uint_16 <span class="number">16</span> 位无符号整数 （即双字节）</span><br><span class="line">uint_32 <span class="number">32</span> 位无符号整数 （即四字节）</span><br><span class="line"></span><br><span class="line">int_8    <span class="number">8</span>  位有符号整数 （即单字节）        </span><br><span class="line">int_16 <span class="number">16</span> 位有符号整数 （即双字节）</span><br><span class="line">int_32 <span class="number">32</span> 位有符号整数 （即四字节）</span><br><span class="line">    </span><br><span class="line">    结构体  - <span class="class"><span class="keyword">struct</span>                                        </span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">    枚举    - <span class="title">enum</span>  </span></span><br><span class="line"><span class="class">        </span></span><br><span class="line"><span class="class">    联合体  - <span class="title">union</span></span></span><br></pre></td></tr></table></figure><p> 2、存储种类声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>     - 声明局部变量，默认此类型</span><br><span class="line"><span class="keyword">register</span> - 使用CPU内部寄存器的变量</span><br><span class="line"><span class="keyword">extern</span>   - 声明外部变量</span><br><span class="line"><span class="type">static</span>   - 声明静态变量</span><br><span class="line"><span class="type">const</span>    - 声明常量变量</span><br><span class="line"><span class="keyword">volatile</span> - 声明变量可能被外部改变</span><br><span class="line"><span class="keyword">typedef</span>  - 数据类型重定义</span><br></pre></td></tr></table></figure><p> 三、程序语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">条件选择 - <span class="keyword">if</span> - <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">开关语句 - <span class="keyword">switch</span> - <span class="keyword">case</span> - <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">循环语句 - <span class="keyword">for</span>  - <span class="keyword">while</span>  <span class="keyword">do</span> - <span class="keyword">while</span></span><br><span class="line"></span><br><span class="line">函数返回 - <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">退出最内层循环体 - <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">转向下一次循环  - <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p> 4、预编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include - 包含一个头文件</span><br><span class="line"></span><br><span class="line">define - 宏定义</span><br></pre></td></tr></table></figure><p>5、运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> - 计算表达式或数据类型的字节数</span><br></pre></td></tr></table></figure><p>==应用举例==</p><p>用typedef重新定义数据类型，方便程序移植。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">char</span>       <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">unsigned</span> <span class="type">char</span>     <span class="type">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">int</span>        <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">unsigned</span> <span class="type">int</span>      <span class="type">uint16_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">signed</span> <span class="type">long</span> <span class="type">int</span>    <span class="type">int32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span>   <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint32_t</span>;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Sys_LED = ~Sys_LED;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cnt = %u\r\n&quot;</span>,Cnt++);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、extern-与-static"><a href="#二、extern-与-static" class="headerlink" title="二、extern 与 static"></a>二、extern 与 static</h4><p>基础理论：</p><p>1、extern</p><p>作用：用于声明外部变量与外部函数</p><p>详细说明：一个源程序通常由若干个c文件组成，C文件之间<code>相互调用</code>函数与变量时，需要通过extern进行外部声明。</p><p>申明对象：基本变量，函数，结构体，枚举，联合体等。</p><p>==Note==：</p><p>函数默认为extern，定义变量不能添加，定义函数是可以的。</p><p>调用外部函数时，需要进行声明，一般用==头文件声明==</p><p><code>.h</code> 生成头文件</p><p>2、static</p><p>作用：用于声明内部变量与内部函数</p><p>详细说明：一个源程序通常由若干个c文件组成，为了防止C文件内的函数与变量被外部调用，需要通过static进行内部声明，保护函数与变量。</p><p>申明对象：基本变量，函数，结构体，枚举，联合体等。</p><p>此外，在函数内部定义的局部变量，用static进行声明，可以防止每次调用函数时，局部变始化为默认值。</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LED.h</span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> Water_LED_t LED;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> Cnt;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">LED.c</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//外部函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Water_LED</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *)</span>;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Delay_ms</span></span><br><span class="line"><span class="comment">* @brief  毫秒延时函数</span></span><br><span class="line"><span class="comment">* @param  ms -&gt; 需要延时的时间</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ms;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1575</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.c</span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED.Water_LED(LED.Ptr_LED);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cnt = %u\r\n&quot;</span>,Cnt++);</span><br><span class="line">Delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、const"><a href="#三、const" class="headerlink" title="三、const"></a>三、const</h4><p>基础理论：</p><p>声明变量为常量，只读，不可以被更改。</p><p>可以修饰变量与指针</p><p>const 与 define 的区别。从功能上说它们确实很像，但它们又有明显的不同：</p><p>1、define是预编译指令，而const是普通变量的声明。define定义的宏是在预处理阶段展开的，而const声明的只读变量是在编译运行阶段使用的。</p><p>2、const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的<code>常变量</code>本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，<code>常变量是有名字的不变量</code>，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。</p><p>3、const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有类型安全检查。</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="四、volatile"><a href="#四、volatile" class="headerlink" title="四、volatile"></a>四、volatile</h4><p>基础理论：</p><p>volatile 影响编译器编译的结果,volatile指出 变量是随时可能发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错。</p><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：</p><p>1、中断服务子程序中访问的非自动变量(Non-automatic variables)</p><p>2、多线程应用中被几个任务共享的变量</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="五、sizeof"><a href="#五、sizeof" class="headerlink" title="五、sizeof"></a>五、sizeof</h4><p>基础理论：</p><p>1、Sizeof的概念</p><p>Sizeof是C语言的一种单目操作符，如C语言的其他操作符++、—等。它并不是函数。Sizeof操作符以字节形式给出了其操作数的存储大小。操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。</p><p>2、Sizeof的用法</p><p>用于数据类型</p><p>sizeof使用形式：sizeof(type)</p><p>数据类型必须括号括住，如sizeof(int)。</p><p>用于变量</p><p>sizeof使用形式：sizeof(var_name)或sizeof var_name</p><p>变量名可以不用括号括住，但尽量用括号。</p><p>eg：</p><p>unsigned char </p><p>计算数组元素长度</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> Arr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The LEN of Arr = %d\r\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="keyword">sizeof</span>(Arr)/<span class="keyword">sizeof</span>(Arr[<span class="number">0</span>])));</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基本框架结构、流程图、普通编程"><a href="#基本框架结构、流程图、普通编程" class="headerlink" title="基本框架结构、流程图、普通编程"></a>基本框架结构、流程图、普通编程</h3><h4 id="一、基本程序框架"><a href="#一、基本程序框架" class="headerlink" title="一、基本程序框架"></a>一、基本程序框架</h4><p>基础理论：</p><p>1、C文件</p><p>① 包含头文件，[宏定义]，[变量定义]，函数等；</p><p>② 通常包含多个C文件，用于实现不同的功能；</p><p>③ 必须包含main.c文件，文件内包含main函数，程序复位后的入口地址；</p><p>④ ==产品化思维，代码得方便阅读，修改与移植==。  </p><p>2、H文件</p><p>1、包含[头文件]，[宏定义]，[新数据类型定义]，外部变量声明，[外部函数声明]等；</p><p>2、通常包含多个H文件，每个C文件对应1个H文件；</p><p>3、通过H文件，将所有C文件紧密联系在一起。</p><p>==应用实例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c 基本框架</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define-------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MAIN_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MAIN_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC8.h&gt;</span>   <span class="comment">//STC8头文件。     主要包含STC8的寄存器定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//标准IO口头文件。 printf打印函数位于此</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;public.h&gt;</span> <span class="comment">//共同文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;LED.h&gt;</span>    <span class="comment">//LED灯</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;KEY.h&gt;</span>    <span class="comment">//按键</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//key.h 基本框架</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br></pre></td></tr></table></figure><h4 id="二、程序流程图"><a href="#二、程序流程图" class="headerlink" title="二、程序流程图"></a>二、程序流程图</h4><p>程序流程图：指示程序的运行逻辑，方便程序编辑与阅读。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610103901433.png" alt="image-20230610103901433"></p><h4 id="三、普通编程"><a href="#三、普通编程" class="headerlink" title="三、普通编程"></a>三、普通编程</h4><p>基础理论：</p><p>普通编程：区分于状态机编程与结构体编程，市面开发板一般采用普通编程，方便实现功能。 由于过多定义全局变量，全局函数，程序不利于阅读、修改与移植，产品开发不推荐此方式</p><p>==应用举例==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    main.c </span></span><br><span class="line"><span class="comment">  * @author  硬件家园</span></span><br><span class="line"><span class="comment">  * @version V1.0</span></span><br><span class="line"><span class="comment">  * @date    2020-11-29</span></span><br><span class="line"><span class="comment">  * @Conpany </span></span><br><span class="line"><span class="comment">  * @project STC8G单片机基础板</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC8.h&gt;</span>   <span class="comment">//STC8头文件。     主要包含STC8的寄存器定义</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//标准IO口头文件。 printf打印函数位于此</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define-------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED  P1  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TRUE  = <span class="number">1</span>,</span><br><span class="line">FALSE = <span class="number">0</span>,</span><br><span class="line">&#125; <span class="type">boot_t</span>;</span><br><span class="line"></span><br><span class="line">bit  KEY1_Flag = TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(<span class="type">void</span>)</span>;          <span class="comment">//GPIO口初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span> ;  <span class="comment">//ms延时函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Note:串口打印与硬件仿真共用接口，不能同时进行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   main</span></span><br><span class="line"><span class="comment">* @brief  主函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO口初始化</span></span><br><span class="line">GPIO_Init(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//按键1中断</span></span><br><span class="line">EX0  = <span class="number">1</span>;             <span class="comment">//打开外部中断0</span></span><br><span class="line">IT0  = <span class="number">1</span>;             <span class="comment">//下降沿触发</span></span><br><span class="line">EA  =  <span class="number">1</span>;       <span class="comment">//打开总中断</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断标志位，为真，执行流水灯，为假，关闭LED灯</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LED = (<span class="number">0x01</span> &lt;&lt; i);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LED = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   GPIO_Init</span></span><br><span class="line"><span class="comment">* @brief  GPIO口初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//P1初始化，推挽输出</span></span><br><span class="line">P1M1 = <span class="number">0x00</span>; <span class="comment">//0000 0000</span></span><br><span class="line">P1M0 = <span class="number">0xFF</span>; <span class="comment">//1111 1111</span></span><br><span class="line">P1   = <span class="number">0x00</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//P3初始化</span></span><br><span class="line">P3M1 = <span class="number">0x0D</span>; <span class="comment">//0000 1101</span></span><br><span class="line">P3M0 = <span class="number">0x02</span>; <span class="comment">//0000 0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P5初始化，推挽输出</span></span><br><span class="line">P5M1 = <span class="number">0x00</span>; <span class="comment">//0000 0000</span></span><br><span class="line">P5M0 = <span class="number">0xFF</span>; <span class="comment">//1111 1111</span></span><br><span class="line">P54  = <span class="number">1</span>;    <span class="comment">//系统LED灯默认亮</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Delay_ms</span></span><br><span class="line"><span class="comment">* @brief  毫秒延时函数</span></span><br><span class="line"><span class="comment">* @param  ms -&gt; 需要延时的时间</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ms;i++)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">1575</span>;j++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   INT0_isr</span></span><br><span class="line"><span class="comment">* @brief  外部中断0服务函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">INT0_isr</span><span class="params">()</span> interrupt  0</span><br><span class="line">&#123;</span><br><span class="line">KEY1_Flag = ~KEY1_Flag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*if(KEY1_Flag == TRUE)</span></span><br><span class="line"><span class="comment">KEY1_Flag = FALSE;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">KEY1_Flag = TRUE;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="状态机编程"><a href="#状态机编程" class="headerlink" title="==状态机编程=="></a>==状态机编程==</h3><h4 id="一、有限状态"><a href="#一、有限状态" class="headerlink" title="一、有限状态"></a>一、有限状态</h4><p>有限状态机是一种概念思想，把复杂的控制逻辑分解成有限个稳定状态，组成闭环系统，通过事件触发，让状态机按设定的顺序处理事务。</p><p>单片机C语言的状态机编程，是利用条件选择语句<code>(switch -- case)</code>切换状态，通过函数内部指令改变状态机状态，让程序按设定的顺序执行。</p><p>机械按键按过程：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610105449882.png" alt="image-20230610105449882">  </p><p>上图为按钮按键典型的动作图，可以提取为四个状态，分别为</p><p>状态1 = 按键弹起状态</p><p>状态2 = 按键不稳定状态1</p><p>状态3 = 按键按下状态</p><p>状态4 = 按键不稳定状态2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(定时器定时 &gt;= <span class="number">10</span>ms) <span class="comment">//10ms为典型消抖时间</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (按健状态)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">case</span> 状态<span class="number">1</span>:<span class="keyword">if</span> (Io为低电平) 按键状态 = 状态<span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 状态<span class="number">2</span>:<span class="keyword">if</span> (Io为低电平) 按键状态 = 状态<span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 状态<span class="number">3</span>:<span class="keyword">if</span> (Io为高电平) 按键状态 = 状态<span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 状态<span class="number">4</span>:<span class="keyword">if</span> (Io为高电平) 按键状态 = 状态<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: 按键状态 = 状态<span class="number">1</span>;</span><br><span class="line">说明:执行到状态<span class="number">4</span>，说明检测到了按键按下，置位按键标志位，</span><br><span class="line">再次检测高电平,是为了按键弹起消抖。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、状态机流程图"><a href="#二、状态机流程图" class="headerlink" title="二、状态机流程图"></a>二、状态机流程图</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610121229174.png" alt="image-20230610121229174" style="zoom:150%;" /> </p><h4 id="三、状态机编程"><a href="#三、状态机编程" class="headerlink" title="三、状态机编程"></a>三、状态机编程</h4><p>1、按键单击检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////定义变量</span></span><br><span class="line"><span class="comment">//状态机状态</span></span><br><span class="line"><span class="type">static</span> KEY_STA_Machine_Stautus_t  KEY_STA_Machine_Stautus = STA1_KEY_Up_Status; </span><br><span class="line"><span class="comment">//按键扫描时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KEY_Scan_Timer = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//按键单击标志位</span></span><br><span class="line">bit KEY1_Click_Flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   KEY1_Datect</span></span><br><span class="line"><span class="comment">* @brief  按键1检测函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_Datect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KEY_Scan_Timer &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(KEY_STA_Machine_Stautus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STA1_KEY_Up_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA2_KEY_DownShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA2_KEY_DownShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA3_KEY_Down_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA4_KEY_UpShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA4_KEY_UpShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY1_Click_Flag = <span class="number">1</span>;</span><br><span class="line">KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KEY_Scan_Timer = <span class="number">0</span>; <span class="comment">//按键扫描时间清零</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、按键单击+长按检测</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">Key.c</span><br><span class="line"><span class="comment">////定义变量</span></span><br><span class="line"><span class="comment">//状态机状态</span></span><br><span class="line"><span class="type">static</span> KEY_STA_Machine_Stautus_t  KEY_STA_Machine_Stautus = STA1_KEY_Up_Status; </span><br><span class="line"><span class="comment">//按键扫描时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> KEY_Scan_Timer = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  KEY_Press_Timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键单击标志位</span></span><br><span class="line">bit KEY1_Click_Flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//按键长按标志位</span></span><br><span class="line">bit KEY1_Press_Flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   KEY1_Datect</span></span><br><span class="line"><span class="comment">* @brief  按键1检测函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KEY1_Datect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KEY_Scan_Timer &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(KEY_STA_Machine_Stautus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STA1_KEY_Up_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA2_KEY_DownShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA2_KEY_DownShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键长按检测定时器从新计数</span></span><br><span class="line">KEY_Press_Timer = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA3_KEY_Down_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA4_KEY_UpShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA4_KEY_UpShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下超过500ms认定为长按，否则为单击</span></span><br><span class="line"><span class="keyword">if</span>(KEY_Press_Timer &gt;= <span class="number">500</span>)</span><br><span class="line">KEY1_Press_Flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KEY1_Click_Flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KEY_Scan_Timer = <span class="number">0</span>; <span class="comment">//按键扫描时间清零</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Timer0_isr()</span></span><br><span class="line"><span class="comment">* @brief  定时器0中断函数(1ms中断一次)</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/***********定时器0中断函数***********/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_isr</span><span class="params">()</span> interrupt 1</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Cnt++ &gt;= <span class="number">1000</span>)</span><br><span class="line">&#123;</span><br><span class="line">Cnt = <span class="number">0</span>;</span><br><span class="line">Sys_LED = ~Sys_LED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KEY_Scan_Timer++;  <span class="comment">//按键扫描定时器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(KEY_Press_Timer &lt; <span class="number">0xFFFF</span>)</span><br><span class="line">KEY_Press_Timer++; <span class="comment">//按键长按定时器 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Key.h</span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">STA1_KEY_Up_Status         = <span class="number">0x01</span>,</span><br><span class="line">STA2_KEY_DownShake_Status  = <span class="number">0x02</span>,</span><br><span class="line">STA3_KEY_Down_Status       = <span class="number">0x03</span>,</span><br><span class="line">STA4_KEY_UpShake_Status    = <span class="number">0x04</span>,</span><br><span class="line">&#125; KEY_STA_Machine_Stautus_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">char</span> KEY_Scan_Timer;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span>  KEY_Press_Timer;</span><br><span class="line"><span class="keyword">extern</span> bit KEY1_Click_Flag;</span><br><span class="line"><span class="keyword">extern</span> bit KEY1_Press_Flag;</span><br><span class="line"><span class="comment">//声明外部函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">KEY1_Datect</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结构体编程"><a href="#结构体编程" class="headerlink" title="==结构体编程=="></a>==结构体编程==</h3><h4 id="一、结构体编程"><a href="#一、结构体编程" class="headerlink" title="一、结构体编程"></a>一、结构体编程</h4><p>知识回顾：</p><p>1、结构体</p><p>由一系列具有相同类型或不同类型的数据构成的数据集合，叫做结构体。、</p><p>进行单片机编程时，为了方便程序<code>阅读、移植、维护</code>，将外设看作一个对象，而对象包含数据、数据集与行为，对应程序中的变量、数组与函数。通过结构体，可以将变量、数组与函数进行封装，定义为新的数据类型。编程时，CPU可以通过新的数据类型，访问外设的变量、数组与函数，非常方便。</p><p>结构体定义新的数据类型：</p><p>typedef  struct</p><p>{</p><p>  变量；</p><p>  指针；</p><p>  函数指针；</p><p>} 新数据类型_t</p><p>之后，我们就可以用新的数据类型定义结构体变量。</p><p>2、指针</p><p>定义如下：</p><p>变量类型 *指针名；</p><p>通过指针，非常方便操作数组。比如串口的接收缓存，将接收缓存的首地址赋给指针后，CPU就可以通过结构体的指针，读取串口的接收缓存。</p><p>3、函数指针</p><p>定义如下：</p><p>返回值类型 ( * 指针变量名) ([形参列表])；</p><p>通过函数指针，可以访问外设的函数。 通过将外设函数的函数名(首地址)赋给函数指针，CPU就可以通过结构体的函数指针，调用外设的函数。</p><h4 id="二、结构体编程框架"><a href="#二、结构体编程框架" class="headerlink" title="二、结构体编程框架"></a>二、结构体编程框架</h4><p>key.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;public.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">STA1_KEY_Up_Status         = <span class="number">0x01</span>,</span><br><span class="line">STA2_KEY_DownShake_Status  = <span class="number">0x02</span>,</span><br><span class="line">STA3_KEY_Down_Status       = <span class="number">0x03</span>,</span><br><span class="line">STA4_KEY_UpShake_Status    = <span class="number">0x04</span>,</span><br><span class="line">&#125; KEY_STA_Machine_Stautus_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KEY_STA_Machine_Stautus_t  KEY_STA_Machine_Stautus; <span class="comment">//按键状态机状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>  KEY_Scan_Timer;   <span class="comment">//按键扫描定时器</span></span><br><span class="line"><span class="type">uint16_t</span> KEY_Press_Timer;  <span class="comment">//按键长按检测定时器</span></span><br><span class="line"><span class="type">uint8_t</span>  KEY_Click_Flag;   <span class="comment">//按键单击标志位</span></span><br><span class="line">  <span class="type">uint8_t</span>  KEY_Press_Flag;   <span class="comment">//按键长按标志位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*KEY_Detect)(<span class="type">void</span>); <span class="comment">//按键扫描函数      </span></span><br><span class="line">&#125; KEY_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> KEY_t  KEY1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>key.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;STC8.h&gt;</span>   <span class="comment">//STC8头文件。     主要包含STC8的寄存器定?</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;KEY.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  KEY1_Status   P32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//按键扫描函数 </span></span><br><span class="line"><span class="comment">//结构体变量定义</span></span><br><span class="line">KEY_t KEY1 = </span><br><span class="line">&#123;</span><br><span class="line">STA1_KEY_Up_Status,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">FALSE,</span><br><span class="line">FALSE,</span><br><span class="line"></span><br><span class="line">KEY1_Detect</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   KEY1_Detect</span></span><br><span class="line"><span class="comment">* @brief  按键1检测函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(KEY1.KEY_Scan_Timer &gt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(KEY1.KEY_STA_Machine_Stautus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STA1_KEY_Up_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA2_KEY_DownShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA2_KEY_DownShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为低电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键长按检测定时器从新计数</span></span><br><span class="line">KEY1.KEY_Press_Timer = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA3_KEY_Down_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA4_KEY_UpShake_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> STA4_KEY_UpShake_Status:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检测IO口依然为高电平</span></span><br><span class="line"><span class="keyword">if</span>(KEY1_Status == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按下超过500ms认定为长按，否则为单击</span></span><br><span class="line"><span class="keyword">if</span>(KEY1.KEY_Press_Timer &gt;= <span class="number">500</span>)</span><br><span class="line">KEY1.KEY_Press_Flag = TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">KEY1.KEY_Click_Flag = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检测IO口变为高电平，干扰引起，误检测</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_STA_Machine_Stautus = STA3_KEY_Down_Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: KEY1.KEY_STA_Machine_Stautus = STA1_KEY_Up_Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KEY1.KEY_Scan_Timer = <span class="number">0</span>; <span class="comment">//按键扫描时间清零</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>public.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PUBLIC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PUBLIC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型重定义</span></span><br><span class="line"><span class="keyword">typedef</span><span class="type">signed</span>   <span class="type">char</span>      <span class="type">sint8_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span>   <span class="type">short</span> <span class="type">int</span> <span class="type">sint16_t</span>; </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span>   <span class="type">long</span>  <span class="type">int</span> <span class="type">sint32_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>      <span class="type">uint8_t</span>;   </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>  <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型 -&gt; BIT位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BIT0 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">0</span>),  </span><br><span class="line">BIT1 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>),  </span><br><span class="line">BIT2 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>),  </span><br><span class="line">BIT3 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>),  </span><br><span class="line">BIT4 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>),</span><br><span class="line">BIT5 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>),</span><br><span class="line">BIT6 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">6</span>),</span><br><span class="line">BIT7 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">7</span>),</span><br><span class="line">&#125;BIT_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型 -&gt; TRUE/FALSE位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TRUE  = (bit)<span class="number">1</span>,</span><br><span class="line">FALSE = (bit)<span class="number">0</span>,</span><br><span class="line">&#125;BOOL_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******预编译宏定义*******/</span></span><br><span class="line"><span class="comment">//#define Monitor_Run_Code   //代码运行监控器 </span></span><br><span class="line"><span class="comment">//#define Hardware_TEST      //硬件测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****主循环*****/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按键1检测函数</span></span><br><span class="line">KEY1.KEY_Detect();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按键1单击执行 - 高四位取反</span></span><br><span class="line"><span class="keyword">if</span>(KEY1.KEY_Click_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Click_Flag = FALSE;</span><br><span class="line">Byte_LED ^= <span class="number">0xF0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键1长按执行 - 低四位取反</span></span><br><span class="line"><span class="keyword">if</span>(KEY1.KEY_Press_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Press_Flag = FALSE;</span><br><span class="line">Byte_LED ^= <span class="number">0x0F</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三、状态机编程-1"><a href="#三、状态机编程-1" class="headerlink" title="三、状态机编程"></a>三、状态机编程</h4><p>通过STC15实战代码讲解结构体编程的应用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普中51单片机</title>
      <link href="/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/"/>
      <url>/2023/11/22/%E6%99%AE%E4%B8%AD51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>学习资料加学习源码</p><p>链接：<a href="https://pan.baidu.com/s/1aybvYKSoAEGx5kTOUW1PjQ">https://pan.baidu.com/s/1aybvYKSoAEGx5kTOUW1PjQ</a><br>提取码：0613</p><h3 id="一、开发板的功能及使用介绍"><a href="#一、开发板的功能及使用介绍" class="headerlink" title="一、开发板的功能及使用介绍"></a>一、开发板的功能及使用介绍</h3><p>开发板的功能及使用介绍</p><p>我们先来看下开发板各功能模块， 如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610201214200.png" alt="image-20230610201214200"> </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610201232031.png" alt="image-20230610201232031"> </p><h3 id="二、51单片机介绍"><a href="#二、51单片机介绍" class="headerlink" title="二、51单片机介绍"></a>二、51单片机介绍</h3><h4 id="单片机简历"><a href="#单片机简历" class="headerlink" title="单片机简历"></a>单片机简历</h4><p>一台能够工作的计算机要有这样几个部件构成： CPU（进行运算、 控制） 、 RAM （数据存储） 、 ROM（程序存储） 、 输入/输出设备（例如： 串行口、 并行输出口等） 。 在个人计算机上这些部件被分成若干块芯片， 安装一个称之为主板的印刷线路板上。 而在单片机中， 这些部件全部被做到一块集成电路芯片中， 所以就称为单片机（也称微控制器 MCU） ， 而且有一些单片机中除了上述部份外， 还集成了其它部份如 A/D， D/A 等。 体积不大， 一般用 40 脚封装， 当然功能多一些单片机也有引脚比较多的， 如 68 引脚， 功能少的只有 10 多个或 20 多个引脚， 有的甚至只 8 只引脚。  </p><h4 id="51单片机简介"><a href="#51单片机简介" class="headerlink" title="51单片机简介"></a>51单片机简介</h4><p>51 单片机是对所有兼容 Intel 8031 指令系统的单片机的统称。 该系列单片机的始祖是 Intel 的 8004 单片机， 后来随着 Flash rom 技术的发展， 8004 单片机取得了长足的进展， 成为应用最广泛的 8 位单片机之一， 其代表型号是 ATMEL公司的 AT89 系列， 它广泛应用于工业测控系统之中。 很多公司都有 51 系列的兼容机型推出， 今后很长的一段时间内将占有大量市场。 51 单片机是基础入门的一个单片机， 还是应用最广泛的一种。 需要注意的是 51 系列的单片机一般不具备自编程能力。  </p><p>80C51 是 MCS-51 系列中的一个典型品种； 其它厂商以 8051 为基核开发出的CMOS 工艺单片机产品统称为 80C51 系列。 当前常用的 80C51 系列单片机主要产品有：  </p><p>Intel(英特尔)的： i80C31、 i80C51、 i87C51， i80C32、 i80C52、 i87C52 等；ATMEL(艾德梅尔)的： AT89C51、 AT89C52、 AT89C2051， AT89S51（RC）AT89S52 （RC） 等；</p><p>Philips(飞利浦)、 华邦、 Dallas(达拉斯)、 Siemens(西门子)等公司的许多产品；  </p><p>STC(国产宏晶)单片机： STC89C51、 STC89C52、 STC89C516、 STC90C516 等众多品牌。80C51 芯片管脚图如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203251280.png" alt="image-20230610203251280"></p><p>上图中左图是 51 单片机非常经典的管脚图， 通常采用的是 DIP-40 封装。<br>其内部资源如下：<br>· 8 位 CPU<br>· 4kbytes 程序存储器(ROM) (52 为 8K)<br>· 128bytes 的数据存储器(RAM) （52 有 256bytes 的 RAM）<br>· 32 条 I/O 口线<br>· 111 条指令， 大部分为单字节指令<br>· 21 个专用寄存器<br>· 2 个可编程定时/计数器<br>· 5 个中断源， 2 个优先级（52 有 6 个）<br>· 一个全双工串行通信口<br>· 外部数据存储器寻址空间为 64kB<br>· 外部程序存储器寻址空间为 64kB<br>· 逻辑操作位寻址功能<br>· 双列直插 40PinDIP 封装<br>· 单一+5V 电源供电<br>CPU： 由运算和控制逻辑组成， 同时还包括中断系统和部分外部特殊功能寄<br>存器；</p><p>RAM： 用以存放可以读写的数据， 如运算的中间结果、 最终结果以及欲显示<br>的数据；<br>ROM： 用以存放程序、 一些原始数据和表格；<br>I/O 口： 四个 8 位并行 I/O 口， 既可用作输入， 也可用作输出<br>T/C： 两个定时/记数器， 既可以工作在定时模式， 也可以工作在计数模式；<br>五个中断源的中断控制系统；<br>一个全双工 UART（通用异步接收发送器） 的串行 I/O 口， 用于实现单片机之<br>间或单片机与微机之间的串行通信；<br>片内振荡器和时钟产生电路， 石英晶体和微调电容需要外接。 最佳振荡频率<br>为 6M—12M。</p><p>其内部结构图如下所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203426520.png" alt="image-20230610203426520"></p><p>总线（BUS） 是单片机各部件之间传送信息的公共通道。 单片机中有内部总线和外部总线两类， 内部总线是 CPU 内部之间的连线， 外部总线是指 CPU 与其它部件之间的连线； 外部总线有三种: 数据总线 DB（ Data Bus） ,地址总线 AB （Address Bus） 和控制总线 CBControl Bus） 。  </p><h4 id="STC89Cxx芯片介绍"><a href="#STC89Cxx芯片介绍" class="headerlink" title="STC89Cxx芯片介绍"></a>STC89Cxx芯片介绍</h4><p>前面介绍了很多款基于 MCS-51 内核设计的 51 单片机， 这么多款 51 单片机是不是都要去学习呢？ 当然不是， 既然他们的内核指令都是一样的， 那我们只需要学会一款典型并具代表性的 51 单片机即可， 其他的都是可以兼容的。  </p><p>早期很长一段时间， 51 单片机大部分使用的是 AT89C51 或者 AT89C52。 随着我国芯片技术的快速发展， 宏晶公司推出的增强型 51 单片机 STC89Cxx/STC90Cxx等系列更受大众喜爱， 除内部资源及功能大大增强外， 还有一个非常重要的是它支持 ISP（在系统可编程） /IAP（在应用可编程） ， 无需专用编程器或专用仿真器。 宏晶公司推出的 51 芯片种类非常多， 我们只需选择一款经典的学习即可。我们开发板上使用的是STC89C52或者STC89C516， 这两款芯片以及其他STC89Cxx或者 STC90Cxx 除 Flash 和 RAM 容量差异外， 内部资源功能几乎一样， 我们只需学习任意一种即可。 下面我们看下常见 PDIP 封装（直插封装） 的 51 单片机芯片实物图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610203704417.png" alt="image-20230610203704417"> </p><p>上图可看到芯片表面印有 STC89C52RC 40I-PDIO40 1947H0XN52.X90C 丝印，下面我们了解下芯片表面丝印的含义：  </p><p>STC—表示芯片为 STC 公司生产的产品， 其他公司的也有 AT、 i、 SST 等。<br>8—表示该芯片为 8051 内核芯片。<br>9—表示内部含有 Flash EEPROM 存储器， 还有如 80C51 中 0 表内部含有MaskROM（掩模 ROM） 存储器； 如 87C51 中 7 表示内部含有 EPROM（紫外线可擦除ROM） 存储器。  </p><p>C—表示该器件为 CMOS 产品。 还有如 89LV52 和 89LE58 中的 LV 和 LE 都表示<br>该芯片为低电压产品（通常为 3.3V 电压供电） ； 而 89S52 中 S 表示该芯片含有<br>可串行下载功能的 Flash 存储器， 即具有 ISP 可在线编程功能。<br>5—固定不变。</p><p>2—表示该芯片内部程序存储（FLASH） 空间大小， 1 为 4KB， 2 为 8KB， 3 为<br>12KB， 即该数乘以 4KB 就是芯片内部的程序存储空间大小。 程序空间大小决定了<br>一个芯片所能装入执行代码的多少。 一般来说， 程序存储空间越大， 芯片价格也<br>越高， 所以我们再选择芯片的时候要根据自己需求选择合适芯片。<br>RC—STC 单片机内部 RAM（随机读写存储器） 为 512B。 还有如 RD+表示内部<br>RAM 为 1280B。 还有芯片会省略此部分。<br>40—表示芯片外部晶振最高可接入 40MHz。 对 AT 单片机数值一般为 24， 表<br>示外部晶振最高位 24MHz。<br>I—产品级别， 表示芯片使用温度范围。<br>C 表示商业级， 温度范围为 0~+70 度。<br>I 表示工业级， 温度范围为-40~+85 度。<br>A 表示汽车级， 温度范围为-40~+125 度。<br>M 表示军用级， 温度范围为-55~+150 度。<br>PDIP40—产品封装型号。 PDIP 表示双列直插式。<br>1947—表示本批芯片生产日期为 19 年第 47 周。<br>H0XN52.X90C—不详， 有关资料显示， 此标号表示芯片制造工艺或处理工艺。</p><h5 id="STC89C51芯片简介"><a href="#STC89C51芯片简介" class="headerlink" title="STC89C51芯片简介"></a>STC89C51芯片简介</h5><p>STC89C51 是 STC 推出的新一代超强抗干扰/高速/低功耗的 51 单片机， 它是<br>采用 8051 核的 ISP（In System Programming） 在系统可编程芯片， 指令代码完<br>全兼容传统的 8051 单片机， 最高工作时钟频率为 80MHz， 片内含 4K Bytes 的可<br>反复擦写 1000 次的 Flash 只读程序存储器， 器件兼容标准 MCS-51 指令系统及<br>80C51 引脚结构， 芯片内集成了通用 8 位中央处理器和 ISP Flash 存储单元， 具<br>有在系统可编程（ISP） 特性， 配合 PC 端的控制程序即可将用户的程序代码下载<br>进单片机内部， 省去了购买通用编程器， 而且速度更快。 STC89C51 系列单片机<br>是单时钟/机器周期(1T)的兼容 8051 内核单片机， 是高速/ 低功耗的新一代<br>8051 单片机， 全新的流水线/精简指令集结构,内部集成 MAX810 专用复位电路。<br>其特性功能主要如下：<br>1： 增强型 8051 单片机， 6 时钟/机器周期和 12 时钟/机器周期可任意选择，指令代码完全兼容传统 8051。<br>2： 工作电压： 5.5V - 3.3V (5V 单片机) / 3.6V - 2.0V (3V 单片机）<br>3： 工作频率范围： 0～40MHz， 相当于普通 8051 的 0～80MHz， 实际工作频<br>率可达 48MHz<br>4： 用户应用程序空间： 4K / 8K / 13K / 16K / 32K / 64K 字节（STC89C516）<br>5： 片上集成 1280 字节或 512 字节或 256 字节 RAM<br>6： 通用 I/O 口(35/39 个)， 复位后为： P1/P2/P3/P4 是准双向口/弱上拉(普<br>通 8051 传统 I/O 口)； P0 口是开漏输出， 作为总线扩展用时， 不用加上拉电阻，<br>作为 I/O 口用时， 需加上拉电阻。<br>7： ISP（在系统可编程） / IAP（在应用可编程） ， 无需专用编程器， 无<br>需专用仿真器， 可通过串口（ RxD/P3.0, TxD/P3.1） 直接下载用户程序， 数秒<br>即可完成一片。<br>8： 有 EEPROM 功能<br>9： 看门狗<br>10： 内部集成 MAX810 专用复位电路（HD 版本和 90C 版本才有） ， 外部晶体<br>20M 以下时， 可省外部复位电路,复位脚可直接接地。<br>11： 有 3 个 16 位定时器/ 计数器， 其中定时器 0 还可以当成 2 个 8 位定时<br>器使用。<br>12： 外部中断 4 路,下降沿中断或低电平触发中断,Power Down 模式可由外<br>部中断低电平触发中断方式唤醒<br>13： 通用异步串行口(UART)， 还可用定时器软件实现多个 UART<br>14： 工作温度范围： -40 ~ +85℃(工业级) / 0 ~ 75℃(商业级)<br>15： 封装： LQFP-44, PDIP-40, PLCC-44, PQFP-44</p><h5 id="STC89C51-芯片引脚介绍"><a href="#STC89C51-芯片引脚介绍" class="headerlink" title="STC89C51 芯片引脚介绍"></a>STC89C51 芯片引脚介绍</h5><p>下图我们可以看到 51 单片机不同封装的引脚图， 当大家首次看见这些引脚<br>时， 一定会有又多又乱的感觉， 而且难以记忆。 千万不要着急， 对于初学者来说，<br>单纯的记忆引脚标号没有任何意义， 最好的方法是边学边记忆。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204218476.png" alt="image-20230610204218476"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204231443.png" alt="image-20230610204231443"></p><h6 id="单片机脚位判断"><a href="#单片机脚位判断" class="headerlink" title="单片机脚位判断"></a>单片机脚位判断</h6><p>​    在在讲解各引脚含义之前， 我们首先应该学会如何在实物上区分引脚序号，<br>基于 8051 内核的单片机， 若引脚数相同， 或封装相同， 它们的引脚功能是相同<br>的， 其中用的较多的是 40 脚 DIP 封装的 51 单片机， 也有 20,28,32， 44 等不同<br>引脚数的 51 单片机， 这些大家也要了解， 不能只见了 40 脚的芯片才认为它是<br>51 单片机。<br>无论哪种芯片， 单片机也好， 其他不知名的芯片也好， 当我们观察它的表面<br>时， 大都会找到一个凹进去的小圆坑， 或是用颜色标记的一个小标记（圆点或三<br>角或其他小图形） ， 这个小圆坑或者小标记所对应的引脚就是这个芯片的第 1脚， 然后逆时针方向数下去， 即 1 到最后一个引脚。 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204539108.png" alt="image-20230610204539108"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204546382.png" alt="image-20230610204546382"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204558377.png" alt="image-20230610204558377"></p><p>上图中对于 LQFP/PQFP 封装， 小圆坑在左下角位置； 对于 DIP 封装， 小圆坑<br>在芯片上方正中间位置， 对应左边第一个脚位为 1； 对于 PLCC 封装， 小圆坑在<br>芯片上方正中间位置， 对应脚位为 1； 在实际焊接或绘制电路板时， 大家务必要<br>注意它们的脚位标号， 否则若焊接错误则导致产品无法正常工作</p><h6 id="51-单片机脚位功能"><a href="#51-单片机脚位功能" class="headerlink" title="51 单片机脚位功能"></a>51 单片机脚位功能</h6><p>接下来我们以上图 PDIP 封装引脚图为例介绍各个引脚的功能， 40 引脚我们<br>按其功能类别可分为四类：<br>①电源引脚。 如 VCC、 GND<br>②时钟引脚。 如 XTAL1、 XTAL2<br>③编程控制引脚。 如 RST、 PSEN、 ALE/PROG、 EA/Vpp。 （此处了解即可）<br>④I/O 口引脚。 如 P0、 P1、 P2、 P3， 4 组 8 位 I/O 口。<br>VCC（40 脚） 、 GND（20 脚） ： 电源引脚， 不同型号单片机接入对应电压，<br>常压为+5V， 低压为+3.3V， 大家在使用时要查看其芯片所要求的电压。</p><p>XTAL1（19 脚） 、 XTAL2（18 脚） ： 外接时钟引脚。 XTAL1 为片内振荡电路的<br>输入端， XTAL2 为片内振荡电路的输出端。 8051 的时钟有两种方式， 一种是片内<br>时钟振荡方式， 即需在这两个引脚处外接石英晶振和振荡电容， 振荡电容的值一<br>般取 10p~30p； 另一种是外部时钟方式， 即将 XTAL1 接地， 外部时钟信号从 XTAL2脚输入。 通常使用第一种方式。<br>RST（9 脚） ： 复位引脚。 当输入连续两个机器周期以上高电平时为有效， 用<br>来完成单片机的复位初始化操作， 即单片机从头开始执行程序。</p><p>PSEN（29 脚） ： 程序存储器允许输出控制端。 在读外部程序存储器时 PSEN<br>低电平有效， 以实现外部程序存储器单元的读操作， 由于现在我们使用的单片机<br>内部已经有足够大的 ROM， 所以几乎没有人再去扩展外部 ROM， 因此这个引脚大<br>家只需了解即可。</p><p>ALE/PROG（30 脚） ： 在扩展外部 RAM 时， ALE 用于控制把 P0 口的输出低 8<br>位地址送锁存器锁存起来， 以实现低位地址和数据的隔离。 ALE 有可能是高电平<br>也有可能是低电平， 当 ALE 为高电平时， 允许地址锁存型号， 当访问外部存储器<br>时， ALE 信号负跳变（即由正变负） 将 P0 口上低 8 位地址信号送入锁存器； 当<br>ALE 为高电平时， P0 口上的内容和锁存器输出一致。 关于锁存器后面我们会有介<br>绍。 在没有访问外部存储器期间， ALE 以 1/6 振荡周期频率输出（即 6 分频） ，<br>当访问外部存储器时， 以 1/12 振荡周期输出（12 分频） 。 从这里可以看到， 当<br>没有扩展外部 RAM 时， ALE 会以 1/6 振荡周期的固定频率输出， 因此可以作为外部时钟， 或作为外部定时脉冲使用。 PROG 为编程脉冲的输入端， 单片机的内部<br>有程序存储器（ROM） ， 它的作用是用来存放用户需要执行的程序， 那么我们怎<br>样才能将写好的程序存入这个 ROM 中呢？ 实际上， 我们是通过编程脉冲输入才写<br>进去的， 这个脉冲的输入端口就是 PROG。 现在绝大多数单片机都已经不需要编<br>程脉冲引脚往内部写程序了， 比如我们使用的 STC 单片机， 它可以直接通过串口<br>往里面写程序， 只需要三条线与计算机相连即可。 而且现在的单片机内部都已经<br>带有丰富的 RAM， 所以也不需要再扩展 RAM 了， 因此 ALE/PROG 引脚用于不大，大家了解即可。</p><p>EA/Vpp（31 脚） ： EA 接高电平时， 单片机读取内部程序存储器。 当扩展有<br>外部 ROM 时， 当读取完内部 ROM 后自动读取外部 ROM。 EA 接低电平时， 单片机直接读取外部 ROM。 我们没有外扩 ROM， 并且需要单片机直接读取内部程序存储器，因此 EA/Vpp 脚直接接高电平。</p><p>P0 口（39 脚~32 脚） ： 双向 8 位三态 I/O 口， 每个口可独立控制。 51 单片<br>机 P0 口内部没有上拉电阻， 若输出高时为高阻态， 不能正常输出高电平， 因此<br>该组 I/O 口， 每个口可独立控制。 51 单片机 P0 口内部没有上拉电阻， 若输出高<br>时为高阻态， 不能正常输出高电平， 因此该组 I/O 口在使用时务必要外接上拉电<br>阻， 一般我们选择接入 10K 欧上拉电阻。</p><p>P1 口（1 脚~8 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上拉<br>电阻， 这种接口输出没有高阻态， 输入也不能锁存， 故不是真正的双向 I/O 口。<br>之所以称它为“准双向” 是因为该口在作为输入使用前， 要先向该口进行写 1<br>操作， 然后单片机内部才可正确读出外部信号， 也就是要使其先有个“准” 备的<br>过程， 所以才称为准双向口。 对 52 单片机 P1.0 引脚的第二功能未 T2 定时器/<br>计数器的外部输入， P1.1 引脚的第二功能为 T2EX 捕捉、 重装触发， 即 T2 的外<br>部控制端。</p><p>P2 口（21 脚~28 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上<br>拉电阻， 与 P1 口相似。</p><p>P3 口（10 脚~17 脚） ： 准双向 8 位 I/O 口， 每个口可独立控制， 内部自带上<br>拉电阻。 作为第一功能使用时就当做普通 I/O 口， 与 P1 口相似。 作为第二功能<br>使用时， 各引脚的定义如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610204858363.png" alt="image-20230610204858363"></p><p>从图中可知， P3 口的每一个引脚均可独立定义为第一功能的输入/输出或第二功能。  </p><h5 id="STC89C51-芯片内部结构"><a href="#STC89C51-芯片内部结构" class="headerlink" title="STC89C51 芯片内部结构"></a>STC89C51 芯片内部结构</h5><p>STC89C51 系列单片机的内部结构框图如下图所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610205026326.png" alt="image-20230610205026326"></p><p>STC89C51 单片机中包含中央处理器(CPU)、 程序存储器(Flash)、 数据存储器<br>(SRAM)、定时/计数器、 UART 串口、 I/O 接口、 EEPROM、看门狗等模块。 STC89C51系列单片机几乎包含了数据采集和控制中所需的所有单元模块， 可称得上一个片上系统。<br>想要了解更多 STC89C5xx 系列芯片介绍， 可以百度搜索对应数据手册。 在我<br>们资料内也提供了该芯片的数据手册， 可作为 STC89C5XX 单片机学习参考。</p><h3 id="三、数字电路与C语言"><a href="#三、数字电路与C语言" class="headerlink" title="三、数字电路与C语言"></a>三、数字电路与C语言</h3><h4 id="电平特性"><a href="#电平特性" class="headerlink" title="电平特性"></a>电平特性</h4><p>单片机是一种数字集成芯片， 数字电路中只有两种电平： 高电平和低电平。<br>为了让大家在刚起步的时候对电平特性有一个清晰的认识， 我们暂时定义单片机<br>输出与输入为 TTL 电平， 其中高电平为+5V， 低电平为 0V。 计算机的串口为 RS232电平， 其中高电平为-12V， 低电平为+12V。 这里强调的是， RS232C 电平为负逻辑电平， 大家不要认为上面是我写错了。 因此当计算机与单片机之间要通信时，需要依靠电平转换芯片， 比如 MAX232 电平转换芯片。</p><p>常用的逻辑电平还有很多， 比如 TTL、 CMOS、 LVTTL、 RS-232、 RS-485 等。<br>其中TTL和CMOS的逻辑电平按典型电压可分为四类： 5V系列（5V TTL和5V CMOS）、3.3V 系列， 2.5V 系列和 1.8V 系列。</p><p>5V TTL 和 5V CMMOS 是通用的逻辑电平。 3.3V 及以下的逻辑电平被称为低电<br>压逻辑电平， 常用的为 LVTTL 电平。 低电压逻辑电平还有 2.5V 和 1.8V 两种。<br>RS-232 和 RS-485 是串口的接口标准， RS-232 是单端输入/输出。 RS-485 是差分<br>输入/输出。<br>TTL 电平信号用的最多， 这是因为数据表示通常采用二进制， +5V 等价于逻<br>辑 1， 0V 等价于逻辑 0， 这被称为 TTL（晶体管-晶体管逻辑电平） 信号系统。</p><p>CMOS 电平 VCC 可达 12V， CMOS 电路输出高电平约为 0.9VCC， 而输出低电平<br>约为 0.1VCC。 CMOS 电路中不使用的输入端不能悬空， 否则会造成逻辑混乱。 另<br>外， CMOS 集成电路电源电压可以在较大范围内变化， 因而对电源的要求不像 TTL<br>集成电路那样严格。</p><p>TTL 电路和 CMOS 电路的逻辑电平关系如下：<br>①VOH： 逻辑电平 1 的输出电压。<br>②VOL： 逻辑电平 0 的输出电压。<br>③VIH： 逻辑电平 1 的输入电压。<br>④VIL： 逻辑电平 0 的输入电压。</p><p>TTL 电平临界值：</p><p>①VOHmin=2.4V， VOLmax=0.4V。<br>②VIHmin=2.0V， VILmax=0.8V。<br>CMOS 电平临界值（假设电源电压为+5V） ：<br>①VOHmin=4.99V， VOLmax=0.01V。<br>②VIHmin=3.5V， VILmax=1.5V。<br>TTL 和 CMOS 的逻辑电平转换： CMOS 电平能驱动 TTL 电平， 但 TTL 电平不能<br>驱动 CMOS 电平， 需加上拉电阻。<br>常用逻辑芯片的特点如下：<br>74LS 系列： TTL 输入： TTL， 输出： TTL<br>74HC 系列： CMOS 输入： CMOS， 输出： CMOS<br>74HCT 系列： CMOS 输入： TTL， 输出： CMOS<br>CD4000 系列： CMOS 输入： TTL， 输出： CMOS</p><p>通常情况下， 单片机、 DSP、 FPGA 之间引脚能否直接相连要参考以下方法进<br>行判断： 一般来说， 同电压的是可以相连的， 不过最好还是要查看下芯片技术手<br>册上的 VIL、 VIH、 VOL 和 VOH 的值， 看是否能够匹配。 有些情况在一般应用中没有问题， 但是参数上就是有点不够匹配， 在某些情况下运行可能就不够稳定， 或<br>者不同批次的器件就不能运行</p><h4 id="二进制与十六进制"><a href="#二进制与十六进制" class="headerlink" title="二进制与十六进制"></a>二进制与十六进制</h4><h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><p>数字电路中只有两种电平特性， 即高电平和低电平， 这也就决定了数字电路<br>中使用二进制。 十进制数大家应该都不陌生， “逢十进一， 借一当十” 是十进制<br>数的特点。 有了十进制数的基础， 我们学习二进制数便非常容易了， “逢二进一，<br>借一当二” 便是二进制数的特点。 十进制数 1 转换为二进制数是 1B（这里 B 表<br>示二进制数的后缀） ； 十进制数 2 转换为二进制数时， 因为已经到 2， 所以需要<br>进 1， 那么二进制数即为 10B； 十进制数 5 转换为二进制数， 2 为 10B， 那么 3<br>即为 10B+1B=11B， 4 即为 11B+1B=100B， 5 即为 100B+1B=101B。 依次类推， 当十<br>进制数为 254 时， 对应而=二进制数为 1111 1110B<code>（中间空一格是为了方便阅读，实际编写不要空格）</code> 。  </p><p>我们可以找出一般规律， 当二进制数转换为十进制数时， 从二进制数的最后<br>一位往前看， 每一位代表的数为 2 的 n 次幂， 这里的 n 表示从最后起的第几位二<br>进制数， n 从 0 算起， 若对应该二进制数位上有 1， 那么就有值， 为 0 则无值。<br>例如， 再把二进制数 1111 1110B 反推回十进制数， 计算过程如下：<br><strong>0 <em> 2^0^+1 </em> 2^1^+1 <em> 2^2^+1 </em> 2^3^+1 <em> 2^4^+1 </em> 2^5^+1 <em> 2^6^+1 </em> 2^7^=254</strong><br>其中 2^n^ 称为“ 位权” 。 对于十进制与二进制之间的转换， 我们能熟练掌握<br>0-15 以内的数就够用了， 为了方便记忆， 我们归纳如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211212487.png" alt="image-20230610211212487"></p><p>实际开发中常常会用到其它比较大的数， 这时我们用 Windows 系统自带的计算器， 选择程序员模式， 可以非常方便的进行二进制、 八进制、 十进制、 十六进制数之间的任意转换， 如下图所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211240014.png" alt="image-20230610211240014"></p><h5 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h5><p>十六进制与二进制大同小异， 不同之处就是十六进制是“逢十六进一， 借一当十六”  。还有一点特别之处需要注意， 十进制的 0-15 表示成十六进制为 0~9、A、 B、 C、 D、 E、 F， 即十进制的 10 对应十六进制的 A， 11 对应 B， 以此类推。我们一般在十六进制数的最后面加上后缀 H， 表示该数为十六进制数， 如 AH、 DEH等。 这里的字母不区分大小写， 在 C 语言编程时要写成“0xa， 0xde” ， 在数的最前面加上“0x” 表示该数为十六进制数。 十进制数与十六进制数之间的转换在这里不再讲解， 大家可参考十进制与二进制数之间的转换规则。 关于十进制、 二进制与十六进制数之间的转换， 我们要熟练掌握 0~15 之间的数， 因为在以后的单片机 C 语言编程中， 我们要大量使用它们。 一般的转换规律是， 先将二进制数转换为十进制数， 再将十进制数转换为十六进制数， 这里不用死机， 在后面的学习中遇到多了也就记住了。 二进制、 十进制、 十六进制 0~15 的数的转换关系如下  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610211859176.png" alt="image-20230610211859176"></p><h4 id="二进制的逻辑运算"><a href="#二进制的逻辑运算" class="headerlink" title="二进制的逻辑运算"></a>二进制的逻辑运算</h4><p>与运算</p><p>“与” 运算是实现“必须都有， 否则就没有” 这种逻辑关系的一种运算。 C语言中运算符为<code>“&amp;”</code> ， 其运算规则如下： 0&amp;0=0， 0&amp;1=0（1&amp;0=0） ,1&amp;1=1。 其运算符号如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212201143.png" alt="image-20230610212201143"></p><p>C 语言中<code>“&amp;&amp;”</code> 表示“按位与” 运算， 意思是变量之间按二进制位数对应关系一一进行“与” 运算。 如（0101 0101） &amp;&amp;（1010 1010） =0000 0000， 而上面讲到的“&amp;” 运算只是对单一位进行运算  </p><p>或运算</p><p>或” 运算是实现“只要其中之一有就有” 这种逻辑关系的一种运算。 C 语言中运算符为<code>“|”</code> ， 其运算规则如下： 0|0=0， 0|1=1（1|0=1） ， 1|1=1。 其运算符号如下  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212329934.png" alt="image-20230610212329934"></p><p>C 语言中<code>“||”</code> 表示“按位或” 运算， 意思是变量之间按二进制位数对应关系一一进行“或” 运算。 如（0101 0101） ||（1010 1010） =1111 1111， 而上面讲到的“|” 运算只是对单一位进行运算。  </p><p>非运算  </p><p>“非” 运算是实现“求反” 这种逻辑关系的一种运算。 C 语言中运算符为“!”，其运算规则如下： !0=1， !1=0。 其运算符号如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212415422.png" alt="image-20230610212415422"></p><p>C 语言中<code>“~”</code> 表示“按位取反” 运算。 如~0101 0101=1010 1010， 而上面讲到的“!” 运算只是对单一位进行运算  </p><p>同或运算  </p><p>“同或” 与“异或” 运算使用的较少， 我们在这里只做简单了解， 大家用到之处可再查找相关资料。 “同或” 运算是实现“必须相同， 否则就没有” 这种逻辑关系的一种运算， 其逻辑运算符为<code>“⊙”</code>。 其运算规则如下：0⊙0=1， 0⊙1=0（1⊙0=0） ， 1⊙1=1。 ==在 C 语言中没有规定符号==。 其运算符号如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212508215.png" alt="image-20230610212508215"></p><p>异或运算  </p><p>异或” 运算是实现“必须不同， 否则就没有” 这种逻辑关系的一种运算，其逻辑运算符为<code>“⊕ ”</code> 。 其运算规则如下： 0⊕ 0=0， 0⊕ 1=1（1⊕ 0=1） ， 1⊕ 1=0。在 C 语言中有“按位异或” 运算<code>“^”</code>。 其运算符号如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212544416.png" alt="image-20230610212544416"></p><h4 id="C51-扩充数据类型"><a href="#C51-扩充数据类型" class="headerlink" title="C51 扩充数据类型"></a>C51 扩充数据类型</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212720411.png" alt="image-20230610212720411"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610212654220.png" alt="image-20230610212654220"></p><h3 id="四、51单片机最小系统"><a href="#四、51单片机最小系统" class="headerlink" title="四、51单片机最小系统"></a>四、51单片机最小系统</h3><h4 id="51-单片机最小系统构成"><a href="#51-单片机最小系统构成" class="headerlink" title="51 单片机最小系统构成"></a>51 单片机最小系统构成</h4><p>若要使系统正常运行， 必须确保单片机的最小系统稳定工作。 51 单片机的最<br>小系统由以下几部分组成：<br>（1） 晶振电路<br>（2） 复位电路<br>（3） 电源电路<br>（4） 下载电路<br>第（4） 是我们添加进来的， 实际上最小系统只由前面 3 个部分组成。 为什<br>么要加入第（4） 部分呢？ 仅靠前面 3 个部分电路只能使单片机正常运行， 但如<br>果我们要给系统更新程序即烧入程序时就没有办法了， 所以我们将第（4） 部分<br>电路也加入到最小系统当中， 这时候我们就可以给系统自由烧入程序了。</p><p>晶振电路提供时钟给单片机工作， 犹如人的心脏。 复位电路提供系统复位操<br>作， 当系统出现运行不正常或者死机等情况时， 可以通过复位按键重新启动系统。<br>电源电路也是非常关键的一个部分， 因为单片机对供电电压是有要求的， 如果电压过大将烧坏芯片， 如果电压过小系统将运行不了。 所以选择一个合适稳定的电源电路是非常关键的  </p><p>还有一点非常重要， 由于 51 单片机的 P0 口是漏极开路， 即输出高电平会导致高阻态， 要让它输出高电平就必须外接上拉电阻， 如下  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610213006547.png" alt="image-20230610213006547"></p><p>相同网络标号的表示其线路是连接在一起的， 这个在后面章节会介绍。 为了增强其他 IO 口的驱动能力， 开发板上也都为其外接了上拉电阻（除了串口） ，通常上拉电阻选择 10K 左右。下面就来介绍下这 4 部分的电路</p><h4 id="晶振电路"><a href="#晶振电路" class="headerlink" title="晶振电路"></a>晶振电路</h4><p>由于单片机正常工作需要一个时钟， 因此就需要在其晶振引脚上外接晶振（我们使用的 STC89CXX 单片机晶振引脚是 18 和 19 脚） ， 至于需要多大晶振这就取决于你所使用的单片机， 由于我们使用的是 51 单片机， 其时钟频率可在0-40MHZ 上运行， 一般情况下我们建议选择 12M（ 适合计算延时时间） 或者是11.0592M（适合串口通信） 。 若直接将此晶振接入单片机晶振引脚， 会发现系统工作不稳定， 这是因为晶振起振的一瞬间会产生一些电感， 为了消除这个电感所带来的干扰， 可以在此晶振两端分别加上一个电容， 电容的选取需要无极性的，另一端需要共地。 根据选取的晶振大小决定电容值， 通常电容可在 10-33PF 值范围内选取。 我们使用的是 33PF 电容。 这样一来就构成了晶振电路。 只有保证晶振电路稳定， 单片机才能继续工作。 其电路如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214427564.png" alt="image-20230610214427564"></p><h4 id="复位电路"><a href="#复位电路" class="headerlink" title="复位电路"></a>复位电路</h4><p>前面我们已经将晶振电路搭建完成， 我们知道晶振犹如人的心脏， 需要无时无刻给单片机提供运行周期。 但即使时钟周期在不停的运行， 系统也有可能会出现崩溃或者瘫痪状态。 这就好比人会生病一样， 人一生病就得看医生， 服用医生开的药后重新获得正常状态。 那么单片机呢， 它是如何获取重生的？ 这就需要设计一个复位电路来实现此功能。 我们知道单片机引脚当中就有一个 RST 复位引脚， 而 STC89CXX 单片机又是高电平复位， 所以只需要让这个引脚保持一段时间高电平就可以。 要实现此功能通常有两种方式， 一种是通过按键进行手动复位，还有一种是上电复位， 即电源开启后自动复位。 手动复位是通过一个按键及电容电阻所组成， 利用按键的开关功能实现复位， 按键按下后 VCC 直接进入到单片机RST 引脚， 松开后 VCC 断开， RST 被电阻拉为低电平。 这一合一开就实现了手动复位。 而自动复位主要是利用 RC 充放电功能， 电源已开启， 由于电容隔直， VCC直接进入 RST， 然后电容开始慢慢充电， 直到充电完成， 此时 RST 被电阻拉低。这样就起到上电复位的效果。 这里我们采用手动复位。 不到系统崩溃， 我们几乎不会操作复位。 复位电路如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214512005.png" alt="image-20230610214512005">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214517742.png" alt="image-20230610214517742">                </p><p>当按下按键 RSTK1， VCC 直接连接到 RST 复位脚， VCC 是高电平所以系统复位。  </p><h4 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h4><p>任何电子器件都需要有一个合适的电源进行供电， 这就好比人要吃饭一样，没有电源， 系统是不会工作的。 STC89CXX 单片机的工作电压是 3.3-5.5V 范围，通常我们使用 5V 直流。 将电源接入到各芯片电源引脚即可。 开发板电源电路如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214623132.png" alt="image-20230610214623132">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214632548.png" alt="    "> </p><p>开发板上还预留了 P3（5V/3V） 端子， 这些端子可以很方便的给外部模块连接电源  </p><h4 id="下载电路"><a href="#下载电路" class="headerlink" title="下载电路"></a>下载电路</h4><p>在前面已经介绍过为什么要加下载电路到最小系统中， 这里就不再重复。 程<br>序要烧写到单片机内是通过上位机（ PC 机） 及对应的软件将编译器生成的<br>xxx.HEX 文件通过单片机串口写入进去。<br>        我们知道现在的笔记本电脑没有 RS232 接口， 所以要使用 USB 转 TTL 串口电<br>平芯片来建立 PC 机和单片机数据传输通路。 通常使用 CH340G 或者 CH340C 芯片<br>来完成电平转换。 CH340G 需外接 12M 晶振， 而 CH340C 内部自带晶振， 所以可<br>不接外部 12M 晶振。 开发板上使用的是 CH340C 芯片。</p><p>开发板下载电路如下图所示</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214837737.png" alt="image-20230610214837737"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610214842614.png" alt="image-20230610214842614"></p><p>本电路是我们自主研发的一键自动下载电路， 无需冷启动。 主要依靠上位机<br>软件（PZ-ISP） 控制 CH340 芯片的 RTS 和 DTR 脚输出， 进而使 MOS 管 Q3 自动断电后上电， 完成冷启动工作。<br>        从上图可以知道， USB1 接口即为程序下载接口， D-和 D+连接到 CH340 芯片<br>的 D-和 D+， 然后 CH340 芯片的串口 TXD 和 RXD 管脚就连接到单片机的串口（P3.0、P3.1） 上， 这里不是直接连接到单片机串口， 而是通过 P5 端子进行转接。 这样做不仅可以让开发板 USB 接口下载程序， 还可以让单片机串口不受 CH340 干扰，这样开发板也可以当成 USB 转 TTL 模块使用， 该设计也是考虑 WIFI、 蓝牙等模块与串口通信不受干扰问题。</p><p>​        USB1 接口不仅可以作为程序下载口， 还可以作为串口通信口， 因为它本身就<br>是实现串口下载。 同时还可以作为电源供电口， 可以看到 USB1 的管脚 1 就是 5V<br>电源脚， 所以开发板的可以直接使用 USB 线来供电， 如果提供的 USB 线有问题，<br>可以使用安卓手机数据线， 接口都是兼容的。 当电源开关打开后， 电源指示灯<br>DP1 即会点亮， 表明系统电源正常。<br>​        至此， 我们就把 51 单片机的最小系统介绍完， 大家在制作最小系统时， 可<br>以参考我们的电路， 这样成功几率会更高。</p><h3 id="五、51单片机工程模板"><a href="#五、51单片机工程模板" class="headerlink" title="五、51单片机工程模板"></a>五、51单片机工程模板</h3><h4 id="单片机工程模板创建"><a href="#单片机工程模板创建" class="headerlink" title="单片机工程模板创建"></a>单片机工程模板创建</h4><h5 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h5><p>首先在电脑任意位置新建一个文件夹， 命名为“51 单片机工程模板创建” 。打开 KEIL C51 软件， 新建一个工程， 工程名根据喜好命名， 但是要注意使用英文， 如果使用中文名可能会出现一些奇怪的错误， 这里我们命名为template， 直接保存在刚才创建的“51 单片机工程模板创建” 文件夹下。 具体步骤如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215508546.png" alt="image-20230610215508546"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215514833.png" alt="image-20230610215514833"></p><h5 id="选择CPU型号"><a href="#选择CPU型号" class="headerlink" title="选择CPU型号"></a>选择CPU型号</h5><p>这个根据开发板使用的 CPU 具体的型号来选择， 我们开发板使用的是STC89C52 或 STC89C516 芯片。 在 KEIL C51 软件内找不到这种型号的单片机， 因为 51 内核单片机具有通用性， 所以在这里可以任选一款 89C52 就行， Keil 软件的关键是程序代码的编写， 而非用户选择什么硬件， 在这里我们选择 Ateml 的89C52 来说明。 具体操作如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215616757.png" alt="image-20230610215616757"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215623993.png" alt="image-20230610215623993"></p><p>点击 OK 键后， 弹出如下对话框：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215637391.png" alt="image-20230610215637391"></p><p>该对话框内容是提示我们是否要将 8051 启动文件添加到工程中， 这里我们选择“否” ， 原因是 KEIL C51 内已经帮我们完成了启动， 所以只需要编写应用程序即可。 选择“否” 后界面如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215648213.png" alt="image-20230610215648213"></p><h5 id="给工程添加文件"><a href="#给工程添加文件" class="headerlink" title="给工程添加文件"></a>给工程添加文件</h5><p>选择 File/New…或者使用工具栏的图标 <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215726575.png" alt="image-20230610215726575"> 来新建一个文件后点击保存， 系统会自动定位到我们工程目录， 只需要在文件名栏输入新建的文件名即可， 一个 51 单片机工程必须含有且仅有一个 main 函数， 因此将新建的文件命名为 main.c（当然也可以根据个人习惯自定义命名， 但必须是英文） ， 点击保存。 具体操作步骤如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215746484.png" alt="image-20230610215746484"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215753306.png" alt="image-20230610215753306"></p><p>然后将新建的 main.c 文件添加到工程中， 选择工程组“Source Group 1”,鼠标右键选择“Add Files to Group ‘Source Group 1’ …” ,然后选择对应的 xxx.c 文件， 点击 Add 键后在点击 Close 关闭。 这时工程中就显示已加入的文件。 具体操作如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215823160.png" alt="image-20230610215823160"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215828167.png" alt="image-20230610215828167"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610215831837.png" alt="image-20230610215831837"></p><h5 id="配置魔术棒选项卡"><a href="#配置魔术棒选项卡" class="headerlink" title="配置魔术棒选项卡"></a>配置魔术棒选项卡</h5><p>这一步的配置工作非常重要， 很多人自己编写程序编译后发现找不到 .HEX 文件， 或者使用我们 51 仿真器的时候出现仿真失败， 这些问题都是在这个地方没有配置好导致的。1， 选择魔术棒工具的 Output 选项卡， 勾选红色框 3， 即程序编译成功后会产生 HEX 文件。 具体操作如下</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230610220013528.png" alt="image-20230610220013528"></p><h3 id="reg52-h-头文件"><a href="#reg52-h-头文件" class="headerlink" title="reg52.h 头文件"></a>reg52.h 头文件</h3><p>头文件作用  </p><p>在代码中引用头文件， 其实际意义就是将这个头文件中的全部内容放到引用头文件的位置处， 免去我们每次编写同类程序都要将头文件中的语句重复编写。在代码中加入头文件有两种书写方法， 分别为#include <reg52.h>和#include “reg52.h”， 包含头文件时都不需要在后面加分号。 两种写法的区别如下：  </p><p>①当使用&lt;&gt;包含头文件时， 编译器先进入到软件安装文件夹处开始搜索这个头文件， 也就是 KEILC51/C51/INC 这个文件夹下， 如果这个文件夹没有引用的头文件， 编译器将会报错。</p><p>②当使用””包含头文件时， 编译器先进入到当前工程所在文件夹处开始搜索该头文件， 如果当前工程所在文件夹下没有该头文件， 编译器将继续回到软件安装文件夹处搜索这个头文件， 若找不到该头文件， 编译器将报错。</p><h3 id="点亮第一个LED"><a href="#点亮第一个LED" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h3><p>不论学习什么单片机， 最简单的外设莫过于 IO 口的高低电平控制， 本章将向大家介绍如何在创建好的工程模板上， 通过控制 51 单片机的 GPIO 使开发板上的 LED 灯点亮。 通过本章的学习， 让大家学会如何在程序中操作 51 单片机的 GPIO 口输出高低电平  </p><h4 id="单片机-GPIO-介绍"><a href="#单片机-GPIO-介绍" class="headerlink" title="单片机 GPIO 介绍"></a>单片机 GPIO 介绍</h4><p>GPIO 概念  </p><p>GPIO（general purpose intput output） 是通用输入输出端口的简称， 可<br>以通过软件来控制其输入和输出。 51 单片机芯片的 GPIO 引脚与外部设备连接<br>起来， 从而实现与外部通讯、 控制以及数据采集的功能。 不过 GPIO 最简单的应<br>用还属点亮 LED 灯了， 只需通过软件控制 GPIO 输出高低电平即可。 当然 GPIO<br>还可以作为输入控制， 比如在引脚上接入一个按键， 通过电平的高低判断按键是<br>否按下。<br>我们开发板上使用的 51 单片机型号是 STC89C52 或 STC89C516， 此芯片共有<br>40 引脚， 芯片引脚图如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085529785.png" alt="image-20230611085529785"></p><p>那么是不是所有引脚都是 GPIO 呢？ 当然不是， 51 单片机引脚可以分为这么<br>几大类：<br>（1） 电源引脚： 引脚图中的 VCC、 GND 都属于电源引脚。<br>（2） 晶振引脚： 引脚图中的 XTAL1、 XTAL2 都属于晶振引脚。<br>（3） 复位引脚： 引脚图中的 RST/VPD 属于复位引脚， 不做其他功能使用。<br>（4） 下载引脚： 51 单片机的串口功能引脚（TXD、 RXD） 可以作为下载引脚</p><p>（5） GPIO 引脚： 引脚图中带有 Px.x 等字样的均属于 GPIO 引脚。 从引脚<br>图可以看出， GPIO 占用了芯片大部分的引脚， 共达 32 个， 分为了 4 组， P0、 P1、P2、 P3， 每组为 8 个 IO， 而且在 P3 组中每个 IO 都具备额外功能， 只要通过相<br>应的寄存器设置即可配置对应的附加功能， 同一时刻， 每个引脚只能使用该引脚的一个功能。</p><p>​        对于这么多 GPIO 管脚， 我们怎么知道具体某个引脚有什么功能呢？ 很简<br>单， 可以查阅 STC89CXX 芯片数据手册获取信息， 数据手册在我们资料“\6—芯<br>片资料\开发板芯片数据手册” 内， 里面有一个 STC89CXX 数据手册.pdf。 里面的<br>第 23 页中就有介绍， 我们截取了一部分内容如下图所示</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085706291.png" alt="image-20230611085706291"></p><p>从上图中我们可以获取引脚的名字和引脚功能等信息。 这个我们开发板芯片原理图内已经将引脚所有功能都标进去了， 所以后面也不需要查找具体引脚有什么功能， 直接看原理图即可  </p><h4 id="GPIO-结构框图与工作原理"><a href="#GPIO-结构框图与工作原理" class="headerlink" title="GPIO 结构框图与工作原理"></a>GPIO 结构框图与工作原理</h4><p>我们使用的 51 单片机 GPIO 分为 P0、 P1、 P2 和 P3 口， 下面分别来介绍其内部结构框图与工作原理。  </p><h5 id="P0-端口"><a href="#P0-端口" class="headerlink" title="P0 端口"></a>P0 端口</h5><p>P0 端口含有 8 位引脚， 下图为其中一个， 其它几个与之完全一致， 因此只需了解当中一个即可。 如下图所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611085920770.png" alt="image-20230611085920770"></p><p>​    由上图可见， P0 端口由锁存器、 输入缓冲器、 切换开关、 一个非门、 一个与<br>非门及场效应管驱动电路构成。 再看图的最右边， 标号为 P0.x 引脚的图标， 也<br>就是说 P0.x 引脚可以是 P0.0 到 P0.7 的任何一位， 即在 P0 口有 8 个与上图相同<br>的电路组成</p><p>下面， 我们先就组成 P0 口的每个单元部份跟大家介绍一下：  </p><p><strong>①输入缓冲器</strong>  </p><p>​        在 P0 口中， 有两个三态的缓冲器， 在学数字电路时， 我们已知道， 三态门<br>有三个状态， 即在输出端可以是高电平、 低电平， 同时还有一种就是高阻状态（或<br>称为禁止状态） ， 大家看上图， 上面一个是读锁存器的缓冲器， 也就是说， 要读<br>取 D 锁存器输出端 Q 的数据， 那就得使读锁存器的这个缓冲器的三态控制端（上<br>图中标号为‘读锁存器’ 端） 有效。 下面一个是读引脚的缓冲器， 要读取 P0.x<br>引脚上的数据， 也要使标号为‘读引脚’ 的这个三态缓冲器的控制端有效， 引脚<br>上的数据才会传输到我们单片机的内部数据总线上。 </p><p><strong>②D 锁存器</strong>  </p><p>​        构成一个锁存器， 通常要用一个时序电路， 时序的单元电路在学数字电路时<br>我们已知道， 一个触发器可以保存一位的二进制数（即具有保持功能） ， 在 51<br>单片机的 32 根 I/O 口线中都是用一个 D 触发器来构成锁存器的。 大家看上图中<br>的 D 锁存器， D 端是数据输入端， CP（CLK） 是控制端（也就是时序控制信号输<br>入端） ， Q 是输出端， Q 非是反向输出端。<br>​        对于 D 触发器来讲， 当 D 输入端有一个输入信号， 如果这时控制端 CP 没有<br>信号（也就是时序脉冲没有到来） ， 这时输入端 D 的数据是无法传输到输出端 Q<br>及反向输出端 Q 非的。 如果时序控制端 CP 的时序脉冲一旦到了， 这时 D 端输入的数据就会传输到 Q 及 Q 非端。 数据传送过来后， 当 CP 时序控制端的时序信号消失了， 这时， 输出端还会保持着上次输入端 D 的数据（即把上次的数据锁存起来了） 。 如果下一个时序控制脉冲信号来了， 这时 D 端的数据才再次传送到 Q端， 从而改变 Q 端的状态。  </p><p><strong>③多路开关</strong>  </p><p>​        在 51 单片机中， 当内部的存储器够用（也就是不需要外扩展存储器时， 这<br>里讲的存储器包括数据存储器及程序存储器） 时， P0 口可以作为通用的输入输<br>出端口（即 I/O） 使用， 对于 8031（内部没有 ROM） 的单片机或者编写的程序超<br>过了单片机内部的存储器容量， 需要外扩存储器时， P0 口就作为‘地址/数据’<br>总线使用。 那么这个多路选择开关就是用于选择是做为普通 I/O 口使用还是作为<br>‘数据/地址’ 总线使用的选择开关了。 大家看上图， 当多路开关与下面接通时，<br>P0 口是作为普通的 I/O 口使用的， 当多路开关是与上面接通时， P0 口是作为‘地<br>址/数据’ 总线使用的</p><p><strong>④场效应管输出驱动</strong>  </p><p>​        从上图中可以看出， P0 口的输出是由两个 MOS 管组成的推拉式结构， 也就是<br>说， 这两个 MOS 管一次只能导通一个， 当 V1 导通时， V2 就截止， 当 V2 导通时，V1 截止。</p><p><strong>⑤与非门、 非门</strong>  </p><p>​            这个在学习数字电路时也很好理解， 如果没有数字电路基础的用户， 可以百<br>度查找与非门、 非门以及前面的 D 触发器详细了解， 这里就不再过多叙述。 当然<br>如果搞不明白这些也不会影响后续我们学习 51 单片机编程， 大家也可以忽略。<br>​            前面我们已将 P0 口的各单元部件进行了一个详细的讲解， 下面我们就来研究一下 P0 口做为 I/O 口及地址/数据总线使用时的具体工作过程</p><p>（1） 作为 I/O 端口输出使用时的工作原理  </p><p>​            P0 口作为 I/O 端口使用时， 多路开关的控制信号为 0（低电平） ， 看上图中的红线部份， 多路开关的控制信号同时与与非门的一个输入端是相接的， 我们知道与门的逻辑特点是“全 1 出 1， 有 0 出 0” 那么控制信号是 0 的话， 这时与门输出的也是一个 0（低电平） ， 与门的输出是 0， V1 管就截止， 在多路控制开关的控制信号是 0（低电平） 时， 多路开关是与锁存器的 Q 非端相接的（即 P0 口作为 I/O 口线使用）  </p><p>​            P0 口用作 I/O 口线， 其由数据总线向引脚输出（即输出状态 Output） 的工作过程： 当写锁存器信号 CP 有效， 数据总线的信号→锁存器的输入端→D 锁存器的反向输出 Q 非端→多路开关→V2 管的栅极→V2 的漏极到输出端 P0.X。 前面我们已讲了， 当多路开关的控制信号为低电平 0 时， 与门输出为低电平， V1 管是截止的， 所以作为输出口时， P0 是漏极开路输出， 类似于 OC 门， 当驱动上接电流负载时， 需要外接上拉电阻。  </p><p>​            下图就是由内部数据总线向 P0 口输出数据的流程图（红色箭头） ：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090402480.png" alt="image-20230611090402480"></p><p>(2） 作为 I/O 端口输入使用时的工作原理  </p><p>数据输入时（读 P0 口） 有两种情况：<br>1、 读引脚<br>读芯片引脚上的数据， 读引脚数时， 读引脚缓冲器打开（即三态缓冲器的控<br>制端要有效） ， 通过内部数据总线输入， 请看下图（红色箭头） 。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090445235.png" alt="image-20230611090445235"></p><p>2、 读锁存器  </p><p>通过打开读锁存器三态缓冲器读取锁存器输出端 Q 的状态， 请看下图（红色箭头)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090531712.png" alt="image-20230611090531712"></p><p>因为现在 STC 51 单片机内存已经足够使用， 所以也用不到通过 P0 口外扩存储器， 对于 P0 口作为外扩存储器时的工作原理这里就不叙述， 如需了解的朋友可以上网百度。  </p><h5 id="P1端口"><a href="#P1端口" class="headerlink" title="P1端口"></a>P1端口</h5><p>​            P1 口的结构最简单， 用途也单一， 仅作为数据输入/输出端口使用。 输出的信息有锁存， 输入有读引脚和读锁存器之分。 P1 端口的一位结构见下图  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090756900.png" alt="image-20230611090756900"></p><p>​            由图可见， P1 端口与 P0 端口的主要差别在于， P1 端口用内部上拉电阻 R 代替了 P0 端口的场效应管 V1， 并且输出的信息仅来自内部总线。 由内部总线输出<br>的数据经锁存器反相和场效应管反相后， 锁存在端口线上， 所以， P1 端口是具有输出锁存的静态口。</p><p>​            由上图可见， 要正确地从引脚上读入外部信息， 必须先使场效应管关断， 以<br>便由外部输入的信息确定引脚的状态。 为此， 在作引脚读入前， 必须先对该端口<br>写入 l。 具有这种操作特点的输入/输出端口， 称为准双向 I/O 口。 8051 单片机<br>的 P1、 P2、 P3 都是准双向口。 P0 端口由于输出有三态功能， 输入前， 端口线已<br>处于高阻态， 无需先写入 l 后再作读操作。<br>​            P1 口的结构相对简单， 前面我们已详细的分析了 P0 口， 只要大家认真的分<br>析了 P0 口的工作原理， P1 口我想大家都有能力去分析， 这里我就不多论述了。<br>​            单片机复位后， 各个端口已自动地被写入了 1， 此时， 可直接作输入操作。<br>如果在应用端口的过程中， 已向 P1 一 P3 端口线输出过 0， 则再要输入时， 必须<br>先写 1 后再读引脚， 才能得到正确的信息。 此外， 随输入指令的不同， P1 端口<br>也有读锁存器与读引脚之分。</p><h5 id="P2端口"><a href="#P2端口" class="headerlink" title="P2端口"></a>P2端口</h5><p>P2 端口的一位结构见下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611090901412.png" alt="image-20230611090901412"></p><p>​        由图可见， P2 端口在片内既有上拉电阻， 又有切换开关 MUX， 所以 P2 端口<br>在功能上兼有 P0 端口和 P1 端口的特点。 这主要表现在输出功能上， 当切换开关<br>向下接通时， 从内部总线输出的一位数据经反相器和场效应管反相后， 输出在端<br>口引脚线上； 当多路开关向上时， 输出的一位地址信号也经反相器和场效应管反<br>相后， 输出在端口引脚线上。</p><p>​            对于 8031 单片机必须外接程序存储器才能构成应用电路（或者我们的应用<br>电路扩展了外部存储器） ， 而 P2 端口就是用来周期性地输出从外存中取指令的<br>地址(高 8 位地址)， 因此， P2 端口的多路开关总是在进行切换， 分时地输出从<br>内部总线来的数据和从地址信号线上来的地址。 因此 P2 端口是动态的 I/O 端口。<br>输出数据虽被锁存， 但不是稳定地出现在端口线上。 其实， 这里输出的数据往往<br>也是一种地址， 只不过是外部 RAM 的高 8 位地址。<br>​            P2 口既可作为 I/O 口使用， 也可作为地址总线使用， 通常主要用作 I/O 口使<br>用， 地址总线使用不作分析。<br>​            P2 口的结构相对简单， 前面我们已详细的分析了 P0 和 P1 口， 只要大家认真的分析了它们的工作原理， P2 口我想大家都有能力去分析， 这里我就不多论述<br>了</p><h5 id="P3端口"><a href="#P3端口" class="headerlink" title="P3端口"></a>P3端口</h5><p>​        P3 口是一个多功能口， 它除了可以作为 I/O 口外， 还具有第二功能， P3 端口的一位结构见下图  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091031839.png" alt="image-20230611091031839"></p><p>​        由上图可见， P3 端口和 Pl 端口的结构相似， 区别仅在于 P3 端口的各端口线有两种功能选择。 当处于第一功能时， 第二输出功能线为 1， 此时， 内部总线信号经锁存器和场效应管输入/输出， 其作用与 P1 端口作用相同， 也是静态准双向 I/O 端口。 当处于第二功能时， 锁存器输出 1， 通过第二输出功能线输出特定的内含信号， 在输入方面， 即可以通过缓冲器读入引脚信号， 还可以通过替代输入功能读入片内的特定第二功能信号。 由于输出信号锁存并且有双重功能， 故P3 端口为静态双功能端口。 有关 P3 口第二功能， 在前面章节芯片管脚功能定义已经讲解过， 此处不再重复  </p><p>​            至此， 我们就把 51 单片机的 P0、 P1、 P2 和 P3 口内部结构及原理讲解完，可能有的朋友会很懵、 看不懂， 没关系， 这些都不会影响你编写单片机应用程序， 大家记住以下几点即可：</p><p><code>①P0 口是漏极开路， 要使其输出高电平， 必须外接上拉电阻， 通常选择4.7K~10K 阻值。</code></p><p><code>②P0、 P1、 P2 几乎都用作普通 I/O 口使用， 既可作为输入， 又可作为输出。</code></p><p><code>③P3 口既可用作普通 I/O 口， 又可作为第二功能使用， 比如串口、 外部中断、 计数器等</code></p><h4 id="LED-简介"><a href="#LED-简介" class="headerlink" title="LED 简介"></a>LED 简介</h4><p>​        LED 即发光二极管。 它具有单向导电性， 通过 5mA 左右电流即可发光， 电流<br>越大， 其亮度越强， 但若电流过大， 会烧毁二极管， 一般我们控制在 3 mA-20mA<br>之间， 通常我们会在 LED 管脚上串联一个电阻， 目的就是为了限制通过发光二极管的电流不要太大， 因此这些电阻又可以称为“限流电阻” 。 当发光二极管发光时， 测量它两端电压约为 1.7V， 这个电压又叫做发光二极管的“导通压降” 。下图左右分别为直插式发光二极管和贴片式发光二极管实物图。 发光二极管正极又称阳极， 负极又称阴极， 电流只能从阳极流向阴极。 直插式发光二极管长脚为阳极， 短脚为阴极。 仔细观察贴片式发光二极管正面的一端有彩色标记， 通常有标记的一端为阴极。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091320385.png" alt="image-20230611091320385">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091358434.png" alt="image-20230611091358434"></p><h4 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上 LED 模块电路如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091447518.png" alt="image-20230611091447518"></p><p>​                在前面我们介绍过如何查看原理图， 相同网络标号表示它们是连接在一起<br>的， 因此 D1-D8 连接到单片机的 P20-P27 口。 图中 LED 采用共阳接法， 即所有<br>LED 阳极管脚接电源 VCC， 阴极管脚通过一个 470 欧的限流电阻接到 P2 口上。 根<br>据前面 LED 的介绍我们知道， 要让 LED 发光即对应的阴极管脚应该为低电平， 若<br>为高电平则熄灭。<br>​            如果要想 51 单片机控制 LED， 就必须通过单片机管脚在 P2 口上输出低电平。本章所要实现的功能是： 点亮 D1 指示灯。</p><h4 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h4><h5 id="点亮第一个LED-1"><a href="#点亮第一个LED-1" class="headerlink" title="点亮第一个LED"></a>点亮第一个LED</h5><p>点亮 D1 指示灯， 即让 P2.0 管脚输出一个低电平。完成后可再控制 D1 指示灯闪烁， 即间隔一段时间点亮和熄灭 D1 指示灯  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>; <span class="comment">//将 P2.0 管脚定义为 LED1</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">0</span>; <span class="comment">//LED1 端口设置为低电平</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611091756870.png" alt="image-20230611091756870">    </p><p>code： 表示程序所占用 FLASH 的大小。<br>data： 数据储存器内部 RAM 占用大小。<br>xdata： 数据储存器外部 RAM 占用大小。</p><h5 id="LED-闪烁实验"><a href="#LED-闪烁实验" class="headerlink" title="LED 闪烁实验"></a>LED 闪烁实验</h5><p>​            如果要实现 LED 闪烁， 只需循环让 D1 指示灯先亮一会后熄灭。 这里就有一<br>个延时问题， 如何来产生延时呢？ 我们知道单片机执行每条代码指令都是需要时<br>间的， 在前面介绍 C 语言时讲解过循环语句， 因此只需编写一个循环函数， 让<br>CPU 不干其它事， 专门在那循环运行即可实现延时功能。 依据人的肉眼余晖效应，<br>延时时间不能太短， 否则就无法观察到 LED 闪烁。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码即为延时函数， 通过 while 循环来实现。 函数入口有一个形式参数ten_us， 如果 ten_us 等于 1， 则 while 循环执行一次， 调用该函数延时时间大约 10us， 当然使用循环来实现延时， 这种延时是不精确的， 目前我们先得到个大概的时间即可。细心的朋友可能会看到函数形参 ten_us 是 u16 类型的， 这个似乎不是 C 语言数据类型关键字， 这是我们重定义的数据类型， 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br></pre></td></tr></table></figure><p>使用关键字 typedef 对系统默认数据类型 unsigned int 和 unsigned char重新命名， 主要是方便我们代码的书写和变量类型的查看。 u16 即代表该变量是16 位的无符号整型数据， u8 代表该变量是 8 位的无符号字符型数据。 有了这个就知道参数的传送范围， 不能超过形参定义的范围。  </p><p>下面看下 main 函数代码， 如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1=<span class="number">0</span>; <span class="comment">//点亮</span></span><br><span class="line">delay_10us(<span class="number">50000</span>); <span class="comment">//大约延时 450ms</span></span><br><span class="line">LED1=<span class="number">1</span>; <span class="comment">//熄灭</span></span><br><span class="line">delay_10us(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数内实现功能很简单， 在 while 循环内不断间隔一定时间点亮 LED1和熄灭 LED1， 这样即可实现 D1 指示灯闪烁。 细心的朋友可能会问， 前面delay_10us 函数形参为 1 时大约是 10us， 那现在实参传输 50000， 不应该是 500ms吗， 为什么注释写的是 450ms 呢？ 这里还得回到刚才话题， 使用循环来延时只是获得一个大概的时间， 并不能精确， 如需精确延时， 后期我们会学习定时器。 此处就不用纠结这个问题  </p><h5 id="通过-KEIL-软件仿真查看延时时间"><a href="#通过-KEIL-软件仿真查看延时时间" class="headerlink" title="通过 KEIL 软件仿真查看延时时间"></a>通过 KEIL 软件仿真查看延时时间</h5><p>上述代码中我们传递实参是 50000， 得到的延时大约是 450ms， 如何来验证呢？ 可以通过 KEIL 自带的软件仿真功能， 操作如下：  </p><p>打开实验工程， 点击魔术棒， 选择“Target” 选项卡， 在 Xtal(MHz)文本框中输入 12M， 该值表示开发板上实际使用外部晶振大小， 如果开发板上使用外部晶振是 11.0592M， 则修改为对应值。 然后点击 OK。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092046007.png" alt="image-20230611092046007"></p><p>②点击仿真按钮， 进入仿真界面， 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092058330.png" alt="image-20230611092058330"></p><p>③点击 RST 按钮， 重新复位系统参数， 此时参数列表中 sec 则为 0， 然后在所要查看调试的代码数字前面用鼠标左键双击即可出现“红色块” ， 我们称之为断点。 如果再次双击， 即可取消该断点。 当点击红色标记 8 运行的时候就能直接运行到我们设置的断点处。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092112656.png" alt="image-20230611092112656"></p><p>④当点击红色标记 8 运行时， 可以看到黄色箭头直接定位到 36 行代码， 也就是我们刚才设置的第一个断点位置， 此时参数列表中 sec 时间是 0.00039s。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092125304.png" alt="image-20230611092125304"></p><p>⑤再次点击红色标记 8 运行时， 此时黄色箭头指向第 37 行代码， 此时 sec为 0.450601s。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230611092137475.png" alt="image-20230611092137475"></p><p>将现在这个时间减去上一步的 sec 时间就可以得到 delay_10us(50000)运行的实际时间了。 再次点击仿真按钮则可退出仿真界面， 回到程序编辑界面。  </p><p>KEIL 软件的仿真功能非常强大， 里面有很多功能， 包括在仿真时使用单步调试观察变量参数等都有， 这里就不过多介绍， 如果对这个感兴趣的可以自行百度搜索 KEILC51 软件仿真的使用  </p><h5 id="LED流水灯实验"><a href="#LED流水灯实验" class="headerlink" title="LED流水灯实验"></a>LED流水灯实验</h5><h6 id="使用移位和循环实现"><a href="#使用移位和循环实现" class="headerlink" title="使用移位和循环实现"></a>使用移位和循环实现</h6><p>如果要实现 LED 流水灯， 只需循环让 D1-D8 指示灯逐个点亮。 同样本实验也需要延时， 这个在前面已介绍， 这里就不多说。 要实现循环点亮， 可以使用最容易理解的方法： 点亮 D1 且把 D2-D8 熄灭， 延时一段时间后再点亮 D2 且把 D1、D3-D8 熄灭， 延时一段时间后再点亮 D3 且把 D1-D2、 D4-D8 熄灭， 如此循环， 这样就可以很简单的实现 LED 流水灯实验， 当然我们不推荐此种方法。 在前面我们学习了 C 语言相关的基础知识， 里面有移位以及循环语句操作， 根据流水灯实现原理， 即 IO 口由低往高或者由高往低逐个输出低电平特点， 那么我们可以将移位操作以及循环结合进来。 实现代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LED_PORT P2 <span class="comment">//使用宏定义 P2 端口</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">LED_PORT=~(<span class="number">0x01</span>&lt;&lt;i); <span class="comment">//将 1 右移 i 位， 然后取反将结果赋值到 LED_PORT</span></span><br><span class="line">delay_10us(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入 main 函数后首先定义一个变量 i， 然后进入 while 循环， 由于要实现 8个 LED 从 D1-&gt;D8 循环点亮， 因此可以使用 for 循环语句循环 8 次， 每循环一次，点亮的小灯向右移动一个， 而 D1-D8 是连接到 P2.0-P2.7 的， 因此输出的低电平要左移一位， 因此可以使用 LED_PORT=~(0x01&lt;&lt;i);语句实现。 0X01&lt;&lt;i 表示 i 增加 1 次， 0x01 中的 1 就移动多少位， 因为 1（高电平） 不会让 LED 点亮， 需要取反后变为低电平 0 才能点亮， 所以最后的结果需要取反后给 LED_PORT 口， 并且每次循环都要延时一段时间， 这样才能分辨出来 LED 在流水 。</p><h6 id="使用左移-crol-、-右移-cror-函数"><a href="#使用左移-crol-、-右移-cror-函数" class="headerlink" title="使用左移_crol_、 右移_cror_函数"></a>使用左移<code>_crol_</code>、 右移<code>_cror_</code>函数</h6><p>除了使用 for 循环语句实现移位， KEIL C51 软件内还有对应的移位库函数，左移函数是<code>_crol_()</code>， 右移函数是<code>_cror_()</code>， 要使用这两个函数在我们的程序中必须包含 intrins.h 头文件。 这两个移位函数大家可以百度了解下， 其内部实现过程是看不到的， 该移位函数实现的移位功能就相当于一个队列内循环移动， 如果是左移， 那么最高位就被移到最低位了， 次高位变为最高位， 依次类推。 使用左移、 右移函数实现的流水灯操作代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">LED_PORT=~<span class="number">0x01</span>;</span><br><span class="line">delay_10us(<span class="number">50000</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) <span class="comment">//将 led 左移一位</span></span><br><span class="line">&#123;</span><br><span class="line">LED_PORT=_crol_(LED_PORT,<span class="number">1</span>);</span><br><span class="line">delay_10us(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++) <span class="comment">//将 led 右移一位</span></span><br><span class="line">&#123;</span><br><span class="line">LED_PORT=_cror_(LED_PORT,<span class="number">1</span>);</span><br><span class="line">delay_10us(<span class="number">50000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 main 函数后首先定义一个变量 i， LED<em>PORT=~0x01， 因为 LED 是低电平点亮， 所以 0X01 取反后的结果是 0XFE， 对应二进制数为 1111 1110， 即最低位 为 0， 因此最开始的 D1 指示灯会点亮， 然后进入 while 循环， 使用 for 循环、`_crol</em><code>和</code><em>cror</em>`移位函数实现 LED 左右流水显示。  </p><p>细心的朋友可能会发现此处每个 for 循环只有 7 次， 为什么不是 8 次呢， 这是因为在进入 main 开始， 就已经将 LED_PORT 端口设置了一次状态， 即让 D1 点亮， 并且我们是想让 LED 从左至右依次点亮， 然后继续又从右至左依次点亮， 这样形成左右流水效果。 假如将循环次数改为 8 次， 我们列举下第一个 for 循环的LED_PORT 端口状态值， 如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始状态： LED_PORT=<span class="number">1111</span> <span class="number">1110</span></span><br><span class="line">i=<span class="number">0</span>： LED_PORT=<span class="number">1111</span> <span class="number">1101</span></span><br><span class="line">i=<span class="number">1</span>： LED_PORT=<span class="number">1111</span> <span class="number">1011</span></span><br><span class="line">i=<span class="number">2</span>： LED_PORT=<span class="number">1111</span> <span class="number">0111</span></span><br><span class="line">i=<span class="number">3</span>： LED_PORT=<span class="number">1110</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">4</span>： LED_PORT=<span class="number">1101</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">5</span>： LED_PORT=<span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">6</span>： LED_PORT=<span class="number">0111</span> <span class="number">1111</span></span><br><span class="line">i=<span class="number">7</span>： LED_PORT=<span class="number">1111</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure><p>过上述列举， 可以非常清楚的了解端口 LED 状态， 所以此处应该将循环次数设置为 7 次， 即 i 最大等于 6。 这样到下一个循环右移时就可以从最高位开始往低位移动， 从而实现左右流水灯效果  </p><h3 id="蜂鸣器实验"><a href="#蜂鸣器实验" class="headerlink" title="蜂鸣器实验"></a>蜂鸣器实验</h3><p>前面章节我们已经介绍了如何控制 51 单片机的 IO 口输出高低电平， 本章我们通过另外一个实验来讲述 51 单片机 IO 口的输出。 通过单片机的一个 IO 口控制板载无源蜂鸣器， 实现蜂鸣器控制。 学习本章可以参考前面 LED 实验章节内容。本章分为如下几部分内容 </p><h4 id="蜂鸣器介绍"><a href="#蜂鸣器介绍" class="headerlink" title="蜂鸣器介绍"></a>蜂鸣器介绍</h4><p>蜂鸣器是一种一体化结构的电子讯响器， 采用直流电压供电， 广泛应用于计算机、 打印机、 复印机、 报警器、 电子玩具、 汽车电子设备、 电话机、 定时器等电子产品中作发声器件。 蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。</p><p>压电式蜂鸣器主要由多谐振荡器、 压电蜂鸣片、 阻抗匹配器及共鸣箱、 外壳等组成。 多谐振荡器由晶体管或集成电路构成， 当接通电源后（1.5~15V 直流工作电压） ， 多谐振荡器起振,输出 1.5～5kHZ 的音频信号， 阻抗匹配器推动压电蜂鸣片发声。</p><p>电磁式蜂鸣器由振荡器、 电磁线圈、 磁铁、 振动膜片及外壳等组成。 接通电源后， 振荡器产生的音频信号电流通过电磁线圈， 使电磁线圈产生磁场， 振动膜片在电磁线圈和磁铁的相互作用下， 周期性地振动发声。</p><p>其实一句话就可概括它们之间的区别， 想要压电式蜂鸣器发声， 需提供一定频率的脉冲信号； 想要电磁式蜂鸣器发声， 只需提供电源即可。</p><p>我们开发板上使用的蜂鸣器是无源蜂鸣器， 属于压电式蜂鸣器类型。 这里说的有源和无源， 并不是指电源的意思， 而是指蜂鸣器内部是否含有振荡电路， 有源蜂鸣器内部自带振荡电路， 只需提供电源即可发声， 而无源蜂鸣器则需提供一定频率的脉冲信号才能发声， 频率大小通常在 1.5-5KHz 之间。 蜂鸣器实物图如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081555865.png" alt="image-20230612081555865"></p><p>对于无源蜂鸣器， 如果改变频率就可以调节蜂鸣器音调， 产生各种不同音色、音调的声音。 如果改变输出电平的高低电平占空比， 则可以改变蜂鸣器的声音大小。  </p><p>对于有源蜂鸣器， 通常内部已经固定了频率， 对于调节频率或占空比可能改变不了蜂鸣器的音调和音量， 当然也有的有源蜂鸣器可以实现和无源蜂鸣器一样的效果。</p><h4 id="硬件设计-1"><a href="#硬件设计-1" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>在前面章节中我们已经对 51 单片机的 GPIO 做了简单介绍， 并且还使用了其中 IO 口直接控制开发板上的 LED。 对于本章要实现蜂鸣器的控制， 我们能否直接使用单片机的 IO 口驱动呢？ 答案是否定的， 因为 51 单片机 IO 口的驱动能力较弱（即使外接上拉电阻） ， 而蜂鸣器驱动需要约 30mA， 所以非常困难， 即使可以驱动， 那对于整个芯片的其它 IO 剩下驱动能力就更加弱甚至无法工作。所以我们不会直接使用 IO 口驱动蜂鸣器， 而是通过三极管把电流放大后再驱动蜂鸣器， 这样 51 单片机的 IO 口只需要提供不到 1mA 的电流就可控制蜂鸣器。所以我们也经常说到 51 单片机是用来做控制的， 而不是驱动。</p><p>我们开发板上的蜂鸣器模块电路如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081716667.png" alt="image-20230612081716667">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612081722333.png" alt="image-20230612081722333"></p><p>​                    从图中可以看出， 蜂鸣器控制管脚直接连接到 51 单片机的 P2.5 管脚上。 图中并没有使用三极管进行电流放大， 而是使用 ULN2003 芯片来驱动， 有关 ULN2003芯片的使用此处先不作介绍， 后面章节会有， 大家暂时只需知道当 P25 输出高电平， BEEP 则输出低电平； 当 P25 输出低电平， BEEP 则输出高电平， 类似一个非门。  </p><p>开发板上使用的是无源蜂鸣器， 它需要一定频率的脉冲（高低电平） 才会发声， 因此需要让 P25 脚以一定频率不断输出高低电平信号才能控制蜂鸣器发出声音。  </p><h4 id="软件设计-1"><a href="#软件设计-1" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 让蜂鸣器发出声音， 一段时间后再关闭， 即让 P2.5管脚输出一定频率的脉冲信号（高低电平） 控制无源蜂鸣器。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">u16 i=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i--)<span class="comment">//循环 2000 次</span></span><br><span class="line">&#123;</span><br><span class="line">BEEP=!BEEP;<span class="comment">//产生一定频率的脉冲信号</span></span><br><span class="line">delay_10us(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">        i=<span class="number">0</span>;<span class="comment">//清零</span></span><br><span class="line">BEEP=<span class="number">0</span>;<span class="comment">//关闭蜂鸣器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后使用 sbit 关键字来定义 P2.5 管脚， 定义好后即可使用 BEEP 来替代 P2.5口的操作。 主函数功能非常简单， 直接进入 while 循环， 在循环内再次套用了一个 while 循环， 只不过这里并非死循环， 而是通过变量 i 值来决定何时退出， i值初始化为 2000， 即该循环会执行 2000 次， 此循环内不断对 BEEP 取反， 然后延时一定时间， 即 P2.5 间隔一定时间输出高低电平， 这样就会产生脉冲信号控制蜂鸣器发出声音， 当 i 值递减到 0 时则退出 while 循环， 然后将 i 值清零， 且将 BEEP 输出 0。 若修改变量 i 的值可以改变蜂鸣器发声时间。</p><p>若要改变音调可以修改延时时间， 但要注意频率不能太大或者太小， 具体大家可以试着调试。 若要改变音量， 可以修改 BEEP 输出高电平时间， 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BEEP=<span class="number">1</span>;</span><br><span class="line">delay_10us(<span class="number">190</span>);</span><br><span class="line">BEEP=<span class="number">0</span>;</span><br><span class="line">delay_10us(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="静态数码管实验"><a href="#静态数码管实验" class="headerlink" title="静态数码管实验"></a>静态数码管实验</h3><p>前面章节我们已经介绍了如何控制 51 单片机的 IO 口输出高低电平， 本章我们通过另外一个实验来讲述 51 单片机 IO 口的输出。 通过单片机的 IO 口控制板载数码管显示。  </p><h4 id="数码管介绍"><a href="#数码管介绍" class="headerlink" title="数码管介绍"></a>数码管介绍</h4><p>​            数码管是一种半导体发光器件， 其基本单元是发光二极管。 数码管也称 LED数码管， 不同行业人士对数码管的称呼不一样， 其实都是同样的产品。 数码管按段数可分为七段数码管和八段数码管， 八段数码管比七段数码管多一个发光二极管单元， 也就是多一个小数点（DP） ， 这个小数点可以更精确的表示数码管想要显示的内容； 按能显示多少个（8） 可分为 1 位、 2 位、 3 位、 4 位、 5 位、6 位、 7 位等数码管。 按发光二极管单元连接方式可分为共阳极数码管和共阴极数码管。  </p><p>​            共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极(COM)的数码管， 共阳数码管在应用时应将公共极 COM 接到+5V， 当某一字段发光二极管的阴极为低电平时， 相应字段就点亮， 当某一字段的阴极为高电平时， 相应字段就不亮。</p><p>​            共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极(COM)的数码管， 共阴数码管在应用时应将公共极 COM 接到地线 GND 上， 当某一字段发光二极管的阳极为高电平时， 相应字段就点亮， 当某一字段的阳极为低电平时， 相应字段就不亮。</p><p>不同位数的数码管实物图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612131708416.png" alt="image-20230612131708416"></p><h4 id="数码管显示原理"><a href="#数码管显示原理" class="headerlink" title="数码管显示原理"></a>数码管显示原理</h4><p>​            不管将几位数码管连在一起， 数码管的显示原理都是一样的， 都是靠点亮内部的发光二极管来发光， 下面我们就来讲解一个数码管是如何亮起来的。 数码管内部电路如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612131741061.png" alt="image-20230612131741061"></p><p>​                从上图可看出， 一位数码管的引脚是 10 个， 显示一个 8 字需要 7 个小段，另外还有一个小数点， 所以其内部一共有 8 个小的发光二极管， 最后还有一个公共端， 多数生产商为了封装统一， 单位数码管都封装 10 个引脚， 其中第 3 和第 8 引脚是连接在一起的。 而它们的公共端又可分为共阳极和共阴极， 图中间为共阳极内部原理图， 右图为共阴极内部原理图。  </p><p>对共阴极数码来说， 其 8 个发光二极管的阴极在数码管内部全部连接在一起，所以称“共阴” ， 而它们的阳极是独立的， 通常在设计电路时一般把阴极接地。当我们给数码管的任意一个阳极加一个高电平时， 对应的这个发光二极管就点亮了。 如果想要显示出一个 8 字， 并且把右下角的小数点也点亮的话， 可以给 8个阳极全部送高电平， 如果想让它显示出一个 0 字， 那么我们可以除了给第“g, dp” 这两位送低电平外， 其余引脚全部都送高电平， 这样它就显示出 0 字了。  </p><p>如果使用共阴数码管， 需要注意增加单片机 IO 口驱动电流， 因为共阴数码管是要靠单片机 IO 口输出电流来点亮的， 但单片机 I/O 口难以输出稳定的、 如此大的电流， 所以数码管与单片机连接时需要加驱动电路， 可以用上拉电阻的方法或使用专门的数码管驱动芯片， 比如 74HC573、 74HC245 等， 其输出电流较大，电路接口简单。</p><p>共阳极数码管其内部 8 个发光二极管的所有阳极全部连接在一起， 电路连接时， 公共端接高电平， 因此我们要点亮哪个发光管二极管就需要给阴极送低电平，此时显示数字的编码与共阴极编码是相反的关系， 数码管内部发光二极管点亮时， 也需要 5mA 以上的电流， 而且电流不可过大， 否则会烧坏发光二极管。 因此不仅要防止数码管电流过大， 同时要防止流经数码管的电流集中到单片机时电流不能过大， 否则会损坏主芯片。</p><p>一般共阳极数码管更为常用， 为什么呢？ 这是因为数码管的非公共端往往接在 IC 芯片的 I/O 上， 而 IC 芯片的驱动能力往往是比较小的， 如果采用共阴极数码管， 它的驱动端在非公共端， 就有可能受限于 IC 芯片输出电流不够而显示昏暗， 要外加上拉电阻或者是增加三极管加大驱动能力。 但是 IC 芯片的灌电流，即输入电流范围比较大。 所以使用共阳极数码管的好处是： 将驱动数码管的工作交到公共端（一般接驱动电源） ， 加大驱动电源的功率自然要比加大 IC 芯片 I/O口的驱动电流简单许多。 另一方面， 这样也能减轻主芯片的负担。  </p><p>我们开发板上使用的数码管是 2 个四位一体的共阴极数码管（即 8 个 LED的阳极全部并联一起引出， 阴极分别引出如 A、 B…DP） ， 本章实验也是在该数码管上实现单个的静态显示。 如果要让共阴数码管显示数字 0， 即对应的段ABCDEF 要点亮即给它高电平， 其他的段熄灭即给它低电平。 其他的数字显示方式一样， 这里就不多说。 下面给出共阴和共阳数码管的 0-F 段码数据表， 如下所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132208405.png" alt="image-20230612132208405"></p><p>​    ①共阴数码管码表  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x3f</span>,  <span class="number">0x06</span>, <span class="number">0x5b</span>, <span class="number">0x4f</span>, <span class="number">0x66</span>, <span class="number">0x6d</span>,</span><br><span class="line"> <span class="number">0</span>      <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">0x7d</span>,  <span class="number">0x07</span>, <span class="number">0x7f</span>, <span class="number">0x6f</span>, <span class="number">0x77</span>, <span class="number">0x7c</span>,</span><br><span class="line"> <span class="number">6</span>      <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     A     B</span><br><span class="line"><span class="number">0x39</span>, <span class="number">0x5e</span>, <span class="number">0x79</span>, <span class="number">0x71</span>, <span class="number">0x00</span>,</span><br><span class="line"> C     D     E     F    无显示</span><br></pre></td></tr></table></figure><p>②共阳数码管码表  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xC0</span>, <span class="number">0xF9</span>, <span class="number">0xA4</span>, <span class="number">0xB0</span>, <span class="number">0x99</span>, <span class="number">0x92</span>,</span><br><span class="line"> <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>     <span class="number">5</span></span><br><span class="line"><span class="number">0x82</span>, <span class="number">0xF8</span>, <span class="number">0x80</span>, <span class="number">0x90</span>, <span class="number">0x88</span>, <span class="number">0x83</span>,</span><br><span class="line"> <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>     <span class="number">9</span>     A     B</span><br><span class="line"><span class="number">0xC6</span>, <span class="number">0xA1</span>, <span class="number">0x86</span>, <span class="number">0x8E</span>, <span class="number">0xFF</span>,</span><br><span class="line"> C     D     E     F    无显示</span><br></pre></td></tr></table></figure><p>从上述共阳和共阴码表中不难发现， 它们的数据正好是相互取反的值。 比如共阴数码管数字 0 段码： 0x3f， 其二进制是： 0011 1111， 取反后为： 1100 0000，转换成 16 进制即为 0XC0。 其他段码依此类推。 该段码数据由来， 是将 a 段作为最低位， b 段作为次低位， 其他按顺序类推， dp 段为最高位， 共 8 位， 正好和51 单片机的一组端口数一样， 因此可以直接使用某一组端口控制数码管的段选数据口， 比如 P0 口。  </p><h4 id="数码管静态显示原理"><a href="#数码管静态显示原理" class="headerlink" title="数码管静态显示原理"></a>数码管静态显示原理</h4><p>LED 数码管显示器工作方式有两种： 静态显示方式和动态显示方式。 静态显示的特点是每个数码管的段选必须接一个 8 位数据线来保持显示的字形码。 当送入一次字形码后， 显示字形可一直保持， 直到送入新字形码为止。 这种方法的优点是占用 CPU 时间少， 显示便于监测和控制。 缺点是硬件电路比较复杂， 成本较高， 比如使用 4 个静态数码管， 那么就得 32 个 IO 来控制， 这对 51 单片机来说是无法承受的， 正因为如此才会有后面章节动态数码实验的讲解  </p><p>动态显示的特点是将所有数码管的段选线并联在一起， 由位选线控制是哪一位数码管有效。 选亮数码管采用动态扫描显示。 所谓动态扫描显示即轮流向各位数码管送出字形码和相应的位选， 利用发光管的余辉和人眼视觉暂留作用， 使人的感觉好像各位数码管同时都在显示。 动态显示的亮度比静态显示要差一些， 所以在选择限流电阻时应略小于静态显示电路中的。  </p><p>章实验使用的数码管虽然是动态数码管电路， 但我们依然可以使用数码管其中一位来学习静态数码管知识。 本章实验主要介绍静态数码管的控制， 有关动态数码管控制将在下一章节介绍。 有关静态数码管的详细介绍， 大家可以在百度上查找了解。</p><h4 id="硬件设计-2"><a href="#硬件设计-2" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上的静态数码管模块电路如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132752909.png" alt="image-20230612132752909"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612132756970.png" alt="image-20230612132756970"></p><p>​        上图电路实际上是动态数码管电路， 使用的是 2 个四位一体的共阴数码管组成， 即 8 位数码管的段选数据 a-dp 全部并联一起引出， 每位数码管的位选即公共端引出， 前面我们也说了， 虽然开发板上没有单个的静态数码管， 但依然可以在动态数码管电路中使用其中一个来学习静态数码管显示。 本实验使用 SMG1 最左边那个数码管作为静态数码管， 因为单片机 IO 口外部都增加了外部上拉电阻，因此 P22、 P23、 P24 引脚默认就是高电平， 根据 38 译码器输出特点， 此时 Y7脚（LED8） 输出有效， 即低电平。 而数码管的段选 a-dp 连接在 74HC245 驱动芯片输出口， 由 P0 端口控制。 所以只要控制 P0 口输出高电平， SMG1 最左边那个数码管默认就可以显示。 此处暂时不去理会 38 译码器的工作原理， 后面动态数码管实验会专门介绍。 74HC245 作为驱动芯片使用， 目的是让数码管能获得更大的电流， 为防止因电流过大烧坏数码管， 在 74HC245 芯片输出管脚又串联了 2个 4 位的 100 欧排阻后连接数码管段码 a-dp 脚。 本章暂时不必了解 74HC245 芯片使用， 只要知道 P0 口输出什么， 74HC245 芯片就输出什么  </p><h4 id="软件设计-2"><a href="#软件设计-2" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 控制静态数码管显示数字 0， 即让 P0 端口输出数字0 的段码 0x3f（共阴） 。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">实验名称： 静态数码管实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后“数码管模块” 最左边数码管显示数字 0</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment"> 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">SMG_A_DP_PORT=gsmg_code[<span class="number">0</span>];<span class="comment">//将数组第 1 个数据赋值给数码管段选口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><p>​        main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后定义一个全局数组变量 gsmg_code 存放共阴数码管 0-F 段码数据。 主函数功能也很简单，首先将数组的第 1 个数据赋值给 SMG_A_DP_PORT， 因为数组内定义的是共阴数码管段码，数组角标为0存储的就是第一个数据0X3F。然后进入while循环，单片机此时一直在 while 内循环操作。当然该条语句也可以放在 while循环语句内，同样会让静态数码管显示 0 。</p><h3 id="动态数码管实验"><a href="#动态数码管实验" class="headerlink" title="动态数码管实验"></a>动态数码管实验</h3><p>​            前面章节我们已经介绍了如何使用 51 单片机控制静态数码管显示， 在实际应用中通常都需要显示多位数值， 如果采用静态数码管显示就不够好， 因此就需要采用另外一种显示方式，即数码管动态显示。 开发板上板载 2 个四位一体的共阴数码管， 本章我们就来介绍下如何使用 51 单片机控制动态数码管显示。本章所要实现的功能是：控制动态数码管从左至右显示数字 0-7。 学习本章可以参考前面的实验章节内容。   </p><h4 id="数码管介绍-1"><a href="#数码管介绍-1" class="headerlink" title="数码管介绍"></a>数码管介绍</h4><p>​        上一章我们主要是介绍一位数码管的内部结构及控制原理。下面我们再来介绍下多位数码管及动态显示原理的相关知识  </p><h5 id="多位数码管简介"><a href="#多位数码管简介" class="headerlink" title="多位数码管简介"></a>多位数码管简介</h5><p>​            多位数码管，即两个或两个以上单个数码管并列集中在一起形成一体的数码管。 当多位一体时，它们内部的公共端是独立的，而负责显示什么数字的段线（a-dp） 全部是连接在一起的， 独立的公共端可以控制多位一体中的哪一位数码管点亮， 而连接在一起的段线可以控制这个能点亮数码管亮什么数字， 通常我们把公共端叫做“位选线” ， 连接在一起的段线叫做“段选线” ， 有了这两个线后，通过单片机及外部驱动电路就可以控制任意的数码管显示任意的数字了。  </p><p>​            一般一位数码管有 10 个引脚， 二位数码管也是 10 个引脚， 四位数码管是12 个引脚， 关于具体的引脚及段、 位标号大家可以查询相关资料， 最简单的办法就是用数字万用表测量， 若没有数字万用表也可用 5V 直流电源串接 1k 电阻后测量， 将测量结果记录， 通过统计便可绘制出引脚标号。 多位数码管有许多是按一定要求设计的， 引脚不完全按照一般规则设定， 所以需要在使用时查找手册，最直接的办法就是按照数码管上的标示向生产商要求。我们开发板上使用了 2 个四位一体的共阴数码管， 这样可在上面同时显示 8个数值。 </p><h5 id="数码管动态显示原理"><a href="#数码管动态显示原理" class="headerlink" title="数码管动态显示原理"></a>数码管动态显示原理</h5><p>​        位数码管依然可以静态显示， 但是显示时要么只显示一位数码管， 要么多位同时显示相同内容。 当多位数码管应用于某一系统时， 它们的“位选” 是可独立控制的， 而“段选” 是连接在一起的， 我们可以通过位选信号控制哪几个数码管亮， 而在同一时刻， 位选选通的所有数码管上显示的数字始终都是一样的， 因为它们的段选是连接在一起的， 送入所有数码管的段选信号都是相同的， 所以它们显示的数字必定一样， 数码管的这种显示方法叫做静态显示。</p><p>​        而动态显示， 就是利用减少段选线， 分开位选线， 利用位选线不同时选择通断， 改变段选数据来实现的。 比如在第一次选中第一位数码管时， 给段选数据 0，下一次位选中第二位数码管时显示 1。 为了在显示 1 的时候， 0 不会消失（当然实际上是消失了） ， 必须在人肉眼观察不到的时间里再次点亮第一次点亮的 0。而这时就需要记住， 人的肉眼正常情况下只能分辨变化超过 24ms 间隔的运动。也就是说， 在下一次点亮 0 这个数字的时间差不得大于 24ms。 这时就会发现，数码管点亮是在向右或者向左一位一位点亮， 形成了动态效果。 如果把间隔时间改长就能直接展现这一现象。</p><p>​        数码管动态显示的应用非常多， 所以大家一要认真学好数码管的动态显示方法。</p><h4 id="245和138-芯片介绍"><a href="#245和138-芯片介绍" class="headerlink" title="245和138 芯片介绍"></a>245和138 芯片介绍</h4><p>​    通过前面内容的介绍我们知道， 要使单片机能控制开发板上 2 位一体的共阴数码管显示， 仅靠单片机 IO 口来驱动是不行的， 这里就需要增加外部驱动芯片，开发板上使用的是 74HC245 芯片。 2 个 4 位一体的共阴数码管的位选线有 8 根，直接让单片机 IO 口控制是没有任何问题的， 但考虑到 51 单片机 IO 口资源的限制， 通常我们会使用一种 IO 扩展芯片， 比如 74HC138、 74HC164、 74HC595 芯片等， 只需要很少的单片机 IO 口就可以扩展出 8 个控制口， 通过级联方式甚至可扩展出更多的控制口（这个在后面 LED 点阵实验章节中会有详细介绍） 。 我们开发板上使用的是74HC138 译码器芯片， 只需单片机 3 个 IO 口就可以实现 8 个位选管脚的控制， 节省了芯片的 IO 资源。  </p><p>​    下面就来看看这两个芯片功能及使用方法。</p><h4 id="74HC245-芯片简介"><a href="#74HC245-芯片简介" class="headerlink" title="74HC245 芯片简介"></a>74HC245 芯片简介</h4><p>​    74HC245 是一种三态输出、八路信号收发器，主要应用于大屏显示， 以及其它的消费类电子产品中增加驱动。  </p><p>（1）主要特性<br>①采用 CMOS 工艺<br>②宽电压工作范围：3.0V-5.0V<br>③双向三态输出<br>④八线双向收发器<br>⑤封装形式：SOP20、SOP20-2、TSSOP20、DIP20</p><p>（1）主要特性<br>①采用 CMOS 工艺<br>②宽电压工作范围：3.0V-5.0V<br>③双向三态输出<br>④八线双向收发器<br>⑤封装形式：SOP20、SOP20-2、TSSOP20、DIP20</p><p>（2）管脚功能定义</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134832661.png" alt="image-20230612134832661"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134837862.png" alt="image-20230612134837862"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612134841707.png" alt="image-20230612134841707"></p><p>​        从上面的管脚功能定义说明及真值表可以知道该芯片使用方法很简单，给 OE使能管脚低电平，DIR 管脚为高电平传输方向是 A-&gt;B 输出，DIR 为低电平传输方向是 B-&gt;A，至于输出高电平还是输出低电平取决于输入端的状态，如果输入为低电平，输出即为低；输入为高电平，输出即为高。如果 OE 使能管脚为高电平，不论 DIR 管脚是高还是低，输出是高组态。<br>通常我们使用 74HC245 芯片用作驱动只会让其在一个方向输出，即 DIR 管脚<br>为高电平，传输方向是 A-&gt;B。</p><h4 id="74HC138-芯片简介"><a href="#74HC138-芯片简介" class="headerlink" title="74HC138 芯片简介"></a>74HC138 芯片简介</h4><p>74HC138D 是一种三通道输入、 八通道输出译码器， 主要应用于消费类电子产品。  </p><p>（1） 主要特性<br>①采用 CMOS 工艺<br>②低功耗<br>③工作电压： 3.0V-5.0V<br>④封装形式： SOP16</p><p>（2） 管脚功能定义  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135000064.png" alt="image-20230612135000064"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135005612.png" alt="image-20230612135005612"></p><p>L代表低电平   0  </p><p>H代表 高电平  1</p><p>X是代表<strong>任意</strong>，可高电平，也可低电平，</p><p>A代表输入、Y代表输出。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612135009222.png" alt="image-20230612135009222"></p><p>​        从上面的管脚功能定义说明及真值表可以知道该芯片使用方法很简单， 给E1、 E2 使能管脚低电平， E3 管脚为高电平， 至于哪个管脚输出有效电平（低电平） ， 要看 A0， A1， A2 输入管脚的电平状态。 如果 A0， A1， A2 都为低电平， 则Y0 输出有效电平（低电平） ， 其他管脚均输出高电平。 如果 A0 为高电平， A1， A2 都为低电平， 则 Y1 输出有效电平（低电平） ， 其他管脚均输出高电平。 其他几种输出大家可以对照真值表查看。 如果 E1、 E2 使能管脚任意一个为高电平或者 E3 为低电平， 不论输入是什么， 输出都为高电平。  </p><p><strong>==这里给大家总结一个方法： A0、 A1、 A2 输入就相当于 3 位 2 进制数， A0 是低位， A1 是次高位， A2 是高位。 而 Y0-Y7 具体哪一个输出有效电平， 就看输入二进制对应的十进制数值。 比如输入是 101（A2， A1， A0） ， 其对应的十进制数是 5， 所以 Y5 输出有效电平（低电平）。==</strong></p><h4 id="硬件设计-3"><a href="#硬件设计-3" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管模块<br>（2） 74HC138<br>开发板上的动态数码管模块电路如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612141602247.png" alt="image-20230612141602247"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612141607938.png" alt="image-20230612141607938"></p><p>​        上图电路使用的是 2 个四位一体的共阴数码管组成，即 8 位数码管的段选数据 a-dp 全部并联一起引出， 每位数码管的位选即公共端引出。数码管的段选 a-dp连接在 74HC245 驱动芯片输出口，由 P0 端口控制。 由 P2.2、 P2.3、 P2.4 管脚控制 74HC138 译码器输入从而控制数码管位选。</p><h4 id="软件设计-3"><a href="#软件设计-3" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 控制动态数码管从左至右显示数字 0-7。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">实验名称： 动态数码管实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后“数码管模块” 显示 01234567</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">***********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"><span class="comment">//定义数码管位选信号控制脚</span></span><br><span class="line">sbit LSA=P2^<span class="number">2</span>;</span><br><span class="line">sbit LSB=P2^<span class="number">3</span>;</span><br><span class="line">sbit LSC=P2^<span class="number">4</span>;</span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"><span class="comment">/***********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">       SMG_A_DP_PORT=gsmg_code[i];<span class="comment">//传送段选数据</span></span><br><span class="line">delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消音</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">******************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">smg_display();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>main.c 文件内代码非常少也很简单， 首先将 51 单片机的头文件包含进来，然后定义 38 译码器的控制引脚， 并将共阴数码管 0-F 段码数据使用数组定义好。主函数功能也很简单， 直接进入 while 循环， 在循环体内执行 smg_display()数码管动态显示函数。 该函数是根据动态数码管显示原理所编写， 即选中所要显示的那位数码管， 然后发送在该位数码管上所要显示的段码数据， 延时一定时间后 在将段选口清零即消隐（消除之前的显示） ， 如此循环 8 次即可实现 8 位数码管显示。 在动态显示中， 要注意延时时间， 只要保证在人肉眼所能感觉时间之内即可， 让我们看到所要显示的内容就像是同时显示一样。 如果时间过长或者过短都可能会影响数码管的显示效果， 大家可以在例程基础上试着修改延时时间观察效果  </p><h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 动态数码管显示01234567。 </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612143533993.png" alt="image-20230612143533993"> </p><h3 id="独立按键实验"><a href="#独立按键实验" class="headerlink" title="独立按键实验"></a>独立按键实验</h3><p>​        前几章介绍的都是 IO 口输出的使用， 这一章我们通过独立按键实验来介绍IO 口作为输入的使用。 开发板上板载 4 个独立按键。 本章所要实现的功能是：通过开发板上的独立按键 K1 控制 D1 指示灯亮灭。 学习本章可以参考前面的实验章节内容。  </p><h4 id="按键介绍"><a href="#按键介绍" class="headerlink" title="按键介绍"></a>按键介绍</h4><p>键是一种电子开关， 使用时轻轻按开关按钮就可使开关接通， 当松开手时,开关断开。 开发板上使用的按键及内部简易图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144057558.png" alt="image-20230612144057558"></p><p>按键管脚两端距离长的表示默认是导通状态， 距离短的默认是断开状态， 如果按键按下， 初始导通状态变为断开， 初始断开状态变为导通。通常的按键所用开关为机械弹性开关,当机械触点断开、 闭合时， 电压信号如下图所示</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144139303.png" alt="image-20230612144139303"></p><p>​        由于机械点的弹性作用， 按键开关在闭合时不会马上稳定的接通， 在断开时也不会一下子断开， 因而在闭合和断开的瞬间均伴随着一连串的抖动。 抖动时间的长短由按键的机械特性决定的， 一般为 5ms 到 10ms。 按键稳定闭合时间的长短则由操作人员的按键动作决定的， 一般为零点几秒至数秒。 按键抖动会引起按键被误读多次。 为了确保 CPU 对按键的一次闭合仅作一次处理， 必须进行消抖。  </p><p>​        按键消抖有两种方式， 一种是硬件消抖， 另一种是软件消抖。 为了使电路更加简单， 通常采用软件消抖。 我们开发板也是采用软件消抖， 一般来说一个简单的按键消抖就是先读取按键的状态， 如果得到按键按下之后， 延时 10ms， 再次读取按键的状态， 如果按键还是按下状态， 那么说明按键已经按下。 其中延时10ms 就是软件消抖处理， 至于硬件消抖， 大家可以百度了解下， 网上都有非常详细的介绍。 这里给大家列出单片机常用的软件去抖动方法：  </p><p>1， 先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻， 所以默认 IO 为高<br>电平） 。<br>2， 读取 IO 口电平确认是否有按键按下。<br>3， 如有 IO 电平为低电平后， 延时几个毫秒。<br>4， 再读取该 IO 电平， 如果仍然为低电平， 说明按键按下。<br>5， 执行按键控制程序。</p><p>独立按键电路构成是由各个按键的一个管脚连接在一起接地， 按键其他引脚分别接到单片机 IO 口。</p><p>我们知道单片机的 IO 口既可作为输出也可作为输入使用， 当检测按键时用的是它的输入功能， 独立按键的一端接地， 另一端与单片机的 I/O 口相连， 开始时先给该 IO 口赋一高电平， 然后让单片机不断地检测该 I/O 口是否变为低电平， 当按键闭合时， 即相当于该 I/O 口通过按键与地相连， 变成低电平， 程序一旦检测到 I/O 口变为低电平则说明按键被按下， 然后执行相应的指令。</p><h4 id="硬件设计-4"><a href="#硬件设计-4" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p><p>（1） LED 模块中 D1 指示灯</p><p>（2） K1 按键</p><p>LED 模块电路在前面章节都介绍过， 这里就不多说， 开发板上的独立按键模块电路如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230612144532165.png" alt="image-20230612144532165"></p><p>​            从上图中可以看出， 4 个独立按键的控制管脚连接到 51 单片机的 P3.0-P3.3脚上。 其中 K1 连接在 P3.1 上， K2 连接在 P3.0 上， K3 连接在 P3.2 上， K4 连接在 P3.3 上。 4 个按键另一端全部连接在 GND， 当按键按下后， 对应 IO 口即为低电平。  </p><h4 id="软件设计-4"><a href="#软件设计-4" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过开发板上的独立按键 K1 控制 D1 指示灯亮灭。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">    <span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//定义 LED1 控制脚</span></span><br><span class="line"></span><br><span class="line">    sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line">    u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">   key=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*****************************************************/</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        u8 key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            key=key_scan(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//检测按键 K1 是否按下</span></span><br><span class="line">            LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        key_scan 函数带一个形参 mode， 该参数用来设定是否连续扫描按键， 如果mode 为 0， 只能操作一次按键， 只有当按键松开后才能触发下次的扫描， 这样做的好处是可以防止按下一次出现多次触发的情况。 如果 mode 为 1， 函数是支持连续扫描的， 即使按键未松开， 在函数内部有 if(mode==1)这条判断语句， 因此 key 始终是等于 1 的， 所以可以连续扫描按键， 当按下某个按键， 会一直返回这 个按键的键值， 这样做的好处是可以很方便实现连按操作。 函数内的 delay_10us(1000)即为软件消抖处理， 通常延时 10ms 即可。  </p><p>​        key_scan 函数还带有一个返回值， 如果未有按键按下， 返回值即为KEY_UNPRESS， 否则返回值即为对应按键的键值， 如 KEY1_PRESS、 KEY2_PRESS、KEY3_PRESS、 KEY4_PRESS， 这都是程序开头定义好的宏， 方便大家理解和使用。函数内定义了一个 static 变量 key， 相当于全局变量， 所以该函数不是一个可重入函数。 还有一点要注意的就是该函数按键的扫描是有优先级的， 因为函数内用了 if…else if…else 格式， 所以最先扫描处理的按键是 KEY1， 其次是KEY2， 然后是 KEY3， 最后是 KEY4。 如果需要将其优先级设置一样， 那么可以全部用 if 语句。  </p><p>​        main 函数中主要就是调用 key_scan 函数用于检测按键， 此时传入的 mode值为 0， 表示单次扫描按键， 然后将扫描按键的值保存在变量 key 中， 最后通过if 判断语句控制 LED1 状态。  </p><h4 id="实验现象"><a href="#实验现象" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K1 键， D1 指示灯亮， 再按下 K1 键， D1 指示灯灭， 如此循环。  </p><h3 id="矩阵按键实验"><a href="#矩阵按键实验" class="headerlink" title="矩阵按键实验"></a>矩阵按键实验</h3><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K1 键， D1 指示灯亮， 再按下 K1 键， D1 指示灯灭， 如此循环。  </p><h4 id="矩阵按键介绍"><a href="#矩阵按键介绍" class="headerlink" title="矩阵按键介绍"></a>矩阵按键介绍</h4><p>​        独立按键与单片机连接时， 每一个按键都需要单片机的一个 I/O 口， 若某单片机系统需较多按键， 如果用独立按键便会占用过多的 I/O 口资源。 单片机系统中 I/O 口资源往往比较宝贵， 当用到多个按键时为了减少 I/O 口引脚， 引入了矩阵按键。  </p><p>​        本章以 4*4 矩阵键盘为例讲解其工作原理和检测方法。 开发板上将 16 个按键排成 4 行 4 列， 第一行将每个按键的一端连接在一起构成行线， 第一列将每个按键的另一端连接在一起构成列线， 这样便一共有 4 行 4 列共 8 根线， 我们将这 8 根线连接到单片机的 8 个 I/O 口上， 通过程序扫描键盘就可检测 16 个键。 用这种方法我们也可实现 3 行 3 列 9 个键、 5 行 5 列 25 个键、 6 行6 列 36 个键甚至更多。  </p><p>​        无论是独立键盘还是矩阵键盘， 单片机检测其是否被按下的依据都是一样的， 也就是检测与该键对应的 I/O 口是否为低电平。 独立键盘有一端固定为低电平， 此种方式编程比较简单。 而矩阵键盘两端都与单片机 I/O 口相连， 因此在检测时需编程通过单片机 I/O 口送出低电平。 检测方法有多种， 最常用的是行列扫描和线翻转法。  </p><p>​        行列扫描法检测时， 先送一列为低电平， 其余几列全为高电平(此时我们确定了列数)， 然后立即轮流检测一次各行是否有低电平， 若检测到某一行为低电平(这时我们又确定了行数)， 则我们便可确认当前被按下的键是哪一行哪一列的， 用同样方法轮流送各列一次低电平， 再轮流检测一次各行是否变为低电平，这样即可检测完所有的按键， 当有键被按下时便可判断出按下的键是哪一个键。当然我们也可以将行线置低电平， 扫描列是否有低电平。 从而达到整个键盘的检测。</p><p>​        线翻转法， 就是使所有行线为低电平时， 检测所有列线是否有低电平， 如果有， 就记录列线值； 然后再翻转， 使所有列线都为低电平， 检测所有行线的值，由于有按键按下， 行线的值也会有变化， 记录行线的值。 从而就可以检测到全部按键。  </p><p>​        矩阵键盘也少不了按键消抖的环节， 本章实验中采用的是行列扫描法来检测哪个按键按下。</p><h4 id="硬件设计-5"><a href="#硬件设计-5" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 静态数码管<br>（2） 4*4 矩阵按键<br>静态数码管模块电路在前面章节都介绍过， 这里就不多说， 开发板上的矩阵按键模块电路如下图所示</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613081823539.png" alt="image-20230613081823539"></p><p>板子是上拉电阻，上拉电阻为1，输入低电平0则按下</p><p>P17为高位，P10为低位</p><p>当P17按下时为 0111 1111    我们赋值0X7F就可以判断P17是否按下    依次类推</p><p>从上图中可以看出， 4*4 矩阵按键引出的 8 根控制线直接连接到 51 单片机的P1 口上。 电路中的 P17 连接矩阵键盘的第 1 行， P13 连接矩阵键盘第 1 列。  </p><h4 id="软件设计-5"><a href="#软件设计-5" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过数码管显示矩阵按键 S1-S16 按下后键值 0-F。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 矩阵按键实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 按下“矩阵按键” 模块中 S1-S16 键， 对应数码管最左边显示 0-F</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_MATRIX_PORT P1 <span class="comment">//使用宏定义矩阵按键控制口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMG_A_DP_PORT P0 <span class="comment">//使用宏定义数码管段码口</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=</span><br><span class="line">    &#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line"> <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">while</span>(ten_us--);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_matrix_ranks_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 使用行列式扫描方法， 检测矩阵按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : key_value： 1-16， 对应 S1-S16 键，</span></span><br><span class="line"><span class="comment">0： 按键未按下</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_matrix_ranks_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xf7</span>;<span class="comment">//给第一列赋值 0， 其余全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>)<span class="comment">//判断第一列按键是否按下</span></span><br><span class="line">&#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第一列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x77</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb7</span>: key_value=<span class="number">5</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd7</span>: key_value=<span class="number">9</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe7</span>: key_value=<span class="number">13</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf7</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">   KEY_MATRIX_PORT=<span class="number">0xfb</span>;<span class="comment">//给第二列赋值 0， 其余全为 1</span></span><br><span class="line"><span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>)<span class="comment">//判断第二列按键是否按下</span></span><br><span class="line">&#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第二列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbb</span>: key_value=<span class="number">6</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdb</span>: key_value=<span class="number">10</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xeb</span>: key_value=<span class="number">14</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfb</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">KEY_MATRIX_PORT=<span class="number">0xfd</span>;<span class="comment">//给第三列赋值 0， 其余全为 1</span></span><br><span class="line"><span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>)<span class="comment">//判断第三列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第三列按键按下后的键值</span></span><br><span class="line">   &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbd</span>: key_value=<span class="number">7</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xdd</span>: key_value=<span class="number">11</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xed</span>: key_value=<span class="number">15</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfd</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0xfe</span>;<span class="comment">//给第四列赋值 0， 其余全为 1</span></span><br><span class="line"><span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>)<span class="comment">//判断第四列按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存第四列按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x7e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xbe</span>: key_value=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xde</span>: key_value=<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xee</span>: key_value=<span class="number">16</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xfe</span>);<span class="comment">//等待按键松开</span></span><br><span class="line"><span class="keyword">return</span> key_value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_matrix_flip_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 使用线翻转扫描方法， 检测矩阵按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : key_value： 1-16， 对应 S1-S16 键，</span></span><br><span class="line"><span class="comment">0： 按键未按下</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_matrix_flip_scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u8 key_value=<span class="number">0</span>;</span><br><span class="line">    KEY_MATRIX_PORT=<span class="number">0x0f</span>;<span class="comment">//给所有行赋值 0， 列全为 1</span></span><br><span class="line">    <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)<span class="comment">//判断按键是否按下</span></span><br><span class="line">    &#123;</span><br><span class="line">        delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">if</span>(KEY_MATRIX_PORT!=<span class="number">0x0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//测试列</span></span><br><span class="line">        KEY_MATRIX_PORT=<span class="number">0x0f</span>;</span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存行为 0， 按键按下后的列值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x07</span>: key_value=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0b</span>: key_value=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0d</span>: key_value=<span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x0e</span>: key_value=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//测试行</span></span><br><span class="line">        KEY_MATRIX_PORT=<span class="number">0xf0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(KEY_MATRIX_PORT)<span class="comment">//保存列为 0， 按键按下后的键值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0x70</span>: key_value=key_value;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xb0</span>: key_value=key_value+<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xd0</span>: key_value=key_value+<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0xe0</span>: key_value=key_value+<span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">while</span>(KEY_MATRIX_PORT!=<span class="number">0xf0</span>);<span class="comment">//等待按键松开</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        key_value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> key_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        key=key_matrix_ranks_scan();</span><br><span class="line">        <span class="keyword">if</span>(key!=<span class="number">0</span>)</span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[key<span class="number">-1</span>];<span class="comment">//得到的按键值减 1 换算成数组下标对应 0-F 段码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        本实验核心代码为 key_matrix_ranks_scan 函数和 key_matrix_flip_scan函数， 前者是使用行列式扫描方式实现， 而后者是使用线翻转式扫描方式实现，实现功能一致， 二者可选其一。 对于初学者， 可能行列式扫描方式更易于理解，因为比较接近独立按键的编程方式。  </p><p>​        行列式扫描原理比较简单， 与独立式按键操作类似， 即给每一列赋值 0， 此时的矩阵按键就被分割成独立按键， 然后再判断每一列中的按键按下情况， 并返回对应的键值。 如此循环 4 组， 就可将 4 列 4 行按键按下键值全部得到。  </p><p>​        而线翻转式扫描相对较难理解， 不过静下心， 在纸上画画， 列举几个数据也是比较容易理解的。  </p><h4 id="实验现象-1"><a href="#实验现象-1" class="headerlink" title="实验现象"></a>实验现象</h4><p>​        使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 S1-S16 键， 最左边数码管对应显示 0-F。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084447693.png" alt="image-20230613084447693"> </p><h3 id="IO扩展（串转并）-74HC595"><a href="#IO扩展（串转并）-74HC595" class="headerlink" title="IO扩展（串转并）-74HC595"></a>IO扩展（串转并）-74HC595</h3><p>​        在前面章节实验中， 我们是直接使用单片机 IO 口控制外围设备， 从 LED 流水灯到动态数码管显示， 可以看到这些外围设备已经占据了很多的 IO 口， 而 51单片机 IO 口非常有限， 如果想要连接更多外围设备， 此时可以通过 IO 扩展来实现。 本章就来介绍另外一种 IO 口扩展方式-串转并， 使用的芯片是 74HC595。 开发板板载 1 个 74HC595 芯片， 仅需单片机 3 个 IO 口即可扩展 8 个， 如果需要还可以将 2 个 74HC595 级联扩展出 16 个 IO， 这就实现用少数 IO 资源控制多个设备。 通过本章的学习， 让大家学会使用 74HC595 芯片来扩展 IO 口。 本章所要实现的功能是： 通过 74HC595 模块控制 LED 点阵以一行循环滚动显示。 学习本章可以参考前面的实验章节内容。 本章分为如下几部分内容：  </p><h4 id="74HC595芯片介绍"><a href="#74HC595芯片介绍" class="headerlink" title="74HC595芯片介绍"></a>74HC595芯片介绍</h4><p>74HC595 是一个 8 位串行输入、 并行输出的位移缓存器， 其中并行输出为三态输出（即高电平、 低电平和高阻抗） 。 芯片管脚及功能说明如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084758935.png" alt="image-20230613084758935">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613084804258.png" alt="image-20230613084804258"></p><p>​        上面两张都是 74HC595 芯片管脚图， 细心的朋友就会发现左侧的 1 脚是 QB，而右侧芯片的 1 脚是 Q1， 左侧芯片的 11 脚是 SCK， 而右侧芯片的 11 脚SH_CP，还有很多其他管脚不一样， 其实这个都没有什么， 每个人在绘制芯片管脚图时命名可能不一样而已， 看一个芯片重点是管脚功能  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15</span> 和 <span class="number">1</span> 到 <span class="number">7</span> 脚 QA--QH： 并行数据输出</span><br><span class="line"><span class="number">9</span> 脚 QH 非： 串行数据输出</span><br><span class="line"><span class="number">10</span> 脚 SCLK 非（ MR） ： 低电平复位引脚</span><br><span class="line"><span class="number">11</span> 脚 SCK（ SHCP） ： 移位寄存器时钟输入</span><br><span class="line"><span class="number">12</span> 脚 RCK（ STCP） ： 存储寄存器时钟输入</span><br><span class="line"><span class="number">13</span> 脚 G 非（ OE） ： 输出有效</span><br><span class="line"><span class="number">14</span> 脚 SER（ DS） ： 串行数据输入</span><br></pre></td></tr></table></figure><p>​        74HC595 是具有 8 位移位寄存器和一个存储器，三态输出功能。移位寄存器和存储器是单独的时钟。 数据在 SCK 的上升沿输入，在 RCK 的上升沿进入到存储器中。 如果两个时钟连在一起， 则移位寄存器总是比存储器早一个脉冲。 移位寄存器有一个串行输入（DS） ，和一个串行输出（Q7 非） ，和一个异步的低电平复位， 存储寄存器有一个并行 8 位的， 具有三态的总线输出， 当 MR 为高电平， OE 为低电平时， 数据在 SHCP 上升沿进入移位寄存器， 在 STCP 上升沿输出到并行端口。  </p><h4 id="硬件设计-6"><a href="#硬件设计-6" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：  </p><p>（1） 8*8LED 点阵模块<br>（2） 74HC595 模块<br>开发板上的 74HC595 模块电路如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613085130884.png" alt="image-20230613085130884"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613085138403.png" alt="image-20230613085138403"></p><p>​        h为高位，a为低位</p><p>​        从上图中可以看出， 74HC595 需要用到的控制管脚 SER、 RCLK、 SRCLK 直接连接到 51 单片机的 P3.4-P3.6 IO 口上， <code>输出端则是直接连接到 LED 点阵模块的行端口上， 即为 LED 发光二极管的阳极， LED 点阵的列则为发光二极管的阴极</code>。</p><p>​        要想控制 LED 点阵， 可以将单片机管脚按照 74HC595 芯片的通信时序要求来传输数据， 这样即可控制 LED 点阵的行数据。 根据 LED 发光二极管导通原理， 当阳极为高电平， 阴极为低电平则点亮， 否则熄灭。 因此通过单片机 P0 口可控制点阵列， 74HC595 可控制点阵行。</p><h4 id="软件设计-6"><a href="#软件设计-6" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过 74HC595 模块控制 LED 点阵以一行循环滚动显示。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： IO 扩展(串转并)实验-74HC595</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵以一行循环滚动显示</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 74HC595 控制管脚</span></span><br><span class="line">sbit SRCLK=P3^<span class="number">6</span>; <span class="comment">//移位寄存器时钟输入</span></span><br><span class="line">sbit RCLK=P3^<span class="number">5</span>; <span class="comment">//存储寄存器时钟输入</span></span><br><span class="line">sbit SER=P3^<span class="number">4</span>; <span class="comment">//串行数据输入</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDDZ_COL_PORT P0 <span class="comment">//点阵列控制端口</span></span></span><br><span class="line"></span><br><span class="line">u8 ghc595_buf[<span class="number">8</span>]=&#123;<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,</span><br><span class="line">                  <span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时10us 微秒</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">u16 i,j;</span><br><span class="line"><span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : hc595_write_data(u8 dat)</span></span><br><span class="line"><span class="comment">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hc595_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次即可将一个字节写入寄存器中</span></span><br><span class="line">    &#123;</span><br><span class="line">        SER=dat&gt;&gt;<span class="number">7</span>;<span class="comment">//优先传输一个字节中的高位</span></span><br><span class="line">        dat&lt;&lt;=<span class="number">1</span>;<span class="comment">//将低位移动到高位</span></span><br><span class="line">        SRCLK=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        SRCLK=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);<span class="comment">//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span><br><span class="line">    &#125;</span><br><span class="line">    RCLK=<span class="number">0</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    RCLK=<span class="number">1</span>;<span class="comment">//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    LEDDZ_COL_PORT=<span class="number">0x00</span>;<span class="comment">//将 LED 点阵列全部设置为 0， 即 LED 阴极为低电平</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">            hc595_write_data(<span class="number">0x00</span>);<span class="comment">//消除前面寄存器缓存数据   消隐</span></span><br><span class="line">            hc595_write_data(ghc595_buf[i]);<span class="comment">//写入新的数据</span></span><br><span class="line">            delay_ms(<span class="number">500</span>);<span class="comment">//延时 500ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        代码还是比较简单易懂的， 首先定义好 74HC595 控制管脚， 以及点阵列控制口， 代码中重新定义了一个 ms 级延时函数 delay_ms， 该函数与前面 delay_10us类似， 都是利用循环占用 CPU 起到延时效果。 然后又定义了 74HC595 的控制函数hc595_write_data， 该函数完全按照 74HC595 的通信时序要求编写， 主要要注意的是 74HC595 是先传输字节的高位后传输低位， 所以需要将字节低位移动到高位传输， 在传输数据时， 要注意移位寄存器时钟和存储寄存器时钟的先后顺序， 将要写入的数据先传输到 74HC595 寄存器中， 即在准备好每位数据时要将 SRCLK进行一个上升沿变化， 此时即可将数据传输到寄存器内， 待循环 8 次即一个字节传输到寄存器中时， 就可以来一个存储时钟上升沿， 此时就可以将 74HC595 寄存器中的数据全部一次传输到 595 端口输出。最后就是在 main 函数中调用 74HC595的控制函数， 将实验中要实现的效果数据写入进去， 从而控制 LED 点阵的阳极，而阴极由 P0 口控制， 默认初始化时已经设置为 0， 也就是说只要 595 输出高电平， 那么对应的行就会点亮。  </p><h4 id="实验现象-2"><a href="#实验现象-2" class="headerlink" title="实验现象"></a>实验现象</h4><p>​        使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口），把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 8*8LED 点阵以一行循环滚动显示。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613090448384.png" alt="image-20230613090448384"></p><p>注意： 做 LED 点阵实验时， 一定要将 LED 点阵旁的 J24 黄色跳线帽短接到 GND一端。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613090521573.png" alt="image-20230613090521573"></p><h3 id="LED点阵实验"><a href="#LED点阵实验" class="headerlink" title="LED点阵实验"></a>LED点阵实验</h3><p>​        在前面章节，我们介绍过静态数码管和动态数码管显示， 其中动态数码管是一种应用非常多的显示设备，除此之外还有很多应用广泛的显示装置， 比如 LED点阵屏、LCD 液晶显示器等。我们开发板上使用了 64 个红色 LED 按照行列排布组成的 <code>8 * 8</code>LED 点阵。 本章就来介绍 LED 点阵的使用，通过本章的学习，让大家能够在 <code>8 * 8</code>LED 点阵屏上显示信息。本章所要实现的功能是： 在 8*8LED 点阵屏上点亮一个点， 上述功能实现后再显示数字图形等。   </p><h4 id="LED点阵介绍"><a href="#LED点阵介绍" class="headerlink" title="LED点阵介绍"></a>LED点阵介绍</h4><p>​        LED 点阵是由发光二极管排列组成的显示器件,在我们日常生活的电器中随处可见， 被广泛应用于汽车报站器， 广告屏等。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613091945253.png" alt="image-20230613091945253">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613091951353.png" alt="image-20230613091951353">        <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092039980.png" alt="image-20230613092039980">        </p><p>​    通常应用较多的是 8 <em> 8 点阵， 然后使用多个 8 </em> 8 点阵可组成不同分辨率的 LED点阵显示屏， 比如 16 <em> 16 点阵可以使用 4 个 8 </em> 8 点阵构成。 因此理解了8 <em> 8LED点阵的工作原理， 其他分辨率的 LED 点阵显示屏都是一样的。 这里以8 </em> 8LED 点阵来做介绍。 其内部结构图如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092151892.png" alt="image-20230613092151892"></p><p>8*8 点阵共由 64 个发光二极管组成， 且每个发光二极管是放置在行线和列线的交叉点上， 当对应的某一行置 1 电平， 某一列置 0 电平， 则相应的二极管就亮；如要将第一个点点亮， 则 1 脚接高电平 a 脚接低电平， 则第一个点就亮了； 如果要将第一行点亮， 则第 1 脚要接高电平， 而（a、 b、 c、 d、 e、 f、 g、 h ） 这些引脚接低电平， 那么第一行就会点亮； 如要将第一列点亮， 则第 a 脚接低电平，而（1、 2、 3、 4、 5、 6、 7、 8） 接高电平， 那么第一列就会点亮。 由此可见， LED点阵的使用也是非常简单的。  </p><h4 id="硬件设计-7"><a href="#硬件设计-7" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 8 <em> 8LED 点阵模块<br>（2） 74HC595 模块<br>74HC595 模块、 8 </em> 8LED 点阵模块电路在前面章节都介绍过， 电路如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092303759.png" alt="image-20230613092303759"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092308683.png" alt="image-20230613092308683"></p><p>​    从上图中可以看出， 74HC595 需要用到的控制管脚 SER、 RCLK、 SRCLK 直接连接到 51 单片机的 P3.4-P3.6 IO 口上， 输出端则是直接连接到 LED 点阵模块的行端口上， 即为 LED 发光二极管的阳极， LED 点阵的列则为发光二极管的阴极。  </p><p>​    要想控制 LED 点阵， 可以将单片机管脚按照 74HC595 芯片的通信时序要求来传输数据， 这样即可控制 LED 点阵的行数据。 根据 LED 发光二极管导通原理， 当阳极为高电平， 阴极为低电平则点亮， 否则熄灭。 因此通过单片机 P0 口可控制点阵列， 74HC595 可控制点阵行。  </p><h4 id="软件设计-7"><a href="#软件设计-7" class="headerlink" title="软件设计"></a>软件设计</h4><p>​        本章所要实现的功能是： 在点阵屏上点亮一个点， 上述功能实现后再显示数字和图形。  </p><h5 id="LED点阵（点亮一个点）"><a href="#LED点阵（点亮一个点）" class="headerlink" title="LED点阵（点亮一个点）"></a>LED点阵（点亮一个点）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LED 点阵实验(点亮一个点)</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵点亮左上角第一个点</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned int u16; //对系统默认数据类型进行重定义</span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned char u8;</span></span></span><br><span class="line"><span class="string"><span class="meta">//定义 74HC595 控制管脚</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SRCLK=P3^6; //移位寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit rCLK=P3^5; //存储寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SER=P3^4; //串行数据输入</span></span></span><br><span class="line"><span class="string"><span class="meta">#define LEDDZ_COL_PORT P0 //点阵列控制端口</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : delay_10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : ten_us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void delay_10us(u16 ten_us)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">while(ten_us--);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta">void hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    for(i=0;i&lt;8;i++)//循环 8 次即可将一个字节写入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        SER=dat&gt;&gt;7;//优先传输一个字节中的高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        dat&lt;&lt;=1;//将低位移动到高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=1;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; </span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=1;//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/***********************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">************************************************************/  </span></span></span><br><span class="line"><span class="string"><span class="meta">void main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    LEDDZ_COL_PORT=0x7f;//将 LED 点阵左边第一列设置为 0， 即 LED 阴极为低电平， 其余列为 1， 即高电平</span></span></span><br><span class="line"><span class="string"><span class="meta">    while(1)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    hc595_write_data(0x80);//将 LED 点阵上边第一行设置为 1， 即 LED 阳极为高电平， 其余行为 0， 即低电平</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p>代码很简单， 与上一章核心代码是一样的， 这里主要是理解如何让 LED 点阵的左上角第一个点点亮， 实际上就是将第一个点对应的行为高电平， 列为低电平即可。 也就是让 74HC595 输出 0X80（1000 0000） ， 这样点阵第一行就是高电平，而 P0 口输出 0X7F（0111 1111） ， 这样点阵第一列就是低电平， 从而让 LED 点阵第一个点点亮。  </p><h5 id="显示数字"><a href="#显示数字" class="headerlink" title="显示数字"></a>显示数字</h5><p>点亮一个点很简单， 可是如何点亮多个点呢？ 如果需要一次显示多个怎么办？ 从原理图上可以看到每一行上都连接着多个 LED 灯， 每一列上也都连接着多个 LED 灯， 如果要点亮一个， 按照上面原理可以， 但是要同时点亮多个怎么办？  </p><p>么就需要用到动态数码管的动态扫描原理。 首先如何点亮一行上面多个灯或者一列上面多个灯？ 明显需要某行或某列有效， 同时使多列或多行有效。 比如在第一行有效（输出高电平） 的情况下， 有效列（输出低电平） 与这一行交点上的 LED 灯就会被点亮。 那么实现一行或一列点亮会比较容易。 如何实现不同行不同列上的灯被多个点亮呢？ 是否是行有效， 列有效就可以？ 并不是！  </p><p>要实现行列不同位置亮灯， 需要使用动态显示的方法， 也要结合扫描的方法。在第一行亮灯一段时间以后灭掉， 点亮第二行一段时间以后灭掉， 点亮第三行一段时间以后灭掉， 如此点亮， 直到八行全部点亮一次， 在第一行点亮到最后一行灭掉的总时间不能超过人肉眼可识别的时间， 即 24 毫秒。 在每一行点亮的时候，给列一个新的数据， 此时对应列的数据就可以体现在这行上要点亮的灯上。 这样就和动态数码管的显示一样， 只不过数码管的 LED 灯是段值。 这里使用 LED 点阵显示数字， 也是多个 LED 同时点亮  </p><p>要想在点阵上显示数字等字符， 首先要获取在 LED 点阵上显示数字字符所需的数据， 即一个数字字符在 LED 点阵上显示， 对应的每行每列都会有一些灯点亮或者熄灭， 这样就会构成一组数据， 也就是数字字符的显示数据， 我们只要将这些数据通过 74HC595 发送到点阵对应的行或列就能显示数字字符  </p><p>数字字符数据如何获取呢？ 这里给大家介绍一个非常好用的工具-取字模软件。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121024046.png" alt="image-20230614121024046"></p><p>双击打开该软件， 首先选择“基本操作-&gt;新建图像” ， 设置图像的宽度和高度为8， 点击确定后将在显示窗口出现一个8 <em> 8的白色格子， 这个就类似于8</em>8LED点阵， 具体操作如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121049722.png" alt="image-20230614121049722"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121053736.png" alt="image-20230614121053736"></p><p>可以看到上图 8*8 点阵区域非常小， 我们可以将其放大， 选择“模拟动画” ，后点击“放大格点” ， 如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121106194.png" alt="image-20230614121106194">  </p><p>然后可以在这个 8*8 白色格子里面点击， 点击后即会在对应位置出现一个黑点， 表示在 LED 点阵对应位置的 LED 灯点亮， 未点击位置（白色） 表示LED 点阵对应位置的 LED 灯熄灭。  </p><p>然后可以在这个 8*8 白色格子里面点击， 点击后即会在对应位置出现一个黑点， 表示在 LED 点阵对应位置的 LED 灯点亮， 未点击位置（白色） 表示LED 点阵对应位置的 LED 灯熄灭。  </p><p>比如在 8 <em> 8LED 点阵上显示数字 0， 那么可以在图中 8</em>8 白色框内通过点击对应位置描出一个数字 0 的外形， 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121150495.png" alt="image-20230614121150495"></p><p>然后设置取模数据的取模方式等内容， 选择“参数设置” 后点击“其他选项” ， 具体操作如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121203793.png" alt="image-20230614121203793"></p><p>然后点击“取模方式” ， 选择 C51 格式选项， 然后在点阵生成区自动会生成数字字符对应的数据（如果是使用汇编编程， 那么汇编对应的汉字数据可选择 A51 格式） 。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121218688.png" alt="image-20230614121218688"></p><p>到这里我们就将数字 0 的数据生成了， 然后将生成的数据复制到我们程序定义的数组中， 如下所示：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_row[<span class="number">8</span>]=&#123;<span class="number">0x00</span>,<span class="number">0x7C</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x82</span>,<span class="number">0x7C</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示数字 0 的行数据</span></span><br></pre></td></tr></table></figure><p>这些数据其实就是上述描绘的数字 0 从左到右依次每列对应的行数据。至于其它数字或字符及简单图形的显示取模方法与上述类似。既然是动态扫描， 就需要不断的扫描每列， 因此可以把 LED 点阵的列控制也用数组存储起来， 为后面循环调用提供方便。 根据数字 0 取模的数据特点是从左至右每列对应的行数据， 因此扫描时也应该从左至右的顺序， 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_col[<span class="number">8</span>]=&#123;<span class="number">0x7f</span>,<span class="number">0xbf</span>,<span class="number">0xdf</span>,<span class="number">0xef</span>,<span class="number">0xf7</span>,<span class="number">0xfb</span>,<span class="number">0xfd</span>,<span class="number">0xfe</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示数字 0 的列数据  </span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LED 点阵实验(点亮一个点)</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 8*8LED 点阵点亮左上角第一个点</span></span><br><span class="line"><span class="comment">注意事项： LED 点阵旁的 J24 黄色跳线帽短接到 GND 一端</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned int u16; //对系统默认数据类型进行重定义</span></span></span><br><span class="line"><span class="string"><span class="meta">typedef unsigned char u8;</span></span></span><br><span class="line"><span class="string"><span class="meta">//定义 74HC595 控制管脚</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SRCLK=P3^6; //移位寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit rCLK=P3^5; //存储寄存器时钟输入</span></span></span><br><span class="line"><span class="string"><span class="meta">sbit SER=P3^4; //串行数据输入</span></span></span><br><span class="line"><span class="string"><span class="meta">#define LEDDZ_COL_PORT P0 //点阵列控制端口</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">u8 gled_row[8]=&#123;0x00,0x7C,0x82,0x82,0x82,0x7C,0x00,0x00&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">//LED 点阵显示数字 0 的行数据</span></span></span><br><span class="line"><span class="string"><span class="meta">u8 gled_col[8]=&#123;0x7f,0xbf,0xdf,0xef,0xf7,0xfb,0xfd,0xfe&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">//LED 点阵显示数字 0 的列数据</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : delay_10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : ten_us</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">void delay_10us(u16 ten_us)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">while(ten_us--);</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/************************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 向 74HC595 写入一个字节的数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : dat： 数据</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">*************************************************************/</span></span></span><br><span class="line"><span class="string"><span class="meta">void hc595_write_data(u8 dat)</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    for(i=0;i&lt;8;i++)//循环 8 次即可将一个字节写入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        SER=dat&gt;&gt;7;//优先传输一个字节中的高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        dat&lt;&lt;=1;//将低位移动到高位</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        SRCLK=1;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);//移位寄存器时钟上升沿将端口数据送入寄存器中</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; </span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        delay_10us(1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        rCLK=1;//存储寄存器时钟上升沿将前面写入到寄存器的数据输出</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">/***********************************************************</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函 数 名 : main</span></span></span><br><span class="line"><span class="string"><span class="meta">* 函数功能 : 主函数</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 入 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">* 输 出 : 无</span></span></span><br><span class="line"><span class="string"><span class="meta">************************************************************/  </span></span></span><br><span class="line"><span class="string"><span class="meta">void main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    u8 i=0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    while(1)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for(i=0;i&lt;8;i++)//循环 8 次扫描 8 行、 列</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            EDDZ_COL_PORT=gled_col[i];//传送列选数据</span></span></span><br><span class="line"><span class="string"><span class="meta">            hc595_write_data(gled_row[i]);//传送行选数据</span></span></span><br><span class="line"><span class="string"><span class="meta">            delay_10us(100);//延时一段时间， 等待显示稳定</span></span></span><br><span class="line"><span class="string"><span class="meta">            hc595_write_data(0x00);//消影</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125; </span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;  </span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure><p>实验代码与前面点亮一个点的核心代码是一样的， 这里重点要理解动态扫描， 如果动态数码管代码能理解， 这个也就没有任何问题。 main 函数中主要是在 while 循环内从上至下， 从左至右不断扫描 8 行、 列， 即首先设置左边第一列有效（P0.7 输出低电平） ， 其余列无效（P0.6-P0.0 输出高电平） ， 然后通过74HC595 输出该列对应的行数据， 延时一段时间等待显示稳定， 最后清除列对应的行数据， 即消影。 从整个流程下来与动态数码管显示程序是很相似的。  </p><h5 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h5><p>该取模软件不仅可以用来取汉字、 数字等字符数据， 还可以用来取图像数据，这里以“心” 形图像为例， 教大家如何使用该软件来获取图像数据。</p><p>（1） 新建图像。 弹出选择框， 开发板 LED 点阵是 8X8 的， 就建一个高 8 宽8 的。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614121938430.png" alt="image-20230614121938430"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122004947.png" alt="image-20230614122004947"></p><p>（2） 选中图像需用格点。 这里每一个格点代表一个 LED 灯， 点击可选中，再次点击也可取消。 在界面上点出爱心。 如下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122016631.png" alt="image-20230614122016631"></p><p>（3） 参数设置。 “参数设置” 选项中有许多可选项， 可以自己进行设置，得到自己想要的结果。 可参考前面取模里面的设置。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122038297.png" alt="image-20230614122038297"></p><p>（4） 生成数据。 设计好图案和参数以后， 就需要生成可用数据。 当点击格式以后会出现相应数据。 如下图所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122049051.png" alt="image-20230614122049051"></p><p>这里将生成的图形数据复制出来粘贴到例程中， 替换数字 0 的数据， 如下  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u8 gled_row[<span class="number">8</span>]=&#123;<span class="number">0x38</span>,<span class="number">0x7C</span>,<span class="number">0x7E</span>,<span class="number">0x3F</span>,<span class="number">0x3F</span>,<span class="number">0x7E</span>,<span class="number">0x7C</span>,<span class="number">0x38</span>&#125;;</span><br><span class="line"><span class="comment">//LED 点阵显示图像的行数据</span></span><br></pre></td></tr></table></figure><p>其余代码与显示数字完全一样， 这里就不再列出。  </p><h4 id="实验现象-3"><a href="#实验现象-3" class="headerlink" title="实验现象"></a>实验现象</h4><p>​    注意： 做 LED 点阵实验时， 一定要将 LED 点阵旁的 J24 黄色跳线帽短接到 GND一端。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613092815573.png" alt="image-20230613092815573"></p><p>LED 点阵（点亮一个点）  </p><p>  使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 8*8LED 点阵左上角显示第一个点。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093012649.png" alt="image-20230613093012649"></p><p>LED 点阵（显示数字） </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093031677.png" alt="image-20230613093031677"></p><p>LED 点阵（显示图像） </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093058969.png" alt="image-20230613093058969"></p><p>注意： ==当不使用 LED 点阵时， 将 LED 点阵旁的 J24 黄色跳线帽短接到 VCC 一端。 这是因为 LED 点阵使用到了 P0 口， 而数码管也使用到 PO 口， 为了不干扰后续数码管显示的一些实验， 所以短接到 VCC 一端==， 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230613093200730.png" alt="image-20230613093200730"></p><h3 id="直流电机实验"><a href="#直流电机实验" class="headerlink" title="直流电机实验"></a>直流电机实验</h3><p>在 51 单片机应用中， 电机控制的应用也非常多。 所以有必要先来了解下电机相关的知识以及如何使用 51 单片机控制电机， 在未学习 PWM 之前， 我们先简单使用 GPIO 来控制电机的旋转和停止。 不能直接使用 GPIO 来驱动电机， 而需要相应的驱动芯片来驱动电机， 开发板板载了一个 ULN2003 驱动芯片， 该芯片是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 不仅可以用来驱动我们的直流电机， 还可用来驱动五线四相步进电机， 比如 28BYJ-48 步进电机。 本章使用的是 ULN2003 芯片来驱动， 本章所要实现的功能是： 直流电机工作约 5S 后停止。 学习本章可以参考前面的实验章节内容。 本章分为如下几部分内容：  </p><h4 id="直流电机介绍"><a href="#直流电机介绍" class="headerlink" title="直流电机介绍"></a>直流电机介绍</h4><p>直流电机是指能将直流电能转换成机械能（直流电动机） 或将机械能转换成直流电能（直流发电机） 的旋转电机。 它是能实现直流电能和机械能互相转换的电机。 当它作电动机运行时是直流电动机， 将电能转换为机械能； 作发电机运行时是直流发电机， 将机械能转换为电能。  </p><p>直流电机的结构应由定子和转子两大部分组成。 直流电机运行时静止不动的部分称为定子， 定子的主要作用是产生磁场， 由机座、 主磁极、 换向极、 端盖、轴承和电刷装置等组成。 运行时转动的部分称为转子， 其主要作用是产生电磁转矩和感应电动势， 是直流电机进行能量转换的枢纽， 所以通常又称为电枢， 由转轴、 电枢铁心、 电枢绕组、 换向器和风扇等组成。  </p><p>直流电机没有正负之分， 在两端加上直流电就能工作。 需要知道直流电机的额定电压和额定功率， 不能使之长时间超负荷运作。 在交换接线后， 可以形成正反转  </p><p>开发板配置的直流电机为 5V 直流电机， 其主要参数如下：<br>轴长： 8mm<br>轴径： 2mm<br>电压： 1-6V<br>参考电流： 0.35-0.4A<br>3V 转速： 17000-18000 转每分钟<br>外观实物图如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122343073.png" alt="image-20230614122343073"></p><p>其内部结构如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122353693.png" alt="image-20230614122353693"></p><h4 id="ULN2003芯片介绍"><a href="#ULN2003芯片介绍" class="headerlink" title="ULN2003芯片介绍"></a>ULN2003芯片介绍</h4><p>前面讲过， 51 单片机主要是用来控制而非驱动， 如果直接使用芯片的 GPIO管脚去驱动大功率器件， 要么将芯片烧坏， 要么就驱动不起来。 所以要驱动大功率器件， 比如电机。 就必须搭建驱动电路， 开发板上板载的驱动芯片是 ULN2003，该芯片是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 不仅可以用来驱动直流电机， 还可用来驱动五线四相步进电机， 比如 28BYJ-48 步进电机。 本章我们使用 ULN2003 来驱动直流电机， 下面来具体介绍下 ULN2003 芯片的使用  </p><p>ULN2003 是一个单片高电压、 高电流的达林顿晶体管阵列集成电路。 它是由7 对 NPN 达林顿管组成的， 它的高电压输出特性和阴极箝位二极管可以转换感应负载。 单个达林顿对的集电极电流是 500mA。 达林顿管并联可以承受更大的电流。此电路主要应用于继电器驱动器， 字锤驱动器， 灯驱动器， 显示驱动器（LED 气体放电） ， 线路驱动器和逻辑缓冲器。 ULN2003 的每对达林顿管都有一个 2.7k串联电阻， 可以直接和 TTL 或 5V CMOS 装置  </p><p>（1） 主要特点<br>①500mA 额定集电极电流（单个输出）<br>②高电压输出： 50V<br>③输入和各种逻辑类型兼容<br>④继电器驱动器<br>（2） 逻辑框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122515458.png" alt="image-20230614122515458"></p><p>从上图可以很容易理解该芯片的使用方法， 其内部相当于非门电路， 即输入高输出为低， 输入为低输出是高， 这里要注意：==因为 ULN2003 的输出是集电极开路， ULN2003 要输出高电平， 必须在输出口外接上拉电阻。 这也就能解释在后面连接直流电机时为什么不能直接将 ULN2003 的 2 个输出口接电机线， 而必须一根线接电源， 另一个才接 ULN2003 输出口==。</p><p>若使用该芯片驱动直流电机， 只可实现单方向控制， 电机一端接电源正极，另一端接芯片的输出口。 若想控制五线四相步进电机， 则可将四路输出接到步进电机的四相上， 电机另一条线接电源正。  </p><h4 id="硬件设计-8"><a href="#硬件设计-8" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 步进电机驱动模块<br>（2） 直流电机<br>开发板上的步进电机驱动模块电路如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614122740295.png" alt="image-20230614122740295"></p><p>从上图可知， ULN2003 的输入口与单片机的 P1.0-P1.3 连接， 对应输出则是OUT1-OUT4， 而 J47 则是提供给外部连接电机的接口， 可以支持直流电机、 五线四相步进电机 28BYJ-48 连接。 本实验使用的是直流电机， 电机的一根线连接在VCC 上， 另一根连接在 OUT1 上， 因此可通过单片机 P1.0 口输出高电平来控制电机旋转， 输出低电源控制电机停止。 注意： 单片机 P1.0 输出低电平时， ULN2003的 OUT1 并不会输出高电平导致停止， 而是因为集电极开路， 导致电机无电流流入致使停止。</p><h4 id="软件设计-8"><a href="#软件设计-8" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 直流电机工作约 5S 后停止。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 直流电机实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 直流电机旋转 5S 后停止</span></span><br><span class="line"><span class="comment">注意事项： 将直流电机两根线分别连接到“步进电机模块” 输出端子 J47 的 5V 和 O1 上。</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义直流电机控制管脚</span></span><br><span class="line">sbit DC_Motor=P1^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DC_MOTOR_RUN_TIME 5000 <span class="comment">//定义直流电机运行时间为 5000ms</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DC_Motor=<span class="number">1</span>;<span class="comment">//开启电机</span></span><br><span class="line">    delay_ms(DC_MOTOR_RUN_TIME);</span><br><span class="line">    DC_Motor=<span class="number">0</span>;<span class="comment">//关闭电机</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实验代码比较简单， 主要就是理解 ULN2003 的电平输出关系， 然后就像控制LED 一样。 这里就不再详细分析了  </p><h4 id="实验现象-4"><a href="#实验现象-4" class="headerlink" title="实验现象"></a>实验现象</h4><p>用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 直流电机工作约 5S后停止。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614170924104.png" alt="image-20230614170924104"></p><p>注意： ==直流电机的两根线要连接在 J47 端子的 O1 和 5V 上。 如下所示==：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230614170946727.png" alt="image-20230614170946727"></p><h3 id="步进电机实验"><a href="#步进电机实验" class="headerlink" title="步进电机实验"></a>步进电机实验</h3><h4 id="步进电机简介"><a href="#步进电机简介" class="headerlink" title="步进电机简介"></a>步进电机简介</h4><p>步进电机是将电脉冲信号转变为角位移或线位移的开环控制元件。 在非超载的情况下， 电机的转速、 停止的位置只取决于脉冲信号的频率和脉冲数， 而不受负载变化的影响， 即给电机加一个脉冲信号， 电机则转过一个步距角。 这一线性关系的存在， 加上步进电机只有周期性的误差而无累计误差等特点。 使得在速度、位置等控制领域用步进电机来控制变的非常的简单。 虽然步进电机已被广泛的应用， 但步进电机并不能像普通的直流电机， 交流电机在常规下使用。 它必须由双环形脉冲信号、 功率驱动电路等组成控制系统方可使用。 因此用好步进电机也并非易事， 它涉及到机械、 电机、 电子及计算机等多专业知识。 下图即为混合式步进电机组成图。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173248513.png" alt="image-20230616173248513"></p><h4 id="步进电机工作原理"><a href="#步进电机工作原理" class="headerlink" title="步进电机工作原理"></a>步进电机工作原理</h4><p>通常步进电机的转子为永磁体， 当电流流过定子绕组时， 定子绕组产生一矢量磁场。 磁场会带动转子旋转一定的角度， 使得转子的一对磁场方向与定子的磁场方向一致。 当定子的矢量磁场旋转一个角度。 转子也随着该磁场转步距角。 每输入一个电脉冲， 电动机转动一个角度前进一步。 它输出的角位移与输入的脉冲数成正比、 转速与脉冲频率成正比。 改变绕组通电的顺序， 电机就会反转。 所以可以控制脉冲数量、 频率及电动机各相绕组的通电顺序来控制步进电机的转动。具体看下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173306284.png" alt="image-20230616173306284"></p><h4 id="步进电机极性区分"><a href="#步进电机极性区分" class="headerlink" title="步进电机极性区分"></a>步进电机极性区分</h4><p>步进电机又分为单极性的步进电机和双极性的步进电机； 具体简易图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173332981.png" alt="image-20230616173332981"></p><p>其中左侧为单极性步进电机， 右侧为双极性的步进电机， 从上图中不难看出区别是什么。 单双极性是指一个步进电机里面有几种电流的流向， 左侧的五线四相步进电机就是单极性的步进电机， 图中的红色箭头为电流的走向， 四根线的电流走向汇总到公共线， 所以称之为单极性电机； 但是右侧则不同， 电机中有两个电流的回路， 两个电流的回路自然就是双极性， 所以称之为双极性电机。  </p><p><code>单极性绕组</code></p><p>单极性步进电机使用的是单极性绕组。 其一个电极上有两个绕组， 这种联接方式为当一个绕组通电时， 产生一个北极磁场； 另一个绕组通电， 则产生一个南极磁场。 因为从驱动器到线圈的电流不会反向， 所以可称其为单极绕组。  </p><p><code>双极性绕组</code>  </p><p>双极性步进电机使用的是双极性绕组。 每相用一个绕组， 通过将绕组中电流反向， 电磁极性被反向。 典型的两相双极驱动的输出步骤在电气原理图和下图中的步进顺序中进一步阐述。 按图所示， 转换只利用绕组简单地改变电流的方向，就能改变该组的极性。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173418031.png" alt="image-20230616173418031"></p><p>永磁步进电机包括一个永磁转子、 线圈绕组和导磁定子， 只要将线圈通电根据电磁铁的原理就会产生磁场， 分为南北极， 见上图所示； 通过改变步进电机定子的磁场， 转子就会因磁场的变化而发生转动， 同理， 依次改变通电的顺序就可以使得电机转动起来。  </p><h4 id="双极性步进电机驱动原理"><a href="#双极性步进电机驱动原理" class="headerlink" title="双极性步进电机驱动原理"></a>双极性步进电机驱动原理</h4><p>下图是一个双极性的步进电机整步， 步进顺序。 在第一步中： 将 A 相通电，根据电磁铁原理， 产生磁性， 并且因异性相吸， 所以磁场将转子固定在第一步的位置； 第二步： 当 A 相关闭， B 相通电时， 转子会旋转 90° ； 第三步： B 相关闭、 A 相通电， 但极性与第 1 步相反， 这促使转子再次旋转 90° 。 在第四步中： A 相关闭、 B 相通电， 极性与第 2 步相反。 重复该顺序促使转子按 90° 的步距角顺时针旋转。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173450584.png" alt="image-20230616173450584"></p><p>上图中显示的步进顺序是单相激励步进， 也可以理解为每次通电产生磁性的相只有一个， 要么 A 相， 要么 B 相； 但是更常用的是双相激励， 但是在转换时，一次只能换相一次， 具体详见下图  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173459038.png" alt="image-20230616173459038"></p><p>上图是两相同时通电的旋转顺序， 与单相激励不同的是， 单相通电后被固定在了与定子正对着的绕组极性， 但是双相同时激励时转子却被固定在两个绕阻的极性中间； 此时通电顺序就变成了 AB 相同时通电即可。  </p><p>在双相激励的过程中， 也可以在换相位时加一个关闭相位的状态而产生走半步的现象， 这将步进电机的整个步距角一分为二， 例如， 一个 90° 的步进电机将每半步移动 45° ， 具体见下图  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173512127.png" alt="image-20230616173512127"></p><ol><li>A 相通电， B 相不通电</li><li><p>A、 B 相全部通电， 且电流相同， 产生相同磁性</p></li><li><p>B 相通电， A 断电</p></li><li>B 相通电， A 相通电， 且电流相等， 产生相同磁性</li><li>A 相通电， B 断电</li><li>A、 B 相全部通电， 且电流相同， 产生相同磁性</li><li>B 相通电， A 断电</li><li>B 相通电， A 相通电， 且电流相等， 产生相同磁性<br> 其中 1~4 步与 5~8 步的电流方向相反（电流相反， 电磁的极性就相反） 这<br> 样就产生了顺时针旋转， 同理逆时针是将通电顺序反过来即可。</li></ol><h4 id="单极性步进电机驱动原理"><a href="#单极性步进电机驱动原理" class="headerlink" title="单极性步进电机驱动原理"></a>单极性步进电机驱动原理</h4><p>单极性与双极性步进电机驱动类似， 都可以分为整步与半步的驱动方式， 不同的是， 双极性的步进电机可以通过改变电流的方向来改变每相的磁场方向， 但是单极性的就不可以了， 它有一个公共端， 这就直接决定了， 电流方向。 具体旋转顺序详见下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173550016.png" alt="image-20230616173550016"></p><p>上图是单极性步进电机整步旋转的过程， 其中， 在图示中分为 5 根线， 分别为 A、 B、 C、 D 和公共端（+） ， 公共端需要一直通电， 剩下 ABCD 相中只要有一个相通电， 即可形成回路产生磁场， 图中的通电顺序为 A-&gt;B-&gt;C-&gt;D， 即可完成上图中的顺时针旋转， 如果想要逆时针旋转只需要将其倒序即可。  </p><p>以上是单相通电产生的整步旋转， 两相通电也可以产生， 两个相邻的相通电，这样相邻的两个相就都产生了回路， 也就产生了磁场， 图中的通电顺序为AB-&gt;BC-&gt;CD-&gt;DA， 同理逆时针旋转的顺序为逆序。 具体看下图：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173612410.png" alt="image-20230616173612410"></p><p>上面两张图清晰的描述了单极性步进电机的通电顺序与旋转的过程， 综合这两张图就是单极性步进电机半步的通电顺序， 具体看下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173621285.png" alt="image-20230616173621285"></p><p>上图兼容了前两张图的所有特点， 也可以说前两张图是这张图的子集， 图中的通电顺序为： A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA 转子每次只走半步 45 度， 所以这也被称为半步驱动， 与整步相比半步的旋转方式旋转起来更加的顺滑。  </p><h4 id="细分驱动原理"><a href="#细分驱动原理" class="headerlink" title="细分驱动原理"></a>细分驱动原理</h4><p>对于细分驱动的原理， 不分单双极性步进电机， 下图以单极性为例：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173640692.png" alt="image-20230616173640692"></p><p>在上图中均为双相激励； 其中图（a） 为 A 相电流很大， B 相的电流极其微弱， 接近 0； 图 (C) 为 A 相和 B 相的电流相同， 电流决定磁场， 所以说 A 相和 B 相的磁场也是相同的， (a) 和（c） 可以是极限特殊的情况， 再看图（b）和图（d） 这两个是由于 A 相和 B 相的电流不同产生位置情况； 由此可以得出改变定子的电流比例就可以使得转子在任意角度停住。 细分的原理就是： 通过改变定子的电流比例， 改变转子在一个整步中的不同位置， 可以将一个整步分成多个小步来运行。  </p><p>在上图中就是一个整步分成了 4 步来跑， 从（a） ~（d） 是 A 相的电流逐渐减小， B 相电流逐渐增大的过程， 如果驱动器的细分能力很强， 可以将其分成32 细分、 64 细分等； 这不仅提高了步进电机旋转的顺畅度而且提高了每步的精度。 细分驱动具有转动顺畅、 精度高、 转矩大的特点， 但控制复杂， 一般需要专用芯片来实现， 例如东芝公司的 TB67S10xA 系列步进电机细分驱动芯片， 最多可以把 1 个整步分为 32 个小步。  </p><h4 id="步进电机技术指标"><a href="#步进电机技术指标" class="headerlink" title="步进电机技术指标"></a>步进电机技术指标</h4><h5 id="静态技术指标"><a href="#静态技术指标" class="headerlink" title="静态技术指标"></a>静态技术指标</h5><p>• 相数： 产生不同对极 N、 S 磁场的激磁线圈对数， 也可以理解为步进电机中线圈的组数， 其中两相步进电机步距角为 1.8° ， 三相的步进电机步距角为1.5° ， 相数越多的步进电机， 其步距角就越小。</p><p>• 拍数： 完成一个磁场周期性变化所需脉冲数或导电状态用 n 表示， 或指电机转过一个齿距角所需脉冲数， 以四相电机为例， 有四相四拍运行方式即AB-BC-CD-DA-AB， 四相八拍运行方式即 A-AB-B-BC-C-CD-D-DA-A。</p><p>• 步距角： 一个脉冲信号所对应的电机转动的角度， 可以简单理解为一个脉冲信号驱动的角度， 电机上都有写， 一般 42 步进电机的步距角为 1.8°</p><p>• 定位转矩： 电机在不通电状态下， 电机转子自身的锁定力矩（由磁场齿形的谐波以及机械误差造成的） 。</p><p>• 静转矩： 电机在额定静态电压作用下， 电机不作旋转运动时， 电机转轴的锁定力矩。 此力矩是衡量电机体积的标准， 与驱动电压及驱动电源等无关。</p><h5 id="动态技术指标"><a href="#动态技术指标" class="headerlink" title="动态技术指标"></a>动态技术指标</h5><p>• 步距角精度： 步进电机转动一个步距角度的理论值与实际值的误差。 用百分比表示： 误差/步距角 *100%。<br>• 失步： 电机运转时运转的步数， 不等于理论上的步数。 也可以叫做丢步，一般都是因负载太大或者是频率过快。<br>• 失调角： 转子齿轴线偏移定子齿轴线的角度， 电机运转必存在失调角， 由失调角产生的误差， 采用细分驱动是不能解决的。<br>• 最大空载起动频率： 在不加负载的情况下， 能够直接起动的最大频率。<br>• 最大空载的运行频率： 电机不带负载的最高转速频率。<br>• 运行转矩特性： 电机的动态力矩取决于电机运行时的平均电流（而非静态电流） ， 平均电流越大， 电机输出力矩越大， 即电机的频率特性越硬。<br>• 电机正反转控制： 通过改变通电顺序而改变电机的正反转。</p><h4 id="28BYJ-48-步进电机简介"><a href="#28BYJ-48-步进电机简介" class="headerlink" title="28BYJ-48 步进电机简介"></a>28BYJ-48 步进电机简介</h4><p>28BYJ48 步进电机自带减速器， 为四相五线步进电机， 直径为 28mm， 实物如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173848598.png" alt="image-20230616173848598"></p><p>28BYJ48 电机内部结构等效图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173855516.png" alt="image-20230616173855516"></p><p>28BYJ48 步进电机旋转驱动方式如下表  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173905222.png" alt="image-20230616173905222"></p><p>28BYJ48 步进电机主要参数如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173915259.png" alt="image-20230616173915259"></p><p>在上图中 28BYJ48 步进电机主要参数中可以看到有一个减速比： 1:64， 步进角为 5.625/64 度， 如果需要转动一圈， 那么需要 360/5.625*64=4096 个脉冲信号。</p><p>减速比这个和之前介绍的直流减速电机有点类似， 所以 28BYJ48 步进电机实际上是： 减速齿轮+步进电机组成， 28BYJ48 步进电机减速齿轮实物图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616173954265.png" alt="image-20230616173954265"></p><p>减速齿轮计算方法如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616174000811.png" alt="image-20230616174000811"></p><h4 id="硬件设计-9"><a href="#硬件设计-9" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 步进电机驱动模块<br>（2） 28BYJ-48 步进电机<br>该电路在前面直流电机实验中已介绍， 此处不再重复。</p><h4 id="软件设计-9"><a href="#软件设计-9" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过 ULN2003 驱动模块控制 28BYJ48 步进电机运行方向及速度， 当按下 KEY1 键可调节电机旋转方向； 当按下 KEY2 键， 电机加速；  当按下 KEY3 键， 电机减速。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 步进电机实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后，当按下 KEY1 键可调节电机旋转方向；当按下KEY2键，电机           加速；当按下 KEY3 键， 电机减速</span></span><br><span class="line"><span class="comment">注意事项： 将步进电机红色线对接到“步进电机模块” 输出端子 J47 的 5V 上， 其          它相序依次接入。</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 ULN2003 控制步进电机管脚</span></span><br><span class="line">    sbit IN1_A=P1^<span class="number">0</span>;</span><br><span class="line">    sbit IN2_B=P1^<span class="number">1</span>;</span><br><span class="line">    sbit IN3_C=P1^<span class="number">2</span>;</span><br><span class="line">    sbit IN4_D=P1^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line"><span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"><span class="comment">// 定义步进电机速度， 值越小， 速度越快</span></span><br><span class="line"><span class="comment">// 最小不能小于 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MAXSPEED 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STEPMOTOR_MINSPEED 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">oid <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_ms</span></span><br><span class="line"><span class="comment">* 函数功能 : ms 延时函数， ms=1 时， 大约延时 1ms</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(u16 ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=ms;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">110</span>;j&gt;<span class="number">0</span>;j--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : step_motor_28BYJ48_send_pulse</span></span><br><span class="line"><span class="comment">* 函数功能 : 输出一个数据给 ULN2003 从而实现向步进电机发送一个脉冲</span></span><br><span class="line"><span class="comment">* 输 入 : step： 指定步进序号， 可选值 0~7</span></span><br><span class="line"><span class="comment">         dir： 方向选择,1： 顺时针,0： 逆时针</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">step_motor_28BYJ48_send_pulse</span><span class="params">(u8 step,u8 dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp=step;</span><br><span class="line">    <span class="keyword">if</span>(dir==<span class="number">0</span>) <span class="comment">//如果为逆时针旋转</span></span><br><span class="line">    temp=<span class="number">7</span>-step;<span class="comment">//调换节拍信号</span></span><br><span class="line">    <span class="keyword">switch</span>(temp)<span class="comment">//8 个节拍控制： A-&gt;AB-&gt;B-&gt;BC-&gt;C-&gt;CD-&gt;D-&gt;DA</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">1</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">1</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: IN1_A=<span class="number">0</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: IN1_A=<span class="number">1</span>;IN2_B=<span class="number">0</span>;IN3_C=<span class="number">0</span>;IN4_D=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"></span><br><span class="line"> u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">   key=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  u8 key=<span class="number">0</span>;</span><br><span class="line">  u8 dir=<span class="number">0</span>;<span class="comment">//默认逆时针方向</span></span><br><span class="line">  u8 speed=STEPMOTOR_MAXSPEED;<span class="comment">//默认最大速度旋转</span></span><br><span class="line">  u8 step=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    key=key_scan(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(key==KEY1_PRESS)<span class="comment">//换向</span></span><br><span class="line">    &#123;</span><br><span class="line">    dir=!dir;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==KEY2_PRESS)<span class="comment">//加速</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(speed&gt;STEPMOTOR_MAXSPEED)</span><br><span class="line">        speed-=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key==KEY3_PRESS)<span class="comment">//减速</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(speed&lt;STEPMOTOR_MINSPEED)</span><br><span class="line">        speed+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">     step_motor_28BYJ48_send_pulse(step++,dir);</span><br><span class="line"><span class="keyword">if</span>(step==<span class="number">8</span>)step=<span class="number">0</span>;</span><br><span class="line">delay_ms(speed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step_motor_28BYJ48_send_pulse 函数用于输出一个数据给 ULN2003， 从而实现向步进电机发送一个脉冲信号。 它有两个形参， 第一个为 step， 指定步进序号， 可选值为 0-7， 代表步进电机控制信号的 8 个节拍。 第二个为 dir， 指定电机的旋转方向， 可选 1:顺时针， 0:逆时针。 这里指的顺时针逆时针是两个不同方向。  </p><p>函数先判断 dir 参数值， 如果为 0， 则为逆时针旋转， 将 step 值变为 8 的互补数， 其实就是将 8 个节拍反向输出  </p><p>主函数实现的功能很简单， 首先定义一些变量， 进入循环， 检测是否有按键按下， 当 KEY1 按下， 切换步进电机方向； 当 KEY2 按下， 使电机加速； 当 KEY3按下， 使电机减速。  </p><p>程序中所用 STEPMOTOR_MAXSPEED 和 STEPMOTOR_MINSPEED 在开头已定义， 表示步进电机最大运行速度和最低运行速度， 当然可以根据实际现象适当调整这两个值。  </p><h4 id="实验现象-5"><a href="#实验现象-5" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 KEY1 键可调节电机旋转方向； 当按下 KEY2 键， 电机加速； 当按下 KEY3 键， 电机减速。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616175032529.png" alt="image-20230616175032529"></p><p>注意： 将步进电机红色线对接到“步进电机模块” 输出端子 J47 的 5V 上，其它相序依次接入。 如下所示  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230616175041386.png" alt="image-20230616175041386"></p><h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>在前面章节， 我们通过介绍 51 单片机 IO 口学习了很多相关的实验。 从最简单的 LED 到数码管动态扫描再到 LED 点阵以及电机控制， 无不体现学习 51 单片机 IO 口操作的重要性。 在前面章节， 我们还提到了学习 51 单片机的重点及难点主要有中断、 定时器、 串口等内容， 这部分内容大家一定要认真掌握， 这部分没有学好就不能说学会了51单片机。因此专门用一章来介绍51单片机的中断系统，为后面学习外部中断、 定时器中断、 串口中断做好铺垫。   </p><h4 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h4><p>中断概念</p><p>中断是为使单片机具有对外部或内部随机发生的事件实时处理而设置的，中断功能的存在， 很大程度上提高了单片机处理外部或内部事件的能力。 它也是单片机最重要的功能之一， 是我们学习单片机必须要掌握的。 很多初学者被困在中断中， 学了很久仍然不知道中断究竟是如何运作的。 千万不要认为它有多难，其实只要掌握正确的学习方法， 没有哪个知识点是学不会的。  </p><p>为了能让大家更容易理解中断概念， 我们先来举一个生活事例： 你打开火，烧上一壶水。 然后去洗衣服， 在洗衣服的过程中， 突然听到水壶发出水开的报警声， 这时， 你停止洗衣服动作， 立即去关掉火， 然后将开水灌入暖水瓶中， 灌完开水后， 你又回去继续洗衣服。 这个过程中实际上就发生了一次中断。  </p><p>对于单片机来讲， 中断是指 CPU 在处理某一事件 A 时， 发生了另一事件 B，请求 CPU 迅速去处理(中断发生)； CPU 暂时停止当前的工作(中断响应)， 转去处理事件 B(中断服务)； 待 CPU 将事件 B 处理完毕后， 再回到原来事件 A 被中断的地方继续处理事件 A(中断返回)， 这一过程称为中断。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617095939575.png" alt="image-20230617095939575"></p><p>再回来看前面讲的生活事例， 与单片机中断结合分析， 你的主任务是洗衣服，水开报警这是一个中断请求， 这一时刻相当于断点处， 你响应中断去关火， 然后将开水灌入暖水瓶中， 这一动作实际上就是处理中断程序， 灌完开水后再回去继续洗衣服， 相当于处理完中断程序后再返回主程序继续执行主程序。 这里需要注意的是， 水开是随时都有可能的， 但是无论什么时候开， 只要一开你将立即去处理它， 处理完后再回来继续接着洗刚才那件衣服。 单片机在执行程序时， 中断也随时有可能发生， 但无论何时发生， 只要一旦发生， 单片机将立即暂停当前程序，赶去处理中断程序， 处理完中断程序后再返回刚才暂停处接着执行原来的程序。  </p><p>单片机在执行程序时其程序流程图如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100002769.png" alt="image-20230617100002769"></p><p>引起 CPU 中断的根源称为中断源。 中断源向 CPU 提出中断请求， CPU 暂时中断原来的事务 A， 转去处理事件 B， 对事件 B 处理完毕后， 再回到原来被中断的地方(即断点)， 称为中断返回。 实现上述中断功能的部件称为中断系统(中断机构)。  </p><p>当中央处理机 CPU 正在处理某件事的时候外界发生了紧急事件请求， 要求CPU 暂停当前的工作， 转而去处理这个紧急事件， 处理完以后， 再回到原来被中断的地方， 继续原来的工作， 这样的过程称为中断。 实现这种功能的部件称为中断系统， 请示 CPU 中断的请求源称为中断源。 微型机的中断系统一般允许多个中断源， 当几个中断源同时向 CPU 请求中断， 要求为它服务的时候， 这就存在CPU 优先响应哪一个中断源请求的问题。 通常根据中断源的轻重缓急排队， 优先处理最紧急事件的中断请求源， 即规定每一个中断源有一个优先级别。 CPU 总是先响应优先级别最高的中断请求。  </p><p>当 CPU 正在处理一个中断源请求的时候(执行相应的中断服务程序)， 发生了另外一个优先级比它还高的中断源请求。 如果 CPU 能够暂停对原来中断源的服务程序， 转而去处理优先级更高的中断请求源， 处理完以后， 再回到原低级中断服务程序， 这样的过程称为中断嵌套。 这样的中断系统称为多级中断系统， 没有中断嵌套功能的中断系统称为单级中断系统。  </p><p>中断的开启与关闭、 设置启用哪一个中断等都是由单片机内部的一些特殊功能寄存器来决定的， 在前面章节的学习中我们仅对单片机 IO 口操作过（实际上操作 IO 口即操作 IO 口寄存器， 只不过编译器已经帮我们把 IO 口寄存器封装好直接操作 IO 即可， 这些可在 51 单片机头文件内查看） ， 从本章开始就会介绍单片机内部更多的特殊功能寄存器以及如何配置它实现相应的功能。  </p><p>随着计算机技术的应用， 人们发现中断技术不仅解决了快速主机与慢速 I/O设备的数据传送问题， 而且还具有如下优点：  </p><p>①分时操作。 CPU 可以分时为多个 I/O 设备服务， 提高了计算机的利用率；<br>②实时响应。 CPU 能够及时处理应用系统的随机事件， 系统的实时性大大增强；<br>③可靠性高。 CPU 具有处理设备故障及掉电等突发性事件能力， 从而使系统可靠性提高。</p><h4 id="中断结构及相关寄存器"><a href="#中断结构及相关寄存器" class="headerlink" title="中断结构及相关寄存器"></a>中断结构及相关寄存器</h4><p>中断结构</p><p>STC89C5X 系列单片机提供了 8 个中断请求源， 它们分别是： 外部中断O(INTO)、 外部中断 1(INT1)、 外部中断 2(INT2)、 外部中断 3(INT3)、 定时器 0中断、 定时器 1 中断、 定时器 2 中断、 串口(UART)中断。 （==注意： 51 系列单片机一定有基本的 5 个中断， 但不全有 8 个中断， 需要查看芯片手册， 通常我们使用的都是基本的 5 个中断： INT0、 INT1、 定时器 0/1， 串口中断== ）。有的中断都具有四个中断优先级（基本型只有两个） 。 用户可以用关总中断允许位(EA/IE.7)或相应中断的允许位来屏蔽所有的中断请求， 也可以用打开相应的中断允许位来使 CPU 响应相应的中断申请。 其中有些中断源可以用软件独立地控制为开中断或关中断状态。 每一个中断的优先级别均可用软件设置。 高优先级的中断请求可以打断低优先级的中断， 反之， 低优先级的中断请求不可以打断高优先级及同优先级的中断。 当两个相同优先级的中断同时产生时， 将由查询次序来决定系统先响应哪个中断。 STC89C5X 系列单片机的各个中断查询次序表如下图所示    </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100533990.png" alt="image-20230617100533990"></p><p>通过设置新增加的特殊功能寄存器 IPH 中的相应位， 可将中断优先级设为四级， 如果只设置 IP 或 XICON， 那么中断优先级就只有两级， 与传统 8051 单片机两级中断优先级完全兼容。 上图中的中断查询次序即为中断号， 这个中断号在编程时非常重要， 当中断来临时， 只有中断号正确才能进入中断。  </p><p>下面我们以 51 单片机均有的 5 个中断来介绍， 其内部结构框图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100552185.png" alt="image-20230617100552185"></p><p>①INT0 对应的是 P3.2 口的附加功能， 可由 IT0(TCON.0)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.2 引脚上出现有效的中断信号时， 中断标志 IE0(TCON.1)置 1， 向 CPU 申请中断。</p><p>②INT1 对应的是 P3.3 口的附加功能， 可由 IT1(TCON.2)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.3 引脚上出现有效的中断信号时， 中断标志 IE1(TCON.3)置 1,向 CPU 申请中断。</p><p>③T0 对应的是 P3.4 口的附加功能， TF0（TCON.5） ,片内定时/计数器 T0 溢出中断请求标志。 当定时/计数器 T0 发生溢出时， 置位 TF0， 并向 CPU 申请中断。</p><p>④T1 对应的是 P3.5 口的附加功能， TF1（ TCON.7） ， 片内定时/计数器 T1溢出中断请求标志。 当定时/计数器 T1 发生溢出时， 置位 TF1， 并向 CPU 申请中断。</p><p>⑤RXD 和 TXD 对应的是 P3.0 和 P3.1 口的附加功能， RI（ SCON.0） 或 TI （SCON.1） ， 串行口中断请求标志。 当串行口接收完一帧串行数据时置位 RI 或当串行口发送完一帧串行数据时置位 TI， 向 CPU 申请中断。</p><h4 id="中断相关寄存器"><a href="#中断相关寄存器" class="headerlink" title="中断相关寄存器"></a>中断相关寄存器</h4><p>（1） 中断允许控制</p><p>CPU 对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE 控制的。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100713162.png" alt="image-20230617100713162"></p><p>EX0(IE.0)， 外部中断 0 允许位；<br>ET0(IE.1)， 定时/计数器 T0 中断允许位；<br>EX1(IE.2)， 外部中断 0 允许位；<br>ET1(IE.3)， 定时/计数器 T1 中断允许位；<br>ES（IE.4)， 串行口中断允许位；<br>EA (IE.7)， CPU 中断允许（总允许） 位。</p><p>（2） 中断请求标志 TCON  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100729112.png" alt="image-20230617100729112"></p><p>IT0（TCON.0） ， 外部中断 0 触发方式控制位。<br>当 IT0=0 时， 为电平触发方式。<br>当 IT0=1 时， 为边沿触发方式（下降沿有效） 。<br>IE0（TCON.1） ， 外部中断 0 中断请求标志位。<br>IT1（TCON.2） ， 外部中断 1 触发方式控制位。<br>IE1（TCON.3） ， 外部中断 1 中断请求标志位。<br>TF0（TCON.5） ， 定时/计数器 T0 溢出中断请求标志位。<br>TF1（TCON.7） ， 定时/计数器 T1 溢出中断请求标志位。</p><p>（3） 中断优先级  </p><p>同一优先级中的中断申请不止一个时， 则有中断优先权排队问题。 同一优先级的中断优先权排队， 由中断系统硬件确定的自然优先级形成， 其排列如所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100752646.png" alt="image-20230617100752646"></p><p>（4） 中断号  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617100812169.png" alt="image-20230617100812169"></p><p>（5） 中断响应条件  </p><p>①中断源有中断请求；<br>②此中断源的中断允许位为 1；<br>③CPU 开中断（即 EA=1） 。<br>以上三条同时满足时， CPU 才有可能响应中断。 在使用中断时我们需要做什<br>么呢？<br>①你想使用的中断是哪个？ 选择相应的中断号；<br>②你所希望的触发条件是什么？<br>③你希望在中断之后干什么？<br>我们以外部中断 0 为例， 如下：<br>主程序中需要有以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>； <span class="comment">//打开总中断开关</span></span><br><span class="line">EX0=<span class="number">1</span>； <span class="comment">//开外部中断 0</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>； <span class="comment">//设置外部中断的触发方式</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> int0() interrupt <span class="number">0</span> using <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//编写用户所需的功能代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断函数中 int0 是函数名， 可自定义， 但必须符合 C 语言标识符定义规则， interrupt 是一个关键字， 表示 51 单片机中断。 后面的“0” 是中断号， 外部中断 0 中断号为 0， 这个可参考前面的内容。 后面的 using 1 可省略不写。  </p><p>至此我们就把 51 单片机的中断简单介绍完， 如果大家还有不明白的可先暂时放下， 先通过实验掌握 51 单片机中断的使用方法， 对于理论方面的知识后续可以深入研究。  </p><h3 id="外部中断实验"><a href="#外部中断实验" class="headerlink" title="外部中断实验"></a>外部中断实验</h3><p>上一章我们介绍了 51 单片机的中断系统， 这一章就来学习 51 单片机的外部中断， 通过上一章的介绍我们知道， 51 单片机外部中断有 2 个， 外部中断 0 和外部中断 1， 它们的使用方法是一样的， 所以只要学会一个即可掌握所有外部中断使用。 本章所要实现的功能是： 使用独立按键 K3 控制 LED 亮灭， K3 连接外部中断 0（P3.2） 管脚。 学习本章可以参考前面的实验章节内容。   </p><h4 id="外部中断介绍"><a href="#外部中断介绍" class="headerlink" title="外部中断介绍"></a>外部中断介绍</h4><p>上一章我们介绍了 51 单片机的中断系统， 我们再回顾一下 51 单片机的中断。当中央处理机 CPU 正在处理某件事的时候外界发生了紧急事件请求， 要求CPU 暂停当前的工作， 转而去处理这个紧急事件， 处理完以后， 再回到原来被中断的地方， 继续原来的工作， 这样的过程称为中断。 实现这种功能的部件称为中断系统， 请示 CPU 中断的请求源称为中断源。 微型机的中断系统一般允许多个中断源， 当几个中断源同时向 CPU 请求中断， 要求为它服务的时候， 这就存在CPU 优先响应哪一个中断源请求的问题。 通常根据中断源的轻重缓急排队， 优先处理最紧急事件的中断请求源， 即规定每一个中断源有一个优先级别。 CPU 总是先响应优先级别最高的中断请求。 中断示意图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101128577.png" alt="image-20230617101128577"></p><p>STC89C5X 系列单片机提供了 4 个外部中断： 外部中断 O(INTO)、 外部中断1(INT1)、 外部中断 2(INT2)、 外部中断 3(INT3)。 （注意： ==51 系列单片机一定有基本的 2 个外部中断， 但不全有 4 个中断， 需要查看芯片手册， 通常我们都是使用基本的 2 个外部中断： INT0 和 INT1==） 。  </p><p>下面我们来看下外部中断结构图， 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101151647.png" alt="image-20230617101151647"></p><p>图中 INT0 和 INT1 即为外部中断 0 和外部中断 1 输入口。<br>①INT0 对应的是 P3.2 口的附加功能， 可由 IT0(TCON.0)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.2 引脚上出现有效的中断信号时， 中断标IE0(TCON.1)置 1， 向 CPU 申请中断。  </p><p>②INT1 对应的是 P3.3 口的附加功能， 可由 IT1(TCON.2)选择其为低电平有效还是下降沿有效。 当 CPU 检测到 P3.3 引脚上出现有效的中断信号时， 中断标IE1(TCON.3)置 1,向 CPU 申请中断。  </p><p>（1） 中断允许控制  </p><p>CPU 对中断系统所有中断以及某个中断源的开放和屏蔽是由中断允许寄存器IE 控制的。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101236422.png" alt="image-20230617101236422"></p><p>EX0(IE.0)， 外部中断 0 允许位；<br>ET0(IE.1)， 定时/计数器 T0 中断允许位；<br>EX1(IE.2)， 外部中断 0 允许位；<br>ET1(IE.3)， 定时/计数器 T1 中断允许位；<br>ES（IE.4)， 串行口中断允许位；<br>EA (IE.7)， CPU 中断允许（总允许） 位。</p><p>（2） 中断请求标志 TCON  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617101250459.png" alt="image-20230617101250459"></p><p>IT0（TCON.0） ， 外部中断 0 触发方式控制位。<br>当 IT0=0 时， 为电平触发方式。<br>当 IT0=1 时， 为边沿触发方式（下降沿有效） 。<br>IE0（TCON.1） ， 外部中断 0 中断请求标志位。<br>IT1（TCON.2） ， 外部中断 1 触发方式控制位。<br>IE1（TCON.3） ， 外部中断 1 中断请求标志位。<br>TF0（TCON.5） ， 定时/计数器 T0 溢出中断请求标志位。<br>TF1（TCON.7） ， 定时/计数器 T1 溢出中断请求标志位。</p><h4 id="外部中断配置"><a href="#外部中断配置" class="headerlink" title="外部中断配置"></a>外部中断配置</h4><p>我们知道要让 51 单片机发生中断必须要满足以下 3 个条件， 这 3 个条件的顺序可以任意：  </p><p>①中断源有中断请求；<br>②此中断源的中断允许位为 1；<br>③CPU 开中断（即 EA=1） </p><p>比如我们配置外部中断 0， 对应的配置程序如下  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EA=<span class="number">1</span>； <span class="comment">//打开总中断开关</span></span><br><span class="line">EX0=<span class="number">1</span>； <span class="comment">//开外部中断 0</span></span><br><span class="line">IT0=<span class="number">0</span>/<span class="number">1</span>； <span class="comment">//设置外部中断的触发方式</span></span><br></pre></td></tr></table></figure><p>如果要配置的是外部中断 1， 只需将 EX0 改为 EX1， IT0 改为 IT1。  </p><p>因为独立按键一端是共地的， 当按下后对应单片机 IO 口被拉低， 而默认单片机 IO 口是高电平， 这样就有一个下降沿过程， 所以通常使用外部中断都是配置为下降沿发， 即 IT0=1；  </p><p>在编写程序时通常我们会将外部中断的配置放到一个自定义函数内便于管理维护。 如下所示：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>;<span class="comment">//跳变沿触发方式（下降沿）</span></span><br><span class="line">    EX0=<span class="number">1</span>;<span class="comment">//打开 INT0 的中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当触发中断后即会进入中断服务函数， 外部中断 0 中断服务函数如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//执行所需的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中断函数中 exti0 是函数名， 可自定义， 但必须符合 C 语言标识符定义规则， interrupt 是一个关键字， 表示 51 单片机中断。 后面的“0” 是中断号， 外部中断 0 中断号为 0， 如果是外部中断 1， 则中断号为 2， 这个可参考中断章节的内容。  </p><h4 id="硬件设计-10"><a href="#硬件设计-10" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 独立按键模块（K3）<br>（2） LED 模块（D1）<br>LED 模块和独立按键模块电路在前面章节已介绍过， 这里就不多说。 原理图中 K3 键是连接在单片机 P3.2 口（外部中断 0） ， K4 按键是连接在 P3.3 口（外部中断 1）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617102452834.png" alt="image-20230617102452834"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617102456878.png" alt="image-20230617102456878"></p><h4 id="软件设计-10"><a href="#软件设计-10" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 使用独立按键 K3 控制 LED 亮灭。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 外部中断 0 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当按下 K3 键可控制 D1 指示灯亮灭</span></span><br><span class="line"><span class="comment">注意事项： 将红外接收传感器取下， 防止对 P3.2 口干扰</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 LED1 管脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义独立按键 K3 控制脚</span></span><br><span class="line">sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : exti0_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 外部中断 0 配置函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>;<span class="comment">//跳变沿触发方式（下降沿）</span></span><br><span class="line">    EX0=<span class="number">1</span>;<span class="comment">//打开 INT0 的中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">exti0_init();<span class="comment">//外部中断 0 配置</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">exti0</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    delay_10us(<span class="number">1000</span>);<span class="comment">//消斗</span></span><br><span class="line">    <span class="keyword">if</span>(KEY3==<span class="number">0</span>)<span class="comment">//再次判断 K3 键是否按下</span></span><br><span class="line">    LED1=!LED1;<span class="comment">//LED1 状态翻转</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序代码比较简单， 首先定义 K3 键与 LED1 的控制管脚， 然后定义了外部中断 0 配置函数 exti0_init， 该函数内容是按照前面介绍的配置方法实现， 即开启总中断、 外部中断 0 功能， 设置外部中断 0 为下降沿触发。 然后进入 while循环， 在循环体内没有执行任何功能程序。  </p><p>有人就会问， 在主函数中怎么没有看到按键对 LED 的控制呢？ 因为我们在exti0_init()函数内就已经把按键管脚配置为外部中断 0 下降沿触发， 当有按键按下， 即会进入对应中断服务函数执行相应的功能程序， LED 的控制就在中断函数内完成的。  </p><p>外部中断 1 的使用与外部中断 0 是一样的 ，这里就不再重复。  </p><h4 id="实验现象-6"><a href="#实验现象-6" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当按下 K3 键， D1 指示灯亮， 再次按下 K3 键， D1 指示灯灭， 如此循环。</p><p>如果下载的是外部中断 1 实验程序， 实验现象如下： 当按下 K4 键， D1 指示灯亮， 再次按下 K4 键， D1 指示灯灭， 如此循环</p><p>注意： 由于红外接收传感器与 K3 共用 P3.2 口， 因此在做外部中断 0 实验时，将红外接收传感器从开发板取下， 防止干扰。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103336224.png" alt="image-20230617103336224"></p><h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>上一章我们介绍了 51 单片机的外部中断， 学习了如何配置 51 单片机的外部中断。 这一章我们来学习 51 单片机的定时器中断。 STC89C5X 含有 3 个定时器：定时器 0、 定时器 1、 定时器 2（注意： ==51 系列单片机一定有基本的 2 个定时器（定时器 0 和定时器 1） ， 但不全有 3 个中断， 需要查看芯片手册， 通常我们使用的是基本的 2 个定时器： 定时器 0/1==） 。 本章以定时器 0 为例进行讲解， 让大家学会 51 单片机定时器的使用， 定时器 1 的使用方法与定时器 0 一样。 本章要实现的功能是： 通过定时器 0 中断控制 D1 指示灯间隔 1 秒闪烁。 学习本章可以参考前面的实验章节内容。  </p><h4 id="定时器介绍"><a href="#定时器介绍" class="headerlink" title="定时器介绍"></a>定时器介绍</h4><p>在介绍定时器之前先科普下几个知识：  </p><p>1， CPU 时序的有关知识  </p><p>①振荡周期： 为单片机提供定时信号的振荡源的周期（晶振周期或外加振荡周期） 。②状态周期： 2 个振荡周期为 1 个状态周期，用 S 表示。振荡周期又称 S 周期或时钟周期。</p><p>③机器周期： 1 个机器周期含 6 个状态周期， 12 个振荡周期。</p><p>④指令周期： 完成 1 条指令所占用的全部时间， 它以机器周期为单位。例如： 外接晶振为 12MHz 时， 51 单片机相关周期的具体值为：</p><p>振荡周期=1/12us;<br>状态周期=1/6us;<br>机器周期=1us;<br>指令周期=1~4us;</p><p>2， 学习定时器前需要明白的几点  </p><p>①51 单片机有两组定时器/计数器， 因为既可以定时， 又可以计数， 故称之为定时器/计数器。</p><p>②定时器/计数器和单片机的 CPU 是相互独立的。 定时器/计数器工作的过程是自动完成的， 不需要 CPU 的参与。</p><p>③51 单片机中的定时器/计数器是根据机器内部的时钟或者是外部的脉冲信号对寄存器中的数据加 1。</p><p>有了定时器/计数器之后， 可以增加单片机的效率， 一些简单的重复加 1 的工作可以交给定时器/计数器处理。 CPU 转而处理一些复杂的事情。 同时可以实现精确定时作用。</p><h5 id="单片机定时器原理"><a href="#单片机定时器原理" class="headerlink" title="单片机定时器原理"></a>单片机定时器原理</h5><p>STC89C5X 单片机内有两个可编程的定时/计数器 T0、 T1 和一个特殊功能定时器 T2。 定时/计数器的实质是加 1 计数器（16 位） ， 由高 8 位和低 8 位两个寄存器 THx 和 TLx 组成。 它随着计数器的输入脉冲进行自加 1， 也就是每来一个脉冲， 计数器就自动加 1， 当加到计数器为全 1 时， 再输入一个脉冲就使计数器回零， 且计数器的溢出使相应的中断标志位置 1， 向 CPU 发出中断请求（定时/计数器中断允许时） 。 如果定时/计数器工作于定时模式， 则表示定时时间已到；如果工作于计数模式， 则表示计数值已满。 可见， 由溢出时计数器的值减去计数初值才是加 1 计数器的计数值。  </p><h5 id="单片机定时-计数器结构"><a href="#单片机定时-计数器结构" class="headerlink" title="单片机定时/计数器结构"></a>单片机定时/计数器结构</h5><p>51 单片机定时器/计数器内部结构如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103814517.png" alt="image-20230617103814517"></p><p>上图中的 T0 和 T1 引脚对应的是单片机 P3.4 和 P3.5 管脚。 51 单片机定时/计数器的工作由两个特殊功能寄存器控制。 TMOD 是定时/计数器的工作方式寄存器， 确定工作方式和功能； TCON 是控制寄存器， 控制 T0、 T1 的启动和停止及设置溢出标志。  </p><p>1， 工作方式寄存器</p><p> TMOD工作方式寄存器 TMOD 用于设置定时/计数器的工作方式， 低四位用于 T0， 高四位用于 T1。 其格式如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103832345.png" alt="image-20230617103832345"></p><p>GATE 是门控位, GATE＝0 时， 用于控制定时器的启动是否受外部中断源信号的影响。 只要用软件使 TCON 中的 TR0 或 TR1 为 1， 就可以启动定时/计数器工作； GATA＝1 时， 要用软件使 TR0 或 TR1 为 1， 同时外部中断引脚 INT0/1 也为高电平时， 才能启动定时/计数器工作。 即此时定时器的启动条件， 加上了 INT0/1 引脚为高电平这一条件。  </p><p>C/T :定时/计数模式选择位。 C/T ＝0 为定时模式;C/T =1 为计数模式。<br>M1M0： 工作方式设置位。 定时/计数器有四种工作方式。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103848616.png" alt="image-20230617103848616"></p><p>2， 控制寄存器 TCON</p><p>TCON 的低 4 位用于控制外部中断,已在前面介绍。 TCON 的高 4 位用于控制定时/计数器的启动和中断申请。 其格式如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617103905583.png" alt="image-20230617103905583"></p><p>TF1（TCON.7） ： T1 溢出中断请求标志位。 T1 计数溢出时由硬件自动置 TF1为 1。 CPU 响应中断后 TF1 由硬件自动清 0。 T1 工作时， CPU 可随时查询 TF1 的状态。 所以， TF1 可用作查询测试的标志。 TF1 也可以用软件置 1 或清 0， 同硬件置 1 或清 0 的效果一样。  </p><p>TR1（TCON.6） ： T1 运行控制位。 TR1 置 1 时， T1 开始工作； TR1 置 0 时， T1 停止工作。 TR1 由软件置 1 或清 0。 所以， 用软件可控制定时/计数器的启动与停止。  </p><p>TF0（TCON.5） ： T0 溢出中断请求标志位， 其功能与 TF1 类同。<br>TR0（TCON.4） ： T0 运行控制位， 其功能与 TR1 类同。</p><h5 id="单片机定时-计数器的工作方式"><a href="#单片机定时-计数器的工作方式" class="headerlink" title="单片机定时/计数器的工作方式"></a>单片机定时/计数器的工作方式</h5><p>1， 方式 0</p><p>方式 0 为 13 位计数， 由 TL0 的低 5 位（高 3 位未用） 和 TH0 的 8 位组成。TL0 的低 5 位溢出时向 TH0 进位， TH0 溢出时， 置位 TCON 中的 TF0 标志， 向 CPU发出中断请求。 其结构图如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104020088.png" alt="image-20230617104020088"></p><p>门控位 GATE 具有特殊的作用。当 GATE=0 时，经反相后使或门输出为 1，此时仅由 TR0 控制与门的开启，与门输出 1 时，控制开关接通，计数开始；当 GATE=1时，由外中断引脚信号控制或门的输出，此时控制与门的开启由外中断引脚信号和 TR0 共同控制。当 TR0=1 时，外中断引脚信号引脚的高电平启动计数， 外中断引脚信号引脚的低电平停止计数。这种方式常用来测量外中断引脚上正脉冲的宽度。 计数模式时， 计数脉冲是 T0 引脚上的外部脉冲。计数初值与计数个数的关系为：X=213-N。</p><p>2， 方式 1</p><p>方式 1 的计数位数是 16 位， 由 TL0 作为低 8 位， TH0 作为高 8 位， 组成了16 位加 1 计数器。 其结构图如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104116590.png" alt="image-20230617104116590"></p><p>计数初值与计数个数的关系为： X=216-N。  </p><p>3， 方式 2  </p><p>方式 2 为自动重装初值的 8 位计数方式。 工作方式 2 特别适合于用作较精确的脉冲信号发生器。 其结构图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104132606.png" alt="image-20230617104132606"></p><p>计数初值与计数个数的关系为： X=28-N。  </p><p>4， 方式 3  </p><p>方式 3 只适用于定时/计数器 T0， 定时器 T1 处于方式 3 时相当于 TR1=0，停止计数。 工作方式 3 将 T0 分成为两个独立的 8 位计数器 TL0 和 TH0。 其结构如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617104148487.png" alt="image-20230617104148487"></p><p>这几种工作方式中应用较多的是方式 1 和方式 2。 定时器中通常使用定时器方式 1， 串口通信中通常使用方式 2。  </p><h4 id="定时器配置"><a href="#定时器配置" class="headerlink" title="定时器配置"></a>定时器配置</h4><p>在使用定时器时， 应该如何配置使其工作？ 其步骤如下（ 各步骤顺序可任意） ：</p><p>①对 TMOD 赋值， 以确定 T0 和 T1 的工作方式， 如果使用定时器 0 即对 T0 配置， 如果使用定时器 1 即对 T1 配置。</p><p>②根据所要定时的时间计算初值,并将其写入 TH0、 TL0 或 TH1、 TL1。<br>③如果使用中断， 则对 EA 赋值， 开放定时器中断。<br>④使 TR0 或 TR1 置位， 启动定时/计数器定时或计数。</p><p>上述中有一个定时/计数器初值的计算， 下面我们来看下如何计算定时/计数器初值。  </p><p>前面我们介绍过机器周期的概念， 它是 CPU 完成一个基本操作所需要的时间。其计算公式是： 机器周期=1/单片机的时钟频率。 51 单片机内部时钟频率是外部时钟的 12 分频， 也就是说当外部晶振的频率输入到单片机里面的时候要进行 12分频。 比如说你用的是 12MHZ 晶振， 那么单片机内部的时钟频率就是 12/12MHZ，当你使用 12MHZ 的外部晶振的时候， 机器周期=1/1M=1us。 如果我们想定时 1ms的初值是多少呢？ 1ms/1us=1000。 也就是要计数 1000 个， 初值=65535-1000+1 （ 因为实际上计数器计数到 65536（ 2 的 16 次方） 才溢出， 所以后面要加 1） =64536=FC18H， 所以初值即为 THx=0XFC， TLx=0X18。  </p><p>知道了如何计算定时/计数器初值， 那么想定时多长时间都可以计算出， 当然由于定时计数器位数有限， 我们不可能直接通过初值定时很长时间， 如果要实现很长时间的定时， 比如定时 1 秒钟。 可以通过初值设置定时 1ms， 每当定时 1ms结束后又重新赋初值， 并且设定一个全局变量累计定时 1ms 的次数， 当累计到1000 次， 表示已经定时 1 秒了。 需要其他定时时间类似操作， 这样我们就可以使用定时器来实现精确延时来替代之前的 delay 函数。  </p><p>这里以定时器 0 为例介绍配置定时器工作方式 1、 设定 1ms 初值， 开启定时器计数功能以及总中断， 如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">TMOD|=<span class="number">0X01</span>;<span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">TL0=<span class="number">0X18</span>;</span><br><span class="line">ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于定时器 1 的使用方法是一样的， 只是将上述的 0 变为 1 即可， 具体可参考我们定时器 1 实验例程。  </p><h4 id="硬件设计-11"><a href="#硬件设计-11" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） LED 模块（D1）<br>（2） 定时器 0</p><p>本章硬件电路非常简单， 只使用到开发板上 LED 模块的 D1， 至于定时器 0它属于 51 单片机内部资源， 只需通过软件配置即可使用。 开发板上 LED 模块电路在前面已经介绍， 这里就不多说。  </p><h4 id="软件设计-11"><a href="#软件设计-11" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 通过定时器 0 中断控制 D1 指示灯间隔 1 秒闪烁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 定时器 0 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当按下 D1 指示灯间隔 1s 闪烁</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"><span class="comment">//定义 LED1 管脚</span></span><br><span class="line">sbit LED1=P2^<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : delay_10us</span></span><br><span class="line"><span class="comment">* 函数功能 : 延时函数， ten_us=1 时， 大约延时 10us</span></span><br><span class="line"><span class="comment">* 输 入 : ten_us</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_10us</span><span class="params">(u16 ten_us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(ten_us--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : time0_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 定时器 0 中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X01</span>;<span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">    TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">    TL0=<span class="number">0X18</span>;</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    time0_init();<span class="comment">//定时器 0 中断配置</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">time0</span><span class="params">()</span> interrupt 1 <span class="comment">//定时器 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">static</span> u16 i;<span class="comment">//定义静态变量 i</span></span><br><span class="line">     TH0=<span class="number">0XFC</span>; <span class="comment">//给定时器赋初值， 定时 1ms</span></span><br><span class="line">     TL0=<span class="number">0X18</span>;</span><br><span class="line">     i++;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       i=<span class="number">0</span>;</span><br><span class="line">       LED1=!LED1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实验代码非常简单， 首先定义 LED1 指示灯控制管脚， 然后定义定时器 0 中断配置函数 time0_init， 该函数配置内容就是按照前面介绍的配置方法所写，即选择定时器工作模式 0、 工作方式 1、 设置定时 1ms 初值、 打开定时器计数功能和开启总中断功能。 然后进入 while 循环， 在循环体内没有执行任何功能程序。当定时时间到达即会进入定时器 0 中断， 在中断服务函数内， 重新赋初值准备下次计数， 并且定义一个静态变量来累计定时 1ms 次数， 当变量等于 1000 时， 表示定时时间达 1 秒， 然后清零变量以及控制 LED 状态翻转。 执行完成后退出中断返回主函数， 当时间到达又进入中断， 如此循环  </p><p><code>为什么要使用关键字 static 将 i 定义为静态变量呢？ 我们希望每次进入中断函数时， i 保存的是上次累加值， 使用了 static 关键字， 就可以让变量 i 实现这种功能， 即不会每次进入中断函数后被初始化为 0。 假如去掉 static 关键字， 那么变量 i 就是一个局部变量， 每次进入中断函数后， 变量 i 初始值都是 0，也就是说它的值永远也不会递增到 1000， 从而实现不了 1s 定时。 可以这样理解，使用了 static 关键字就相当于将 i 变成了一个全局变量功能</code></p><p>对于定时器 1 的使用方法是一样的， 只是将上述的 0 变为 1 即可， 具体可参考我们定时器 1 实验例程。  </p><h4 id="实验现象-7"><a href="#实验现象-7" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当 D1 指示灯间隔 1s闪烁。  </p><p>注意： 实验中我们是以 12M 晶振为例讲解初值的计算， 假如外部晶振为11.0592M， 那么使用前面的计算公式可能就比较繁琐， 这里给大家推荐一个非常好用的小工具“\5—开发工具\4-常用辅助开发软件\51 定时器计算.exe” ， 打开小工具， 选择好定时器工作方式、 晶振频率、 定时时长即可得出 TH 和 TL 的初值。 假如现在使用的晶振是 11.0592M， 使用定时器方式 1， 定时时间为 1ms， 设置界面如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617105403054.png" alt="image-20230617105403054"></p><p>定时器初值为 TH0=0XFC， TL0=0X66。 该值与前面 12M 晶振得到的初值是有差别的， 这也就是很多同学咨询为什么开发板上定时器工作慢或者快的原因， 一定要注意开发板上使用的外部晶振大小， 晶振大小不同， 换算的初值是不一样的。  </p><h3 id="串口通信实验"><a href="#串口通信实验" class="headerlink" title="串口通信实验"></a>串口通信实验</h3><h4 id="通信的基本概念"><a href="#通信的基本概念" class="headerlink" title="通信的基本概念"></a>通信的基本概念</h4><p>我们知道 51 单片机不仅可以实现串口通信， 还可以通过 IO 口模拟实现多种其他通信， 比如 SPI、 IIC 等， 学习这些通信前， 我们很有必要了解下通信的基本概念。 通信的方式可以分为多种， 按照数据传送方式可分为串行通信和并行通信。 按照通信的数据同步方式， 可分为异同通信和同步通信。 按照数据的传输方向又可分为单工、 半双工和全双工通信。 下面我们就来简单介绍这几种通信方式。  </p><h5 id="串行通信与并行通信"><a href="#串行通信与并行通信" class="headerlink" title="串行通信与并行通信"></a>串行通信与并行通信</h5><p>（1） 串行通信</p><p>串行通信是指使用一条数据线， 将数据一位一位地依次传输， 每一位数据占据一个固定的时间长度。 其只需要少数几条线就可以在系统间交换信息， 特别适用于计算机与计算机、 计算机与外设之间的远距离通信。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210128564.png" alt="image-20230617210128564"></p><p>串行通信的特点： 传输线少， 长距离传送时成本低， 且可以利用电话网等现成的设备， 但数据的传送控制比并行通信复杂。  </p><p>（2） 并行通信</p><p>并行通信通常是将数据字节的各位用多条数据线同时进行传送， 通常是 8位、 16 位、 32 位等数据一起传输。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210153647.png" alt="image-20230617210153647"></p><p>并行通信的特点： 控制简单、 传输速度快； 由于传输线较多， 长距离传送时成本高且接收方的各位同时接收存在困难， 抗干扰能力差。  </p><h5 id="异步通信与同步通信"><a href="#异步通信与同步通信" class="headerlink" title="异步通信与同步通信"></a>异步通信与同步通信</h5><p>1） 异步通信</p><p>异步通信是指通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程。 为使双方的收发协调， 要求发送和接收设备的时钟尽可能一致。</p><p>异步通信是以字符（构成的帧） 为单位进行传输， 字符与字符之间的间隙（时间间隔） 是任意的， 但每个字符中的各位是以固定的时间传送的， 即字符之间不一定有“位间隔” 的整数倍的关系， 但同一字符内的各位之间的距离均为“ 位间隔” 的整数倍。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210350742.png" alt="image-20230617210350742"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210353671.png" alt="image-20230617210353671"></p><p>异步通信的特点： 不要求收发双方时钟的严格一致， 实现容易， 设备开销较小， 但每个字符要附加 2～3 位用于起止位， 各帧之间还有间隔， 因此传输效率不高。  </p><p>（2） 同步通信  </p><p>同步通信时要建立发送方时钟对接收方时钟的直接控制， 使双方达到完全同步。 此时， 传输数据的位之间的距离均为“位间隔” 的整数倍， 同时传送的字符间不留间隙， 即保持位同步关系， 也保持字符同步关系。 发送方对接收方的同步可以通过两种方法实现。 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210501026.png" alt="image-20230617210501026"></p><h5 id="单工、半双工与全双工"><a href="#单工、半双工与全双工" class="headerlink" title="单工、半双工与全双工"></a>单工、半双工与全双工</h5><p>（1） 单工通信</p><p>单工是指数据传输仅能沿一个方向， 不能实现反向传输。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210539846.png" alt="image-20230617210539846"></p><p>（2） 半双工通信</p><p>半双工是指数据传输可以沿两个方向， 但需要分时进行。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210623643.png" alt="image-20230617210623643"></p><p>（3） 全双工通信全双工是指数据可以同时进行双向传输。 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617210646678.png" alt="image-20230617210646678"></p><h5 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h5><p>衡量通信性能的一个非常重要的参数就是通信速率， 通常以比特率(Bitrate)  来表示。 比特率是每秒钟传输二进制代码的位数， 单位是： 位／ 秒（ bps） 。 如每秒钟传送 240 个字符， 而每个字符格式包含 10 位(1 个起始位、 1 个停止位、8 个数据位)， 这时的比特率为：  </p><p>​                            10 位× 240 个/秒 = 2400 bps  </p><p>在后面会遇到一个“波特率” 的概念， 它表示每秒钟传输了多少个码元。 而码元是通信信号调制的概念， 通信中常用时间间隔相同的符号来表示一个二进制数字， 这样的信号称为码元。 如常见的通信传输中， 用 0V 表示数字 0， 5V 表示数字 1， 那么一个码元可以表示两种状态 0 和 1， 所以一个码元等于一个二进制比特位， 此时波特率的大小与比特率一致； 如果在通信传输中， 有 0V、 2V、4V 以及 6V 分别表示二进制数 00、 01、 10、 11， 那么每个码元可以表示四种状态， 即两个二进制比特位， 所以码元数是二进制比特位数的一半， 这个时候的波特率为比特率的一半。 由于很多常见的通信中一个码元都是表示两种状态，所以我们常常直接以波特率来表示比特率。  </p><h4 id="单片机串口介绍"><a href="#单片机串口介绍" class="headerlink" title="单片机串口介绍"></a>单片机串口介绍</h4><h5 id="串口通信简介"><a href="#串口通信简介" class="headerlink" title="串口通信简介"></a>串口通信简介</h5><p>串口通信(Serial Communication)， 是指外设和计算机间通过数据信号线、地线等按位进行传输数据的一种通信方式， 属于串行通信方式。 串口是一种接口标准， 它规定了接口的电气标准， 没有规定接口插件电缆以及使用的协议。  </p><p>(1)接口标准</p><p>串口通信的接口标准有很多， 有 RS-232C、 RS-232、 RS-422A、 RS-485 等。常用的是 RS-232 和 RS-485。 RS-232 其实是 RS-232C 的改进， 原理是一样的。这里我们就以 RS-232C 接口进行讲解。  </p><p>RS-232C 是 EIA（美国电子工业协会） 1969 年修订 RS-232C 标准。 RS-232C定义了数据终端设备（DTE） 与数据通信设备（DCE） 之间的物理接口标准。  </p><p>RS-232C 接口规定使用 25 针连接器， 简称 DB25， 连接器的尺寸及每个插针的排列位置都有明确的定义， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211033056.png" alt="image-20230617211033056"></p><p>RS-232C 还有一种 9 针的非标准连接器接口， 简称 DB9。 串口通信使用的大多都是 DB9 接口。 DB25 和 DB9 接头有公头和母头之分， 其中带针状的接头是公头， 而带孔状的接头是母头。 9 针串口线的外观图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211044935.png" alt="image-20230617211044935"></p><p>从上图中可以看到公头和母头的管脚定义顺序是不一样， 这一点需要特别注意。 这些管脚都有什么作用呢？ 9 针串口和 25 针串口常用管脚的功能说明如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211435725.png" alt="image-20230617211435725"></p><p>在串口通信中， 通常我们只使用 2、 3、 5 三个管脚， 即 TXD、 RXD、 SGND，其他管脚功能大家看不明白也没关系。  </p><p>RS-232C 对逻辑电平也做了规定， 如下：<br>在 TXD 和 RXD 数据线上：<br>1.逻辑 1 为-3~-15V 的电压</p><p>2.逻辑 0 为 3~15V 的电压<br>在 RTS、 CTS、 DSR、 DTR 和 DCD 等控制线上：<br>1.信号有效（ ON 状态） 为 3~15V 的电压<br>2.信号无效（ OFF 状态） 为-3~-15V 的电压</p><p>由此可见， RS-232C 是用正负电压来表示逻辑状态， 与晶体管-晶体管逻辑集成电路（TTL） 以高低电平表示逻辑状态的规定正好相反。 而我们 51 单片机使用的就是 TTL 电平， 所以要实现 51 单片机与计算机的串口通信， 需要进行 TTL与 RS-232C 电平转换， 通常使用的电平转换芯片是 MAX232。  </p><p>在串口通信中通常 PC 机的 DB9 为公头， 单片机上使用的串口 DB9 为母头，通过一根直通串口线进行相连。 在 9 针串口线实物图即为直通型串口线， 串口线（COM） 母头连接计算机 DB9 的公头， 串口线公头连接单片机上使用的 DB9 母头， 这样就是将 2、 3、 5 管脚直接相连。 如果你要实现两台计算机串口通信，那么就需要一根交叉串口线， 将 2 对 3、 3 对 2、 5 对 5 连接， 交叉串口线一般两头都是母头。  </p><p>串口通信中还需要注意的是， 串口数据收发线要交叉连接， 计算机的 TXD要对应单片机的 RXD， 计算机的 RXD 要对应单片机的 TXD， 并且共 GND， 如下图  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211528273.png" alt="image-20230617211528273"></p><p>有的朋友就会问了， 在计算机与单片机进行串口通信时， 使用的不是直通线吗， 这时候怎么让 TXD 与 RXD 交叉连接？ 前面我们说了单片机处理的是 TTL电平， 需要使用 RS232 电平转换芯片， 将 RS232 电平转换芯片串行数据输出管脚交叉连接在 DB9 母头上即可， 本章后面硬件设计部分会介绍。  </p><p>（2） 通信协议  </p><p>RS232 的通信协议比较简单， 通常遵循 96-N-8-1 格式。</p><p>“96” 表示的是通信波特率为 9600。 串口通信中通常使用的是异步串口通信， 即没有时钟线， 所以两个设备要通信， 必须要保持一致的波特率， 当然， 波特率常用值还有 4800、 115200 等。</p><p>“N” 表示的是无校验位， 由于串口通信相对更容易受到外部干扰导致传输数据出现偏差， 可以在传输过程加上校验位来解决这个问题。 校验方法有奇校验(odd)、 偶校验(even)、 0 校验(space)、 1 校验(mark)以及无校验(noparity)。具体的介绍， 大家可以百度串口通信了解。  </p><p>“8”表示的是数据位数为 8 位， 其数据格式在前面介绍异步通信中已讲过。当然数据位数还可以为 5、 6、 7 位长度。  </p><p>“1” 表示的是 1 位停止位， 串口通讯的一个数据包从起始信号开始， 直到停止信号结束。 数据包的起始信号由一个逻辑 0 的数据位表示， 而数据包的停止信号可由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示， 只要双方约定一致即可  </p><p>（3） 串口内部结构  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211623164.png" alt="image-20230617211623164"></p><p>上图中右边的 TXD 和 RXD 为单片机 IO 口， TXD 对应的是 P3.1 管脚， RXD 对应的是 P3.0 管脚。 其内部工作方式在后面小节会介绍。  </p><h5 id="串口相关寄存器"><a href="#串口相关寄存器" class="headerlink" title="串口相关寄存器"></a>串口相关寄存器</h5><p>（1） 串口控制寄存器 SCON  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211703180.png" alt="image-20230617211703180"></p><p>SM0 和 SM1 为工作方式选择位：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211710640.png" alt="image-20230617211710640"></p><p>SM2： 多机通信控制位， 主要用于方式 2 和方式 3。 当 SM2=1 时可以利用收到的 RB8 来控制是否激活 RI（RB8＝0 时不激活 RI， 收到的信息丢弃； RB8＝1 时收到的数据进入 SBUF， 并激活 RI， 进而在中断服务中将数据从 SBUF 读走） 。 当SM2=0 时， 不论收到的 RB8 为 0 和 1， 均可以使收到的数据进入 SBUF， 并激活 RI （即此时 RB8 不具有控制 RI 激活的功能） 。 通过控制 SM2， 可以实现多机通信。  </p><p>REN： 允许串行接收位。 由软件置 REN=1， 则启动串行口接收数据； 若软件置REN=0， 则禁止接收。  </p><p>TB8： 在方式 2 或方式 3 中， 是发送数据的第 9 位， 可以用软件规定其作用。可以用作数据的奇偶校验位， 或在多机通信中， 作为地址帧/数据帧的标志位。在方式 0 和方式 1 中， 该位未用到。  </p><p>RB8： 在方式 2 或方式 3 中， 是接收到数据的第 9 位， 作为奇偶校验位或地址帧/数据帧的标志位。 在方式 1 时， 若 SM2=0， 则 RB8 是接收到的停止位。  </p><p>TI： 发送中断标志位。 在方式 0 时， 当串行发送第 8 位数据结束时， 或在其它方式， 串行发送停止位的开始时， 由内部硬件使 TI 置 1， 向 CPU 发中断申请。在中断服务程序中， 必须用软件将其清 0， 取消此中断申请。  </p><p>RI： 接收中断标志位。 在方式 0 时， 当串行接收第 8 位数据结束时， 或在其它方式， 串行接收停止位的中间时， 由内部硬件使 RI 置 1， 向 CPU 发中断申请。也必须在中断服务程序中， 用软件将其清 0， 取消此中断申请。  </p><p>（2） 电源控制寄存器 PCON  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211742829.png" alt="image-20230617211742829"></p><p>SMOD： 波特率倍增位。 在串口方式 1、 方式 2、 方式 3 时， 波特率与 SMOD 有关， 当 SMOD=1 时， 波特率提高一倍。 复位时， SMOD=0。  </p><h4 id="串口工作方式"><a href="#串口工作方式" class="headerlink" title="串口工作方式"></a>串口工作方式</h4><p>前面在介绍寄存器时已经知道了 51 单片机串口的几种工作方式， 下面分别来对它介绍。  </p><h5 id="方式0"><a href="#方式0" class="headerlink" title="方式0"></a>方式0</h5><p>方式 0 时， 串行口为同步移位寄存器的输入输出方式。 主要用于扩展并行输入或输出口。 数据由 RXD（P3.0） 引脚输入或输出， 同步移位脉冲由 TXD（P3.1）引脚输出。 发送和接收均为 8 位数据， 低位在先， 高位在后。 波特率固定为fosc/12。 对应的输入输出时序图如下所示：  </p><p>①方式 0 输出  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211846944.png" alt="image-20230617211846944"></p><p>②方式 0 输入  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211900975.png" alt="image-20230617211900975"></p><h5 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h5><p>方式 1 是 10 位数据的异步通信口。 TXD 为数据发送引脚， RXD 为数据接收引脚， 传送一帧数据的格式如下所示。 其中 1 位起始位， 8 位数据位， 1 位停止位。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211929371.png" alt="image-20230617211929371"></p><p>对应的输入输出时序图如下所示：<br>①方式 1 输出</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211947725.png" alt="image-20230617211947725"></p><p>②方式 1 输入  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617211954248.png" alt="image-20230617211954248"></p><p>用软件置 REN 为 1 时， 接收器以所选择波特率的 16 倍速率采样 RXD 引脚电平， 检测到 RXD 引脚输入电平发生负跳变时， 则说明起始位有效， 将其移入输入移位寄存器， 并开始接收这一帧信息的其余位。 接收过程中， 数据从输入移位寄存器右边移入， 起始位移至输入移位寄存器最左边时， 控制电路进行最后一次移位。 当 RI=0， 且 SM2=0（或接收到的停止位为 1） 时， 将接收到的 9 位数据的前8 位数据装入接收 SBUF， 第 9 位（停止位） 进入 RB8， 并置 RI=1， 向 CPU 请求中断。  </p><h5 id="方式2和方式3"><a href="#方式2和方式3" class="headerlink" title="方式2和方式3"></a>方式2和方式3</h5><p>方式 2 或方式 3 时为 11 位数据的异步通信口。 TXD 为数据发送引脚， RXD 为数据接收引脚。 其数据格式如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212026404.png" alt="image-20230617212026404"></p><p>对应的输入输出时序图如下所示：<br>①方式 2、 方式 3 输出</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212038037.png" alt="image-20230617212038037"></p><p>发送开始时， 先把起始位 0 输出到 TXD 引脚， 然后发送移位寄存器的输出位（D0） 到 TXD 引脚。 每一个移位脉冲都使输出移位寄存器的各位右移一位， 并由TXD 引脚输出。 第一次移位时， 停止位“1” 移入输出移位寄存器的第 9 位上，以后每次移位， 左边都移入 0。 当停止位移至输出位时， 左边其余位全为 0， 检测电路检测到这一条件时， 使控制电路进行最后一次移位， 并置 TI=1， 向 CPU请求中断。  </p><p>②方式 2、 方式 3 输入  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212048439.png" alt="image-20230617212048439"></p><p>接收时， 数据从右边移入输入移位寄存器， 在起始位 0 移到最左边时， 控制电路进行最后一次移位。 当 RI=0， 且 SM2=0（或接收到的第 9 位数据为 1） 时，接收到的数据装入接收缓冲器 SBUF 和 RB8（接收数据的第 9 位） ， 置 RI=1， 向CPU 请求中断。 如果条件不满足， 则数据丢失， 且不置位 RI， 继续搜索 RXD 引脚的负跳变。  </p><h4 id="串口的使用方法"><a href="#串口的使用方法" class="headerlink" title="串口的使用方法"></a>串口的使用方法</h4><h5 id="如何计算波特率"><a href="#如何计算波特率" class="headerlink" title="如何计算波特率"></a>如何计算波特率</h5><p>方式 0 的波特率 = fosc/12<br>方式 2 的波特率 =（2SMOD/64） · fosc<br>方式 1 的波特率 =（2SMOD/32） · （T1 溢出率）<br>方式 3 的波特率 =（2SMOD/32） · （T1 溢出率）</p><p>其中 T1 溢出率 = fosc /{12× [256 －（TH1） ] }， 当然还可以使用资料“\5—开发工具\4-常用辅助开发软件\51 波特率初值设定.exe” 内附带的小工具自动生成波特率。 其使用方法如下：<br>①双击打开该工具， 其界面如下</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212330027.png" alt="image-20230617212330027"></p><p>②选择定时器工作方式， 输入开发板上使用的晶振频率大小， 选择所要使用的波特率， SMOD 为是否倍频， 这个在前面介绍寄存器时说过， 下面的误差大小可以反映出通信时是否出现乱码。 在使用串口通信时， 定时器 1 工作方式为 2，串口工作方式为 1， 以开发板晶振是 11.0592Mh 为例， 假如晶振频率是 12M， 那么在生成的波特率就会有误差而导致通信出错。 为什么替换可以从误差值反映出来。 在本章实验中波特率选择 9600， 使用 SMOD， 即值为 1， 点击确定后即会自动生成定时/计数器 THx 的值， 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212402571.png" alt="image-20230617212402571"></p><p>从上图可知， 使用 11.0592M 晶振时， 误差为 0。 我们对比下当外部晶振使用12Mh 时， 波特率误差多大， 如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617212412528.png" alt="image-20230617212412528"></p><p>从上图可知， 当使用 12M 晶振时， 波特率误差有 6.98%， 是比较大的， 会导致在通信过程中出现乱码等错误信息。 这是我们不希望看到的， 所以再次说明下，==在做串口通信实验时， 一定要确认外部晶振是否是 11.0592M==。</p><p>对于波特率的计算方法大家要知道， 开发中建议大家使用小工具， 它会给你带来很多便利。  </p><h5 id="串口初始化步骤"><a href="#串口初始化步骤" class="headerlink" title="串口初始化步骤"></a>串口初始化步骤</h5><p>如何使用串口， 大家可以按照以下几个步骤配置。<br>①确定 T1 的工作方式（TMOD 寄存器） ；<br>②确定串口工作方式（SCON 寄存器） ；<br>③计算 T1 的初值（设定波特率） ， 装载 TH1、 TL1；<br>④启动 T1（TCON 中的 TR1 位） ；<br>⑤如果使用中断， 需开启串口中断控制位（IE 寄存器） 。</p><p>例如： 设置串口为工作方式 1、 波特率为 9600、 波特率加倍、 使用中断。 其配置程序如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : uart_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 串口通信中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : baud： 波特率对应的 TH、 TL 装载值</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">    TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">    TL1=baud;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在主函数中调用该函数并传入 OXFA 值即可， 如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br></pre></td></tr></table></figure><h4 id="硬件设计-12"><a href="#硬件设计-12" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>开发板上板载一个 USB 转串口模块。 其硬件电路如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213027782.png" alt="image-20230617213027782"></p><p>从上图中可以看出， 通过 CH340 芯片把 51 单片机的串口与 PC 机的 USB 口进行连接， 不仅可以实现程序的烧入， 还可实现串口通信功能。 根据前面介绍，串口通信需将数据收发管脚交叉连接， 所以可以看到在 CH340 芯片的 2 和 3 脚已做处理。 电路中其他部分是自动下载电路部分， 目的是控制单片机的电源， 无需冷启动。 使用 USB 转串口芯片， 免去了一根串口线， 使用普通 USB 数据线（支持安卓手机数据线） 就可以进行串口通信。  </p><p>从上图中可以看到 CH340 的 2、 3 脚串口并非直接连接到单片机串口， 而是连接在 P5 端子上， 这样就把 CH340 的串口与单片机串口独立出来， 为什么不直接连接而要使用这个 P5 端子呢？ 这是方便用户可以使用开发板上的 USB 转 TTL模块（也就是 CH340 转串口模块） 做一些串口类模块的调试， 比如： WIFI、 蓝牙、GPS、 GPRS 等， 直接利用 PC 上位机来调试模块。 同时也方便用户使用板载 USB转 TTL 模块给其它类型单片机下载程序  </p><p>如果使用黄色跳线帽将 P5 端子的 1、 2 短接， 3、 4 短接， 那么 CH340 串口与单片机串口是连接一起的， 此时即可实现程序的下载或串口通信。  </p><h4 id="软件设计-12"><a href="#软件设计-12" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 串口通信实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示</span></span><br><span class="line"><span class="comment">注意事项： 使用黄色跳线帽将 CH340 旁的 P5 端子的 UTX 和 P30 短接， URX 和 P31 短接， 出厂默认已短接好</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16;<span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : uart_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 串口通信中断配置函数， 通过设置 TH 和 TL 即可确定定时时间</span></span><br><span class="line"><span class="comment">* 输 入 : baud： 波特率对应的 TH、 TL 装载值</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(u8 baud)</span></span><br><span class="line">&#123;</span><br><span class="line">    TMOD|=<span class="number">0X20</span>; <span class="comment">//设置计数器工作方式 2</span></span><br><span class="line">    SCON=<span class="number">0X50</span>; <span class="comment">//设置为工作方式 1</span></span><br><span class="line">    PCON=<span class="number">0X80</span>; <span class="comment">//波特率加倍</span></span><br><span class="line">    TH1=baud; <span class="comment">//计数器初始值设置</span></span><br><span class="line">    TL1=baud;</span><br><span class="line">    ES=<span class="number">1</span>; <span class="comment">//打开接收中断</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    TR1=<span class="number">1</span>; <span class="comment">//打开计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   uart_init(<span class="number">0XFA</span>);<span class="comment">//波特率为 9600</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123; </span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">uart</span><span class="params">()</span> interrupt 4 <span class="comment">//串口通信中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 rec_data;</span><br><span class="line">    RI = <span class="number">0</span>; <span class="comment">//清除接收中断标志位</span></span><br><span class="line">    rec_data=SBUF; <span class="comment">//存储接收到的数据</span></span><br><span class="line">    SBUF=rec_data; <span class="comment">//将接收到的数据放入到发送寄存器</span></span><br><span class="line">    <span class="keyword">while</span>(!TI); <span class="comment">//等待发送数据完成</span></span><br><span class="line">    TI=<span class="number">0</span>; <span class="comment">//清除发送完成标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实验代码比较简单， 首先定义了串口通信中断配置函数 uart_init， 该函数有一个入口参数 baud， 该值可改变通信波特率。 该函数的实现即是按照前面介绍的串口配置步骤。 最后进入 while 循环， 在循环体内不执行任何功能程序。 如果发生接收中断， 即会进入串口中断执行， 执行完后回到主函数内继续运行， 如此循环。  </p><h4 id="实验现象-8"><a href="#实验现象-8" class="headerlink" title="实验现象"></a>实验现象</h4><p>  使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 当串口助手发送数据给单片机， 单片机原封不动转发给串口助手显示。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213721647.png" alt="image-20230617213721647"></p><p>注意： 使用黄色跳线帽将 CH340 旁的 P5 端子的 UTX 和 P30 短接， URX 和 P31短接， 出厂默认已短接好。 如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230617213743554.png" alt="image-20230617213743554"></p><h3 id="I2C-EEPROM-实验"><a href="#I2C-EEPROM-实验" class="headerlink" title="I2C-EEPROM 实验"></a>I2C-EEPROM 实验</h3><p>这一章我们来学习如何使用 51 单片机的 IO 口模拟 I2C 时序， 并实现与AT24C02（EEPROM） 之间的双向通信。 开发板板载了 1 个 EEPROM 模块， 可实现IIC 通信。 本章要实现的功能是： 系统运行时， 数码管右 3 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加 1， 按 K4 键显示数据清零， 最大能写入的数据是 255。   </p><h4 id="I2C介绍"><a href="#I2C介绍" class="headerlink" title="I2C介绍"></a>I2C介绍</h4><p>I2C（Inter－Integrated Circuit） 总线是由 PHILIPS 公司开发的两线式串行总线， 用于连接微控制器及其外围设备。 是微电子通信控制领域广泛采用的一种总线标准。 它是同步通信的一种特殊形式， 具有接口线少， 控制方式简单，器件封装形式小， 通信速率较高等优点。 I2C 总线只有两根双向信号线。 一根是数据线 SDA， 另一根是时钟线 SCL。 由于其管脚少， 硬件实现简单， 可扩展性强等特点， 因此被广泛的使用在各大集成芯片内。 下面我们就从 I2C 的物理层与协议层来了解 I2C。  </p><h4 id="I2C物理层"><a href="#I2C物理层" class="headerlink" title="I2C物理层"></a>I2C物理层</h4><p>I2C 通信设备常用的连接方式如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618095935286.png" alt="image-20230618095935286"></p><p>它的物理层有如下特点：（1） 它是一个支持多设备的总线。 “总线” 指多个设备共用的信号线。 在一个 I2C 通讯总线中， 可连接多个 I2C 通讯设备， 支持多个通讯主机及多个通讯从机。</p><p>（2） 一个 I2C 总线只使用两条总线线路， 一条双向串行数据线(SDA)， 一条串行时钟线(SCL)。 数据线即用来表示数据， 时钟线用于数据收发同步。</p><p>（3） 每个连接到总线的设备都有一个独立的地址， 主机可以利用这个地址进行不同设备之间的访问。</p><p>（4） 总线通过上拉电阻接到电源。 当 I2C 设备空闲时， 会输出高阻态， 而当所有设备都空闲， 都输出高阻态时， 由上拉电阻把总线拉成高电平。</p><p>（5） 多个主机同时使用总线时， 为了防止数据冲突， 会利用仲裁方式决定由哪个设备占用总线。</p><p>（ 6） 具有三种传输模式： 标准模式传输速率为 100kbit/s， 快速模式为400kbit/s， 高速模式下可达 3.4Mbit/s， 但目前大多 I2C 设备尚不支持高速模式。</p><p>（7） 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。</p><p>下面我们来了解下 I2C 总线常用的一些术语：<br>主机： 启动数据传送并产生时钟信号的设备；<br>从机： 被主机寻址的器件；<br>多主机： 同时有多于一个主机尝试控制总线但不破坏传输；<br>主模式： 用 I2CNDAT 支持自动字节计数的模式； 位 I2CRM,I2CSTT,I2CSTP控制数据的接收和发送；<br>从模式： 发送和接收操作都是由 I2C 模块自动控制的；<br>仲裁： 是一个在有多个主机同时尝试控制总线但只允许其中一个控制总线并使传输不被破坏的过程；<br>同步： 两个或多个器件同步时钟信号的过程；<br>发送器： 发送数据到总线的器件；<br>接收器： 从总线接收数据的器件。</p><h4 id="I2C协议层"><a href="#I2C协议层" class="headerlink" title="I2C协议层"></a>I2C协议层</h4><p>I2C 的协议定义了通信的起始和停止信号、 数据有效性、 响应、 仲裁、 时钟同步和地址广播等环节。 下面我们就来简单介绍下。  </p><p>（1） 数据有效性规定  </p><p>I2C 总线进行数据传送时， 时钟信号为高电平期间， 数据线上的数据必须保持稳定， 只有在时钟线上的信号为低电平期间， 数据线上的高电平或低电平状态才允许变化。 如下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100322562.png" alt="image-20230618100322562"></p><p>每次数据传输都以字节为单位， 每次传输的字节数不受限制。  </p><p>（2） 起始和停止信号  </p><p>SCL 线为高电平期间， SDA 线由高电平向低电平的变化表示起始信号； SCL线为高电平期间， SDA 线由低电平向高电平的变化表示终止信号。 如下图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100338176.png" alt="image-20230618100338176"></p><p>起始和终止信号都是由主机发出的， 在起始信号产生后， 总线就处于被占用的状态； 在终止信号产生后， 总线就处于空闲状态。  </p><p>（3） 应答响应  </p><p>每当发送器件传输完一个字节的数据后， 后面必须紧跟一个校验位， 这个校验位是接收端通过控制 SDA（数据线） 来实现的， 以提醒发送端数据我这边已经接收完成， 数据传送可以继续进行。 这个校验位其实就是数据或地址传输过程中的响应。 响应包括“应答(ACK)” 和“非应答(NACK)” 两种信号。 作为数据接收端时， 当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后， 若希望对方继续发送数据， 则需要向对方发送“应答(ACK)” 信号即特定的低电平脉冲，发送方会继续发送下一个数据； 若接收端希望结束数据传输， 则向对方发送“非应答(NACK)” 信号即特定的高电平脉冲， 发送方接收到该信号后会产生一个停止信号， 结束信号传输。 应答响应时序图如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100351714.png" alt="image-20230618100351714"></p><p>每一个字节必须保证是 8 位长度。 ==数据传送时，先传送最高位（MSB），每一个被传送的字节后面都必须跟随一位应答位（即一帧共有 9 位）==。  </p><p>由于某种原因从机不对主机寻址信号应答时（如从机正在进行实时性的处理工作而无法接收总线上的数据） ， 它必须将数据线置于高电平， 而由主机产生一个终止信号以结束总线的数据传送。  </p><p>如果从机对主机进行了应答， 但在数据传送一段时间后无法继续接收更多的数据时， 从机可以通过对无法接收的第一个数据字节的“非应答” 通知主机， 主机则应发出终止信号以结束数据的继续传送。  </p><p>当主机接收数据时， 它收到最后一个数据字节后， 必须向从机发出一个结束传送的信号。 这个信号是由对从机的“非应答” 来实现的。 然后， 从机释放 SDA线， 以允许主机产生终止信号。  </p><p>这些信号中， 起始信号是必需的， 结束信号和应答信号都可以不要。  </p><p>（4） 总线的寻址方式  </p><p>I2C 总线寻址按照从机地址位数可分为两种， 一种是 7 位， 另一种是 10位。 采用 7 位的寻址字节（寻址字节是起始信号后的第一个字节） 的位定义如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100501806.png" alt="image-20230618100501806"></p><p>D7～D1 位组成从机的地址。 D0 位是数据传送方向位， 为“ 0” 时表示主机向从机写数据， 为“1” 时表示主机由从机读数据。  </p><p>10 位寻址和 7 位寻址兼容， 而且可以结合使用。 10 位寻址不会影响已有的 7 位寻址， 有 7 位和 10 位地址的器件可以连接到相同的 I2C 总线。 我们就以 7 位寻址为例进行介绍。  </p><p>当主机发送了一个地址后， 总线上的每个器件都将头 7 位与它自己的地址比较， 如果一样， 器件会判定它被主机寻址， 其他地址不同的器件将被忽略后面的数据信号。 至于是从机接收器还是从机发送器， 都由 R/W 位决定的。 从机的地址由固定部分和可编程部分组成。 在一个系统中可能希望接入多个相同的从机， 从机地址中可编程部分决定了可接入总线该类器件的最大数目。 如一个从机的 7 位寻址位有 4 位是固定位， 3 位是可编程位， 这时仅能寻址 8 个同样的器件， 即可以有 8 个同样的器件接入到该 I2C 总线系统中。  </p><p>（5） 数据传输  </p><p>I2C 总线上传送的数据信号是广义的， 既包括地址信号， 又包括真正的数据信号。 在起始信号后必须传送一个从机的地址（7 位） ， 第 8 位是数据的传送方向位（R/W） ， 用“ 0” 表示主机发送（写） 数据（W） ， “ 1” 表示主机接收数据（R） 。 每次数据传送总是由主机产生的终止信号结束。 但是， 若主机希望继续占用总线进行新的数据传送， 则可以不产生终止信号， 马上再次发出起始信号对另一从机进行寻址。  </p><p>在总线的一次数据传送过程中， 可以有以下几种组合方式：<br>a、 主机向从机发送数据， 数据传送方向在整个传送过程中不变</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100530523.png" alt="image-20230618100530523"></p><p>注意： 有阴影部分表示数据由主机向从机传送， 无阴影部分则表示数据由从机向主机传送。 A 表示应答， A 非表示非应答（高电平） 。 S 表示起始信号， P 表示终止信号。  </p><p>b、 主机在第一个字节后， 立即从从机读数据  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100541210.png" alt="image-20230618100541210"></p><p>c、 在传送过程中， 当需要改变传送方向时， 起始信号和从机地址都被重复产生一次， 但两次读/写方向位正好相反  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100548070.png" alt="image-20230618100548070"></p><p>到这里我们就介绍完 I2C 总线， 由于 51 单片机没有硬件 IIC 接口， 即使有硬件接口我们通常还是采用软件模拟 I2C。 主要原因是硬件 IIC 设计的比较复杂， 而且稳定性不怎么好， 程序移植比较麻烦， 而用软件模拟 IIC， 最大的好处就是移植方便， 同一个代码兼容所有单片机， 任何一个单片机只要有 IO 口（不需要特定 IO） ， 都可以很快的移植过去。  </p><p>下面我们再来了解下开发板上的 AT24C02 芯片。  </p><h4 id="AT24C02-介绍"><a href="#AT24C02-介绍" class="headerlink" title="AT24C02 介绍"></a>AT24C02 介绍</h4><p>AT24C01/02/04/08/16…是一个 1K/2K/4K/8K/16K 位串行 CMOS， 内部含有128/256/512/1024/2048 个 8 位字节， AT24C01 有一个 8 字节页写缓冲器， AT24C02/04/08/16 有一个 16 字节页写缓冲器。 该器件通过 I2C 总线接口进行操作， 它有一个专门的写保护功能。 我们开发板上使用的是 AT24C02（EEPROM）芯片， 此芯片具有 I2C 通信接口， 芯片内保存的数据在掉电情况下都不丢失，所以通常用于存放一些比较重要的数据等。 AT24C02 芯片管脚及外观图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100619399.png" alt="image-20230618100619399"></p><p>芯片管脚说明如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100635643.png" alt="image-20230618100635643"></p><p>AT24C02 器件地址为 7 位， 高 4 位固定为 1010， 低 3 位由 A0/A1/A2 信号线的电平决定。 因为传输地址或数据是以字节为单位传送的， 当传送地址时，器件地址占 7 位， 还有最后一位（最低位 R/W） 用来选择读写方向， 它与地址无关。 其格式如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100725578.png" alt="image-20230618100725578"></p><p>我们开发板已经将芯片的 A0/A1/A2 连接到 GND， 所以器件地址为1010000， 即 0x50（未计算最低位） 。 如果要对芯片进行写操作时， R/W 即为 0，写器件地址即为 0XA0； 如果要对芯片进行读操作时， R/W 即为 1， 此时读器件地址为 0XA1。 开发板上也将 WP 引脚直接接在 GND 上， 此时芯片允许数据正常读写。</p><p>I2C 总线时序如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100737208.png" alt="image-20230618100737208"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100740278.png" alt="image-20230618100740278"></p><p>关于 AT24C02（EEPROM） 的更多信息， 可参考“\6—芯片资料\开发板芯片数据手册” 内 24C02 数据手册来了解。  </p><h4 id="硬件设计-13"><a href="#硬件设计-13" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 独立按键（K1-K4）<br>（2） 动态数码管<br>（3） EEPROM 模块电路（AT24C02）</p><p>独立按键和动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面我们来看下开发板上 EEPROM 模块电路， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618100805470.png" alt="image-20230618100805470"></p><p>从图中可以看出， 芯片的 SCL 和 SDA 管脚是连接在单片机的 P2.1 和 P2.0 上，在介绍 IIC 总线的时候我们说过， 为了让 IIC 总线默认为高电平， 通常会在 IIC总线上接上拉电阻， 在图中并没有看到 SCL 和 SDA 管脚有上拉电阻， 这是因为开发板单片机 IO 都外接了 10K 上拉电阻， 当单片机 IO 口连接到芯片的 SCL 和 SDA脚时即相当于它们外接上拉电阻， 所以此处可以省去。  </p><h4 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h4><p>本章所要实现的功能是： 系统运行时， 数码管右 3 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加1， 按 K4 键显示数据清零， 最大能写入的数据是 255。</p><p>程序框架如下：<br>（1） 编写按键检测功能<br>（2） 编写数码管显示功能<br>（3） 编写 IIC 驱动， 包括起始、 停止、 应答信号等<br>（4） 编写 AT24C02 读写功能<br>（5） 编写主函数</p><p>前面的实验章节都已编写过按键检测、 数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 I2C 时序的模拟及数据的读写上。这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p><p>按键检测函数  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg52.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> u16; <span class="comment">//对系统默认数据类型进行重定义</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> u8;</span><br><span class="line">    <span class="comment">//定义独立按键控制脚</span></span><br><span class="line">    sbit KEY1=P3^<span class="number">1</span>;</span><br><span class="line">    sbit KEY2=P3^<span class="number">0</span>;</span><br><span class="line">    sbit KEY3=P3^<span class="number">2</span>;</span><br><span class="line">    sbit KEY4=P3^<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//使用宏定义独立按键按下的键值</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY1_PRESS 1</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY2_PRESS 2</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY3_PRESS 3</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY4_PRESS 4</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> KEY_UNPRESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : key_scan</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测独立按键是否按下， 按下则返回对应键值</span></span><br><span class="line"><span class="comment">* 输 入 :     mode=0： 单次扫描按键</span></span><br><span class="line"><span class="comment">             mode=1： 连续扫描按键</span></span><br><span class="line"><span class="comment">* 输 出 :   KEY1_PRESS： K1 按下</span></span><br><span class="line"><span class="comment">            KEY2_PRESS： K2 按下</span></span><br><span class="line"><span class="comment">            KEY3_PRESS： K3 按下</span></span><br><span class="line"><span class="comment">            KEY4_PRESS： K4 按下</span></span><br><span class="line"><span class="comment">            KEY_UNPRESS： 未有按键按下</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line">u8 <span class="title function_">key_scan</span><span class="params">(u8 mode)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">static</span> u8 key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(mode)key=<span class="number">1</span>;<span class="comment">//连续扫描按键</span></span><br><span class="line">        <span class="keyword">if</span>(key==<span class="number">1</span>&amp;&amp;(KEY1==<span class="number">0</span>||KEY2==<span class="number">0</span>||KEY3==<span class="number">0</span>||KEY4==<span class="number">0</span>))<span class="comment">//任意按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">            delay_10us(<span class="number">1000</span>);<span class="comment">//消抖</span></span><br><span class="line">            key=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(KEY1==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY1_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY2==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY2_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY3==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY3_PRESS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(KEY4==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> KEY4_PRESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(KEY1==<span class="number">1</span>&amp;&amp;KEY2==<span class="number">1</span>&amp;&amp;KEY3==<span class="number">1</span>&amp;&amp;KEY4==<span class="number">1</span>) <span class="comment">//无按键按下</span></span><br><span class="line">    &#123;</span><br><span class="line">   key=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> KEY_UNPRESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码为按键检测函数， 调用此函数后若有按键按下， 会返回对应键值。该函数在前面独立按键实验章节已详细介绍， 此处不再重复。  </p><p>数码管显示函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="comment">//共阴极数码管显示 0~F 的段码数据</span></span><br><span class="line">u8 gsmg_code[<span class="number">17</span>]=&#123;<span class="number">0x3f</span>,<span class="number">0x06</span>,<span class="number">0x5b</span>,<span class="number">0x4f</span>,<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x7d</span>,<span class="number">0x07</span>,</span><br><span class="line">  <span class="number">0x7f</span>,<span class="number">0x6f</span>,<span class="number">0x77</span>,<span class="number">0x7c</span>,<span class="number">0x39</span>,<span class="number">0x5e</span>,<span class="number">0x79</span>,<span class="number">0x71</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 要显示的数据</span></span><br><span class="line"><span class="comment">pos： 从左开始第几个位置开始显示， 范围 1-8</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 dat[],u8 pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    u8 pos_temp=pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=pos_temp;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">        SMG_A_DP_PORT=gsmg_code[dat[i-pos_temp]];<span class="comment">//传送段选数据</span></span><br><span class="line">delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消音</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码也很好理解， 在前面动态数码管实验章节已介绍。 不同的是， 此处我们做了一些改良， 即给 smg_display 函数增加了 2 个形参， dat 和 pos， dat 是一个 u8 类型的数组， 方便外部传入要显示的数据； pos 是数码管从左开始第几个位置开始显示， 取值范围是 1-8， 如果为 1， 即从第一位数码管开始显示， 最多显示 8 位数据； 如果取 2， 即从第二位数码管开始显示， 最多显示 7 位数据。由于给函数增加了 2 个形参， 所以该条语句就变为如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMG_A_DP_PORT=gsmg_code[dat[i-pos_temp]];</span><br></pre></td></tr></table></figure><p>当确定好显示位置， pos_temp 值就确定， 如果要显示的数据也确定， dat 数组内的值就直接可以通过数码管段选数据赋值给 SMG_A_DP_PORT。  </p><p>有些朋友可能看不懂为什么 dat[i-pos_temp]含义， 因为动态扫描， for 循环从 i 起始值开始， 而一般外部传入的数组 dat 是从下标 0 开始， 所以为i-pos_temp。</p><p>I2C 读写字节函数  </p><p>通过前面 I2C 的介绍， 我们知道， 要进行 I2C 通信， 需要编写起始信号、 停止信号、 应答和非应答信号。 因为 I2C 通信是以字节为单位进行传输的， 所以还需要编写 I2C 读写字节的函数。 打开 iic.c 具体代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_start</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 IIC 起始信号</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    IIC_SDA=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SDA=<span class="number">0</span>; <span class="comment">//当 SCL 为高电平时， SDA 由高变为低</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//钳住 I2C 总线， 准备发送或接收数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_stop</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 IIC 停止信号</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    IIC_SDA=<span class="number">0</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SDA=<span class="number">1</span>; <span class="comment">//当 SCL 为高电平时， SDA 由低变为高</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_ack</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 ACK 应答</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    IIC_SDA=<span class="number">0</span>; <span class="comment">//SDA 为低电平</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_nack</span></span><br><span class="line"><span class="comment">* 函数功能 : 产生 NACK 非应答</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_nack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    IIC_SDA=<span class="number">1</span>; <span class="comment">//SDA 为高电平</span></span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_wait_ack</span></span><br><span class="line"><span class="comment">* 函数功能 : 等待应答信号到来</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1， 接收应答失败</span></span><br><span class="line"><span class="comment">         0， 接收应答成功</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">iic_wait_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 time_temp=<span class="number">0</span>;</span><br><span class="line">    IIC_SCL=<span class="number">1</span>;</span><br><span class="line">    delay_10us(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(IIC_SDA) <span class="comment">//等待 SDA 为低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        <span class="keyword">if</span>(time_temp&gt;<span class="number">100</span>)<span class="comment">//超时则强制结束 IIC 通信</span></span><br><span class="line">        &#123;</span><br><span class="line">        iic_stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_write_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : IIC 发送一个字节</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 发送一个字节</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iic_write_byte</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    IIC_SCL=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++) <span class="comment">//循环 8 次将一个字节传出， 先传高再传低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((dat&amp;<span class="number">0x80</span>)&gt;<span class="number">0</span>)</span><br><span class="line">            IIC_SDA=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IIC_SDA=<span class="number">0</span>;</span><br><span class="line">        dat&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : iic_read_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : IIC 读一个字节</span></span><br><span class="line"><span class="comment">* 输 入 : ack=1 时， 发送 ACK， ack=0， 发送 nACK</span></span><br><span class="line"><span class="comment">* 输 出 : 应答或非应答</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line">u8 <span class="title function_">iic_read_byte</span><span class="params">(u8 ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>,receive=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ ) <span class="comment">//循环 8 次将一个字节读出， 先读高再传低位</span></span><br><span class="line">    &#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">        IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(IIC_SDA)receive++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">    iic_nack();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    iic_ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码是基于 I2C 时序编写， 具体可以参考时序图和程序注释来看， 非常好理解。 程序中 IIC_SDA 和 IIC_SCL 是 EEPROM 的控制引脚， 在 iic.h 头文件已定义。  </p><p>AT24C02 读写字节函数  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iic.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : at24c02_write_one_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : 在 AT24CXX 指定地址写入一个数据</span></span><br><span class="line"><span class="comment">* 输 入 : addr:写入数据的目的地址</span></span><br><span class="line"><span class="comment">         dat:要写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">at24c02_write_one_byte</span><span class="params">(u8 addr,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA0</span>); <span class="comment">//发送写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr);<span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(dat); <span class="comment">//发送字节</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_stop(); <span class="comment">//产生一个停止条件</span></span><br><span class="line">    delay_ms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : at24c02_write_one_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : 在 AT24CXX 指定地址写入一个数据</span></span><br><span class="line"><span class="comment">* 输 入 : addr:写入数据的目的地址</span></span><br><span class="line"><span class="comment">         dat:要写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line">u8 <span class="title function_">at24c02_read_one_byte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 temp=<span class="number">0</span>;</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA0</span>); <span class="comment">//发送写命令</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_write_byte(addr); <span class="comment">//发送写地址</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    iic_start();</span><br><span class="line">    iic_write_byte(<span class="number">0XA1</span>); <span class="comment">//进入接收模式</span></span><br><span class="line">    iic_wait_ack();</span><br><span class="line">    temp=iic_read_byte(<span class="number">0</span>); <span class="comment">//读取字节</span></span><br><span class="line">    iic_stop(); <span class="comment">//产生一个停止条件</span></span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//返回读取的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码也是基于 AT24C02 数据手册中读写数据格式实现， 在前面介绍 I2C协议时有介绍。 此处不再重复。  </p><p>主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： I2C-EEPROM 实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管右 4 位显示 0， 按 K1 键将数据写入到 EEPROM 内保存，按 K2 键读取 EEPROM 内保存的数据， 按 K3 键显示数据加 1， 按 K4 键显示数据清零，最大能写入的数据是 255。</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;24c02.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_ADDRESS 0 <span class="comment">//定义数据存入 EEPROM 的起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 key_temp=<span class="number">0</span>;</span><br><span class="line">    u8 save_value=<span class="number">0</span>;</span><br><span class="line">    u8 save_buf[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line">    key_temp=key_scan(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(key_temp==KEY1_PRESS)</span><br><span class="line">    &#123;</span><br><span class="line">        at24c02_write_one_byte(EEPROM_ADDRESS,save_value);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY2_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">        save_value=at24c02_read_one_byte(EEPROM_ADDRESS);</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY3_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">        save_value++;</span><br><span class="line">        <span class="keyword">if</span>(save_value==<span class="number">255</span>)save_value=<span class="number">255</span>;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key_temp==KEY4_PRESS)</span><br><span class="line">&#123;</span><br><span class="line">save_value=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">    save_buf[<span class="number">0</span>]=save_value/<span class="number">100</span>;</span><br><span class="line">save_buf[<span class="number">1</span>]=save_value%<span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">save_buf[<span class="number">2</span>]=save_value%<span class="number">100</span>%<span class="number">10</span>;</span><br><span class="line">smg_display(save_buf,<span class="number">6</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码很简单， 首先将所需要用到的外设驱动程序的头文件包含进来， 这样在 main.c 中才能使用， 然后在 main 中定义所需变量， 进入 while 循环后， 检测按键是否按下， 然后根据返回的键值操作对应功能， 最后是将按键调节的值显示在后 3 位数码管上。</p><p>实验现象  </p><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 码管右 3 位显示 0，按 K1 键将数据写入到 EEPROM 内保存， 按 K2 键读取 EEPROM 内保存的数据， 按K3 键显示数据加 1， 按 K4 键显示数据清零， 最大能写入的数据是 255。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618103158720.png" alt="image-20230618103158720"></p><h3 id="DS18B20温度传感器实验"><a href="#DS18B20温度传感器实验" class="headerlink" title="DS18B20温度传感器实验"></a>DS18B20温度传感器实验</h3><h4 id="DS18B20介绍"><a href="#DS18B20介绍" class="headerlink" title="DS18B20介绍"></a>DS18B20介绍</h4><p>DS18B20 是由 DALLAS 半导体公司推出的一种的“一线总线（单总线） ” 接口的温度传感器。 与传统的热敏电阻等测温元件相比， 它是一种新型的体积小、适用电压宽、 与微处理器接口简单的数字化温度传感器。  </p><p>DS18B20 温度传感器具有如下特点：  </p><p>1、 适应电压范围更宽， 电压范围： 3.0～5.5V， 在寄生电源方式下可由数据线供电。</p><p>2、 独特的单线接口方式， DS18B20 在与微处理器连接时仅需要一条口线即可实现微处理器与 DS18B20 的双向通讯。</p><p>3、 DS18B20 支持多点组网功能， 多个 DS18B20 可以并联在唯一的三线上，实现组网多点测温。</p><p>4、 DS18B20 在使用中不需要任何外围元件， 全部传感元件及转换电路集成在形如一只三极管的集成电路内。</p><p>5、 温范围－55℃～+125℃， 在-10～+85℃时精度为±0.5℃</p><p>6、 可编程的分辨率为 9～12 位， 对应的可分辨温度分别为 0.5℃、 0.25℃、0.125℃ 和 0.0625℃， 可实现高精度测温。</p><p>7、 在 9 位分辨率时最多在 93.75ms 内把温度转换为数字， 12 位分辨率时最多在 750ms 内把温度值转换为数字， 速度更快。</p><p>8、 测量结果直接输出数字温度信号， 以”一根总线”串行传送给 CPU， 同时可传送 CRC 校验码， 具有极强的抗干扰纠错能力。</p><p>9、 负压特性： 电源极性接反时， 芯片不会因发热而烧毁， 但不能正常工作。DS18B20 外观实物如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112628421.png" alt="image-20230618112628421"></p><p>从 DS18B20 外观图可以看到， 当我们正对传感器切面（传感器型号字符那一面） 时， 传感器的管脚顺序是从左到右排列。 管脚 1 为 GND， 管脚 2 为数据DQ， 管脚 3 为 VDD。 如果把传感器插反， 那么电源将短路， 传感器就会发烫，很容易损坏， 所以一定要注意传感器方向， 通常我们在开发板上都会标出传感器的凸起出， 所以只需要把传感器凸起的方向对着开发板凸起方向插入即可。  </p><p>DS18B20 内部结构如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112702555.png" alt="image-20230618112702555"></p><p>ROM 中的 64 位序列号是出厂前被光刻好的， 它可以看作是该 DS18B20 的地址序列号。 64 位光刻 ROM 的排列是： 开始 8 位（28H） 是产品类型标号， 接着的 48 位是该 DS18B20 自身的序列号， 最后 8 位是前面 56 位的循环冗余校验码。 光刻 ROM 的作用是使每一个 DS18B20 都各不相同， 这样就可以实现一根总线上挂接多个 DS18B20 的目的。  </p><p>DS18B20 温度传感器的内部存储器包括一个高速的暂存器 RAM 和一个非易失性的可电擦除的 EEPROM,后者存放高温度和低温度触发器 TH、 TL 和配置寄存器。  </p><p>配置寄存器是配置不同的位数来确定温度和数字的转化， 配置寄存器结构如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112728589.png" alt="image-20230618112728589"></p><p>低五位一直都是”1”， TM 是测试模式位， 用于设置 DS18B20 在工作模式还是在测试模式。 在 DS18B20 出厂时该位被设置为 0， 用户不需要去改动。 R1 和R0 用来设置 DS18B20 的精度（分辨率） ， 可设置为 9， 10， 11 或 12 位， 对应的分辨率温度是 0.5℃， 0.25℃， 0.125℃和 0.0625℃。 R0 和 R1 配置如下图：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112743253.png" alt="image-20230618112743253"></p><p>在初始状态下默认的精度是 12 位， 即 R0=1、 R1=1。 高速暂存存储器由 9 个字节组成， 其分配如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112749937.png" alt="image-20230618112749937"></p><p>当温度转换命令（44H） 发布后， 经转换所得的温度值以二字节补码形式存放在高速暂存存储器的第 0 和第 1 个字节。 存储的两个字节， 高字节的前 5 位是符号位 S， 单片机可通过单线接口读到该数据， 读取时低位在前， 高位在后，数据格式如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112757551.png" alt="image-20230618112757551"></p><p>如果测得的温度大于 0， 这 5 位为‘ 0’ ， 只要将测到的数值乘以 0.0625 （默认精度是 12 位） 即可得到实际温度； 如果温度小于 0， 这 5 位为‘ 1’ ，测到的数值需要取反加 1 再乘以 0.0625 即可得到实际温度。 温度与数据对应关系如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112807663.png" alt="image-20230618112807663"></p><p>比如我们要计算+85 度， 数据输出十六进制是 0X0550， 因为高字节的高 5位为 0， 表明检测的温度是正温度， 0X0550 对应的十进制为 1360， 将这个值乘以 12 位精度 0.0625， 所以可以得到+85 度。</p><p>知道了怎么计算温度， 接下来我们就来看看如何读取温度数据， 由于 DS18B20是单总线器件， 所有的单总线器件都要求采用严格的信号时序， 以保证 数据的完整性。 DS18B20 时序包括如下几种： 初始化时序、 写（0 和 1） 时序、 读（0和 1） 时序。 DS18B20 发送所有的命令和数据都是字节的低位在前。 这里我们简单介绍这几个信号的时序：  </p><p>（1） 初始化时序  </p><p>单总线上的所有通信都是以初始化序列开始。 主机输出低电平， 保持低电平时间至少 480us（该时间的时间范围可以从 480 到 960 微妙） ， 以产生复位脉冲。 接着主机释放总线， 外部的上拉电阻将单总线拉高， 延时 15～60 us， 并进入接收模式。 接着 DS18B20 拉低总线 60~240 us， 以产生低电平应答脉冲， 若为低电平， 还要做延时， 其延时的时间从外部上拉电阻将单总线拉高算起最少要480 微妙。 初始化时序图如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618112900120.png" alt="image-20230618112900120"></p><p>（2） 写时序写时序包括写 0 时序和写 1 时序。 所有写时序至少需要 60us， 且在 2 次独立的写时序之间至少需要 1us 的恢复时间， 两种写时序均起始于主机拉低总线。 写 1 时序： 主机输出低电平， 延时 2us， 然后释放总线， 延时 60us。 写 0时序： 主机输出低电平， 延时 60us， 然后释放总线， 延时 2us。 写时序图如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113040438.png" alt="image-20230618113040438"></p><p>（3） 读时序单总线器件仅在主机发出读时序时， 才向主机传输数据， 所以， 在主机发出读数据命令后， 必须马上产生读时序， 以便从机能够传输数据。 所有读时序至少需要 60us， 且在 2 次独立的读时序之间至少需要 1us 的恢复时间。 每个读时序都由主机发起， 至少拉低总线 1us。 主机在读时序期间必须释放总线， 并且在时序起始后的 15us 之内采样总线状态。 读时序图如下</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113049396.png" alt="image-20230618113049396"></p><p>典型的读时序过程为： 主机输出低电平延时 2us， 然后主机转入输入模式延时 12us， 然后读取单总线当前的电平， 然后延时 50us。  </p><p>在了解了单总线时序之后， 我们来看看 DS18B20 的典型温度读取过程， DS18B20 的典型温度读取过程为： 复位→发 SKIP ROM 命令（0XCC） →发开始转换命令（0X44） →延时→复位→发送 SKIP ROM 命令（0XCC） →发读存储器命令（0XBE） →连续读出两个字节数据(即温度)→结束。  </p><p>至此我们就介绍完 DS18B20， 如需更详细的介绍， 请大家参考“\6—芯片资料\开发板芯片数据手册\DS18B20 中文.pdf” 。  </p><h4 id="硬件设计-14"><a href="#硬件设计-14" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p><p>（1） 动态数码管</p><p>（2） DS18B20动态数码管电路在前面章节已介绍， 这里就不再重复。 下面来看下开发板上DS18B20 模块电路， 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618113143907.png" alt="image-20230618113143907"></p><p>从上图可以看出， 传感器接口的单总线管脚接至单片机 P3.7 IO 口上， 在介绍单总线的时候我们说过， 为了让单总线默认为高电平， 通常会在单总线上接上拉电阻， 在图中并没有看到有上拉电阻， 这是因为单片机 IO 都外接了 10K 上拉电阻， 当单片机 IO 口连接到传感器的总线管脚时即相当于它们外接上拉电阻，所以此处可以省去。  </p><h4 id="软件设计-13"><a href="#软件设计-13" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 插上 DS18B20 温度传感器， 数码管显示检测的温度值。  程序框架如下：<br>（1） 编写数码管显示功能<br>（2） 编写 DS18B20 读取温度功能<br>（3） 编写主函数</p><p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 DS18B20 时序的模拟及数据的读写上。 下面我们打开“\4—实验程序\1—基础实验\20-DS18B20 温度传感器实验” 工程， 在 App 工程组中可以看到新添加了 ds18b20.c 文件（里面包含了 DS18B20 驱动程序） ， 还要包含对应的头文件路径。  </p><p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p><h5 id="数码管显示函数"><a href="#数码管显示函数" class="headerlink" title="数码管显示函数"></a>数码管显示函数</h5><p>本实验要显示温度值， 就存在小数和符号位， 所以不能直接使用前面的数码管显示函数， 需要做一点点小改动， 代码如下  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : smg_display</span></span><br><span class="line"><span class="comment">* 函数功能 : 动态数码管显示</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 要显示的数据</span></span><br><span class="line"><span class="comment">pos： 从左开始第几个位置开始显示， 范围 1-8</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">smg_display</span><span class="params">(u8 dat[],u8 pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    u8 pos_temp=pos<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=pos_temp;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">switch</span>(i)<span class="comment">//位选</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: LSC=<span class="number">1</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: LSC=<span class="number">1</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: LSC=<span class="number">0</span>;LSB=<span class="number">1</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: LSC=<span class="number">0</span>;LSB=<span class="number">0</span>;LSA=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    MG_A_DP_PORT=dat[i-pos_temp];<span class="comment">//传送段选数据</span></span><br><span class="line">    delay_10us(<span class="number">100</span>);<span class="comment">//延时一段时间， 等待显示稳定</span></span><br><span class="line">    SMG_A_DP_PORT=<span class="number">0x00</span>;<span class="comment">//消影</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前数码管显示驱动程序不同的就是红色加粗标记的那条语句， 可以看到此处没有直接使用数码管段码数据， 而是通过外部提供处理好的数码管段码数据传入进来， 这样可使数码管显示更加灵活， 后面实验我们都将采用这种方式。 因为要让外部提前处理好数码管段码数据， 所以段码数组 gsmg_code 就要定义为全局变量， 需在 smg.h 头文件中声明下即可： extern u8 gsmg_code[17];  </p><h5 id="DS18B20-初始化函数"><a href="#DS18B20-初始化函数" class="headerlink" title="DS18B20 初始化函数"></a>DS18B20 初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 初始化 DS18B20 的 IO 口 DQ 同时检测 DS 的存在</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1:不存在， 0:存在</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds18b20_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ds18b20_reset();</span><br><span class="line">    <span class="keyword">return</span> ds18b20_check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数带有一个返回值， 如果返回值为 1 表示 DS18B20 初始化失败， 返回值为 0 表示初始化成功。 函数返回值其实就是通过调用 ds18b20_check 函数获得，此函数用来检测DS18B20是否存在。初始化函数内还调用了ds18b20_reset函数，这两个函数其实就是根据前面介绍的初始化时序编写， 对应的代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_reset</span></span><br><span class="line"><span class="comment">* 函数功能 : 复位 DS18B20</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_reset</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DS18B20_PORT=<span class="number">0</span>; <span class="comment">//拉低 DQ</span></span><br><span class="line">    delay_10us(<span class="number">75</span>); <span class="comment">//拉低 750us</span></span><br><span class="line">    DS18B20_PORT=<span class="number">1</span>; <span class="comment">//DQ=1</span></span><br><span class="line">    delay_10us(<span class="number">2</span>); <span class="comment">//20US</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_check</span></span><br><span class="line"><span class="comment">* 函数功能 : 检测 DS18B20 是否存在</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 1:未检测到 DS18B20 的存在， 0:存在</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds18b20_check</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 time_temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(DS18B20_PORT&amp;&amp;time_temp&lt;<span class="number">20</span>) <span class="comment">//等待 DQ 为低电平</span></span><br><span class="line">&#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果超时则强制返回 1</span></span><br><span class="line"><span class="keyword">else</span> time_temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((!DS18B20_PORT)&amp;&amp;time_temp&lt;<span class="number">20</span>) <span class="comment">//等待 DQ 为高电平</span></span><br><span class="line">&#123;</span><br><span class="line">        time_temp++;</span><br><span class="line">        delay_10us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(time_temp&gt;=<span class="number">20</span>)<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//如果超时则强制返回 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="温度读取函数"><a href="#温度读取函数" class="headerlink" title="温度读取函数"></a>温度读取函数</h5><p>初始化 DS18B20 后， 我们就可以按照前面介绍的 DS18B20 的典型温度读取过程来编写温度读取函数， 代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">** 函 数 名 : ds18b20_read_temperture</span></span><br><span class="line"><span class="comment">* 函数功能 : 从 ds18b20 得到温度值</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 温度数据</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">ds18b20_read_temperture</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    u8 dath=<span class="number">0</span>;</span><br><span class="line">    u8 datl=<span class="number">0</span>;</span><br><span class="line">    u16 value=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ds18b20_start();<span class="comment">//开始转换</span></span><br><span class="line">    ds18b20_reset();<span class="comment">//复位</span></span><br><span class="line">    ds18b20_check();</span><br><span class="line">    ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//SKIP ROM</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0xbe</span>);<span class="comment">//读存储器</span></span><br><span class="line">    </span><br><span class="line">    datl=ds18b20_read_byte();<span class="comment">//低字节</span></span><br><span class="line">    dath=ds18b20_read_byte();<span class="comment">//高字节</span></span><br><span class="line">    value=(dath&lt;&lt;<span class="number">8</span>)+datl;<span class="comment">//合并为 16 位数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((value&amp;<span class="number">0xf800</span>)==<span class="number">0xf800</span>)<span class="comment">//判断符号位， 负温度</span></span><br><span class="line">&#123;</span><br><span class="line">        value=(~value)+<span class="number">1</span>; <span class="comment">//数据取反再加 1</span></span><br><span class="line">        temp=value*(<span class="number">-0.0625</span>);<span class="comment">//乘以精度</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//正温度</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp=value*<span class="number">0.0625</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该函数首先调用了 ds18b20_start 函数用来开始 DS18B20 的温度转换， 其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds18b20_start</span></span><br><span class="line"><span class="comment">* 函数功能 : 开始温度转换</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds18b20_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ds18b20_reset();<span class="comment">//复位</span></span><br><span class="line">    ds18b20_check();<span class="comment">//检查 DS18B20</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0xcc</span>);<span class="comment">//SKIP ROM</span></span><br><span class="line">    ds18b20_write_byte(<span class="number">0x44</span>);<span class="comment">//转换命令</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最终将 2 个字节的温度数据读取出来， 判断最高字节的高 5 位是否为 0， 如果为 0 表明读取的温度值为正温度， 直接乘以 0.0625 即可， 否则为负温度， 需取反后加 1 再乘以 0.0625。  </p><h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><p>编写好 DS18B20 初始化和温度读取函数后， 接下来就可以编写主函数了， 代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DS18B20 温度传感器实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 插上 DS18B20 温度传感器， 数码管显示检测的温度值</span></span><br><span class="line"><span class="comment">注意事项： 注意温度传感器的方向， 在接口处我们已经用丝印画了一个凸起，</span></span><br><span class="line"><span class="comment">所以只需要将温度传感器对应插入即可</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds18b20.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> temp_value;</span><br><span class="line">    u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">    ds18b20_init();<span class="comment">//初始化 DS18B20</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       i++;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">50</span>==<span class="number">0</span>)<span class="comment">//间隔一段时间读取温度值， 间隔时间要大于温度传感器转换温度时间</span></span><br><span class="line">          temp_value=ds18b20_read_temperture()*<span class="number">10</span>;<span class="comment">//保留温度值小数后一位</span></span><br><span class="line">       <span class="keyword">if</span>(temp_value&lt;<span class="number">0</span>)<span class="comment">//负温度</span></span><br><span class="line">       &#123;</span><br><span class="line">           temp_value=-temp_value;</span><br><span class="line">           temp_buf[<span class="number">0</span>]=<span class="number">0x40</span>;<span class="comment">//显示负号</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         temp_buf[<span class="number">0</span>]=<span class="number">0x00</span>;<span class="comment">//不显示</span></span><br><span class="line">       temp_buf[<span class="number">1</span>]=gsmg_code[temp_value/<span class="number">1000</span>];<span class="comment">//百位</span></span><br><span class="line">       temp_buf[<span class="number">2</span>]=gsmg_code[temp_value%<span class="number">1000</span>/<span class="number">100</span>];<span class="comment">//十位</span></span><br><span class="line">       temp_buf[<span class="number">3</span>]=gsmg_code[temp_value%<span class="number">1000</span>%<span class="number">100</span>/<span class="number">10</span>]|<span class="number">0x80</span>;<span class="comment">//个位+小数点</span></span><br><span class="line">       temp_buf[<span class="number">4</span>]=gsmg_code[temp_value%<span class="number">1000</span>%<span class="number">100</span>%<span class="number">10</span>];<span class="comment">//小数点后一位</span></span><br><span class="line">       smg_display(temp_buf,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数代码很简单， 首先调用所需外设头文件， 然后初始化 DS18B20， 在 while循环中间隔一定时间读取温度数据， 并将温度值保留小数点后一位， 然后将读取的温度数据转换为数码管可显示的段码， 最后调用数码管显示函数。  </p><h4 id="实验现象-9"><a href="#实验现象-9" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 插上 DS18B20 温度传感器， 数码管显示检测的温度值。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230618115505081.png" alt="image-20230618115505081"></p><p>实验说明： DS18B20 默认起始温度是 85 度， 之后就会进入到正常温度检测，如果条件允许可以在零下温度下检测看看  </p><p>注意： ==一定要注意温度传感器的方向， 在接口处我们已经用丝印画了一个凸起， 所以只需要将温度传感器对应插入即可==。  </p><h3 id="DS1302-时钟实验"><a href="#DS1302-时钟实验" class="headerlink" title="DS1302 时钟实验"></a>DS1302 时钟实验</h3><p>在前面章节， 我们介绍了如何使用单片机 IO 口模拟 IIC 总线、 单总线时序。这一章我们来学习 DS1302 时钟芯片， 该芯片是 3 线 SPI 接口， 所以需要使用 51单片机的 3 个 IO 口模拟 SPI 时序与 DS1302 时钟芯片通信， 将时钟日历数据读取出来。 开发板上集成了 1 个 DS1302 时钟模块， 可使用它设计一个多功能电子时钟。 本章要实现的功能是： 系统运行时， 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX” 。 学习本章可以参考前面的实验章节内容。   </p><h4 id="DS1302-时钟芯片介绍"><a href="#DS1302-时钟芯片介绍" class="headerlink" title="DS1302 时钟芯片介绍"></a>DS1302 时钟芯片介绍</h4><h5 id="DS1302-简介"><a href="#DS1302-简介" class="headerlink" title="DS1302 简介"></a>DS1302 简介</h5><p>DS1302 是 DALLAS 公司推出的涓流充电时钟芯片， 内含有一个实时时钟/日历和 31 字节静态 RAM， 通过简单的串行接口与单片机进行通信。 实时时钟/日历电路提供秒、 分、 时、 日、 周、 月、 年的信息， 每月的天数和闰年的天数可自动调整。 时钟操作可通过 AM/PM 指示决定采用 24 或 12 小时格式。 DS1302 与单片机之间能简单地采用同步串行的方式进行通信， 仅需用到三根通信线： ①RES复位②I/O 数据线③SCLK 串行时钟。 时钟/RAM 的读/写数据以一个字节或多达31 个字节的字符组方式通信。 DS1302 工作时功耗很低保持数据和时钟信息时功率小于 1mW。  </p><p>DS1302 由 DS1202 改进而来增加了以下的特性： 双电源管脚用于主电源和备份电源供应， Vcc1 为可编程涓流充电电源， 附加七个字节存储器。 它广泛应用于电话、 传真、 便携式仪器以及电池供电的仪器仪表等产品领域下面。  </p><p>主要的性能指标：<br>★ 实时时钟具有能计算 2100 年之前的秒、 分、 时、 日、 星期、 月、 年的能力， 还有闰年调整的能力；<br>★ 31 个 8 位暂存数据存储 RAM；<br>★ 串行 I/O 口方式使得管脚数量最少；</p><p>★ 宽范围工作电压 2.0~5.5V；<br>★ 工作在 2.0V 时， 电流小于 300nA；<br>★ 读/写时钟或 RAM 数据时有两种传送方式单字节传送和多字节传送字符组方式；<br>★ 8 脚 DIP 封装或可选的 8 脚 SOIC 封装根据表面装配；<br>★ 简单 3 线接口；<br>★ 与 TTL 兼容 Vcc=5V；<br>★ 可选工业级温度范围-40~+85；<br>下面来看下 DS1302 芯片的管脚及功能。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621232901649.png" alt="image-20230621232901649"></p><p>1， VCC2： 主电源引脚<br>2， X1、 X2： DS1302 外部晶振引脚， 通常需外接 32.768K 晶振<br>3， GND： 电源地<br>4， CE： 使能引脚， 也是复位引脚（新版本功能变） 。<br>5， I/O： 串行数据引脚， 数据输出或者输入都从这个引脚<br>6， SCLK： 串行时钟引脚<br>7， VCC1： 备用电源</p><h5 id="DS1302-使用"><a href="#DS1302-使用" class="headerlink" title="DS1302 使用"></a>DS1302 使用</h5><p>操作 DS1302 的大致过程， 就是将各种数据写入 DS1302 的寄存器， 以设置它当前的时间的格式。 然后使 DS1302 开始运作， DS1302 时钟会按照设置情况运转， 再用单片机将其寄存器内的数据读出。 再用液晶显示， 就是我们常说的简易电子钟。 所以总的来说 DS1302 的操作分 2 步（显示部分属于液晶显示的内容，不属于 DS1302 本身的内容） ， 但是在讲述操作时序之前， 我们要先看看寄存器， DS1302 有一个控制寄存器、 12 个日历、 时钟寄存器和 31 个 RAM。  </p><p>（1） 控制寄存器  </p><p>控制寄存器用于存放 DS1302 的控制命令字， DS1302 的 RST 引脚回到高电平后写入的第一个字节就为控制命令。 它用于对 DS1302 读写过程进行控制， 格式如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621232947772.png" alt="image-20230621232947772"></p><p>上图是 DS1302 的寄存器样式， 我们看到：  </p><p>1、 第 7 位永远都是 1；<br>2、 第 6 位， 1 表示 RAM， 寻址内部存储器地址； 0 表示 CK， 寻址内部寄存器；<br>3、 第 5 到第 1 位， 为 RAM 或者寄存器的地址；</p><p>4、 最低位， 高电平表示 RD， 即下一步操作将要“读” ； 低电平表示 W， 即下一步操作将要“写” 。 （与 AT24C02 寄存器类似， 这点要理解好） 。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233040454.png" alt="image-20230621233040454"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233044573.png" alt="image-20230621233044573"></p><p>比如要读秒寄存器则命令为 1000 0001， 反之写为 1000 0000， 要注意其含义。</p><p>2） 日历/时钟寄存器<br>DS1302 共有 12 个寄存器， 其中有 7 个与日历、 时钟相关， 存放的数据为 BCD码形式。 格式如下：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233120895.png" alt="image-20230621233120895"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233128545.png" alt="image-20230621233128545"></p><p>下面对几个寄存器做下说明：  </p><p>秒寄存器： 低四位为秒的个位， 高的次三位为秒的十位。 最高位 CH 为DS1302 的运行标志， 当 CH=0 时， DS1302 内部时钟运行， 反之 CH=1 时停止；</p><p>小时寄存器： 时寄存器。 最高位为 12/24 小时的格式选择位， 该位为 1 时表示 12 小时格式。 当设置为 12 小时显示格式时， 第 5 位的高电平表示下午（PM） ； 而当设置为 24 小时格式时， 第 5 位位具体的时间数据。</p><p>写保护寄存器： 当该寄存器最高位 WP 为 1 时， DS1302 只读不写， 所以要在往 DS1302 写数据之前确保 WP 为 0。</p><p>慢充电寄存器（涓细电流充电） 寄存器： 我们知道， 当 DS1302 掉电时， 可以马上调用外部电源保护时间数据。 该寄存器就是配置备用电源的充电选项的。其中高四位（4 个 TCS） 只有在 1010 的情况下才能使用充电选项； 低四位的情况与 DS1302 内部电路有关， 具体大家可以查看“\6—开发板芯片资料\开发板芯片数据手册\DS1302 中文手册.pdf” 。</p><p>前面我们提到在日历/时钟寄存器中都是以 BCD 码存放数据， 那么 BCD 码是什么呢？ BCD 码是通过 4 位二进制码来表示 1 位十进制中的 0~9 这 10 个数码。如下所示：</p><p>  <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233222778.png" alt="image-20230621233222778"></p><p>所以从 DS1302 中读取出来的时钟数据均为 BCD 码格式， 需转换为我们习惯的 10 进制， 转换方法在源程序里， 后面我们会介绍。  </p><p>（3） DS1302 的读写时序在控制指令字输入后的下一个 SCLK 时钟的上升沿时， 数据被写入 DS1302，数据输入从低位（位 0） 开始。 同样， 在紧跟 8 位的控制指令字后的下一个 SCLK脉冲的下降沿读出 DS1302 的数据， 读出数据时从低位 0 位到高位 7。 其时序图如下所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233307314.png" alt="image-20230621233307314"></p><p>上图就是 DS1302 的三个时序： 复位时序， 单字节写时序， 单字节读时序；  </p><p>CE（RST） ： 复位时序， 即在 RST 引脚产生一个正脉冲， 在整个读写器件， RST 要保持高电平， 一次字节读写完毕之后， 要注意把 RST 返回低电平准备下次读写周期；  </p><p>单字节读时序： 注意读之前还是要先对寄存器写命令， 从最低位开始写； 可以看到， 写数据是在 SCLK 的上升沿实现， 而读数据在 SCLK 的下降沿实现。 所以，在单字节读时序中， 写命令的第八个上升沿结束后紧接着的第八个下降沿就将要读寄存器的第一位数据读到数据线上了！ 这个就是 DS1302 操作中最特别的地方。当然读出来的数据也是最低位开始。  </p><p>单字节写时序： 两个字节的数据配合 16 个上升沿将数据写入即可。  </p><p>程序注意事项：  </p><p>★要记得在操作 DS1302 之前关闭写保护；</p><p>★注意用延时来降低单片机的速度以配合器件时序；</p><p>★DS1302 读出来的数据是 BCD 码形式， 要转换成我们习惯的 10 进制， 转换方法在源程序里；</p><p>★读取字节之前， 将 IO 设置为输入口， 读取完之后， 要将其改回输出口；</p><p>★在写程序的时候， 建议实现开辟数组（内存空间） 来集中放置 DS1302 的一系列数据， 方便以后扩展键盘输入。</p><p>到这里我们就介绍完 DS1302 时钟芯片， 如需更详细的介绍， 请大家参考“\6—开发板芯片资料\开发板芯片数据手册\DS1302 中文手册.pdf” 。</p><h4 id="硬件设计-15"><a href="#硬件设计-15" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下： </p><p>（1） 动态数码管</p><p>（2） DS1302</p><p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面我们来看下开发板上 DS1302 时钟模块电路， 如下图所示</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621233452506.png" alt="image-20230621233452506"></p><p>从上图中可知， DS1302 芯片的控制管脚接至单片机 P3.4-P3.6 上， 在芯片的X1、 X2 管脚处外接了一个 32.768KHZ 晶振， 为时钟运行提供一个稳定的时钟频率， C2 和 C3 为旁路电容， 目的是消除晶振起振时产生的电感干扰。 对于本开发板无外接备用电池， 如果需要可自行将外部备用电源接入第 8 脚 VCC1。  </p><h4 id="软件设计-14"><a href="#软件设计-14" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX”。程序框架如下：</p><p>（1） 编写数码管显示功能<br>（2） 编写 DS1302 时钟读写功能<br>（3） 编写主函数</p><p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 DS1302 时序的模拟及数据的读写上。 下面我们打开“\4—实验程序\1—基础实验\21-DS1302 时钟实验” 工程， 在 App 工程组中可以看到新添加了 ds1302.c 文件（里面包含了 DS1302 驱动程序） ， 还要包含对应的头文件路径  </p><p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p><h5 id="DS1302-读写函数"><a href="#DS1302-读写函数" class="headerlink" title="DS1302 读写函数"></a>DS1302 读写函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds1302.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"><span class="comment">//---DS1302 写入和读取时分秒的地址命令---//</span></span><br><span class="line"><span class="comment">//---秒分时日月周年 最低位读写位;-------//</span></span><br><span class="line">u8 gREAD_RTC_ADDR[<span class="number">7</span>] = &#123;<span class="number">0x81</span>, <span class="number">0x83</span>, <span class="number">0x85</span>, <span class="number">0x87</span>, <span class="number">0x89</span>, <span class="number">0x8b</span>, <span class="number">0x8d</span>&#125;;</span><br><span class="line">u8 gWRITE_RTC_ADDR[<span class="number">7</span>] = &#123;<span class="number">0x80</span>, <span class="number">0x82</span>, <span class="number">0x84</span>, <span class="number">0x86</span>, <span class="number">0x88</span>, <span class="number">0x8a</span>, <span class="number">0x8c</span>&#125;;</span><br><span class="line"><span class="comment">//---DS1302 时钟初始化 2021 年 5 月 20 日星期四 13 点 51 分 47 秒。 ---//</span></span><br><span class="line"><span class="comment">//---存储顺序是秒分时日月周年,存储格式是用 BCD 码---//</span></span><br><span class="line">u8 gDS1302_TIME[<span class="number">7</span>] = &#123;<span class="number">0x47</span>, <span class="number">0x51</span>, <span class="number">0x13</span>, <span class="number">0x20</span>, <span class="number">0x04</span>, <span class="number">0x05</span>, <span class="number">0x21</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_write_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 写单字节</span></span><br><span class="line"><span class="comment">* 输 入 : addr： 地址/命令</span></span><br><span class="line"><span class="comment">dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_write_byte</span><span class="params">(u8 addr,u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">DS1302_RST=<span class="number">0</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 低电平</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_RST=<span class="number">1</span>;<span class="comment">//RST 由低到高变化</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=addr&amp;<span class="number">0x01</span>;</span><br><span class="line">addr&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">&#125;f</span><br><span class="line"><span class="title function_">or</span><span class="params">(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=dat&amp;<span class="number">0x01</span>;</span><br><span class="line">dat&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;D</span><br><span class="line">S1302_RST=<span class="number">0</span>;<span class="comment">//RST 拉低</span></span><br><span class="line">_nop_();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_read_byte</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 读单字节</span></span><br><span class="line"><span class="comment">* 输 入 : addr： 地址/命令</span></span><br><span class="line"><span class="comment">* 输 出 : 读取的数据</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line">u8 <span class="title function_">ds1302_read_byte</span><span class="params">(u8 addr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">u8 temp=<span class="number">0</span>;</span><br><span class="line">u8 value=<span class="number">0</span>;</span><br><span class="line">DS1302_RST=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 低电平</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_RST=<span class="number">1</span>;<span class="comment">//RST 由低到高变化</span></span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次写 1 位， 先写低位再写高位</span></span><br><span class="line">&#123;</span><br><span class="line">DS1302_IO=addr&amp;<span class="number">0x01</span>;</span><br><span class="line">addr&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">&#125;f</span><br><span class="line"><span class="title function_">or</span><span class="params">(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><span class="comment">//循环 8 次， 每次读 1 位， 先读低位再读高位</span></span><br><span class="line">&#123;</span><br><span class="line">temp=DS1302_IO;</span><br><span class="line">value=(temp&lt;&lt;<span class="number">7</span>)|(value&gt;&gt;<span class="number">1</span>);<span class="comment">//先将 value 右移 1 位， 然后 temp 左移 7 位，</span></span><br><span class="line">最后或运算</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">0</span>;</span><br><span class="line">_nop_();</span><br><span class="line">&#125;D</span><br><span class="line">S1302_RST=<span class="number">0</span>;<span class="comment">//RST 拉低</span></span><br><span class="line">_nop_();</span><br><span class="line">DS1302_CLK=<span class="number">1</span>;<span class="comment">//对于实物中， P3.4 口没有外接上拉电阻的， 此处代码需要添加， 使数</span></span><br><span class="line">据口有一个上升沿脉冲。</span><br><span class="line">_nop_();</span><br><span class="line">DS1302_IO = <span class="number">0</span>;</span><br><span class="line">_</span><br><span class="line"><span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">DS1302_IO = <span class="number">1</span>;</span><br><span class="line">_nop_();</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_init</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 初始化时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line">ds1302_write_byte(<span class="number">0x8E</span>,<span class="number">0X00</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ds1302_write_byte(gWRITE_RTC_ADDR[i],gDS1302_TIME[i]);</span><br><span class="line">&#125;d</span><br><span class="line"><span class="title function_">s1302_write_byte</span><span class="params">(<span class="number">0x8E</span>,<span class="number">0X80</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ds1302_read_time</span></span><br><span class="line"><span class="comment">* 函数功能 : DS1302 读取时间</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ds1302_read_time</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">gDS1302_TIME[i]=ds1302_read_byte(gREAD_RTC_ADDR[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>各函数功能在代码内有详细注释， 大家可以参考注释理解。 程序开头定义了3 个数组： gREAD_RTC_ADDR、 gWRITE_RTC_ADDR 和 gDS1302_TIME。 gREAD_RTC_ADDR和 gWRITE_RTC_ADDR 数组内存储的是 DS1302 写入和读取时分秒的地址命令， 这个可以对照前面介绍的寄存器看。 TIME 数组是用来存储初始化时间， 每个数据对应含义在代码内已做注释。 在使用中主要调用 ds1302_init()函数和ds1302_read_time()函数来初始化 DS1302 时钟数据以及读取 DS1302 时钟数据。在初始化时钟数据时， 首先要禁止写保护即关闭写保护功能， 然后将所需设置的时钟数据写入到对应的时钟寄存器地址内， 最后打开写保护功能， 以防止意外修改 DS1302 内部寄存器。 对于读取时钟数据其实很简单， 只要从对应的时钟寄存器地址内读取数据即可， 然后将读取的数据存储到一个缓存数组中， 方便数据的处理与显示， 这个操作在后面 main.c 文件内会有。  </p><h5 id="主函数-1"><a href="#主函数-1" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DS1302 时钟实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX”</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ds1302.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">u8 time_buf[<span class="number">8</span>];</span><br><span class="line">ds1302_init();<span class="comment">//初始化 DS1302</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ds1302_read_time();</span><br><span class="line">time_buf[<span class="number">0</span>]=gsmg_code[gDS1302_TIME[<span class="number">2</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">1</span>]=gsmg_code[gDS1302_TIME[<span class="number">2</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">time_buf[<span class="number">2</span>]=<span class="number">0x40</span>;</span><br><span class="line">time_buf[<span class="number">3</span>]=gsmg_code[gDS1302_TIME[<span class="number">1</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">4</span>]=gsmg_code[gDS1302_TIME[<span class="number">1</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">time_buf[<span class="number">5</span>]=<span class="number">0x40</span>;</span><br><span class="line">time_buf[<span class="number">6</span>]=gsmg_code[gDS1302_TIME[<span class="number">0</span>]/<span class="number">16</span>];</span><br><span class="line">time_buf[<span class="number">7</span>]=gsmg_code[gDS1302_TIME[<span class="number">0</span>]&amp;<span class="number">0x0f</span>];</span><br><span class="line">smg_display(time_buf,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数代码非常简单， 首先调用外设头文件， 然后初始化 DS1302 并设定好初始时间， 进入 while 循环， 读取 DS1302 时钟数据存储至全局变量数组gDS1302_TIME 中， 最后将读取的数据转换为数码管可显示的段码数据并调用数码管显示函数显示时间  </p><p>==细心的朋友可能发现， 在处理 DS1302 读取的数据时， 取高低位是使用除 16和取余 16， 并非之前的除 10 和取余 10。 这是因为写入进 DS1302 时是 BCD 码，读取出的数据也是 BCD 码， 而 BCD 码即是 4 位表示一个十进制数， 类似于一个字节的十六进制数据的高 4 位和低 4 位一样， 所以这里是除 16 和取余 16==。  </p><h4 id="实验现象-10"><a href="#实验现象-10" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示电子时钟时分秒， 格式为“XX-XX-XX” 。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230621234048436.png" alt="image-20230621234048436"></p><h3 id="红外遥控实验"><a href="#红外遥控实验" class="headerlink" title="红外遥控实验"></a>红外遥控实验</h3><p>在前面章节， 我们介绍的通信， 如 SPI、 IIC 等通信均为有线， 这一章我们来介绍一种无线通信技术—红外遥控通信。 我们开发板标配了一个一体化红外接收头和红外遥控器， 我们来学习如何使用 51 单片机解码红外遥控器的信号。 本章使用 51 单片机的外部中断功能来解码红外遥控器的编码信号。 本章要实现的功能是： 使用外部中断功能将遥控器键值编码数据解码后通过数码管显示。 学习本章可以参考前面的实验章节内容。   </p><h4 id="红外遥控介绍"><a href="#红外遥控介绍" class="headerlink" title="红外遥控介绍"></a>红外遥控介绍</h4><h5 id="红外线简介"><a href="#红外线简介" class="headerlink" title="红外线简介"></a>红外线简介</h5><p>人的眼睛能看到的可见光按波长从长到短排列， 依次为红、 橙、 黄、 绿、 青、蓝、 紫。 其中红光的波长范围为 0.62～0.76μ m； 紫光的波长范围为 0.38～0.46μ m。 比紫光波长还短的光叫紫外线， 比红光波长还长的光叫红外线。 红外线遥控就是利用波长为 0.76～1.5μ m 之间的近红外线来传送控制信号的。</p><h5 id="红外遥控的原理"><a href="#红外遥控的原理" class="headerlink" title="红外遥控的原理"></a>红外遥控的原理</h5><p>红外遥控是一种无线、 非接触控制技术， 具有抗干扰能力强， 信息传输可靠，功耗低， 成本低， 易实现等显著优点， 被诸多电子设备特别是家用电器广泛采用，并越来越多的应用到计算机系统中。    </p><p>由于红外线遥控不具有像无线电遥控那样穿过障碍物去控制被控对象的能力， 所以， 在设计红外线遥控器时， 不必要像无线电遥控器那样， 每套(发射器和接收器)要有不同的遥控频率或编码(否则， 就会隔墙控制或干扰邻居的家用电器)， 所以同类产品的红外线遥控器， 可以有相同的遥控频率或编码， 而不会出 现遥控信号“串门” 的情况。 这对于大批量生产以及在家用电器上普及红外线遥控提供了极大的方便。 由于红外线为不可见光， 因此对环境影响很小， 再由红外光波动波长远小于无线电波的波长， 所以红外线遥控不会影响其他家用电器， 也不会影响临近的无线电设备。  </p><p>红外遥控通信系统一般由红外发射装置和红外接收设备两大部分组成。  </p><h5 id="红外发射装置"><a href="#红外发射装置" class="headerlink" title="红外发射装置"></a>红外发射装置</h5><p>红外发射装置， 也就是通常我们说的红外遥控器是由键盘电路、 红外编码电路、 电源电路和红外发射电路组成。 红外发射电路的主要元件为红外发光二极管。它实际上是一只特殊的发光二极管； 由于其内部材料不同于普通发光二极管， 因而在其两端施加一定电压时， 它便发出的是红外线而不是可见光。 目前大量的使用的红外发光二极管发出的红外线波长为 940nm 左右， 外形与普通发光二极管相同。 红外发光二极管有透明的， 还有不透明的， 在我们的红外遥控器上可以看到这个红外发光二极管。 红外遥控器和红外发光二极管如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082825945.png" alt="image-20230619082825945"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082840543.png" alt="image-20230619082840543"></p><p>通常红外遥控为了提高抗干扰性能和降低电源消耗， 红外遥控器常用载波的方式传送二进制编码， 常用的载波频率为 38kHz， 这是由发射端所使用的 455kHz晶振来决定的。 在发射端要对晶振进行整数分频， 分频系数一般取 12， 所以455kHz÷12≈37.9kHz≈38kHz。 也有一些遥控系统采用 36kHz、 40 kHz、 56 kHz等， 一般由发射端晶振的振荡频率来决定。 所以， 通常的红外遥控器是将遥控信号（二进制脉冲码） 调制在 38KHz 的载波上， 经缓冲放大后送至红外发光二极管， 转化为红外信号发射出去的。  </p><p>二进制脉冲码的形式有多种， 其中最为常用的是 NEC Protocol 的 PWM 码(脉冲宽度调制)和 Philips RC-5 Protocol 的 PPM 码(脉冲位置调制码， 脉冲串之间的时间间隔来实现信号调制)。 如果要开发红外接收设备， 一定要知道红外遥控器的编码方式和载波频率， 我们才可以选取一体化红外接收头和制定解码方案。 我们配套的红外遥控器使用的是 NEC 协议， 其特征如下：  </p><p>1、 8 位地址和 8 位指令长度；<br>2、 地址和命令 2 次传输（确保可靠性）<br>3、 PWM 脉冲位置调制， 以发射红外载波的占空比代表“0” 和“1” ；<br>4、 载波频率为 38Khz；<br>5、 位时间为 1.125ms 或 2.25ms；</p><p>NEC 码的位定义： 一个脉冲对应 560us 的连续载波， 一个逻辑 1 传输需要2.25ms（560us 脉冲+1680us 低电平）， 一个逻辑 0 的传输需要 1.125ms（560us脉冲+560us 低电平） 。 而红外接收头在收到脉冲的时候为低电平， 在没有脉冲的时候为高电平， 这样， 我们在接收头端收到的信号为： 逻辑 1 应该是 560us 低+1680us 高， 逻辑 0 应该是 560us 低+560us 高。 所以可以通过计算高电平时间判断接收到的数据是 0 还是 1。 NEC 码位定义时序图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619082956754.png" alt="image-20230619082956754"></p><p>NEC 遥控指令的数据格式为： 引导码、 地址码、 地址反码、 控制码、 控制反码。 引导码由一个 9ms 的低电平和一个 4.5ms 的高电平组成， 地址码、 地址反码、 控制码、 控制反码均是 8 位数据格式。 按照低位在前， 高位在后的顺序发送。 采用反码是为了增加传输的可靠性（可用于校验） 。 数据格式如下：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083004535.png" alt="image-20230619083004535"></p><p>NEC 码还规定了连发码(由 9ms 低电平+2.5m 高电平+0.56ms 低电平+97.94ms 高电平组成)， 如果在一帧数据发送完毕之后， 红外遥控器按键仍然没有放开， 则发射连发码， 可以通过统计连发码的次数来标记按键按下的长短或次数。  </p><h5 id="红外接收设备"><a href="#红外接收设备" class="headerlink" title="红外接收设备"></a>红外接收设备</h5><p>红外接收设备是由红外接收电路、 红外解码、 电源和应用电路组成。 红外遥控接收器的主要作用是将遥控发射器发来的红外光信好转换成电信号， 再放大、限幅、 检波、 整形， 形成遥控指令脉冲， 输出至遥控微处理器。 近几年不论是业余制作还是正式产品， 大多都采用成品红外接收头。 成品红外接收头的封装大致有两种： 一种采用铁皮屏蔽； 一种是塑料封装。 均有三只引脚， 即电源正（ VDD）、电源负（GND） 和数据输出（VOUT） 。 其外观实物图如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083101068.png" alt="image-20230619083101068"></p><p>正对接收头的凸起处看， 从左至右， 管脚依次是 1： VOUT， 2： GND， 3： VDD。  </p><p>由于红外接收头在没有脉冲的时候为高电平， 当收到脉冲的时候为低电平，所以可以通过外部中断的下降沿触发中断， 在中断内通过计算高电平时间来判断接收到的数据是 0 还是 1。 外部中断的相关知识， 大家可以参考前面的“外部中断实验” ， 如果想要更加深入的了解红外遥控通信， 大家可以百度， 网上这方面的资料可谓是铺天盖地  </p><h4 id="硬件设计-16"><a href="#硬件设计-16" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管<br>（2） 红外接收头和遥控器</p><p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 红外遥控器和接收头是一体的， 内部结构不用去管它。 下面来看下开发板上红外接收模块电路， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619083146910.png" alt="image-20230619083146910"></p><p>从上图中可知， 红外接收头的输出管脚接至单片机 P3.2 管脚上， 为了保证红外接收头输出管脚默认为高电平， 需外接一个 10K 上拉电阻， 可在上图并没有看到有上拉电阻， 在前面介绍最小系统时已知道， 单片机 IO 口都增加了 10K 上拉电阻， 所以此处可省略。  </p><h4 id="软件设计-15"><a href="#软件设计-15" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示红外解码遥控器键值。程序框架如下：  </p><p>（1） 编写数码管显示功能<br>（2） 编写红外解码函数<br>（3） 编写主函数</p><p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在红外解码上。 下面我们打开“\4—实验程序\1—基础实验\22-红外遥控实验” 工程， 在 App 工程组中可以看到新添加了 ired.c 文件（里面包含了红外解码驱动程序） ， 还要包含对应的头文件路径。</p><p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p><h5 id="红外初始化函数"><a href="#红外初始化函数" class="headerlink" title="红外初始化函数"></a>红外初始化函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : ired_init</span></span><br><span class="line"><span class="comment">* 函数功能 : 红外端口初始化函数， 外部中断 0 配置</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ired_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IT0=<span class="number">1</span>; <span class="comment">//下降沿触发</span></span><br><span class="line">    EX0=<span class="number">1</span>; <span class="comment">//打开中断 0 允许</span></span><br><span class="line">    EA=<span class="number">1</span>; <span class="comment">//打开总中断</span></span><br><span class="line">    IRED=<span class="number">1</span>; <span class="comment">//初始化端口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为我们使用外部中断 0 来解码红外遥控数据， 所以需初始化配置外部中断0。 初始化配置在外部中断实验章节已详细介绍， 此处不再重复。  </p><h5 id="红外解码函数"><a href="#红外解码函数" class="headerlink" title="红外解码函数"></a>红外解码函数</h5><p>初始化外部中断后， 中断就已经开启了， 当 P32 引脚来一个下降沿， 就会触发一次中断， 在中断内我们可以计算高电平时间， 通过高电平时间判断是否进入引导码及数据 0 和 1。 具体代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ired</span><span class="params">()</span> interrupt 0 <span class="comment">//外部中断 0 服务函数</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ired_high_time=<span class="number">0</span>;</span><br><span class="line">    u16 time_cnt=<span class="number">0</span>;</span><br><span class="line">    u8 i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(IRED==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">      time_cnt=<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">while</span>((!IRED)&amp;&amp;(time_cnt))<span class="comment">//等待引导信号 9ms 低电平结束， 若超过 10ms强制退出</span></span><br><span class="line">  &#123;</span><br><span class="line">            delay_10us(<span class="number">1</span>);<span class="comment">//延时约 10us</span></span><br><span class="line">            time_cnt--;</span><br><span class="line">            <span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span>(IRED)<span class="comment">//引导信号 9ms 低电平已过， 进入 4.5ms 高电平</span></span><br><span class="line">  &#123;</span><br><span class="line">        time_cnt=<span class="number">500</span>;</span><br><span class="line">        <span class="keyword">while</span>(IRED&amp;&amp;time_cnt)<span class="comment">//等待引导信号 4.5ms 高电平结束， 若超过 5ms 强制退出</span></span><br><span class="line">&#123;</span><br><span class="line">                delay_10us(<span class="number">1</span>);</span><br><span class="line">            time_cnt--;</span><br><span class="line">            <span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//循环 4 次， 读取 4 个字节数据</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)<span class="comment">//循环 8 次读取每位数据即一个字节</span></span><br><span class="line">&#123;</span><br><span class="line">time_cnt=<span class="number">600</span>;</span><br><span class="line"><span class="keyword">while</span>((IRED==<span class="number">0</span>)&amp;&amp;time_cnt)<span class="comment">//等待数据 1 或 0 前面的 0.56ms结束， 若超过 6ms 强制退出</span></span><br><span class="line">&#123;</span><br><span class="line">                    delay_10us(<span class="number">1</span>);</span><br><span class="line">                    time_cnt--;</span><br><span class="line">                    <span class="keyword">if</span>(time_cnt==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">                time_cnt=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span>(IRED)<span class="comment">//等待数据 1 或 0 后面的高电平结束， 若超过 2ms 强制退出</span></span><br><span class="line">&#123;</span><br><span class="line">                    delay_10us(<span class="number">10</span>);<span class="comment">//约 0.1ms</span></span><br><span class="line">                    ired_high_time++;</span><br><span class="line">                    <span class="keyword">if</span>(ired_high_time&gt;<span class="number">20</span>)<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">                gired_data[i]&gt;&gt;=<span class="number">1</span>;<span class="comment">//先读取的为低位， 然后是高位</span></span><br><span class="line"><span class="keyword">if</span>(ired_high_time&gt;=<span class="number">8</span>)<span class="comment">//如果高电平时间大于 0.8ms， 数据则为1， 否则为 0</span></span><br><span class="line">                gired_data[i]|=<span class="number">0x80</span>;</span><br><span class="line">                ired_high_time=<span class="number">0</span>;<span class="comment">//重新清零， 等待下一次计算时间</span></span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">        <span class="keyword">if</span>(gired_data[<span class="number">2</span>]!=~gired_data[<span class="number">3</span>])<span class="comment">//校验控制码与反码， 错误则返回</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            gired_data[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>进入中断函数， 表示以来下降沿， 然后判断管脚是否为低电平， 如果为低电平则首先判断引导信号， 根据前面 NEC 协议可知， 引导信号有 9ms 的低电平和4.5ms 的高电平， 因此通过 time_cnt 赋值 1000， 然后在 while 循环内判断， time_cnt 每递减一次约 10us， 1000 次则为 10ms， 在解码时， 这个时间要适当放宽一点范围， 因为不同传感器性能会有差异， 所以此处以 10ms 的低电平为界限，如果超过 10ms 则强制退出， 防止系统死机。 判断完引导信号的低电平， 接着判断高电平， 实现方法一样。 当引导信号判断完成后进入地址码、 地址反码、 控制码及控制反码共 4 个字节的数据判断， 也就是数据 0 和 1 的判断， 实现方法也是和前面判断引导信号一样， 这里使用到了嵌套循环， 外层循环次数是 4， 表示读取 4 个字节， 内层循环次数是 8， 表示读取每个字节的 8 位。 注意， 红外遥控解码数据是从低位开始， 最后是高位。  </p><p>最后将读取的 4 个字节数据存储在全局变量数组 gired_data 中， 外部可直接使用这四个字节。  </p><h5 id="主函数-2"><a href="#主函数-2" class="headerlink" title="主函数"></a>主函数</h5><p>打开 main.c 文件， 代码如下  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： 红外遥控实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示数码管上显示红外解码遥控器键值</span></span><br><span class="line"><span class="comment">注意事项： 红外接收头凸起处要与 PCB 板接口凸起丝印处对应</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ired.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ired_buf[<span class="number">3</span>];</span><br><span class="line">    ired_init();<span class="comment">//红外初始化</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        ired_buf[<span class="number">0</span>]=gsmg_code[gired_data[<span class="number">2</span>]/<span class="number">16</span>];<span class="comment">//将控制码高 4 位转换为数码管段码</span></span><br><span class="line">        ired_buf[<span class="number">1</span>]=gsmg_code[gired_data[<span class="number">2</span>]%<span class="number">16</span>];<span class="comment">//将控制码低 4 位转换为数码管段码</span></span><br><span class="line">        ired_buf[<span class="number">2</span>]=<span class="number">0X76</span>;<span class="comment">//显示 H 的段码</span></span><br><span class="line">        smg_display(ired_buf,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数代码很简单， 首先调用使用的外设头文件， 然后初始化红外， 进入while 循环将红外解码数据转换为数码管段码数据， 然后在数码管上显示。  </p><h4 id="实验现象-11"><a href="#实验现象-11" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示红外解码遥控器键值。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619084925918.png" alt="image-20230619084925918"></p><p>注意： ==红外接收头的凸起位置需对到 PCB 板丝印凸出位置， 否则功能无法正常实现。 出厂时的遥控器电池盖内都有一张绝缘片， 使用时必须将此绝缘片拿掉。 还有键值码不是大家所想的按键上的数字字符码， 这个要区分开==。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619084944057.png" alt="image-20230619084944057">        <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085026365.png" alt="image-20230619085026365"></p><p>实验说明： 我们配的遥控器所有键的地址码与反码都是相同的， 不同的是控制码和控制反码， 其实知道了控制码就知道了控制反码， 所以如果要使用红外遥控控制其他设备， 可以通过区分控制码来实现。  </p><p>如果程序下载了， 能显示“00H” ， 按键时却没有反应， 首先检查遥控器是否拔下绝缘片。 如果要检查遥控器好坏， 可以在光线暗的地方， 打开手机摄像机，将遥控器前方的发射灯对准手机摄像头， 按下按键， 在手机上是否能看见灯闪，来判断遥控器好坏。  </p><h3 id="ADC模数转换实验"><a href="#ADC模数转换实验" class="headerlink" title="ADC模数转换实验"></a>ADC模数转换实验</h3><p>在前面章节， 我们介绍的都是对数字信号的操作也就是 0 和 1 操作， 本章我们就来讲解如何检测外部模拟信号， 因为我们使用的 STC89C5x 单片机内部不含ADC 接口， 所以需要外接一个 ADC 转换芯片将模拟信号转换成数字信号供单片机处理。 我们开发板上集成了一个 ADC 模数转换电路， 选用的 ADC 芯片是 12 位的AD 芯片-XPT2046。 本章要实现的功能是： 通过 ADC 转换电路采集电位器电压值，将采集转换后的 AD 值通过数码管显示。  </p><h4 id="ADC介绍"><a href="#ADC介绍" class="headerlink" title="ADC介绍"></a>ADC介绍</h4><p>我们知道 51 单片机系统内部运算时用的全部是数字量， 即 0 和 1， 因此对单片机系统而言， 无法直接操作模拟量， 必须将模拟量转换成数字量。 所谓数字量， 就是用一系列 0 和 1 组成的二进制代码表示某个信号大小的量。 用数字量表示同一个模拟量时， 数字位数可以多也可以少， 位数越多则表示的精度越高，位数越少表示的精度就越低。  </p><h4 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h4><p>ADC（analog to digital converter） 也称为模数转换器， 是指一个将模拟信号转变为数字信号。 单片机在采集模拟信号时， 通常都需要在前端加上 A/D 芯片。  </p><p>下面我们看下 ADC 的主要技术指标：  </p><p>（1） 分辨率  </p><p>ADC 的分辨率是指对于允许范围内的模拟信号， 它能输出离散数字信号值的个数。 这些信号值通常用二进制数来存储， 因此分辨率经常用比特作为单位， 且这些离散值的个数是 2 的幂指数。  </p><p>例如： 12 位 ADC 的分辨率就是 12 位， 或者说分辨率为满刻度的 1/(2^12)。一个 10V 满刻度的 12 位 ADC 能分辨输入电压变化最小值是</p><p>​                                    10V× 1/(212 )=2.4mV  </p><p>（2） 转换误差  </p><p>转换误差通常是以输出误差的最大值形式给出。 它表示 A/D 转换器实际输出的数字量和理论上的输出数字量之间的差别。 常用最低有效位的倍数表示。 例如给出相对误差≤±LSB/2， 这就表明实际输出的数字量和理论上应得到的输出数字量之间的误差小于最低位的半个字。  </p><p>（3） 转换速率  </p><p>ADC 的转换速率是能够重复进行数据转换的速度， 即每秒转换的次数。 而完成一次 A/D 转换所需的时间（包括稳定时间） ， 则是转换速率的倒数  </p><h4 id="ADC-转换原理"><a href="#ADC-转换原理" class="headerlink" title="ADC 转换原理"></a>ADC 转换原理</h4><p>AD 转换器（ADC） 将模拟量转换为数字量通常要经过 4 个步骤： 采样、 保持、量化和编码。 所谓采样即是将一个时间上连续变化的模拟量转换为时间上离散变化的模拟量。 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085326801.png" alt="image-20230619085326801"></p><p>将采样结果存储起来， 直到下次采样， 这个过程叫做保持。 一般采样器和保持电路一起总称为采样保持电路。 将采样电平归化为与之接近的离散数字电平，这个过程叫做量化。 将量化后的结果按照一定数制形式表示就是编码。 将采样电平（模拟值） 转换为数字值时， 主要有两类方法： 直接比较型与间接比较型。  </p><p>—直接比较型： 就是将输入模拟信号直接与标准的参考电压比较， 从而得到数字量。 常见的有并行 ADC 和逐次比较型 ADC。  </p><p>—间接比较型： 输入模拟量不是直接与参考电压比较， 而是将二者变为中间的某种物理量在进行比较， 然后将比较所得的结果进行数字编码。 常见的有双积分型 ADC。  </p><p>下面就以常用的逐次比较型 ADC 和双积分型 ADC 介绍其工作原理。  </p><p>（1） 逐次逼近型 ADC  </p><p>采用逐次逼近法的 AD 转换器是有一个比较器、 DA 转换器、 缓冲寄存器和控制逻辑电路组成， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085416215.png" alt="image-20230619085416215"></p><p>基本原理是： 从高位到低位逐次试探比较， 就像用天平秤物体， 从重到轻逐级增减砝码进行试探。 逐次逼近法的转换过程是： 初始化时将逐次逼近寄存器各位清零， 转换开始时， 先将逐次逼近寄存器最高位置 1， 送入 DA 转换器， 经 DA转换后生成的模拟量送入比较器， 称为 U0， 与送入比较器的待转换的模拟量 Ux进行比较， 若 U0&lt;Ux， 该位 1 被保留， 否则被清除。 然后再将逐次逼近寄存器次高位置 1， 将寄存器中新的数字量送 DA 转换器， 输出的 U0 再与 Ux 比较， 若 U0&lt;Ux，该位 1 被保留， 否则被清除。 重复此过程， 直至逼近寄存器最低位。 转换结束后，将逐次逼近寄存器中的数字量送入缓冲寄存器， 得到数字量的输出。 逐次逼近的操作过程是在一个控制电路的控制下进行的。  </p><p>（2） 双积分型 ADC  </p><p>采用双积分法的 AD 转换器由电子开关、 积分器、 比较器和控制逻辑等部件组成。 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085438807.png" alt="image-20230619085438807"></p><p>其基本原理： 将输入电压变换成与其平均值成正比的时间间隔， 再把此时间间隔转换成数字量， 属于间接转换。 双积分法 AD 转换的过程是： 先将开关接通待转换的模拟量 Vi， Vi 采样输入到积分器， 积分器从零开始进行固定时间 T 的正向积分， 时间 T 到后， 开关再接通与 Vi 极性相反的基准电压 Vref， 将 Vref输入到积分器， 进行反向积分， 直到输出为 0V 时停止积分。 Vi 越大， 积分器输出电压越大， 反向积分时间也越长。 计数器在反向积分时间内所计的数值， 就是输入模拟电压 Vi 所对应的数字量， 实现了 AD 转换。  </p><h4 id="XPT2046芯片介绍"><a href="#XPT2046芯片介绍" class="headerlink" title="XPT2046芯片介绍"></a>XPT2046芯片介绍</h4><p>XPT2046 是一款 4 线制电阻式触摸屏控制器， 内含 12 位分辨率 125KHz转换速率逐步逼近型 A/D 转换器。 XPT2046 支持从 1.5V 到 5.25V 的低电压I/O 接口。 XPT2046 能通过执行两次 A/D 转换查出被按的屏幕位置， 除此之外，还可以测量加在触摸屏上的压力。 内部自带 2.5V 参考电压， 可以作为辅助输入、温度测量和电池监测之用， 电池监测的电压范围可以从 0V 到 6V。 XPT2046 片内集成有一个温度传感器。 在 2.7V 的典型工作状态下， 关闭参考电压， 功耗可小于 0.75mW。 XPT2046 采用微小的封装形式： TSSOP-16,QFN-16 和 VFBGA－48。工作温度范围为-40℃～+85℃。 与 ADS7846、 TSC2046、 AK4182A 完全兼容。  </p><p>（1） 主要特性<br>①工作电压范围为 1.5V～5.25V<br>②支持 1.5V～5.25V 的数字 I/O 口<br>③内建 2.5V 参考电压源<br>④电源电压测量（ 0V~6V）<br>⑤内建结温测量功能</p><p>⑥触摸压力测量<br>⑦采用 3 线制 SPI 通信接口<br>⑧具有自动省电功能</p><p>（2） 芯片管脚说明  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085544095.png" alt="image-20230619085544095">    <img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085549687.png" alt="    "></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085614968.png" alt="image-20230619085614968"></p><p>XPT2046 是一种典型的逐次逼近型模数转换器（SAR ADC） ， 包含了采样/保持、 模数转换、 串口数据 输出等功能。 同时芯片集成有一个 2.5V 的内部参考电压源、 温度检测电路， 工作时使用外部时钟。 XPT2046 可以单电源供电， 电源电压范围为 2.7V～5.5V。 参考电压值直接决定 ADC 的输入范围， 参考电压可以使用内部参考电压， 也可以从外部直接输入 1V～VCC 范围内的参考电压（要求外部参考电压源输出阻抗低） 。 X、 Y、 Z、 VBAT、 Temp 和 AUX 模拟信号经过片内的控制寄存器选择后进入 ADC， ADC 可以配置为单端或差分模式。 选择 VBAT、 Temp和 AUX 时应该配置为单端模式； 作为触摸屏应用时， 应该配置为差分模式， 这可有效消除由于驱动开关的寄生电阻及外部的干扰带来的测量误差， 提高转换精度。 单端和差分模式输入配置如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085635113.png" alt="image-20230619085635113"></p><p>XPT2046 数据接口是串行接口， 其典型工作时序如下图所示， 图中展示的信号来自带有基本串行接口的单片机或数据信号处理器。 处理器和转换器之间的的通信需要 8 个时钟周期， 可采用 SPI、 SSI 和 Microwire 等同步串行接口。 一次完整的转换需要 24 个串行同步时钟（DCLK） 来完成。  </p><p>前 8 个时钟用来通过 DIN 引脚输入控制字节。 当转换器获取有关下一次转换的足够信息后， 接着根据获得的信息设置输入多路选择器和参考源输入， 并进入采样模式， 如果需要， 将启动触摸面板驱动器。 3 个多时钟周期后， 控制字节设置完成， 转换器进入转换状态。 这时， 输入采样－保持器进入保持状态， 触摸面板驱动器停止工作（单端工作模式） 。 接着的 12 个时钟周期将完成真正的模数转换。 如果是度量比率转换方式（SER/DFR＝0） ， 驱动器在转换过程中将一直工作， 第 13 个时钟将输出转换结果的最后一位。 剩下的 3 个多时钟周期将用来完成被转换器忽略的最后字节（DOUT 置低） 。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085655240.png" alt="image-20230619085655240"></p><p>在对 XPT2046 进行控制时， 控制字节由 DIN 输入的控制字命令格式如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085704132.png" alt="image-20230619085704132"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085707280.png" alt="image-20230619085707280"></p><p>至此， 我们就对 ADC 的基本原理及 XPT2046 芯片介绍完， 大家如果想要更详细的了解其工作原理， 可以查看资料“\6—开发板芯片资料\开发板芯片数据手册\xpt2046 中文.pdf” 。  </p><h4 id="硬件设计-17"><a href="#硬件设计-17" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） 动态数码管<br>（2） ADC 模块</p><p>动态数码管电路在前面章节都介绍过， 这里就不再重复。 下面来看下开发板上 ADC 模块电路， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085743661.png" alt="image-20230619085743661"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619085746616.png" alt="image-20230619085746616"></p><p>从上图中可以看出， 该电路是集成的， XPT2046 芯片的控制管脚接至单片机P3.4~P3.7 管脚上， XPT2046 芯片的 ADC 输入转换通道分别接入了 AD1 电位器、NTC1 热敏传感器、 GR1 光敏传感器， 还有一个外接通道 AIN3 接在 DAC（PWM） 模块的 J52 端子上供外部模拟信号检测。  </p><p>注意： 上图中 XPT2046 的 DOUT 脚与 DS18B20 温度传感器均连接到单片机的P3.7， 因此该两个外设资源不能同时使用， 可以分时复用。  </p><h4 id="软件设计-16"><a href="#软件设计-16" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 数码管上显示 AD 模块采集电位器的电压值。程序框架如下：  </p><p>（1） 编写数码管显示功能<br>（2） 编写 ADC 转换函数<br>（3） 编写主函数</p><p>前面的实验章节都已编写过数码管显示功能， 现在对大家来说应该不是问题， 所以本章软件的重点在 XPT2046 读写数据上。   这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。  </p><h5 id="ADC读写函数"><a href="#ADC读写函数" class="headerlink" title="ADC读写函数"></a>ADC读写函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xpt2046.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;intrins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_wirte_data</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 写数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 写入的数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">xpt2046_wirte_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)<span class="comment">//循环 8 次， 每次传输一位， 共一个字节</span></span><br><span class="line">    &#123;</span><br><span class="line">    DIN = dat &gt;&gt; <span class="number">7</span>;<span class="comment">//先传高位再传低位</span></span><br><span class="line">    dat &lt;&lt;= <span class="number">1</span>;<span class="comment">//将低位移到高位</span></span><br><span class="line">    CLK = <span class="number">1</span>;<span class="comment">//CLK 由低到高产生一个上升沿， 从而写入数据</span></span><br><span class="line">    _nop_();</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_read_data</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 读数据</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : XPT2046 返回 12 位数据</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u16 <span class="title function_">xpt2046_read_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u16 dat=<span class="number">0</span>;</span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)<span class="comment">//循环 12 次， 每次读取一位， 大于一个字节数， 所以返回值类型是 u16</span></span><br><span class="line">   &#123;</span><br><span class="line">        dat &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        CLK = <span class="number">1</span>;</span><br><span class="line">        _nop_();</span><br><span class="line">        CLK = <span class="number">0</span>; <span class="comment">//CLK 由高到低产生一个下降沿， 从而读取数据</span></span><br><span class="line">        _</span><br><span class="line">        <span class="title function_">nop_</span><span class="params">()</span>;</span><br><span class="line">        dat |= DOUT;<span class="comment">//先读取高位， 再读取低位。</span></span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> dat;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : xpt2046_read_adc_value</span></span><br><span class="line"><span class="comment">* 函数功能 : XPT2046 读 AD 数据</span></span><br><span class="line"><span class="comment">* 输 入 : cmd： 指令</span></span><br><span class="line"><span class="comment">* 输 出 : XPT2046 返回 AD 值</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line">u16 <span class="title function_">xpt2046_read_adc_value</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line">    u16 adc_value=<span class="number">0</span>;</span><br><span class="line">    CLK = <span class="number">0</span>;<span class="comment">//先拉低时钟</span></span><br><span class="line">    CS = <span class="number">0</span>;<span class="comment">//使能 XPT2046</span></span><br><span class="line">    xpt2046_wirte_data(cmd);<span class="comment">//发送命令字</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">6</span>; i&gt;<span class="number">0</span>; i--);<span class="comment">//延时等待转换结果</span></span><br><span class="line">    CLK = <span class="number">0</span>;</span><br><span class="line">    _nop_();</span><br><span class="line">    CLK = <span class="number">1</span>;<span class="comment">//发送一个时钟， 清除 BUSY</span></span><br><span class="line">    _nop_();</span><br><span class="line">    adc_value=xpt2046_read_data();</span><br><span class="line">    CS = <span class="number">1</span>;<span class="comment">//关闭 XPT2046</span></span><br><span class="line">    <span class="keyword">return</span> adc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面 XPT2046 时序图可知， XPT2046 完成一个完整的转换需要 24 个串行时钟， 也就是需要 3 个字节的 SPI 时钟。 XPT2046 前 8 个串行时钟， 是接收 1 个字节的转换命令， 接收到转换命令了之后， 然后使用 1 个串行时钟的时间来完成数据转换（当然在编写程序的时候， 为了得到精确的数据， 你可以适当的延时一下） ， 然后返回 12 个字节长度（12 个字节长度也计时 12 个串行时钟） 的转换结果。 然后最后 4 个串行时钟返回 4 个无效数据， 可以忽略。xpt2046_read_adc_value 函数就是按照这个时序实现。 至于xpt2046_wirte_data 和 xpt2046_read_data 函数是 IO 口模拟的 SPI 读写时序，与 DS1302 的读写是一样的。  </p><p>上述代码使用的管脚在 xpt2046 头文件已定义， 这里就不列出。  </p><h5 id="主函数-3"><a href="#主函数-3" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： ADC 模数转换实验--电位器电压采集</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， 数码管上显示 AD 模块采集电位器的电压值</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;smg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xpt2046.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 adc_value=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> adc_vol;<span class="comment">//ADC 电压值</span></span><br><span class="line">    u8 adc_buf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        adc_value=xpt2046_read_adc_value(<span class="number">0x94</span>);<span class="comment">//测量电位器</span></span><br><span class="line">        adc_vol=<span class="number">5.0</span>*adc_value/<span class="number">4096</span>;<span class="comment">//将读取的 AD 值转换为电压</span></span><br><span class="line">        adc_value=adc_vol*<span class="number">10</span>;<span class="comment">//放大 10 倍， 即保留小数点后一位</span></span><br><span class="line">        adc_buf[<span class="number">0</span>]=gsmg_code[adc_value/<span class="number">10</span>]|<span class="number">0x80</span>;</span><br><span class="line">        adc_buf[<span class="number">1</span>]=gsmg_code[adc_value%<span class="number">10</span>];</span><br><span class="line">        adc_buf[<span class="number">2</span>]=<span class="number">0x3e</span>;<span class="comment">//显示单位 V</span></span><br><span class="line">        smg_display(adc_buf,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数代码非常简单， 首先调用外设头文件， 然后定义一些变量存储 AD 值和电压值， 进入 while 循环， 读取电位器的 AD 值， 根据 XPT2046 单端模式输入配置表可知， 要采集 X+脚通道的信号， 则配置值为 0X94。 得到 AD 值后， 可按照如下公式计算电压值： Vref*ADC_Value/分辨率。  </p><p>其中 Vref 是参考电压， XPT2046 接入的是 5V， ADC_Value 是读取的 AD 值，分辨率是 ADC 的位数（212=4096） 。  </p><p>经过公式计算后会得到小数， 所以定义了一个 float 型变量 adc_vol 存储，然后将该值放大 10 倍， 目的是保留小数后一位。 最后将得到的电压值转换为数码管段码数据显示。  </p><h4 id="实验现象-12"><a href="#实验现象-12" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 数码管上显示 AD 模块采集电位器的电压值。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619090932392.png" alt="image-20230619090932392"></p><p>注意： 调节电位器 AD1 时， 数码管上显示的电压值也将变化。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230619090943449.png" alt="image-20230619090943449"></p><p>对于光敏电阻和热敏电阻以及 AIN3 外部采集通道实验， 大家可以直接打开实验工程， 它们与电位器电压采集程序相比仅仅是配置命令不同而已。  </p><p>==电位器对应的采集通道命令： 0X94==<br>==光敏电阻对应的采集通道命令： 0XA4==<br>==热敏电阻对应的采集通道命令： 0XD4==<br>==外部输入 AIN3 对应的采集通道命令： 0XE4==</p><h3 id="DAC数模转换实验"><a href="#DAC数模转换实验" class="headerlink" title="DAC数模转换实验"></a>DAC数模转换实验</h3><p>在前面章节， 我们介绍了如何使用 51 单片机来采集外部模拟信号， 这一章来介绍下如何使用 51 单片机输出模拟信号， 要让 51 单片机输出模拟信号， 同样需要相应的转换器， 这种转换器我们称之为 DAC 数模转换器， 但 DAC 专用芯片价格是比较高的， 在实际应用中通常使用 PWM 技术来模拟 DAC 输出。 我们开发板上集成了一个 DAC(PWM)模块电路， 通过单片机 IO 口生成 PWM 波来模拟 DAC 输出。本章要实现的功能是： 系统运行时， DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果，由暗变亮再由亮变暗。 学习本章可以参考前面的实验章节内容。   </p><h4 id="DAC介绍"><a href="#DAC介绍" class="headerlink" title="DAC介绍"></a>DAC介绍</h4><h5 id="DAC简介"><a href="#DAC简介" class="headerlink" title="DAC简介"></a>DAC简介</h5><p>DAC（Digital to analog converter） 即数字模拟转换器， 它可以将数字信号转换为模拟信号。 它的功能与 ADC 相反。 在常见的数字信号系统中， 大部分传感器信号被转化成电压信号， 而 ADC 把电压模拟信号转换成易于计算机存储、处理的数字编码， 由计算机处理完成后， 再由 DAC 输出电压模拟信号， 该电压模拟信号常常用来驱动某些执行器件， 使人类易于感知。 如音频信号的采集及还原就是这样一个过程。</p><p>DAC 的主要技术指标如下：</p><p>（1）分辨率</p><p>DAC 的分辨率是输入数字量的最低有效位（LSB） 发生变化时， 所对应的输出模拟量（电压或电流） 的变化量。 它反映了输出模拟量的最小变化值。 分辨率与输入数字量的位数有确定的关系， 可以表示成 FS /（2^n） 。 FS 表示满量程输入值， n 为二进制位数。 对于 5V 的满量程， 采用８ 位的 DAC 时， 分辨率为 5V/256 ＝19.5mV； 当采用 12 位的 DAC 时， 分辨率则为 5V/4096＝1.22mV。 显然， 位数越多分辨率就越高。  </p><p>（2）线性度</p><p>线性度（也称非线性误差） 是实际转换特性曲线与理想直线特性之间的最大偏差。 常以相对于满量程的百分数表示。 如±１ ％是指实际输出值与理论值之差在满刻度的±１ ％以内。  </p><p>（3）绝对精度和相对精度  </p><p>绝对精度（简称精度） 是指在整个刻度范围内， 任一输入数码所对应的模拟量实际输出值与理论值之间的最大误差。 绝对精度是由 DAC 的增益误差（当输入数码为全 1 时， 实际输出值与理想输出值之差） 、 零点误差（数码输入为全０ 时， DAC 的非零输出值） 、 非线性误差和噪声等引起的。 绝对精度（即最大误差） 应小于 1 个 LSB。 相对精度与绝对精度表示同一含义， 用最大误差相对于满刻度的百分比表示。</p><p>（4）建立时间</p><p>建立时间是指输入的数字量发生满刻度变化时， 输出模拟信号达到满刻度值的± 1/2LSB 所需的时间。 是描述 D/A 转换速率的一个动态指标。 根据建立时间的长短， 可以将 DAC 分成超高速（＜1μ S)、 高速（10～1μ S） 、 中速（100～10 μ S） 、 低速（≥100μ S） 几档。  </p><h5 id="DAC工作原理"><a href="#DAC工作原理" class="headerlink" title="DAC工作原理"></a>DAC工作原理</h5><p>了解了 DAC 基本概念及特性后， 再来看下其工作原理， 下面以Ｔ 型电阻网络DAC 来介绍。 其内部结构图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623113905674.png" alt="image-20230623113905674"></p><p>​                                DAC 输出电压计算公式： V0=Vref*z/256  </p><p>公式中的 z 表示单片机给的数字量， vref 为参考电压， 通常我们是接在系统电源上， 即 5V， 数值 256 表示 DAC 精度为 8 位。  </p><p>DAC 主要由数字寄存器、 模拟电子开关、 位权网络、 求和运算放大器和基准电压源（或恒流源） 组成。 用存于数字寄存器的数字量的各位数码， 分别控制对应位的模拟电子开关， 使数码为 1 的位在位权网络上产生与其位权成正比的电流值， 再由运算放大器对各电流值求和， 并转换成电压值。  </p><p>上述的模拟电子开关都分别接着一个分压的器件， 比如说电阻。 模拟开关的个数取决于 DAC 的精度。 那么 N 个电子开关就把基准电压分为 N 份（并不是平均分哦） ， 而这些开关根据输入的二进制每一位数据对应开启或者关闭， 把分压的器件上的电压引入输出电路中。  </p><h4 id="PWM介绍"><a href="#PWM介绍" class="headerlink" title="PWM介绍"></a>PWM介绍</h4><p>出于成本考虑， 在实际开发应用中， 使用较多的是通过 PWM 来模拟 DAC 输出。下面就先来了解下 PWM 相关概念。  </p><p>PWM 是 Pulse Width Modulation 的缩写， 中文意思就是脉冲宽度调制， 简称脉宽调制。 它是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术， 其控制简单、 灵活和动态响应好等优点而成为电力电子技术最广泛应用的控制方式， 其应用领域包括测量， 通信， 功率控制与变换， 电动机控制、 伺服控制、 调光、 开关电源， 甚至某些音频放大器， 因此学习 PWM 具有十分重要的现实意义。  </p><p>其实我们也可以这样理解， PWM 是一种对模拟信号电平进行数字编码的方法。 通过高分辨率计数器的使用， 方波的占空比被调制用来对一个具体模拟信号的电平进行编码。 PWM 信号仍然是数字的， 因为在给定的任何时刻， 满幅值的直流供电要么完全有(ON)， 要么完全无(OFF)。 电压或电流源是以一种通(ON)或断(OFF)的重复脉冲序列被加到模拟负载上去的。 通的时候即是直流供电被加到负载上的时候， 断的时候即是供电被断开的时候。 只要带宽足够， 任何模拟值都可以使用 PWM 进行编码。  </p><p>PWM 对应模拟信号的等效图， 如下图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114011095.png" alt="image-20230623114011095"></p><p>从图中可以看到， 上图 a 是一个正弦波即模拟信号， b 是一个数字脉冲波形即数字信号。 我们知道在计算机系统中只能识别是 1 和 0， 对于 51 单片机芯片， 要么输出高电平（5V） ， 要么输出低电平（0） ， 假如要输出 1.5V 的电压， 那么就必须通过相应的处理， 比如本章所要讲解的 PWM 输出， 其实从上图也可以看到， 只要保证数字信号脉宽足够就可以使用 PWM 进行编码， 从而输出1.5V的电压。</p><p>PWM 的输出其实就是对外输出脉宽可调（即占空比调节） 的方波信号， 信号频率是由 T 的值决定， 占空比由 C 的值决定。 其示意图如图所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114107284.png" alt="image-20230623114107284"></p><p>从上图中可以看到， PWM 输出频率是不变的， 改变的是 C 的值， 此值的改变将导致 PWM 输出信号占空比的改变。 占空比其实就是一个周期内高电平时间与周期的比值。 而频率的话可以使用 51 单片机的定时器确定。  </p><h4 id="硬件设计-18"><a href="#硬件设计-18" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：<br>（1） DAC(PWM)模块<br>下面来看下开发板上 DAC(PWM)模块电路， 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114148609.png" alt="image-20230623114148609"></p><p>从上图中可知， PWM 输出控制管脚接在单片机 P2.1 管脚上， DAC1 为 PWM 输出信号， 将其连接一个 LED， 这样可以通过指示灯的状态直观的反映出 PWM 输出电压值变化。 LM358 芯片与这些电容电阻构成了一个跟随电路， 即输入是多少，输出即为多大电压， 输出电压范围是 0-5V。 输出信号由 J52 端子的 DAC1 引出，在其端子上还有一个 AIN3 脚， 它是上一章介绍 ADC 时的外部模拟信号输入通道。  </p><p>如果使用短接片将 DAC1 和 AIN3 短接， 这样就可以使用 XPT2046 芯片采集检测PWM 输出信号。  </p><h4 id="软件设计-17"><a href="#软件设计-17" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗。  </p><p>程序框架如下：<br>（1） 编写 PWM 函数<br>（2） 编写主函数</p><p>本章软件的重点是如何让单片机 IO 口输出 PWM。 下面我们打开“\4—实验程序\1—基础实验\24-DAC 数模转换实验” 工程， 在 App 工程组中可以看到新添加了 pwm.c 文件（里面包含了 PWM 驱动程序） ， 还要包含对应的头文件路径。</p><p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p><h5 id="PWM实现函数"><a href="#PWM实现函数" class="headerlink" title="PWM实现函数"></a>PWM实现函数</h5><p>PWM 的实现均在 pwm.c 文件中， 代码如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"><span class="comment">//全局变量定义</span></span><br><span class="line">u8 gtim_h=<span class="number">0</span>;<span class="comment">//保存定时器初值高 8 位</span></span><br><span class="line">u8 gtim_l=<span class="number">0</span>;<span class="comment">//保存定时器初值低 8 位</span></span><br><span class="line">u8 gduty=<span class="number">0</span>;<span class="comment">//保存 PWM 占空比</span></span><br><span class="line">u8 gtim_scale=<span class="number">0</span>;<span class="comment">//保存 PWM 周期=定时器初值*tim_scale</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : pwm_init</span></span><br><span class="line"><span class="comment">* 函数功能 : PWM 初始化函数</span></span><br><span class="line"><span class="comment">* 输 入 : tim_h： 定时器高 8 位</span></span><br><span class="line"><span class="comment">tim_l： 定时器低 8 位</span></span><br><span class="line"><span class="comment">tim_scale： PWM 周期倍数： 定时器初值*tim_scale</span></span><br><span class="line"><span class="comment">duty： PWM 占空比（要小于等于 tim_scale）</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm_init</span><span class="params">(u8 tim_h,u8 tim_l,u16 tim_scale,u8 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    gtim_h=tim_h;<span class="comment">//将传入的初值保存在全局变量中， 方便中断函数继续调用</span></span><br><span class="line">    gtim_l=tim_l;</span><br><span class="line">    gduty=duty;</span><br><span class="line">    gtim_scale=tim_scale;</span><br><span class="line">    TMOD|=<span class="number">0X01</span>; <span class="comment">//选择为定时器 0 模式， 工作方式 1</span></span><br><span class="line">    TH0 = gtim_h; <span class="comment">//定时初值设置</span></span><br><span class="line">    TL0 = gtim_l;</span><br><span class="line">    ET0=<span class="number">1</span>;<span class="comment">//打开定时器 0 中断允许</span></span><br><span class="line">    EA=<span class="number">1</span>;<span class="comment">//打开总中断</span></span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//打开定时器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : pwm_set_duty_cycle</span></span><br><span class="line"><span class="comment">* 函数功能 : PWM 设置占空比</span></span><br><span class="line"><span class="comment">* 输 入 : duty： PWM 占空比（要小于等于 tim_scale）</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm_set_duty_cycle</span><span class="params">(u8 duty)</span></span><br><span class="line">&#123;</span><br><span class="line">    gduty=duty;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm</span><span class="params">(<span class="type">void</span>)</span> interrupt 1 <span class="comment">//定时器 0 中断函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> u16 time=<span class="number">0</span>;</span><br><span class="line">    TH0 = gtim_h; <span class="comment">//定时初值设置</span></span><br><span class="line">    TL0 = gtim_l;</span><br><span class="line">    time++;</span><br><span class="line">    <span class="keyword">if</span>(time&gt;=gtim_scale)<span class="comment">//PWM 周期=定时器初值*gtim_scale， 重新开始计数</span></span><br><span class="line">    time=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(time&lt;=gduty)<span class="comment">//占空比</span></span><br><span class="line">    PWM=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    PWM=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述代码主要是基于定时器实现 PWM 输出， PWM 初始化实际上为定时器 0 初始化， pwm_init 函数有 4 个入口参数， tim_h 和 tim_l 为定时器定时初值， 即进入中断时间； tim_scale 参数为 PWM 的周期倍数， 使用该值乘以定时器初值可得出 PWM 的周期； duty 参数为 PWM 占空比， 即一个周期内高电平所占的时间比例。在 pwm 初始化函数内， 将函数入口参数通过全局变量保存， 方便在后续中断函数内使用 。</p><p>pwm_set_duty_cycle 函数是占空比设置函数， 该函数有一个入口参数， 用于设置 PWM 占空比， 注意， 该值不能超过初始化中的 PWM 的周期倍数值。  </p><p>最后就是定时器 0 的中断服务函数， 在中断内定义了一个静态变量用于统计进入中断的次数时间， 当进入中断次数时间大于等于 gtim_scale 周期倍数， 则重新开始计数， 表示 PWM 周期为定时器初值*gtim_scale； 然后当计数次数时间小于等于设置的占空比次数时间， 则使对应 IO 输出高电平， 否则输出低电平。  </p><h5 id="主函数-4"><a href="#主函数-4" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： DAC 模数转换实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 dir=<span class="number">0</span>;<span class="comment">//默认为 0</span></span><br><span class="line">    u8 duty=<span class="number">0</span>;</span><br><span class="line">    pwm_init(<span class="number">0XFF</span>,<span class="number">0XF6</span>,<span class="number">100</span>,<span class="number">0</span>);<span class="comment">//定时时间为 0.01ms， PWM 周期是100*0.01ms=1ms， 占空比为 0%</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(dir==<span class="number">0</span>)<span class="comment">//当 dir 为递增方向</span></span><br><span class="line">      &#123;</span><br><span class="line">         duty++;<span class="comment">//占空比递增</span></span><br><span class="line">      <span class="keyword">if</span>(duty==<span class="number">70</span>)dir=<span class="number">1</span>;<span class="comment">//当到达一定值切换方向， 占空比最大能到 100， 但到达 70 左右再递增，</span></span><br><span class="line">    <span class="comment">//肉眼也分辨不出亮度变化</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        duty--;</span><br><span class="line">        <span class="keyword">if</span>(duty==<span class="number">0</span>)dir=<span class="number">0</span>;<span class="comment">//当到达一定值切换方向</span></span><br><span class="line">       &#125; </span><br><span class="line">    pwm_set_duty_cycle(duty);<span class="comment">//设置占空比</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);<span class="comment">//短暂延时， 让呼吸灯有一个流畅的效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主函数比较简单， 首先调用外设驱动头文件， 然后进入主函数初始化 PWM，将定时器设置为 0.01ms， 初值为 0XFFF6， 即每隔 0.01ms 进入一次中断。 PWM 周期倍数设置为 100， 即 PWM 周期为 1ms， 占空比设置为 0。 最后进入 while 循环，通过 dir 切换方向实现 duty 值的自增和自减来调节占空比， 将该值传入到占空比调节函数 pwm_set_duty_cycl。 为了使呼吸灯流畅， 每调节占空比短暂延时一下。  </p><h4 id="实验现象-13"><a href="#实验现象-13" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： DAC(PWM)模块上的指示灯 DA1 呈呼吸灯效果， 由暗变亮再由亮变暗。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114605939.png" alt="image-20230623114605939"></p><p>注意： ==实验中可通过 DA1 指示灯观察 PWM 输出， 也可使用万用表测量 DAC 和GND 电压， 观察电压变化==。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623114622424.png" alt="image-20230623114622424"></p><h3 id="LCD1602-液晶显示实验"><a href="#LCD1602-液晶显示实验" class="headerlink" title="LCD1602 液晶显示实验"></a>LCD1602 液晶显示实验</h3><p>在前面章节， 我们已经学习过几种显示装置， 例如静态数码管、 动态数码管、8*8LED 点阵、 串口通信。 使用它们可以直观显示一些字符数据， 但是它们也有各种局限性， 比如显示字符数据太少， 硬件设计复杂、 代码编写难度大等。 这一章就来介绍一种非常简单且常用的显示装置—LCD1602 液晶显示器， 使用它可以显示更多的字符数字。 我们开发板上集成了一个 LCD1602 液晶显示器接口， 将LCD1602 液晶对应插入即可。 本章要实现的功能是： 系统运行时， 在 LCD1602 液晶上显示字符信息。   </p><h4 id="LCD1602-介绍"><a href="#LCD1602-介绍" class="headerlink" title="LCD1602 介绍"></a>LCD1602 介绍</h4><h5 id="LCD1602-简介"><a href="#LCD1602-简介" class="headerlink" title="LCD1602 简介"></a>LCD1602 简介</h5><p>1602 液晶也叫 1602 字符型液晶， 它能显示 2 行字符信息， 每行又能显示 16个字符。 它是一种专门用来显示字母、 数字、 符号的点阵型液晶模块。 它是由若干个 5x7 或者 5x10 的点阵字符位组成， 每个点阵字符位都可以用显示一个字符，每位之间有一个点距的间隔， 每行之间也有间隔， 起到了字符间距和行间距的作用， 正因为如此， 所以它不能很好的显示图片。 其实物图如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204441951.png" alt="image-20230623204441951"></p><p>大家手上拿到的 LCD1602 外观可能和上图不一样， 这是由于不同厂家设计所致， 但使用方法是一样的。 在上图中可以看到有 16 个管脚孔， 从左至右管脚编号顺序是 1-16， 其功能定义如下所示：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204454458.png" alt="image-20230623204454458"></p><p>下面对几个管脚做下说明：</p><p>3 脚： VL， 液晶显示偏压信号， 用于调整 LCD1602 的显示对比度， 一般会外接电位器用以调整偏压信号， 注意此脚电压为 0 时可以得到最强的对比度。</p><p>4 脚： RS， 数据/命令选择端， 当此脚为高电平时， 可以对 1602 进行数据字节的传输操作， 而为电平时， 则是进行命令字节的传输操作。 命令字节， 即是用来对 LCD1602 的一些工作方式作设置的字节； 数据字节， 即使用以在 1602 上显示的字节。 值得一提的是， LCD1602 的数据是 8 位的。 </p><p>5 脚： R/W， 读写选择端。 当此脚为高电平可对 LCD1602 进行读数据操作，反之进行写数据操作。</p><p>6 脚： E， 使能信号， 其实是 LCD1602 的数据控制时钟信号， 利用该信号的上升沿实现对 LCD1602 的数据传输。</p><p>7~14 脚： 8 位并行数据口， 而 51 单片机一组 IO 也是 8 位， 使得对 LCD1602的数据读写大为方便。</p><p>在 LCD1602 内部含有 80 个字节的 DDRAM， 它是用来寄存显示字符的。 其地址和屏幕的对应关系如下表</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204540896.png" alt="image-20230623204540896"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204545684.png" alt="image-20230623204545684"></p><p>从上图可知， 不是所有的地址都可以直接用来显示字符数据， 只有第一行中的 00-0F， 第二行中的 40-4F 才能显示， 其他地址只能用于存储。 要显示字符时要先输入显示字符地址， 也就是告诉模块在哪里显示字符， 例如第二行第一个字符的地址是 40H， 那么是否直接写入 40H 就可以将光标定位在第二行第一个字符的位置呢？ 这样不行， 因为写入显示地址时要求最高位 D7 恒定为高电平 1所以实际写入的数据应该是 01000000B(40H） +10000000B(80H)=11000000B(C0H)。 在 1602 中我们就用前 16 个就行了。 第二行也一样用前 16 个地址。  </p><h5 id="LCD1602-常用指令"><a href="#LCD1602-常用指令" class="headerlink" title="LCD1602 常用指令"></a>LCD1602 常用指令</h5><p>在使用 LCD1602 时， 我们需要掌握一些常用的指令， 这些指令对于 LCD1602初始化是必须的。  </p><p>（1） 清屏指令  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204707058.png" alt="image-20230623204707058"></p><p>功能：</p><p><1> 清除液晶显示器， 即将 DDRAM 的内容全部填入”空白”的 ASCII 码 20H;</p><p><2> 光标归位， 即将光标撤回液晶显示屏的左上方;</p><p><3> 将地址计数器(AC)的值设为 0。</p><p>（2） 模式设置指令  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204731208.png" alt="image-20230623204731208"></p><p>功能：<br>设定每次写入 1 位数据后光标的移位方向， 并且设定每次写入的一个字符是否移动。<br>I/D： 0=写入新数据后光标左移 1=写入新数据后光标右移<br>S： 0=写入新数据后显示屏不移动 1=写入新数据后显示屏整体右移 1 个字符</p><p>（3） 显示开关控制指令</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623204755334.png" alt="image-20230623204755334"></p><p>功能：<br>控制显示器开/关、 光标显示/关闭以及光标是否闪烁。</p><p>D： 0=显示功能关     1=显示功能开</p><p>C： 0=无光标            1=有光标</p><p>B： 0=光标闪烁         1=光标不闪烁</p><p>（4） 功能设定指令</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205053609.png" alt="image-20230623205053609"></p><p>功能：<br>设定数据总线位数、 显示的行数及字型。</p><p>DL： 0=数据总线为 4 位          1=数据总线为 8 位<br>N：   0=显示 1 行                     1=显示 2 行<br>F：   0=5× 7 点阵/每字符         1=5× 10 点阵/每字符</p><h5 id="LCD1602-使用"><a href="#LCD1602-使用" class="headerlink" title="LCD1602 使用"></a>LCD1602 使用</h5><p>要使用 LCD1602， 首先需要对其初始化， 即通过写入一些特定的指令实现。然后选择要在 LCD1602 的哪个位置显示并将所要显示的数据发送到 LCD 的DDRAM。 使用 LCD1602 通常都是用于写数据进去， 很少使用读功能。 LCD1602 操作步骤如下所示  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1） 初始化</span><br><span class="line">（2） 写命令（RS=L） ， 设置显示坐标</span><br><span class="line">（3） 写数据（RS=H）</span><br></pre></td></tr></table></figure><p>在此， 不需要读出它的数据的状态或者数据本身。 所以只需要看两个写时序：  </p><p>①当要写指令字， 设置 LCD1602 的工作方式时： 需要把 RS 置为低电平， RW置为低电平， 然后将数据送到数据口 D0~D7， 最后 E 引脚一个高脉冲将数据写入。  </p><p>②当要写入数据字， 在 1602 上实现显示时： 需要把 RS 置为高电平， RW 置为低电平， 然后将数据送到数据口 D0~D7， 最后 E 引脚一个高脉冲将数据写入。  </p><p>写指令和写数据， 差别仅仅在于 RS 的电平不一样而已。 以下是 LCD1602 的时序图：  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205825355.png" alt="image-20230623205825355"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623205830257.png" alt="image-20230623205830257"></p><p>从上图可以看到， 以上给的时间参数全部是 ns 级别的， 而 51 单片机的机器周期是 1us， 指令周期是 2-4 个机器周期， 所以即便在程序里不加延时程序， 也可以很好的配合 LCD1602 的时序要求了。  </p><p>当要写命令字节的时候， 时间由左往右， RS 变为低电平， R/W 变为低电平，注意看是 RS 的状态先变化完成。 然后这时， DB0~DB7 上数据进入有效阶段， 接着 E 引脚有一个整脉冲的跳变， 接着要维持时间最小值为 tpw=400ns 的 E 脉冲宽度。然后E引脚负跳变， RS电平变化， R/W 电平变化。这样便是一个完整的LCD1602写命令的时序。  </p><p>注意： 这里介绍的是 8 位 LCD1602， 现在某些公司为简化引脚数， 使用 4 位LCD1602。 使用 4 位 LCD1602 时， 应该多看手册， 找到不同点， 对原有程序加以修改。 我们例程也做了 4 位和 8 位 LCD1602 的兼容， 具体后面会介绍。  </p><p>至此， 我们就把 LCD1602 介绍完了， 大家如果想要更详细的了解它， 可以查看资料“\6—芯片资料\开发板芯片数据手册\LCD1602 液晶完整中文资料.pdf”。  </p><h4 id="硬件设计-19"><a href="#硬件设计-19" class="headerlink" title="硬件设计"></a>硬件设计</h4><p>本实验使用到硬件资源如下：</p><p>（1） LCD1602 液晶</p><p>开发板上集成了一个 LCD1602 液晶接口， 下面来看下开发板上 LCD1602 液晶接口电路， 如下图所示：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623210233002.png" alt="image-20230623210233002"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623210237507.png" alt="image-20230623210237507"></p><p>从上图中可知， LCD1602 的 8 位数据口 DB0-DB7 与单片机的 P0.0-P0.7 管脚连接， LCD1602 的 RS、 RW、 E 脚与单片机的 P2.6、 P2.5、 P2.7 管脚连接。 RJ1是一个电位器， 用来调节 LCD1602 对比度即显示亮度。  </p><p>注意： 这里原理图是使用的 8 位 LCD1602 接口设计， 是可以兼容 4 位 LCD1602的。 对于非标准接口的 LCD1602， 我们也会通过转接板将其转接为对应开发板接口的。 对于 4 位 LCD1602 在传输数据的时候需要将 8 位的数据截成两段， 先发送高四位， 在发送低四位。 其它引脚操作方法不变。  </p><h4 id="软件设计-18"><a href="#软件设计-18" class="headerlink" title="软件设计"></a>软件设计</h4><p>本章所要实现的功能是： 在 LCD1602 液晶上显示字符信息。<br>程序框架如下：<br>（1） 编写 LCD1602 显示函数<br>（2） 编写主函数</p><p>本章软件的重点是如何对 LCD1602 进行写命令和数据。 下面我们打开“\4—实验程序\1—基础实验\25-LCD1602 液晶显示实验” 工程， 在 App 工程组中可以看到新添加了 lcd1602.c 文件（里面包含了 LCD1602 驱动程序） ， 还要包含对应的头文件路径。</p><p>这里我们分析几个重要函数， 其他部分程序大家可以打开工程查看。</p><h5 id="LCD1602-驱动函数"><a href="#LCD1602-驱动函数" class="headerlink" title="LCD1602 驱动函数"></a>LCD1602 驱动函数</h5><p>打开lcd1602.c文件，代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_write_cmd</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 写命令</span></span><br><span class="line"><span class="comment">* 输 入 : cmd： 指令</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_cmd</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">0</span>;<span class="comment">//选择命令</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=cmd;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//4 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_cmd</span><span class="params">(u8 cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">0</span>;<span class="comment">//选择命令</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=cmd;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">    LCD1602_DATAPORT=cmd&lt;&lt;<span class="number">4</span>;<span class="comment">//准备命令</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_write_data</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 写数据</span></span><br><span class="line"><span class="comment">* 输 入 : dat： 数据</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">1</span>;<span class="comment">//选择数据</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=dat;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_write_data</span><span class="params">(u8 dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    LCD1602_RS=<span class="number">1</span>;<span class="comment">//选择数据</span></span><br><span class="line">    LCD1602_RW=<span class="number">0</span>;<span class="comment">//选择写</span></span><br><span class="line">    LCD1602_E=<span class="number">0</span>;</span><br><span class="line">    LCD1602_DATAPORT=dat;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">    LCD1602_DATAPORT=dat&lt;&lt;<span class="number">4</span>;<span class="comment">//准备数据</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">1</span>;<span class="comment">//使能脚 E 先上升沿写入</span></span><br><span class="line">    delay_ms(<span class="number">1</span>);</span><br><span class="line">    LCD1602_E=<span class="number">0</span>;<span class="comment">//使能脚 E 后负跳变完成写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_init</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 初始化</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)<span class="comment">//8 位 LCD</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x38</span>);<span class="comment">//数据总线 8 位， 显示 2 行， 5*7 点阵/字符</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x0c</span>);<span class="comment">//显示功能开， 无光标， 光标闪烁</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x06</span>);<span class="comment">//写入新数据后光标右移， 显示屏不移动</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x28</span>);<span class="comment">//数据总线 4 位， 显示 2 行， 5*7 点阵/字符</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x0c</span>);<span class="comment">//显示功能开， 无光标， 光标闪烁</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x06</span>);<span class="comment">//写入新数据后光标右移， 显示屏不移动</span></span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);<span class="comment">//清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_clear</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 清屏</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_write_cmd(<span class="number">0x01</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : lcd1602_show_string</span></span><br><span class="line"><span class="comment">* 函数功能 : LCD1602 显示字符</span></span><br><span class="line"><span class="comment">* 输 入 : x,y： 显示坐标， x=0~15， y=0~1;</span></span><br><span class="line"><span class="comment">         str： 显示字符串</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd1602_show_string</span><span class="params">(u8 x,u8 y,u8 *str)</span></span><br><span class="line">&#123;</span><br><span class="line">   u8 i=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span>(y&gt;<span class="number">1</span>||x&gt;<span class="number">15</span>)<span class="keyword">return</span>;<span class="comment">//行列参数不对则强制退出</span></span><br><span class="line">   <span class="keyword">if</span>(y&lt;<span class="number">1</span>) <span class="comment">//第 1 行显示</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">while</span>(*str!=<span class="string">&#x27;\0&#x27;</span>)<span class="comment">//字符串是以&#x27;\0&#x27;结尾， 只要前面有内容就显示</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">16</span>-x)<span class="comment">//如果字符长度超过第一行显示范围， 则在第二行继续显示</span></span><br><span class="line">&#123;</span><br><span class="line">lcd1602_write_cmd(<span class="number">0x80</span>+i+x);<span class="comment">//第一行显示地址设置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lcd1602_write_cmd(<span class="number">0x40</span>+<span class="number">0x80</span>+i+x<span class="number">-16</span>);<span class="comment">//第二行显示地址设置</span></span><br><span class="line">&#125;</span><br><span class="line">lcd1602_write_data(*str);<span class="comment">//显示内容</span></span><br><span class="line">str++;<span class="comment">//指针递增</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//第 2 行显示</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">while</span>(*str!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">16</span>-x) <span class="comment">//如果字符长度超过第二行显示范围， 则在第一行继续显示</span></span><br><span class="line">    &#123;</span><br><span class="line">lcd1602_write_cmd(<span class="number">0x80</span>+<span class="number">0x40</span>+i+x);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">lcd1602_write_cmd(<span class="number">0x80</span>+i+x<span class="number">-16</span>);</span><br><span class="line">&#125;</span><br><span class="line">lcd1602_write_data(*str);</span><br><span class="line">str++;</span><br><span class="line">i++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在代码中可以看到有如下格式：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (LCD1602_4OR8_DATA_INTERFACE==0)</span></span><br><span class="line">...（省略内容 <span class="number">1</span>）</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...（省略内容 <span class="number">2</span>）</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这是 C 语言中的条件编译， 如果 LCD1602_4OR8_DATA_INTERFACE 值等于 0，则执行省略内容 1 部分， 否则执行省略内容 2 部分， 这个和 if…else 是类似的。而 LCD1602_4OR8_DATA_INTERFACE 是在 lcd1602.h 中定义好的宏， 用于选择使用的 LCD1602 是 8 位数据口还是 4 位数据口， 通过这个宏就可以兼容 8 位和 4 位 2款 LCD1602 驱动， 非常方便。 如果大家觉得代码过长， 可以将兼容的一块去掉，这样代码就简短明了。  </p><p>lcd1602_write_cmd 函数是 LCD1602 写命令， lcd1602_write_data 函数是LCD1602 写数据， 它们之间的区别仅在于控制脚 RS 的值， 如果为 0 则写命令，为 1 则写数据。 对于 8 位数据和 4 位数据口的驱动， 不同之处在于 8 位数据是一次性传输到端口， 而 4 位数据口需要将一个字节数据分两次传输， 高 4 位和低 4位。  </p><p>lcd1602_init 函数是 LCD1602 初始化函数， 根据其命令设置相应的值， 开启LCD1602 显示。  </p><p>lcd1602_clear 函数是 LCD1602 清屏函数， 实际上也是调用lcd1602_write_cmd 函数写 0X01 命令。  </p><p>lcd1602_show_string 函数是 LCD1602 显示字符函数， 该函数有 3 个入口参数， x 和 y 用来确定显示的坐标， x 范围是 0-15， y 范围是 0-1。 str 参数是一个指针类型变量， 用于传递显示的内容。 函数内首先判断 xy 坐标是否有效， 无效则强制退出， 然后根据 xy 值在对应的坐标位置显示内容  </p><h5 id="主函数-5"><a href="#主函数-5" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">实验名称： LCD1602 液晶显示实验</span></span><br><span class="line"><span class="comment">接线说明：</span></span><br><span class="line"><span class="comment">实验现象： 下载程序后， LCD1602 上显示字符信息</span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;public.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd1602.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">* 函 数 名 : main</span></span><br><span class="line"><span class="comment">* 函数功能 : 主函数</span></span><br><span class="line"><span class="comment">* 输 入 : 无</span></span><br><span class="line"><span class="comment">* 输 出 : 无</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    lcd1602_init();<span class="comment">//LCD1602 初始化</span></span><br><span class="line">    lcd1602_show_string(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;Hello World!&quot;</span>);<span class="comment">//第一行显示</span></span><br><span class="line">    lcd1602_show_string(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;0123456789&quot;</span>);<span class="comment">//第二行显示</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数代码非常简单， 首先调用外设驱动头文件， 然后进入 main 函数初始化 LCD1602， 并调用 LCD1602 显示函数让第一行显示”Hello World!”， 第二行显示”0123456789”。  </p><p>这里说明下， 在开发中通常会显示数值， 比如温度数据， 程序中我们获取的温度数据通常存储在 float 变量中， 并非字符串， 此时需要想办法将 float 变量中的值转换为字符串， 比如 float temp=31.2， 那么我们可以再定义一个数组temp_buf[]用于保存 temp 中的每一个位， 操作如下：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temp=<span class="number">31.2</span>;</span><br><span class="line">u8 temp_buf[<span class="number">5</span>];</span><br><span class="line">u16 temp_value=temp*<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">temp_buf[<span class="number">0</span>]=temp_value/<span class="number">100</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">1</span>]=temp_value%<span class="number">100</span>/<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">2</span>]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">temp_buf[<span class="number">3</span>]=temp_value%<span class="number">100</span>%<span class="number">10</span>+<span class="number">0x30</span>;</span><br><span class="line">temp_buf[<span class="number">4</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">lcd1602_show_string(<span class="number">0</span>,<span class="number">0</span>,temp_buf);</span><br></pre></td></tr></table></figure><p>将浮点数转换为整型变量， 然后将整型值的每一个位取出来存储在数组temp_buf 中， 细心的朋友会发现取出的每一位后面加了 0X30， 这个值是将数字0-9 转换为 ASCII 码， 因为液晶是以 ASCII 码显示的。 最后一个数组元素赋值了’ \0’ ， 这是为了让 LCD1602 显示函数知道数组内结束位置。  </p><p>根据 C 语言指针的特点， 此时调用 LCD1602 显示函数时， 只需要将数组名传递进去即可， 因为数组名即为该数组的起始地址， 然后显示函数内部通过指针访问数组的每一位。  </p><h4 id="实验现象-14"><a href="#实验现象-14" class="headerlink" title="实验现象"></a>实验现象</h4><p>使用 USB 线将开发板和电脑连接成功后（电脑能识别开发板上 CH340 串口） ，把编译后产生的.hex 文件烧入到芯片内， 实现现象如下： 在 LCD1602 液晶上显示字符信息。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623212156893.png" alt="image-20230623212156893"></p><p>注意： LCD1602 液晶要正确插入到 LCD1602 接口 J2 位置， 插反或差错都会导致显示不正常。 如果出现显示看不清， 可调节板子 LCD1602 接口下的 RJ1 电位器。 如果 LCD1602 无法显示， 可重启电源或复位  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230623212213060.png" alt="image-20230623212213060"></p>]]></content>
      
      
      <categories>
          
          <category> 51单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程模板</title>
      <link href="/2023/11/22/%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/11/22/%E7%BC%96%E7%A8%8B%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="c文件"><a href="#c文件" class="headerlink" title=".c文件"></a>.c文件</h3><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    main.c </span></span><br><span class="line"><span class="comment">  * @author  快乐6+1</span></span><br><span class="line"><span class="comment">  * @date    </span></span><br><span class="line"><span class="comment">  * @project 模块化编程</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/* Includes     ----------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------------------------------说明 -----------------------------------------</span></span><br><span class="line"><span class="comment">1、 单片机型号  -&gt; </span></span><br><span class="line"><span class="comment">2、 系统时钟     -&gt; </span></span><br><span class="line"><span class="comment">3、 复位           -&gt; </span></span><br><span class="line"><span class="comment">4、 MyPrintf    -&gt; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5、 定时器0      -&gt; </span></span><br><span class="line"><span class="comment">6、 串口1         -&gt; </span></span><br><span class="line"><span class="comment">6、 串口2         -&gt; </span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   main</span></span><br><span class="line"><span class="comment">* @brief  主函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   </span></span><br><span class="line"><span class="comment">* @brief  </span></span><br><span class="line"><span class="comment">* @param  </span></span><br><span class="line"><span class="comment">* @retval       </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h3><p>MyApplication.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MyApplication_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MyApplication_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __x_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __x_H__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/2023/11/20/Android/"/>
      <url>/2023/11/20/Android/</url>
      
        <content type="html"><![CDATA[<p>先随便学学了解一下，主要是为了期末考试，但是后面做手机程序控制单片机也能用到，后期用到在认真学吧</p><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><div class="table-container"><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>layout_width</td><td>组件的宽度</td></tr><tr><td>layout_height</td><td>组件的高度</td></tr><tr><td>id</td><td>为TextView设置一个组件id</td></tr><tr><td>text</td><td>设置显示的文本内容</td></tr><tr><td>textColor</td><td>设置字体颜色</td></tr><tr><td>textStyle</td><td>设置字体风格，三个可选值: normal(无效果) bold(加粗) italic(斜体）</td></tr><tr><td>textSize</td><td>字体大小，单位一般是用sp</td></tr><tr><td>background</td><td>控件的背景颜色，可以理解为填充整个控件的颜色，可以是图片</td></tr><tr><td>gravityr</td><td>设置控件中因容的对齐方向，TextView中是文字，lmageView中是图片等等</td></tr><tr><td>layout_marginLeft</td><td>左对齐</td></tr></tbody></table></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span>  <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;italic&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="文件定义"><a href="#文件定义" class="headerlink" title="文件定义"></a>文件定义</h4><h5 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h5><p>颜色在这里自己定义</p><p>十六进制的前缀，前边的两个ff表示颜色的透明度，范围为00～ff，其中00表示全透明，ff表示不透明。后面的六位ff00ff表示颜色色值。表示颜色的三原色蓝绿红，请注意颜色表示一定是八位的十六进制数字。请大家理解其中八位数字各自的含义。</p><div class="table-container"><table><thead><tr><th>透明度</th><th>对应十六进制</th></tr></thead><tbody><tr><td>100%</td><td>ff</td></tr><tr><td>90%</td><td>e6</td></tr><tr><td>85%</td><td>d9</td></tr><tr><td>80%</td><td>cc</td></tr><tr><td>70%</td><td>b3</td></tr><tr><td>60%</td><td>99</td></tr><tr><td>50%</td><td>80</td></tr><tr><td>40%</td><td>66</td></tr><tr><td>30%</td><td>4d</td></tr><tr><td>20%</td><td>33</td></tr><tr><td>15%</td><td>26</td></tr><tr><td>10%</td><td>1a</td></tr><tr><td>5%</td><td>0d</td></tr><tr><td>0%</td><td>00</td></tr></tbody></table></div><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/image-20230919170230054.webp" alt=""></p><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>字体文件在这里定义</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/2.webp" alt=""></p><p>可以看到预览效果是这样的</p><p><img src="C:\Users\Y\Pictures\Camera Roll\2.png" alt="image-20230919172554218"></p><p>但是这里获取了id后，运行会覆盖掉之前设置的文本</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919172617772.png" alt="image-20230919172617772"></p><p>代码效果</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919172741153.png" alt="image-20230919172741153"></p><h4 id="带阴影的TextView"><a href="#带阴影的TextView" class="headerlink" title="带阴影的TextView"></a>带阴影的TextView</h4><p>==<strong>android:shadowColor</strong>==:设置阴影颜色,需要与shadowRadius一起使用<br><strong>==android:shadowRadius==</strong>:设置阴影的模糊程度,设为0.1就变成字体颜色了,建议使用3.0<br><strong>==android:shadowDx==</strong> :设置阴影在水平方向的偏移,就是水平方向阴影开始的横坐标位置<br>==<strong>android:shadowDy</strong>== :设置阴影在竖直方向的偏移,就是竖直方向阴影开始的纵坐标位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textStyle</span>=<span class="string">&quot;italic&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowColor</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:shadowRadius</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowDx</span>=<span class="string">&quot;10.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:shadowDy</span>=<span class="string">&quot;10.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">   /&gt;</span></span><br></pre></td></tr></table></figure><p>效果</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919174550907.png" alt="image-20230919174550907"></p><h4 id="跑马灯效果的TextView"><a href="#跑马灯效果的TextView" class="headerlink" title="跑马灯效果的TextView"></a>跑马灯效果的TextView</h4><p>android:singleLine:内容单行显示<br>android:focusable:是否可以获取焦点<br>android:focusablelnTouchMode:用于控制视图在触摸模式下是否可以聚焦<br>android:ellipsize:在哪里省略文本<br>android:marqueeRepeatLimit:字幕动画重复的次数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">&quot;@string/tv_one&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textColor</span>=<span class="string">&quot;@color/black&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textStyle</span>=<span class="string">&quot;italic&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:textSize</span>=<span class="string">&quot;30sp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shadowColor</span>=<span class="string">&quot;@color/red&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shadowRadius</span>=<span class="string">&quot;3.0&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shadowDx</span>=<span class="string">&quot;10.0&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shadowDy</span>=<span class="string">&quot;10.0&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:singleLine</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:ellipsize</span>=<span class="string">&quot;marquee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:marqueeRepeatLimit</span>=<span class="string">&quot;marquee_forever&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:focusable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:focusableInTouchMode</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:clickable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安卓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeRTOS</title>
      <link href="/2023/11/18/FreeRTOS/"/>
      <url>/2023/11/18/FreeRTOS/</url>
      
        <content type="html"><![CDATA[<p><code>注</code>：<strong>此教程代码笔记基于硬件家园，开发板是STM32ZET6。参考代码，请注意板子引脚</strong></p><hr><h1 id="系统简介与移植"><a href="#系统简介与移植" class="headerlink" title="系统简介与移植"></a>系统简介与移植</h1><h2 id="FreeRTOS简介"><a href="#FreeRTOS简介" class="headerlink" title="FreeRTOS简介"></a>FreeRTOS简介</h2><h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统是为了区别于通用的计算机操作系统，人们把嵌入到对象体系中，为实现对象体系智能化控制的计算机操作系统，称作嵌入式计算机操作系统，简称嵌入式操作系统。</p><p>嵌入式操作系统分类：</p><blockquote><p>① 按对外部事件的响应能力来分类，嵌入式操作系统分实时操作系统和分时操作系统。如果操作系统能及时的响应外部事件请求，并能控制所有实时设备和实时任务协调运行，且能在一个规定的时间内完成对事件的处理，那么这种系统就称为实时操作系统。如果操作系统按时间片轮转完成各个任务，任务没有优先级，这种系统就称为分时操作系统。</p><p>② 按时间的严格程度来分，实时操作系统又分为强实时操作系统和弱实时操作系统。系统必须在极其严格的时间内完成的任务叫做硬实时操作系统，比如飞机系统；如果不是很严格的话就是弱实时操作系统，比如信息采集系统。</p></blockquote><h3 id="FreeRTOS实时操作系统"><a href="#FreeRTOS实时操作系统" class="headerlink" title="FreeRTOS实时操作系统"></a>FreeRTOS实时操作系统</h3><p>FreeRTOS是一款开源免费的实时操作系统，商业使用的话不需要用户公开源代码，也不存在任何版权问题，是当前小型嵌入式操作系统市场使用率最高的。</p><p>FreeRTOS 的移植比较简单，只需要用户添加需要的源码文件，不需要做任何的底层工作，再添加几个宏定义即可，详情可以看第四节的手动移植FreeRTOS 操作系统。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_%201.webp" alt=""></p><h3 id="为什么选择FreeRTOS操作系统"><a href="#为什么选择FreeRTOS操作系统" class="headerlink" title="为什么选择FreeRTOS操作系统"></a>为什么选择FreeRTOS操作系统</h3><blockquote><p>①  开源免费；</p><p>②  简单易学；</p><p>③ 在RTOS中占有率最高；</p><p>④ FreeRTOS被移植到了很多不同的微处理器，比如STM32，极为方便；</p><p>⑤ 许多半导体厂商产品的SDK采用FreeRTOS，比如WIFI与蓝牙模块；</p><p>⑥ 许多软件厂商使用FreeRTOS作为本公司软件的操作系统，比如TouchGFX；</p></blockquote><h3 id="FreeRTOS特点"><a href="#FreeRTOS特点" class="headerlink" title="FreeRTOS特点"></a>FreeRTOS特点</h3><blockquote><p> ① 支持抢占式调度，合作式调度和时间片调度；</p><p>② 支持 35 种系统架构；</p><p>③ 设计的简单易用，典型的内核使用大小在 4k-9k；</p><p>④ 移植非常简单，代码主要用 C 编写；</p><p>⑤ 支持消息队列、二值信号量、计数信号量、递归信号量和互斥信号量、事件通知，可用于任务与任务间的消息传递和同步，任务与中断间的消息传递和同步；</p><p>⑥ 提供丰富的，配置好的工程例子；</p><p>⑦ 多个任务可以分配相同优先级，即支持时间片调度；</p><p>⑧  高效的软件定时器；</p><p>⑨ 强大的跟踪执行函数；</p><p>⑩ 任务优先级数量不限；</p><p>⑩① 任务的数量不限；</p><p>⑩② 开源免费  </p></blockquote><h2 id="裸机系统与多任务系统"><a href="#裸机系统与多任务系统" class="headerlink" title="裸机系统与多任务系统"></a>裸机系统与多任务系统</h2><h3 id="裸机系统"><a href="#裸机系统" class="headerlink" title="裸机系统"></a>裸机系统</h3><p>裸机编程时，先初始化相关的硬件，然后让主程序在一个死循环里面不断的循环，顺序地处理各种事件。 对于紧急事件，采用中断功能进行快速响应。</p><p><strong>伪代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//功能函数1</span></span><br><span class="line">        <span class="built_in">Fun_1</span>();</span><br><span class="line">        <span class="comment">//功能函数2</span></span><br><span class="line">        <span class="built_in">Fun_2</span>();</span><br><span class="line">        。。。        </span><br><span class="line">        <span class="comment">//功能函数n</span></span><br><span class="line">        <span class="built_in">Fun_n</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//中断函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>建议：</strong>对于工业与消费级产品，大部分采用裸机系统。采用硬件家园主推的面向对象编程思维和模块化编程技术，规范程序架构，采用结构体封装外设，程序方便阅读、修改与移植，提高开发效率的同时，降低维护程序的难度。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_2%20.webp" alt=""></p><h4 id="多任务系统"><a href="#多任务系统" class="headerlink" title="多任务系统"></a>多任务系统</h4><p>相比于裸机系统，多任务系统的事件处理是在任务中完成的，对于紧急事件，同样采用中断功能进行快速响应。</p><p>多任务系统通常包含多个任务，彼此独立，方便编程。 同时，任务具有优先级，高优先级任务可以打断低优先级任务，系统的实时性进一步得到提高。</p><p><strong>伪代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FreeRTOS初始化</span></span><br><span class="line">    <span class="built_in">FreeRTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FreeRTOS启动，开始任务调度，不再返回</span></span><br><span class="line">    <span class="built_in">FreeRTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中断函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//中断函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ISR_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//中断任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>引入操作系统后，在编程时不需要精心设计程序执行流，任务间不存在干扰，编程反而变得简单了。 </p><p>当然，系统需要占用一定的RAM与FLASH资源，如今的单片机，RAM与FLASH越来越大，为采用操作系统编程提供了便利。</p><h4 id="裸机系统与多任务系统对比"><a href="#裸机系统与多任务系统对比" class="headerlink" title="裸机系统与多任务系统对比"></a>裸机系统与多任务系统对比</h4><p>裸机系统与多任务系统各自具有优势，在各自的领域都具有应用价值，不能简单的说孰优孰劣，掌握后，根据产品功能合理选择。</p><p>裸机系统：工业产品与消费级用的非常多，特别是低端的单片机，必须采用裸机系统，采用模块化技术，编程也可以很方便</p><p>多任务系统：适合单片机高端，功能复杂的产品，多任务管理，编程简单很多。</p><p>两者对比：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_3.webp" alt="图片"></p><h2 id="初学FreeRTOS准备工作"><a href="#初学FreeRTOS准备工作" class="headerlink" title="初学FreeRTOS准备工作"></a>初学FreeRTOS准备工作</h2><p>搭建开发环境</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_4.webp" alt=""></p><p>下载安装STM32CubeMX和Keil</p><h2 id="手动移植FreeRTOS"><a href="#手动移植FreeRTOS" class="headerlink" title="手动移植FreeRTOS"></a>手动移植FreeRTOS</h2><p><strong>第一步：</strong>官网下载或qq群下载FreeRTOS源码</p><p>官网网址：<a href="https://www.freertos.org">https://www.freertos.org</a></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_18.webp" alt="图片"></p><p><strong>第二步：</strong>准备基础工程 - 使用HAL05 - LED流水灯，延时时钟基准由SysTick改到TIM2，删除主循环内的代码</p><p><strong>原因：</strong>FreeRTOS操作系统使用SysTick作为基准时钟</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_5.webp" alt="图片"></p><p><strong>第三步：</strong>将FreeROS源码添加至工程中，设置头文件路径，编译工程</p><p>① 将FreeRTOS源码复制到工程中， 另外，将portable与RVDS文件夹多余的文件删除</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_6.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_7.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_8.webp" alt="图片"></p><p>② Keil工程新建2个Groups - FreeRTOS/Source与FreeRTOS/Port，同时添加相应的文件</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_9.webp" alt="图片"></p><p>③ 添加头文件路径</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_10.webp" alt="图片"></p><p>④ 编译工程</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_11.webp" alt="图片"></p><p><strong>第四步：</strong>将FreeRTOSConfig.h文件(位于Demo - CORTEX_STM32F103_Keil工程中)添加至工程的MyApplication文件内， 方便打开与修改，同时添加至MyApplication文件组内，再次编译</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_12.webp" alt="图片"></p><p><strong>第五步：</strong>修改FreeRTOSConfig.h文件，是stm32f1xx_it.c文件，编译ok</p><p>① 修改FreeRTOSConfig.h文件，并编译</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_13.webp" alt="图片"></p><p>② 注释掉stm32f1xx_it.c文件的SVC，PendSV，Systick中断函数，编译ok</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_14.webp" alt="图片"></p><p><strong>第六步：</strong>工程添加MyTask.c文件，里面预先写好了3个任务，同时MyApplicatin.h头文件添加FreeRTOS与MyTask的头文件，编译ok</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_15.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_16.webp" alt="图片"></p><p>第七步：在main.c文件调用任务创建函数与系统调度函数，编译ok。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_17.webp" alt="图片"></p><p>第八步：将程序下载至STM32物联网实战板，正常运行。</p><p>LED1 - 间隔100ms 闪烁</p><p>LED2 - 间隔500ms 闪烁</p><p>LED3 - 间隔1000ms闪烁</p><p><strong>至此，手动移植完成。</strong></p><h2 id="STM32CubeMX生成FreeRTOS"><a href="#STM32CubeMX生成FreeRTOS" class="headerlink" title="STM32CubeMX生成FreeRTOS"></a>STM32CubeMX生成FreeRTOS</h2><p><strong>第二步：</strong>准备基础工程 - 使用HAL05 - LED流水灯，延时时钟基准由<code>SysTick</code>改到<code>TIM2</code></p><p><strong>原因：</strong>FreeRTOS操作系统使用<code>SysTick</code>作为基准时钟</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_5.webp" alt="图片"></p><p><strong>第三步：</strong>左侧选择Middleware选项卡，点击FERRRTOS，Interface选择CMSIS_V1，配置参数默认即可。</p><p>说明：</p><p>Disable   - 禁用FreeRTOS</p><p>CMSIS_V1 - CMSIS-RTOS版本为V1.02，一般选择这个</p><p>CMSIS_V2 - CMSIS-RTOS版本为V2.00，兼容更多的CPU架构，但代码量更大</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_20.webp" alt="图片"></p><p><strong>第四步：</strong>选择Tasks and Queue，修改默认任务<code>defaultTask</code>(双击进入编辑任务界面)，并额外添加LED2与LED3任务。</p><p>说明：</p><p>编辑任务时，软件要求不同位置不能使用同样的名称，因为任务名称设定为LED1_Task,任务函数设定为LED1</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_21.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_22.webp" alt="图片"></p><p><strong>第四步：</strong>保存工程，并生产代码，删除主循环内的代码，编译<code>keil</code>工程</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_23.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_24.webp" alt="图片"></p><p><strong>第五步：</strong>打开<code>freertos.c</code>文件，在LED1、LED2、LED3函数内添加代码，编译ok</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_25.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_26.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free1_27.webp" alt="图片"></p><p><strong>第六步：</strong>将程序下载至STM32物联网实战板，正常运行。</p><p>LED1 - 间隔100ms 闪烁</p><p>LED2 - 间隔500ms 闪烁</p><p>LED3 - 间隔1000ms闪烁</p><hr><h1 id="启动流程、编码风格与调试方法"><a href="#启动流程、编码风格与调试方法" class="headerlink" title="启动流程、编码风格与调试方法"></a>启动流程、编码风格与调试方法</h1><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>RTOS主要有两种比较流行的启动方式，下面会通过伪代码讲解两种启动方式的区别，然后看看STM32cubeMX集成的FreeRTOS采用哪种启动方式。</p><p>方法一：在main函数中将硬件初始化、RTOS系统初始化，同时创建所有任务，再启动RTOS调度器。</p><p><strong>伪代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTOS初始化</span></span><br><span class="line">    <span class="built_in">RTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//创建任务n</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//RTOS启动，开始任务调度，不再返回</span></span><br><span class="line">   <span class="built_in">RTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：在main函数中将硬件初始化、RTOS系统初始化，只创建一个启动任务，再启动RTOS调度器。 之后，在启动任务中创建各种应用任务，当所有任务创建完成，启动任务把自己删除。</p><p><strong>伪代码如下：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span></span></span><br><span class="line"></span><br><span class="line">#变量定义</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//硬件初始化</span></span><br><span class="line">    <span class="built_in">Hardware_Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTOS初始化</span></span><br><span class="line">    <span class="built_in">RTOS_Init</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(AppTaskCreate);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//RTOS启动，开始任务调度，不再返回</span></span><br><span class="line">   <span class="built_in">RTOS_Start</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//起始任务，在里面创建各种应用任务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AppTaskCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//创建任务1</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   。。。</span><br><span class="line">   <span class="comment">//创建任务n</span></span><br><span class="line">   <span class="built_in">RTOS_TaskCreate</span>(Task_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建完应用任务，删除自身，释放内存</span></span><br><span class="line">   <span class="built_in">RTOS_TaskDelate</span>(AppTaskCreate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务函数1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务1处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"><span class="comment">//任务函数n</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Task_n</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">   <span class="comment">//无限循环，不能返回</span></span><br><span class="line">   <span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//任务n处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>STM32cubeMX集成的FreeRTOS如下图，采用的是第一种启动方式。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_1.webp" alt="image-20231119203004873"></p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>如下图，FreeRTOS使用的数据类型虽然都是标准C的数据类型，但都进行了重定义，取了个新名字。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_2.webp" alt="image-20231119203315563"></p><p>需要注意的是，<code>char</code>数据类型可以通过keil指定了有符号或者无符号，默认为无符号。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_3.webp" alt="image-20231119203434375"></p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>在FreeRTOS中，定义变量时，把变量的类型作为前缀，方便用户通过变量即可知道变量的类型。  </p><p><code>char</code>变量的前缀是<code>c</code>，<code>short</code>变量的前缀是<code>s</code>，<code>long</code>变量的前缀是<code>l</code>，其它比如结构体、任务句柄等是<code>x</code>； </p><p>如果是无符号类型的，前缀再加<code>u</code>;</p><p>如果是指针变量，前缀再加<code>p</code>。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>   cTemp</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>    ucTemp</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*   pucTemp</span><br></pre></td></tr></table></figure><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>函数名包含了函数返回值的类型、函数所在的文件名以及函数的功能，如果是私有的函数，还会加<code>prv</code>前缀。   这种命名方式方便寻找函数定义并了解函数作用，值得借鉴。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">x <span class="title">TaskCreate</span><span class="params">()</span> <span class="comment">//函数的返回值为任务句柄，在Task.c中定义，作用是创建任务；</span></span></span><br><span class="line"><span class="function">v <span class="title">TaskPrioritySet</span><span class="params">()</span> <span class="comment">//函数的返回值为void，在Task.c中定义，作用是设置优先级；</span></span></span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>在FreeRTOS中，宏用大写字母表示，并配有小写字母作为前缀， 前缀用于指示该宏在哪个头文件定义。</p><p>举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">portMAX_DELAY,  <span class="comment">//位于portable.h；</span></span><br><span class="line">configUSE_PREEMPTION, <span class="comment">//位于FreeRTOSConfig.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此外，有几个通用的宏定义贯穿FreeRTOS的整个代码，都是表示0与1的宏，如下：</span></span><br><span class="line">pdTRUE    <span class="number">1</span></span><br><span class="line">pdFALSE   <span class="number">0</span></span><br><span class="line">pdPASS    <span class="number">1</span></span><br><span class="line">pdFAIL     <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><p>本节为大家介绍FreeRTOS的调试方法，主要是获取任务的执行情况，通过串口打印出来，方便后续的系统配置与优化工程，非常实用。</p><p>1、串口打印调试说明</p><p>为了了解任务的运行状态、任务栈的使用情况以及各个任务的 CPU 使用率，需要用到官方提供的两个函数 <code>vTaskList</code>和 <code>vTaskGetRunTimeStats</code>。</p><p>用户可以通过这两个函数获得任务信息，然后通过串口将其打印出来，当然，也可以通过任何其它方式将其显示出来。后续课程统一采用串口打印的方式显示任务信息。</p><p>2、定时器</p><p>为了获取 FreeRTOS 的任务信息，需要创建一个定时器，这个定时器的时间基准精度要高于系统时钟节拍，达到系统时钟节拍的10 ~ 20倍，这样得到的任务信息才准确。</p><p><strong>Note：</strong></p><blockquote><p>① <code>这种调试方式仅限调试、测试，实际项目中不要使用，因为这种测试方式比较影响系统实时性</code></p><p>② FreeRTOS 的系统内核没有对计数时间做溢出保护。 比如定时器周期为50us，最大支持计数时间：2^32 * 50us / 3600s =59.6 分钟。运行时间超过了 59.6 分钟将不准确。</p></blockquote><p>3、具体实现</p><p>学习FreeRTOS操作系统的目的是利用多任务功能更好的管理产品外设，因此调试代码将在STM32物联网实战项目HAL裸机开发整合代码工程上启用FreeRTOS操作系统，因为最后一讲包含了全部外设驱动函数，方便后续的调用。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_4.webp" alt="图片"></p><p>①、处理工程代码 - 删除裸机框架的代码(main.c，MyInit.c,callback.c与System.c文件)，系统运行指示灯关闭；</p><p>②、STM32CubeMX配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_5.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_6.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_7.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_8.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_9.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_10.webp" alt="图片"></p><p>③、完善keil工程代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_11.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_12.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_13.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_14.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free2_15.webp" alt="图片"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote><p> 开启定时器3，去main函数里写定时器的回调函数。我忘记写回调函数一直显示不出来运行状态。</p></blockquote><hr><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="系统配置说明"><a href="#系统配置说明" class="headerlink" title="系统配置说明"></a>系统配置说明</h2><p>实际应用FreeRTOS的时候，我们需要根据产品需求配置FreeRTOS，满足产品需求的同时，发挥FreeRTOS的最佳性能。</p><p>FreeRTOS的系统配置文件为<code>FreeRTOSConfig.h</code>，在此配置文件中可完成FreeRTOS的裁剪与配置。 <strong>初学的话，有个大概了解即可，随着后续的深入学习，再熟练设置每个配置选项。</strong></p><p><code>FreeRTOSConfig.h</code> 根据正在构建的应用程序定制 FreeRTOS 内核。因此，它特定于应用程序，而不是 FreeRTOS，并且应该位于应用程序目录中，而不是位于 FreeRTOS 内核源代码目录中。</p><p>另外，大部分配置选项在FreeRTOS.h文件中都有默认的配置，在应用时，把需要的配置选项放在<code>FreeRTOSConfig.h</code>文件即可。</p><p>关于系统配置，官网也有详细介绍</p><p>网址：<a href="http://www.freertos.org/a00110.html">http://www.freertos.org/a00110.html</a></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_1.webp" alt="image-20231119221626682"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_2.webp" alt="image-20231119221646921"></p><h2 id="“Config”开始的宏-内核配置"><a href="#“Config”开始的宏-内核配置" class="headerlink" title="“Config”开始的宏 - 内核配置"></a>“Config”开始的宏 - 内核配置</h2><p>STM32cubeMX中的配置：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_3.webp" alt="image-20231119221723257"></p><p><strong>configUSE_PREEMPTION</strong></p><blockquote><ul><li>配置为 1 </li></ul><p>使能抢占式调度器</p><ul><li>配置为 0 </li></ul><p>使能合作式调度器</p></blockquote><p><strong>configUSE_PORT_OPTIMISED_TASK_SELECTION</strong></p><blockquote><p> 此配置用于优化优先级列表中要执行的最高优先级任务的算法。对 CM 内核的移植文件，默认已经在文件 <code>portmacro.h</code> 文件中使能。</p><ul><li><p>通用方式—-配置为 0： </p><p>   所有平台的移植文件都可以配置为 0，因为这是通用方式。 </p><p>   纯 C 编写，比专用方式效率低。</p><p>   可用的优先级数量不限制。</p></li><li><p>专用方式—-配置为 1： </p><p>  部分平台支持。</p><p>  这些平台架构有专用的汇编指令，比如 CLZ（Count Leading Zeros）指令，通过这些指令可以加快算法执行速度。 </p><p>  比通用方式高效。</p><p>  有最大优先级数限制，通常限制为 32 个。</p></li></ul></blockquote><p><strong>configUSE_TICKLESS_IDLE</strong></p><blockquote><p>此配置用于使能 <code>tickless</code>低功耗模式</p><ul><li><p>配置为 1</p><p>  使能 <code>tickless</code>低功耗模式</p></li><li><p>配置为 0</p><p>  禁能 <code>tickless</code>低功耗模式</p></li></ul></blockquote><p><strong>configCPU_CLOCK_HZ</strong></p><blockquote><p>此参数用于定义 CPU 的主频，单位 Hz</p></blockquote><p><strong>configTICK_RATE_HZ</strong></p><blockquote><p>此参数用于定义系统时钟节拍数，单位 Hz，一般取 1000Hz 即可。本教程配套的例子也全部采用这个时钟节拍数。过高的的系统时钟节拍将使得 FreeRTOS 内核运行占用过多的时间，增加系统负荷</p></blockquote><p><strong>configMAX_PRIORITIES</strong></p><blockquote><p>此参数用于定义可供用户使用的最大任务优先级数，如果这个定义的是 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5，对于这一点，初学者要特别的注意。 </p></blockquote><p><strong>configMINIMAL_STACK_SIZE</strong></p><blockquote><p>此参数用于定义空闲任务的栈空间大小，单位字，即 4 字节。</p></blockquote><p><strong>configTOTAL_HEAP_SIZE</strong></p><blockquote><p>定义堆大小，FreeRTOS 内核，用户动态内存申请，任务栈，任务创建，信号量创建，消息队列创建等都需要用这个空间。</p></blockquote><p><strong>configMAX_TASK_NAME_LEN</strong></p><blockquote><p>定义任务名最大的字符数，末尾的结束符 ‘\0’也要计算在内。</p></blockquote><p><strong>configUSE_16_BIT_TICKS</strong></p><blockquote><p>系统时钟节拍计数使用 <code>TickType_t</code>数据类型定义的。</p><p>如果用户使能了宏定义 <code>configUSE_16_BIT_TICKS</code>，那么 <code>TickType_t</code>定义的就是 16 位无符号数，如 果没有使能，那么 <code>TickType_t</code>定义的就是 32 位无符号数。对于 32 位架构的处理器，一定要禁止此宏定义，即设置此宏定义数值为 0 即可。而 16 位无符号数类型主要用于 8 位和 16 位架构的处理器。</p></blockquote><p><strong>configIDLE_SHOULD_YIELD</strong></p><blockquote><p>此参数用于使能与空闲任务同优先级的任务，只有满足以下两个条件时，此参数才有效果：</p><ol><li><p>使能抢占式调度器。</p></li><li><p>有创建与空闲任务同优先级的任务。</p></li></ol><p>配置为 1，就可以使能此特性了，实际应用中不建议用户使用此功能，将其配置为 0 即可。</p></blockquote><p><strong>configUSE_TASK_NOTIFICATIONS</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能任务间直接的消息传递，包含信号量，事件标志组和消息邮箱。 </p></li><li><p>配置为 0</p><p>  禁能此特性。</p></li></ul></blockquote><p><strong>configUSE_MUTEXES</strong></p><blockquote><ul><li>配置为 1</li></ul><p>​    使能互斥信号量</p><ul><li>配置为 0</li></ul><p>​    禁能互斥信号量</p></blockquote><p><strong>configUSE_RECURSIVE_MUTEXES</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能递归互斥信号量</p></li><li><p>配置为 0</p><p>  禁能递归互斥信号量</p></li></ul></blockquote><p><strong>configUSE_COUNTING_SEMAPHORES</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能计数信号量</p></li><li><p>配置为 0</p><p>  禁能计数信号量</p></li></ul></blockquote><p><strong>configQUEUE_REGISTRY_SIZE</strong></p><blockquote><p>通过此定义来设置可以注册的信号量和消息队列个数。队列注册有两个目的，这两个目的都与内核调试有关：</p><p>注册队列的时候，可以给队列起一个名字，当使用调试组件的时候，通过名字可以很容易的区分不同队列</p><p>通过队列的相关信息，调试器可以很容易定位队列和信号量，能够定位信号量是因为 FreeRTOS 信号量也是基于队列实现的。当然，如果用户没有使用内核方面的调试器，这个宏定义是没有意义的。</p></blockquote><p><strong>configUSE_QUEUE_SETS</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能消息队列</p></li><li><p>配置为 0</p><p>  禁能消息队列。</p></li></ul></blockquote><p><strong>configUSE_TIME_SLICING</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能时间片调度。</p></li><li><p>配置为 0</p><p>  禁能时间片调度。</p></li></ul><pre><code>用户没有配置此选项如果用户没有配置此选项默认在` FreeRTOS.h` 文件中已经配置为 1，即使能时间片调度。</code></pre></blockquote><h2 id="“Config”开始的宏-其他配置"><a href="#“Config”开始的宏-其他配置" class="headerlink" title="“Config”开始的宏 - 其他配置"></a>“Config”开始的宏 - 其他配置</h2><p>STM32cubeMX中的配置：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_4.webp" alt="image-20231119221804305"></p><p>钩子函数配置：</p><p>钩子函数的主要功能是用于函数的扩展，用户可以根据自己的需要往里面添加相关的测试函数。</p><p><strong>configUSE_IDLE_HOOK</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能空闲任务的钩子函数</p></li><li><p>配置为 0</p></li></ul><p>禁能空闲任务钩子函数</p></blockquote><p><strong>configUSE_MALLOC_FAILED_HOOK</strong></p><blockquote><p>当创建任务，信号量或者消息队列时，FreeRTOS 通过函数 <code>pvPortMalloc</code>()申请动态内存。</p><ul><li><p>配置为 1</p><p>  使能动态内存申请失败时的钩子函数</p></li><li><p>配置为 0</p><p>  禁能动态内存申请失败时的钩子函数</p></li></ul></blockquote><p> <strong>configUSE_TICK_HOOK</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能滴答定时器中断里面执行的钩子函数</p></li><li><p>配置为 0</p><p>  禁能滴答定时器中断里面执行的钩子函数</p></li></ul></blockquote><p> <strong>configCHECK_FOR_STACK_OVERFLOW</strong></p><blockquote><p>FreeRTOS 的栈溢出检测支持两种方法，为了方便描述，我们这里将其称之为方法一和方法二。</p><ul><li><p>配置为 2</p><p>  栈溢出检测使用方法二。</p></li><li><p>配置为 1</p><p>  栈溢出检测使用方法一。</p></li><li><p>配置为 0</p><p>  禁止栈溢出检测。</p></li></ul></blockquote><p>任务运行信息获取配置：</p><p><strong>configGENERATE_RUN_TIME_STATS</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能任务运行状态参数统计。</p></li><li><p>配置为 0</p><p>  禁止此特性。 </p></li></ul></blockquote><p><strong>configUSE_TRACE_FACILITY</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能此配置将添加额外的结构体成员和函数，以此来协助可视化和跟踪</p></li><li><p>配置为 0</p><p>  禁止此特性。 </p></li></ul></blockquote><p> <strong>configUSE_STATS_FORMATTING_FUNCTIONS</strong></p><blockquote><p>用户配置宏定义 <code>configUSE_TRACE_FACILITY</code>和 <code>configUSE_STATS_FORMATTING_FUNCTIONS</code>都为 1 的时候，将使能函数 <code>vTaskList</code>() 和 <code>vTaskGetRunTimeStats</code>()</p><p>如果两者中任何一个为 0，那么这两个函数都将被禁能。</p></blockquote><p>合作式任务配置：</p><p><strong>configUSE_CO_ROUTINES</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能合作式调度相关函数。</p></li><li><p>配置为 0</p><p>  禁能合作式调度相关函数。</p></li></ul></blockquote><p><strong>configMAX_CO_ROUTINE_PRIORITIES</strong></p><blockquote><p>此参数用于定义可供用户使用的最大的合作式任务优先级数，如果这个定义的是 5，那么用户可以使用的优先级号是 0,1,2,3,4，不包含 5，对于这一点，初学者要特别的注意。</p></blockquote><p>软件定时器配置：</p><p> <strong>configUSE_TIMERS</strong></p><blockquote><ul><li><p>配置为 1</p><p>  使能软件定时器。</p></li><li><p>配置为 0</p><p>  失能软件定时器</p></li></ul></blockquote><p> <strong>configTIMER_TASK_PRIORITY</strong></p><blockquote><p> 配置软件定时器任务的优先级。</p></blockquote><p> <strong>configTIMER_QUEUE_LENGTH</strong></p><blockquote><p>配置软件定时器命令队列的长度。</p></blockquote><p><strong>configTIMER_TASK_STACK_DEPTH</strong></p><blockquote><p>配置软件定时器任务的栈空间大小</p></blockquote><p><code>断言配置</code></p><p>STM32cubeMX生成的：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_5.webp" alt="image-20231119221818493"></p><p>后续可以根据需要进行修改。</p><p>中断相关：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_6.webp" alt="image-20231119221837209"></p><p><code>configLIBRARY_LOWEST_INTERRUPT_PRIORITY</code>：</p><p>配置中断最低优先级，通常为15(因为STM32的抢占式优先级最多设置为4bit，优先级最低只能设置为15)，此参数用于配置<code>SysTick</code>与<code>PendSV</code>。</p><p><code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>：</p><p>配置系统可管理的最高优先级，此参数用于配置BASEPRI寄存器。 如果设置为5，则优先级数值为0,1,2,3,4的中断是不受FreeRTOS管理的，不可被屏蔽，也不能调用FreeRTOS中的API接口函数，而中断优先级在5-15的中断受系统FreeRTOS管理，可以被屏蔽</p><h2 id="“INCLUDE-”开始的宏"><a href="#“INCLUDE-”开始的宏" class="headerlink" title="“INCLUDE_”开始的宏"></a>“INCLUDE_”开始的宏</h2><p>以“INCLUDE”开头的宏允许您的应用程序将未使用的实时内核组件从您的工程中移除， 这可节约嵌入式应用程序所需的任何 ROM 或 RAM。</p><p>每个宏都采用以下形式：</p><p><code>INCLUDE_FunctionName</code></p><p>其中 <code>FunctionName</code> 表示可以选择性地排除的 API 函数（或函数集）。</p><p>要包含 API 函数，请将宏设置为 1，要排除该函数，请将宏设置为 0。</p><p>例如：</p><p>要包含 <code>vTaskDelete</code>() API 函数，请使用：</p><p><code>#define INCLUDE_vTaskDelete 1</code></p><p>要从构建中排除 <code>vTaskDelete</code>()，请使用：</p><p><code>#define INCLUDE_vTaskDelete 0</code></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_7.webp" alt="图片"></p><p>STM32cubeMX中的配置：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free3_8.webp" alt="图片"></p><hr><h1 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h1><h2 id="任务概念"><a href="#任务概念" class="headerlink" title="任务概念"></a>任务概念</h2><h3 id="任务的基本概念"><a href="#任务的基本概念" class="headerlink" title="任务的基本概念"></a>任务的基本概念</h3><p>从系统的角度看，任务是竞争系统资源的最小运行单元。</p><p>FreeRTOS是一个支持多任务的操作系统，在FreeRTOS中，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其他任务运行。</p><p>每个任务在自己的环境中运行，在任何时刻，只有一个任务得到运行，FreeRTOS调度器决定运行哪个任务。调度器会不断的启动、停止每一个任务，宏观上看，所有的任务都在同时进行。</p><p>在FreeRTOS中，每个任务都有自己的栈空间(一段连续的内存)，用于保存任务运行环境。任务越多，需要的栈空间就越大，而一个系统能运行多少个任务，取决于系统可用的内存。</p><p>任务通常会运行在一个死循环中，不会退出，如果不需要某个任务，可以调用FreeRTOS中的删除任务API函数将任务删除，释放系统资源。</p><h3 id="任务状态的概念"><a href="#任务状态的概念" class="headerlink" title="任务状态的概念"></a>任务状态的概念</h3><p>FreeRTOS系统中的任务有四种状态：</p><p><strong>Running—运行态</strong></p><p>当任务处于实际运行时被称之为运行态，即 CPU 的使用权被这个任务占用。</p><p><strong>Ready—就绪态</strong></p><p>处于就绪态的任务是指那些能够运行（没有被阻塞和挂起），但是当前没有运行的任务，因为同优先级或更高优先级的任务正在运行。</p><p><strong>Blocked—阻塞态</strong></p><p>由于等待信号量，消息队列，事件标志组等而处于的状态被称之为阻塞态，另外任务调用延迟函数也会处于阻塞态。</p><p><strong>Suspended—挂起态</strong></p><p>类似阻塞态，通过调用函数 vTaskSuspend()对指定任务进行挂起，挂起后这个任务将不被执行，只有调用函数 xTaskResume()才可以将这个任务从挂起态恢复。</p><h3 id="任务状态的切换"><a href="#任务状态的切换" class="headerlink" title="任务状态的切换"></a>任务状态的切换</h3><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/640" alt="图片"></p><h2 id="系统启动与空闲任务"><a href="#系统启动与空闲任务" class="headerlink" title="系统启动与空闲任务"></a>系统启动与空闲任务</h2><h3 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h3><p>使用如下函数启动 FreeRTOS调度： </p><p><code>vTaskStartScheduler();</code></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/7e93203d7ea3edc486397d8740765a49.png" alt="图片"></p><p>启动函数介绍：</p><p>函数原型：</p><p><code>void vTaskStartScheduler( void );</code></p><p>函数描述：函数 <code>vTaskStartScheduler</code>用于启动 FreeRTOS 调度器，即启动 FreeRTOS 的多任务执行。</p><p>使用这个函数要注意以下几个问题：</p><blockquote><ol><li><p>空闲任务和可选的定时器任务是在调用这个函数后自动创建的。</p></li><li><p>正常情况下这个函数是不会返回的。如果有返回，极有可能是用于定时器任务或者空闲任务的内存空间不足造成创建失败，此时需要加大FreeRTOS可管理的内存空间。</p></li></ol></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120224.png" alt="图片"></p><p>2、空闲任务</p><p>空闲任务是FreeRTOS系统中没有其它任务运行时自动进入的系统任务，不需要用户创建，启用调度器时，调度器会自动创建空闲任务。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120351.png" alt="图片"></p><p>空闲任务的作用：</p><blockquote><p>① 执行删除任务时，系统并不会立即释放任务的内存空间，只会将任务添加到结束列表中，真正的系统资源回收工作在空闲任务中完成。</p><p>②可以在空闲任务中实现低功耗功能，后续会详细讲解。</p></blockquote><h2 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h2><p>创建任务的方式：</p><p>① 静态创建任务，<code>xTaskCreateStatic()</code>，需要自行定义任务栈空间与任务控制块，一般不采用，不作介绍。</p><p>②动态创建任务，<code>xTaskCreate()</code>，系统动态分配任务栈空间与任务控制块，应用采用此方式。</p><p>动态创建任务函数详解：</p><p><strong>函数原型：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120517.webp" alt="图片"></p><p><strong>函数描述：</strong></p><p>函数 <code>xTaskCreate</code>用于实现 FreeRTOS 操作系统的任务创建，并且还可以自定义任务栈的大小。</p><blockquote><p> 第 一 个参数填创建任务的函数名</p><p> 第 二 个参数是任务名，这个参数主要用于调试的时候方便看是哪个任务</p><p> 第 三 个参数是任务栈大小，单位 word，也就是 4 字节</p><p> 第 四 个参数是创建的任务函数的形参</p><p> 第 五 个参数是定义任务优先级</p><p> 第 六 个参数是任务句柄，用于区分不同的任务</p></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120716.webp" alt="图片"></p><p><strong>STM32cubeMX创建方法：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121120912.webp" alt="图片"></p><p>方法详解：</p><p>① 首先利用宏定义定义任务参数结构体变量</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121607.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121701.webp" alt="图片"></p><p>#name：将name转化为字符串，等效于”name”</p><p><code>os_thread_def__name</code>:将name以字符串方式拼接，等效于”<code>os_thread_def_name</code>“</p><p>① 调用动态创建函数创建任务，形参为上面的结构体地址</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121733.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121858.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121925.webp" alt="图片"></p><h2 id="任务删除"><a href="#任务删除" class="headerlink" title="任务删除"></a>任务删除</h2><p>删除任务函数详解：</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTask )</span>;  <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vTaskDelete</code>用于实现 FreeRTOS 操作系统的任务删除。 </p><p> 第 1 个参数填要删除任务的句柄</p><p>使用这个函数要注意以下问题：</p><blockquote><p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p><p><code>#define INCLUDE_vTaskDelete 1</code></p><p>② 如果用往此函数里面填的任务 ID 是 NULL，即数值 0 的话，那么删除的就是当前正在执行的任务，此任务被删除后，FreeRTOS 会切换到任务就绪列表里面下一个要执行的最高优先级任务。</p><p>③ 在 FreeRTOS 中，创建任务所需的内存需要在空闲任务中释放，如果用户在 FreeRTOS 中调用了这个函数的话，一定要让空闲任务有执行的机会，否则这块内存是无法释放的。另外，创建的这个任务在使用中申请了动态内存，这个内存不会因为此任务被删除而删除，这一点要注意，一定要在删除前将此内存释放。</p></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121121955.webp" alt="图片"></p><h2 id="任务挂起"><a href="#任务挂起" class="headerlink" title="任务挂起"></a>任务挂起</h2><p>挂起任务函数详解：</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspend</span><span class="params">( TaskHandle_t xTaskToSuspend)</span>; <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vTaskSuspend</code>用于实现 FreeRTOS 操作系统的任务挂起。 </p><p> 第 1 个参数填要挂起任务的句柄</p><p>使用这个函数要注意以下问题：</p><p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p><p><code>#define INCLUDE_vTaskSuspend 1</code></p><p>② 如果用往此函数里面填的任务 ID 是 <code>NULL</code>，即数值 0 的话，那么挂起的就是当前正在执行的任务，此任务被挂起后，FreeRTOS 会切换到任务就绪列表里面下一个要执行的高优先级任务。</p><p>③ 多次调用此函数的话，只需调用一次 <code>vTaskResume</code>即可将任务从挂起态恢复。</p><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122008.webp" alt="图片"></p><h2 id="任务恢复-普通方式与中断方式"><a href="#任务恢复-普通方式与中断方式" class="headerlink" title="任务恢复(普通方式与中断方式)"></a>任务恢复(普通方式与中断方式)</h2><p>普通方式恢复任务函数详解：</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskResume</span><span class="params">( TaskHandle_t xTaskToResume)</span>;<span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vTaskResume</code>用于实现 FreeRTOS 操作系统的任务恢复</p><p> 第 1 个参数填要恢复任务的句柄</p><p>使用这个函数要注意以下问题：</p><p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p><p><code>#define INCLUDE_vTaskSuspend 1</code></p><p>② 多次调用函数 <code>vTaskSuspend</code>的话，只需调用一次 <code>vTaskResume</code>即可将任务从挂起态恢复。</p><p>③ 此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的<code>xTaskResumeFromISR</code>()，以后缀 <code>FromISR</code>结尾。</p><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122026.webp" alt="图片"></p><p>中断方式恢复任务函数详解：</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">vTaskResumeFromISR</span><span class="params">( TaskHandle_t xTaskToResume)</span>; <span class="comment">/* 任务句柄 */</span> </span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vTaskResumeFromISR</code>用于实现 FreeRTOS 操作系统的任务恢复。</p><p> 第 1 个参数填要恢复任务的句柄</p><p>使用这个函数要注意以下问题：</p><p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code>配置文件中配置如下宏定义为 1</p><p><code>#define INCLUDE_xResumeFromISR 1</code></p><p>② 多次调用函数 <code>vTaskSuspend</code>的话，只需调用一次 <code>vTaskResumeFromISR</code>即可将任务从挂起态恢复。</p><p>③ 如果用户打算采用这个函数实现中断与任务的同步，要注意一种情况，如果此函数的调用优先于函数<code>vTaskSuspend</code>被调用，那么此次同步会丢失，这种情况下建议使用信号量来实现同步。</p><ol><li>此函数是用于中断服务程序中调用的，故不可以在任务中使用此函数，任务中使用的是 <code>vTaskResume</code>。</li></ol><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122030.webp" alt="图片"></p><h2 id="任务管理编程"><a href="#任务管理编程" class="headerlink" title="任务管理编程"></a>任务管理编程</h2><p>1、STM32cubeMX初始化</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122034.webp" alt="图片"></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122039.webp" alt="图片"></p><p>说明：按键任务手动创建。</p><p>2、文件结构如下</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122043.webp" alt="图片"></p><p>3、程序功能</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122048.webp" alt="图片"></p><p>4、按键结构体</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122051.webp" alt="图片"></p><p>5、按键检测函数</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122055.webp" alt="图片"></p><p>6、创建按键任务</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122059.webp" alt="图片"></p><p>7、按键任务执行函数</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20231121122104.webp" alt="图片"></p><hr><h1 id="任务调度与任务栈"><a href="#任务调度与任务栈" class="headerlink" title="任务调度与任务栈"></a>任务调度与任务栈</h1><h2 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h2><p>简单的说，调度器就是使用相关的调度算法来决定当前需要执行的任务。</p><p>FreeRTOS 操作系统支持三种调度方式：抢占式调度，时间片调度和合作式调度。</p><p>1.合作式调度</p><p>合作式调度器提供了一种单任务的的系统结构：</p><blockquote><ul><li>当任务需要运行的时候，被添加到等待队列</li><li>任务在特定的时刻被调度运行（以周期性或者单次方式）</li><li>任务运行直到完成(高优先级任务不可抢占CPU)，然后由调度器选择下一个任务</li></ul></blockquote><p>优点：调度简单，系统占用资源少(单任务结构，运行时高优先级任务不会抢占CPU，不需要给每个任务分配独立的栈空间)</p><p>缺点：系统实时性不够好</p><p>Note：</p><blockquote><p>单片机资源越来越丰富，加上合作式调度器的系统实时性不够好，合作式调度已经很少用了，FreeRTOS在新的版本中已不再更新，简单了解即可</p></blockquote><p>2.抢占式调度</p><p>抢占式调度器提供了一种多任务的的系统结构，高优先级任务可以抢占低优先级任务的CPU使用权，使得系统实时性非常好。</p><p>使用抢占式调度器时，根据任务重要程度合理分配优先级，CPU会优先执行就绪列表中优先级最高的任务。</p><p>下面图片： 任务1优先级 &lt; 任务2优先级 &lt; 任务3优先级</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free5_1.webp" alt=""></p><p>3.时间片调度</p><p>时间片调度针对同优先级的任务，调度算法给同优先级的任务分配一个专门的列表，用于记录当前就绪的任务，并为每个任务分配一个时间片。</p><p>下面图片： 任务1优先级 = 任务2优先级 = 任务3优先级 = 任务4优先级</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/2.webp" alt=""></p><h2 id="抢占式调度编程测试"><a href="#抢占式调度编程测试" class="headerlink" title="抢占式调度编程测试"></a>抢占式调度编程测试</h2><p>实验方法:</p><p>创建3个任务,情况如下：</p><p>任务1： 优先级低，阻塞，打印信息</p><p>任务2： 优先级中，运行时不阻塞，不挂起，闪灯</p><p>任务3： 优先级高，阻塞，打印信息</p><p>实验分析:</p><p>因为任务2一直运行，不释放CPU，使得低优先级的任务1无法获得CPU使用权，而任务3优先高，可以抢占CPU获得运行。</p><p>实验现象:</p><p>任务2指示灯闪烁，任务3打印信息输出。</p><p><strong>Note：</strong></p><blockquote><p>可以将任务2的优先级设置为最高，观察实验现象。</p></blockquote><h2 id="时间片调度编程测试"><a href="#时间片调度编程测试" class="headerlink" title="时间片调度编程测试"></a>时间片调度编程测试</h2><p>实验方法:</p><p>创建3个相同优先级的任务，打印信息，延时10ms，灯闪烁。 另外，方便测试，FreeRTOS的Tick设置为20，也就是每50ms进行一次系统调度。</p><p>实验分析:</p><p>3个任务优先级相同，按时间片调度，调度时间为50ms，因此每个任务可以连续执行5次。</p><p>实验现象:</p><p>3个任务循环打印5次，闪5次灯。</p><p><strong>Note：</strong></p><blockquote><p>可以禁止时间片调度，观察实验现象。</p></blockquote><h2 id="任务栈大小确认"><a href="#任务栈大小确认" class="headerlink" title="任务栈大小确认"></a>任务栈大小确认</h2><p>在FreeRTOS的应用设计中，每个任务都需要独立的栈空间，而且每个任务需要的栈大小也是不同的。将如下的几个选项简单的累加就可以得到一个粗略的栈大小：</p><p>1、函数</p><blockquote><p>  ① 局部变量</p><p>   ② 函数形参 (针对函数嵌套)</p><p>   ③ 函数返回地址 (针对函数嵌套)</p><p>   ④ 函数内部的状态保存</p></blockquote><p>2、任务切换</p><p>3、发生中断</p><p>实际应用中将这些都加起来是一件非常麻烦的工作，上面这些栈空间加起来的总和只是栈的最小需求，实际分配的栈大小可以在最小栈需求的基础上乘以一个安全系数，一般取 1.5-2。</p><p>上面的计算是我们用户可以确定的栈大小，项目应用中还存在无法确定的栈大小，比如调用printf函数就很难确定实际的栈消耗。又比如通过函数指针实现函数的间接调用，因为函数指针不是固定的指向一个函数进行调用，而是根据不同的程序设计可以指向不同的函数，使得栈大小的计算变得比较麻烦。</p><p>另外还要注意一点，建议不要编写递归代码，因为我们不知道递归的层数，栈的大小也是不好确定的。</p><p><strong>建议：</strong></p><blockquote><p>可以事先给任务分配一个大的栈空间，然后通过第二讲介绍的调试方法打印任务栈的使用情况，运行一段时间就会有个大概的范围了，再乘以安全系数，即可得到需要使用的栈空间。</p></blockquote><p>如下图：Test1-3使用的栈空间：(128-106)=22 words， 乘以安全系数，分配33 words即可。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/3.webp" alt=""></p><h2 id="任务栈溢出与检测"><a href="#任务栈溢出与检测" class="headerlink" title="任务栈溢出与检测"></a>任务栈溢出与检测</h2><h3 id="任务栈溢出"><a href="#任务栈溢出" class="headerlink" title="任务栈溢出"></a>任务栈溢出</h3><p>上节讲解了如何确定任务栈的大小，那什么又是栈溢出呢？简单的说就是用户分配的栈空间不够用了，溢出了。</p><p>下面我们举一个简单的实例，栈生长方向从高地址向低地址生长（M4 和 M3 是这种方式）：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/4.webp" alt=""></p><blockquote><p>① 上图标识 1 的位置是 RTOS 的某个任务调用了函数 test()前的 SP 栈指针位置</p><p>② 上图标识 2 的位置是调用了函数 test 需要保存返回地址到栈空间。这一步不是必须的，对于 M3和 M4 内核是先将其保存到 LR 寄存器中，如果 LR 寄存器中有保存上一级函数的返回地址，需要将 LR 寄存器中的内容先入栈</p><p>③ 上图标识 3 的位置是局部变量 <code>int i</code> 和 <code>int array</code>[10]占用的栈空间，但申请了栈空间后已经越界了。这个就是所谓的栈溢出了。如果用户在函数 <code>test</code>中通过数组 <code>array</code>修改了这部分越界区的数据且这部分越界的栈空间暂时没有用到或者数据不是很重要，情况还不算严重，但是如果存储的是关键数据，会直接导致系统崩溃</p><p>④ 上图标识 4 的位置是局部变量申请了栈空间后，栈指针向下偏移（返回地址+变量 i+10 个数组元素）*4 =48 个字节</p><p>⑤ 上图标识 5 的位置可能是其它任务的栈空间，也可能是全局变量或者其它用途的存储区，如果 test函数在使用中还有用到栈的地方就会从这里申请，这部分越界的空间暂时没有用到或者数据不是很重要，情况还不算严重，但是如果存储的是关键数据，会直接导致系统崩溃</p></blockquote><h3 id="FreerRTOS栈溢出检测机制"><a href="#FreerRTOS栈溢出检测机制" class="headerlink" title="FreerRTOS栈溢出检测机制"></a>FreerRTOS栈溢出检测机制</h3><p>FreeRTOS 提供了两种栈溢出检测机制，这两种检测都是在任务切换时才会进行：</p><p>方法一：</p><p>在任务切换时检测任务栈指针是否过界了，如果过界了，在任务切换的时候会触发栈溢出钩子函数(钩子函数的主要作用就是对原有函数的功能进行扩展，用户可以根据自己的需要往里面添加相关的测试代码)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t xTask, <span class="type">signed</span> <span class="type">char</span> *pcTaskName )</span>;</span><br></pre></td></tr></table></figure><p>用户可以在钩子函数里面做一些处理。这种方法不能保证所有的栈溢出都能检测到。比如任务在执行的过程中出现过栈溢出。任务切换前栈指针又恢复到了正常水平，这种情况在任务切换的时候是检测不到的。又比如任务栈溢出后，把这部分栈区的数据修改了，这部分栈区的数据不重要或者暂时没有用到还好，但如果是重要数据被修改将直接导致系统进入硬件异常，这种情况下，栈溢出检测功能也是检测不到的。</p><p>使用方法一需要用户在 <code>FreeRTOSConfig.h</code>文件中配置如下宏定义：</p><p><code>#define configCHECK_FOR_STACK_OVERFLOW 1</code></p><p>方法二：</p><p>任务创建的时候将任务栈所有数据初始化为 0xa5，任务切换时进行任务栈检测的时候会检测末尾的 16 个字节是否都是 0xa5，通过这种方式来检测任务栈是否溢出了。相比方法一，这种方法的速 度稍慢些，但是这样就有效地避免了方法一里面的部分情况。不过依然不能保证所有的栈溢出都能检测到，比如任务栈末尾的 16 个字节没有用到，即没有被修改，但是任务栈已经溢出了，这种情况是检测不到的。另外任务栈溢出后，任务栈末尾的 16 个字节没有修改，但是溢出部分的栈区数据被修改了，这部分栈区的数据不重要或者暂时没有用到还好，但如果是重要数据被修改将直接导致系统进入硬件异常，这种情况下，栈溢出检测功能也是检测不到的。</p><p>使用方法二需要用户在 <code>FreeRTOSConfig.h</code> 文件中配置如下宏定义：</p><p><code>#define configCHECK_FOR_STACK_OVERFLOW  2</code></p><h2 id="栈溢出编程测试"><a href="#栈溢出编程测试" class="headerlink" title="栈溢出编程测试"></a>栈溢出编程测试</h2><p>实验方法:</p><p>本实验就是在任务KEY_Task中申请过大的数组，模拟栈溢出的情况，检测到按键1按下时，对数组赋值，模拟产生系统硬件错误。  检测溢出后触发钩子函数，将发生栈溢出的任务打印出来。</p><p>实验现象:</p><p>串口打印KEY任务发生栈溢出，按下KEY1，系统产生硬件错误。</p><p><strong>Note：</strong></p><blockquote><p>FreerRTOS栈溢出检测机制的2种方法都试试。</p><p><code>#define configCHECK_FOR_STACK_OVERFLOW 1</code></p><p><code>#define configCHECK_FOR_STACK_OVERFLOW 2</code></p></blockquote><hr><h1 id="任务与中断优先级，临界保护"><a href="#任务与中断优先级，临界保护" class="headerlink" title="任务与中断优先级，临界保护"></a>任务与中断优先级，临界保护</h1><h2 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h2><p> 1.NVIC基础知识<strong>(回顾)</strong></p><blockquote><p>NVIC 即嵌套向量中断控制器(Nested Vectored Interrupt Controller)。STM32 的中有一个强大而方便的 NVIC，它是属于 CM4 内核的器件。NVIC 是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。但是各个芯片厂商在设计芯片的时候会对 CM4 内核里面的 NVIC 进行裁剪，把不需要的部分去掉，所以说 STM32 的 NVIC 是 CM4 的 NVIC 的一个子集</p><p>STM32 中有两个优先级的概念: 抢占式优先级和响应优先级，响应优先级也称子优先级，每个中断源都需要被指定这两种优先级。<br>具有高抢占式优先级的中断可以在具有低抢占式优先级的中断处理过程中被响应，即中断嵌套，或者说高抢占式优先级的中断可以嵌套在低抢占式优先级的中断中。<br>当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个:如果他们的抢占式优先级和响应优先级都相硬件家园等，则根据他们在中断表中的排位顺序决定先处理哪一个</p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_1.webp" alt=""></p><p>2.FreeRTOS配置NVIC</p><p><strong>Note：</strong></p><blockquote><p><code>官方强烈建议将中断优先级分组设置为4，即抢占优先级可配置范围是0-15，数值越小，抢占优先级越高。</code></p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_2.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_3.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_4.webp" alt=""></p><p>3、<code>SVC</code>，<code>PendSV</code>与<code>Systick</code>中断</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_5.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_6.webp" alt=""></p><p>SVC 中断：</p><blockquote><p>在 FreeRTOS 的移植文件 <code>ports.c</code> 中有用到 <code>SVC</code>中断的 0 号系统服务，即 <code>SVC</code>0。此中断在 FreeRTOS中仅执行一次，用于启动第一个要执行的任务。另外，由于 FreeRTOS 没有配置 SVC 的中断优先级，默认没有配置的情况下，<code>SVC 中断的优先级就是最高的 0</code>。</p></blockquote><p><code>PendSV</code>与<code>Systick</code>中断：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_7.webp" alt=""></p><p>4、不受FreeTOS管理的中断</p><blockquote><p>FreeRTOS 内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件，得不到及时执行的话，后果是可想而知的。</p><p>针对这种情况，FreeRTOS 就专门做了一种新的开关中断实现机制。关闭中断时仅关闭受 FreeRTOS管理的中断，不受 FreeRTOS 管理的中断不关闭，这些不受管理的中断都是高优先级的中断，用户可以在这些中断里面加入需要实时响应的程序。</p><p>FreeRTOS 能够实现这种功能的奥秘就在于 FreeRTOS 开关中断使用的是寄存器 <code>basepri</code>：</p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_8.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_9.webp" alt=""></p><p>5、STM32CubeMX配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_10.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_11.webp" alt=""></p><h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><p>1、任务优先级说明</p><blockquote><p>① FreeRTOS 中任务的最高优先级是通过 <code>FreeRTOSConfig.h</code> 文件中的 <code>configMAX_PRIORITIES</code>进行配置的，用户实际可以使用的优先级范围是 <code>0</code>到 <code>configMAX_PRIORITIES – 1</code>。比如我们配置此宏定义为 <code>5</code>，那么用户可以使用的优先级号是 <strong>0,1,2,3,4</strong>，<code>不包含 5</code>，对于这一点，初学者要特别的注意。</p><p>② <code>用户配置任务的优先级数值越小，那么此任务的优先级越低，空闲任务的优先级是 0</code>。</p><p>③ 建议用户配置宏定义 <code>configMAX_PRIORITIES</code> 的最大值不要超过 32，即用户任务可以使用的优先级范围是0到31。因为对于CM内核的移植文件，用户任务的优先级不是大于等于32的话，<code>portmacro.h</code>文件中的宏定义<code>configUSE_PORT_OPTIMISED_TASK_SELECTION</code>会优化优先级列表中要执行的最高优先级任务的获取算法（对于 CM 内核的移植文件，此宏定义默认是使能的，当然，用户也可以在<code>FreeRTOSConfig.h</code> 文件中进行配置）。</p><p>④ 如果用户在 <code>FreeRTOSConfig.h</code> 文件中配置宏定义 <code>configUSE_TIME_SLICING</code>为 1，或者没有配置此宏定义，时间片调度都是使能的。另外，只要芯片资源允许，可以配置任意多个同优先级任务。</p><p>⑤ <code>FreeRTOS 中处于运行状态的任务永远是当前能够运行的最高优先级任务。</code></p></blockquote><p>2、任务优先级分配方案</p><p>对于初学者，有时候会纠结任务优先级设置为多少合适，因为任务优先级设置多少是没有标准的。对于这个问题，这里为大家推荐一个标准，任务优先级设置推荐方式如下图：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_12.webp" alt=""></p><blockquote><p>① <code>IRQ 任务</code>：IRQ 任务是指通过中断服务程序进行触发的任务，此类任务应该设置为所有任务里面<code>优先级最高</code>的。</p><p>② <code>高优先级后台任务</code>：比如按键检测，触摸检测，USB 消息处理，串口消息处理等，都可以归为这一类任务。</p><p>③ <code>低优先级的时间片调度任务</code>：比如 emWin 的界面显示，LED 数码管的显示等不需要实时执行的都可以归为这一类任务。实际应用中用户不必拘泥于将这些任务都设置为优先级 1 的同优先级任务，可以设置多个优先级，<code>只需注意这类任务不需要高实时性</code>。</p><p>④ <code>空闲任务</code>：空闲任务是系统任务。</p><p>⑤ <code>特别注意</code>：<code>IRQ 任务和高优先级任务必须设置为阻塞式</code>（调用消息等待或者延迟等函数即可），只有这样，高优先级任务才会释放 CPU 的使用权，,从而低优先级任务才有机会得到执行。</p></blockquote><p>3、中断优先级和任务优先级区别</p><blockquote><p>部分初学者也容易在这两个概念上面出现问题。简单的说，这两个之间没有任何关系，不管中断的优先级是多少，中断的优先级永远高于任何任务的优先级，即任务在执行的过程中，中断来了就开始执行中断服务程序。</p><p>另外对于 <code>STM32</code>，<code>中断优先级的数值越小，优先级越高</code>。而 <code>FreeRTOS</code>的任务优先级是，<code>任务优先级数值越小，任务优先级越低</code>。</p></blockquote><p>4、任务优先级修改与获取</p><p>优先级获取：</p><p><strong>函数原型：</strong></p><p><code>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</code>/<em> 任务句柄 </em>/</p><p><strong>函数描述：</strong></p><p>函数 <code>vTaskPriorityGet</code>用于获取 FreeRTOS 任务优先级。</p><p>第 1 个参数是任务句柄，用于区分不同的任务。</p><p>使用这个函数要注意以下问题：</p><ol><li>使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</li></ol><p><code>#define INCLUDE_vTaskPriorityGet  1</code></p><ol><li>如果第二个参数里面填的是 NULL，即数值 0 的话，那么获取的优先级就是当前正在执行的任务</li></ol><p>优先级修改：</p><p><strong>函数原型：</strong></p><p><code>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )</code>;  给任务配置的新优先级 </p><p><strong>函数描述：</strong></p><p>函数 <code>vTaskPrioritySet</code>用于实现 FreeRTOS 任务优先级的修改。 </p><p> 第 1 个参数是任务句柄，用于区分不同的任务。 </p><p> 第 2 个参数是给任务配置的新优先级。</p><p>使用这个函数要注意以下问题：</p><blockquote><p>① 使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为 1</p><p><code>#define INCLUDE_vTaskPrioritySet  1</code></p><p>② 如果第一个参数里面填的是 NULL，即数值 0 的话，那么配置的就是当前正在执行的任务</p><p>③ 如果被修改的任务的优先级，修改后高于正在执行的任务，将执行任务切换，切换到修改好的高优先级任务。</p><p>④ 第二个参数数值不可大于等于 <code>FreeRTOSConfig.h</code> 文件中的宏定义：<code>#define configMAX_PRIORITIES 配置的数值</code>。</p></blockquote><h2 id="开关中断与临界段函数"><a href="#开关中断与临界段函数" class="headerlink" title="开关中断与临界段函数"></a>开关中断与临界段函数</h2><p>1、临界段概念</p><p>代码的临界段也称为临界区，一旦这部分代码开始执行，则不允许中断打断。为确保临界段代码的执行不被中断，在进入临界段之前须关中断，而临界段代码执行完毕后，要立即开中断。</p><p>进入临界段前操作寄存器 <code>basepri</code>关闭了所有小于等于宏定义 <code>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</code>所定义的中断优先级，这样临界段代码就不会被中断干扰到，而且实现任务切换功能的 <code>PendSV</code>中断和滴答定时器中断是最低优先级中断，所以此任务在执行临界段代码期间是不会被其它高优先级任务打断的。退出临界段时重新操作 <code>basepri</code>寄存器，即打开被关闭的中断（这里我们不考虑不受 FreeRTOS 管理的更高优先级中断）</p><p>除了 FreeRTOS 操作系统源码所带的临界段以外，用户写应用的时候也有临界段的问题，比如以下两种：</p><ul><li><p>读取或者修改变量（特别是用于任务间通信的全局变量）的代码，一般来说这是最常见的临界代码。</p></li><li><p>调用公共函数的代码，特别是不可重入的函数，如果多个任务都访问这个函数，结果是可想而知的。总之，对于临界段要做到执行时间越短越好，否则会影响系统的实时性。</p></li></ul><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_13.webp" alt=""></p><p>2、开关中断函数</p><p>FreeRTOS 提供了一组开关中断函数，比较简单。</p><p>具体实现如下：</p><p><code>#define taskDISABLE_INTERRUPTS()  portDISABLE_INTERRUPTS()</code></p><p><code>#define taskENABLE_INTERRUPTS()   portENABLE_INTERRUPTS()</code></p><p>进一步跟踪宏定义的实现如下：</p><p><code>#define portDISABLE_INTERRUPTS()  vPortRaiseBASEPRI()</code></p><p><code>#define portENABLE_INTERRUPTS()   vPortSetBASEPRI( 0 )</code></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_14.webp" alt=""></p><p><strong>Note：</strong></p><blockquote><p><code>这两个函数不建议使用，因为不支持嵌套。</code></p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_15.webp" alt=""></p><p>3、任务代码临界段处理函数</p><p>任务代码进入和退出临界段的函数如下：</p><p><code>#define taskENTER_CRITICAL()  portENTER_CRITICAL()</code></p><p><code>#define taskEXIT_CRITICAL()    portEXIT_CRITICAL()</code></p><p>源码实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_16.webp" alt=""></p><p>通过上面两个函数 <code>vPortEnterCritical</code>和 <code>vPortExitCritical</code>可以看出，进入临界段和退出临界段是通过函数调用开关中断函数<code>portENABLE_INTERRUPTS</code>和 <code>portDISABLE_INTERRUPTS</code>实现的。<code>细心的读者还会发现上面的这两个函数都对变量 uxCriticalNesting 进行了操作。这个变量比较重要，用于临界段的嵌套计数。</code></p><p><strong>Note</strong></p><blockquote><p><code>临界段处理函数必须成对使用。</code></p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_17.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_18.webp" alt=""></p><p>4、中断代码临界段处理函数</p><p>中断代码进入和退出临界段的函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> taskENTER_CRITICAL_FROM_ISR()  portSET_INTERRUPT_MASK_FROM_ISR()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )</span></span><br></pre></td></tr></table></figure><p>源码实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_19.webp" alt=""></p><p>通过上面的源码可以看出，中断服务程序里面的临界段代码的开关中断也是通过寄存器 <code>basepri</code>实现的。初学的同学也许会问，这里怎么没有中断嵌套计数了呢？是的，这里换了另外一种实现方法，通过保存和恢复寄存器 <code>basepri</code>的数值就可以实现嵌套使用。</p><p><strong>Note：</strong></p><blockquote><p><code>临界段处理函数必须成对使用。</code></p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free6_20.webp" alt=""></p><h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><h3 id="CubeMX配置"><a href="#CubeMX配置" class="headerlink" title="CubeMX配置"></a>CubeMX配置</h3><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_1.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_2.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree6_3.webp" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line">    <span class="comment">//KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span>(KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//测试任务代码临界段</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;更改前的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">vTaskPrioritySet</span>(<span class="literal">NULL</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;更改后的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进入代码临界段\r\n&quot;</span>);</span><br><span class="line">        <span class="built_in">taskENTER_CRITICAL</span>();  <span class="comment">//进入代码临界段</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;延时5s，尽管KEY任务的优先级最低，但由于进入了临界段，任务不会切换，LED灯应该停止闪烁5s\n&quot;</span>);</span><br><span class="line"><span class="built_in">HAL_Delay</span>(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">taskEXIT_CRITICAL</span>();   <span class="comment">//退出代码临界段</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;退出代码临界段\r\n&quot;</span>);</span><br><span class="line">     </span><br><span class="line">      </span><br><span class="line"><span class="built_in">vTaskPrioritySet</span>(<span class="literal">NULL</span>,<span class="number">5</span>); <span class="comment">// 优先级更改移动到退出临界段之后</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前的KEY任务的优先级为：%u\r\n&quot;</span>,(<span class="type">uint16_t</span>)<span class="built_in">uxTaskPriorityGet</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY2处理</span></span><br><span class="line"><span class="keyword">if</span>(KEY.KeyCode == KEY2)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY3处理</span></span><br><span class="line"><span class="keyword">if</span>(KEY.KeyCode == KEY3)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//KEY4处理</span></span><br><span class="line"><span class="keyword">if</span>(KEY.KeyCode == KEY4)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞延时20ms</span></span><br><span class="line"><span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>我使用的定时器是TIM2作为freertos的延时时钟基准，需要把TIM2的优先级调高，不然会卡死在HAL_Delay导致退不出来代码临界段！</p></blockquote><hr><h1 id="调度锁，中断锁，任务锁"><a href="#调度锁，中断锁，任务锁" class="headerlink" title="调度锁，中断锁，任务锁"></a>调度锁，中断锁，任务锁</h1><h2 id="调度锁、中断锁，任务锁"><a href="#调度锁、中断锁，任务锁" class="headerlink" title="调度锁、中断锁，任务锁"></a>调度锁、中断锁，任务锁</h2><h3 id="调度锁"><a href="#调度锁" class="headerlink" title="调度锁"></a>调度锁</h3><p>调度锁就是 RTOS 提供的调度器开关函数，如果某个任务调用了调度锁开关函数，处于调度锁开和调度锁关之间的代码在执行期间是不会被高优先级的任务抢占的，即任务调度被禁止。这一点要跟临界段的作用区分开，调度锁只是禁止了任务调度，并没有关闭任何中断，中断还是正常执行的。而临界段进行了开关中断操作。</p><h3 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h3><p>中断锁就是 RTOS 提供的开关中断函数，FreeRTOS 没有专门的中断锁函数，使用上一讲里面介绍的中断服务程序临界段处理函数就可以实现同样效果。</p><h3 id="任务锁"><a href="#任务锁" class="headerlink" title="任务锁"></a>任务锁</h3><p>简单的说，为了防止当前任务的执行被其它高优先级的任务打断而提供的锁机制就是任务锁。FreeRTOS 也没有专门的任务锁函数，但是使用 FreeRTOS 现有的功能有两种实现方法：</p><blockquote><ul><li>利用调度锁关闭任务切换</li><li>利用 FreeRTOS 的任务代码临界段处理函数关闭 <code>PendSV</code>中断和 <code>Systick</code>中断，进而关闭任务切换。</li></ul></blockquote><h2 id="调度锁在线编程测试"><a href="#调度锁在线编程测试" class="headerlink" title="调度锁在线编程测试"></a>调度锁在线编程测试</h2><p>1、调度锁开启函数</p><p>调度锁开启函数  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure><p>使用这个函数要注意以下问题：</p><blockquote><p>①. 调度锁函数只是禁止了任务调度，并没有关闭任何中断。</p><p>②. 调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>一定要成对使用。</p><p>③. 切不可在调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>之间调用任何会引起任务切换的 API，比如 <code>vTaskDelayUntil</code>、<code>vTaskDelay</code>、<code>xQueueSend</code>等。</p></blockquote><p>调度锁关闭函数   <code>BaseType_t vTaskResumeAll(void)</code></p><p>调度锁关闭后，如果需要任务切换，此函数返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p><p>使用这个函数要注意以下问题：</p><blockquote><p>①. 调度锁函数只是禁止了任务调度，并没有关闭任何中断。</p><p>②. 调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>一定要成对使用。</p><p>③. 切不可在调度锁开启函数 <code>vTaskSuspendAll</code>和调度锁关闭函数 <code>xTaskResumeAll</code>之间调用任何会引起任务切换的 API，比如 <code>vTaskDelayUntil</code>、<code>vTaskDelay</code>、<code>xQueueSend</code>等。</p></blockquote><p>2、应用方法</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free7_1.webp" alt=""></p><p>3、调度锁在线编程测试</p><p>实验方法：</p><p>创建2个任务，情况如下：</p><p>任务1：优先级低，启用调度锁，调度锁开关之间使用HAL_Delay延时5s，退出调度锁后，使用HAL_Delay继续延时2s</p><p>任务2：优先级高，指示灯100ms快闪</p><p>实验分析：任务2本应该间隔100ms连续快闪，由于低优先级的任务一调用了调度锁开关函数，而且延时了5s，延时期间关闭了任务切换，在此期间，任务2不运行，结果就是任务2的指示灯间隔5s快闪10次。</p><hr><h1 id="时间管理-系统节拍，延时函数"><a href="#时间管理-系统节拍，延时函数" class="headerlink" title="时间管理(系统节拍，延时函数)"></a>时间管理(系统节拍，延时函数)</h1><h2 id="系统节拍"><a href="#系统节拍" class="headerlink" title="系统节拍"></a>系统节拍</h2><p>FreeRTOS实时操作系统需要一个时钟节拍，以供系统处理诸如延时、超时、软件定时器等与时间相关的事件。</p><p>时钟节拍是周期性定时中断，这个中断可以看做是系统心跳。中断时间间隔取决于不同的应用，一般是 1ms – 100ms。时钟的节拍中断使得内核可以将任务延迟若干个时钟节拍，以及当任务等待事件发生时，提供等待超时等依据。时钟节拍率越快，系统响应越快，系统的额外开销也越大。</p><p>对于 Cortex-M3 内核的 STM32F103 ，教程配套的例子都是用滴答定时器来实现系统时钟节拍的。</p><p>滴答定时器 Systick</p><p>SysTick 定时器位于 NVIC 中，用于产生 SysTick 异常（异常号：15），滴答定时器是一个 24 位的递减计数器，支持中断。使用比较简单，专门用于给操作系统提供时钟节拍。</p><p>FreeRTOS 的系统时钟节拍可以在配置文件 <code>FreeRTOSConfig.h</code> 里面设置：</p><p><code>#define configTICK_RATE_HZ ( ( TickType_t ) 1000 )</code></p><p>如上所示的宏定义配置表示系统时钟节拍是 1KHz，即 1ms。</p><h2 id="延时相关函数"><a href="#延时相关函数" class="headerlink" title="延时相关函数"></a>延时相关函数</h2><p>1、作用</p><p>FreeRTOS 中的时间延迟函数主要有以下两个作用：</p><p>为周期性执行的任务提供延迟。</p><p> 对于抢占式调度器，让高优先级任务可以通过时间延迟函数释放 CPU 使用权，从而让低优先级任务可以得到执行。</p><p>2、相关函数</p><p>FreeRTOS 时间相关的函数主要有以下 4 个： </p><p> <code>vTaskDelay ()</code></p><p><code>vTaskDelayUntil ()</code></p><p><code>xTaskGetTickCount()</code></p><p> <code>xTaskGetTickCountFromISR()</code></p><p>下面我们对这 4 个函数依次进行说明：</p><p><strong>① 函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">(  <span class="type">const</span> TickType_t xTicksToDelay )</span>; </span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong>函数 <code>vTaskDelay</code>用于任务的延迟。 属于相对延时，指每次延时都是从执行函数<code>vTaskDelay</code>()开始，直到延时指定的时间（参数：滴答值）结束。 </p><p> 参数 <code>xTicksToDelay</code>用于设置延迟的时钟节拍个数，范围 <code>1- 0xFFFFFFFF</code>。</p><p>延迟时间的最大值在<code>portmacro.h</code> 文件里面有定义：</p><p><code>typedef uint32_t TickType_t;</code></p><p><code>#define portMAX_DELAY ( TickType_t )</code> 0xffffffffUL</p><p>即延迟时间的范围是：1- 0xFFFFFFFF</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_1.webp" alt=""></p><p><strong>② 函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelayUntil</span><span class="params">( </span></span><br><span class="line"><span class="params">    TickType_t *pxPreviousWakeTime, </span></span><br><span class="line"><span class="params">    <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong>函数 <code>vTaskDelayUntil</code>用于周期性延迟。 属于绝对延时，指间隔指定的时间（参数：滴答值），执行一次调用<code>vTaskDelayUntil</code>()函数的任务。</p><p> 第 1 个参数，存储任务最后一次解除阻塞的时间</p><p> 第 2 个参数，周期性延迟时间。</p><p>使用这个函数要注意以下问题：</p><ol><li>使用此函数需要在 <code>FreeRTOSConfig.h</code> 配置文件中配置如下宏定义为1</li></ol><p><code>#define INCLUDE_vTaskDelayUntil 1</code></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_4.webp" alt=""></p><p><strong>③ 函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> TickType_t <span class="title function_">xTaskGetTickCount</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_2.webp" alt=""></p><p><strong>函数描述：</strong>函数 <code>xTaskGetTickCount</code>用于获取系统当前运行的时钟节拍数。</p><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数用于在任务代码里面调用，如果在中断服务程序里面调用的话，需要使用函数<code>xTaskGetTickCountFromISR</code>，这两个函数切不可混用。</p></blockquote><p><strong>④ 函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> TickType_t <span class="title function_">xTaskGetTickCountFromISR</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free8_3.webp" alt=""></p><p><strong>函数描述：</strong>函数 <code>xTaskGetTickCountFromISR</code>用于获取系统当前运行的时钟节拍数。</p><p>使用这个函数要注意以下问题：</p><p>1.此函数用于在中断服务程序里面调用，如果在任务里面调用的话，需要使用函数 <code>xTaskGetTickCount</code>，这两个函数切不可混用。</p><h2 id="对延时与绝对延时的区别与编程测试"><a href="#对延时与绝对延时的区别与编程测试" class="headerlink" title="对延时与绝对延时的区别与编程测试"></a>对延时与绝对延时的区别与编程测试</h2><p>1、问题：周期性去处理某一件事情。你会通过什么方式去实现？</p><p>比如：间隔10ms去采集传感器的数据，然后通过一种算法计算出一个结果，最后通过串口发送出去。对于裸机编程，首先想到的是：利用定时器，定时10ms中断，在中断里面处理。但中断函数适合处理简单数据，要求快进快出，不适合算法、通信等需要长时间占用CPU的处理。对计时精度要求比较高的地方适合定时器，像本节说的周期性采集传感器数据，要求不适合很高，那么就引入本文说的绝对延时。</p><blockquote><p>相对延时：指每次延时都是从执行函数vTaskDelay()开始，直到延时指定的时间（参数：滴答值）结束。</p><p>绝对延时：指间隔指定的时间（参数：滴答值），执行一次调用vTaskDelayUntil()函数的任务。</p></blockquote><p>3、通过编程测试相对延时和绝对延时的区别</p><p>创建2个任务，情况如下：</p><p>任务1：HAL_Delay延时50ms，模拟传感器采集数据与被中断或高优先级任务打断的时间，printf打印任务运行次数，再通过<code>vTaskDelay</code>相对延时200ms；</p><p>任务2：HAL_Delay延时50ms，模拟传感器采集数据与被中断或高优先级任务打断的时间，printf打印任务运行次数，再通过<code>vTaskDelayUntil</code>就绝对延时200ms；</p><p>实验分析：</p><p>任务1由于采用相对延时，printf间隔250ms(50ms+200ms)打印信息</p><p>任务2由于采用绝对延时，printf间隔200ms(50ms+150ms)打印信息</p><p><strong>疑问：</strong>为什么采用绝对延时，printf间隔为50ms+<strong>150ms</strong>。  </p><p><strong>解答：</strong>任务执行时，先花50ms执行模拟采集数据与被中断或高优先级任务打断的时间， 接着，调用<code>vTaskDelayUntil</code>, 此函数会根据第 1 个实参(存储任务最后一次解除阻塞的时间)与当前系统时间计算出模拟采集数据与被中断或高优先级任务打断的50ms时间，此时只延时200ms-50ms=150ms，以确保任务周期性执行，所以<code>vTaskDelayUntil</code>实际只阻塞了150ms。</p><p>&lt;串口打印信息&gt;</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree8_1.webp" alt="image-20231130200641421"></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p><code>注</code>：把宏定义修改成1 <code>#define INCLUDE_vTaskDelayUntil 1</code> 不然使用不了函数，前面有说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">osThreadDef</span>(LED1, LED1_Task, osPriorityBelowNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED1Handle = <span class="built_in">osThreadCreate</span>(<span class="built_in">osThread</span>(LED1), <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">osThreadDef</span>(LED2, LED2_Task, osPriorityNormal, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">  LED2Handle = <span class="built_in">osThreadCreate</span>(<span class="built_in">osThread</span>(LED2), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED1_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED1_Task */</span></span><br><span class="line">  <span class="type">uint16_t</span> Task1_Cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//模拟传感器采集数据与被中断或高优先级任务打断的时间</span></span><br><span class="line"><span class="built_in">HAL_Delay</span>(<span class="number">50</span>);</span><br><span class="line">LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line"><span class="comment">//打印任务运行次数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;任务一执行次数：%u\r\n&quot;</span>,++Task1_Cnt);</span><br><span class="line"><span class="comment">//相对延时200ms</span></span><br><span class="line"><span class="built_in">osDelay</span>(<span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED1_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED2_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED2_Task */</span></span><br><span class="line"> portTickType PreviousWakeTime;</span><br><span class="line">  <span class="type">uint16_t</span> Task2_Cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取当前系统时间</span></span><br><span class="line">PreviousWakeTime = <span class="built_in">xTaskGetTickCount</span>();</span><br><span class="line"><span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//模拟传感器采集数据与被中断或高优先级任务打断的时间</span></span><br><span class="line"><span class="built_in">HAL_Delay</span>(<span class="number">50</span>);</span><br><span class="line">  LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line"><span class="comment">//打印任务运行次数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;任务二执行次数：%u\r\n&quot;</span>,++Task2_Cnt);</span><br><span class="line"><span class="comment">//绝对延时200ms</span></span><br><span class="line"><span class="built_in">osDelayUntil</span>(&amp;PreviousWakeTime,<span class="number">200</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED2_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="链表-数据结构"><a href="#链表-数据结构" class="headerlink" title="链表(数据结构)"></a>链表(数据结构)</h1><h2 id="链表简述"><a href="#链表简述" class="headerlink" title="链表简述"></a>链表简述</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针</strong>链接次序实现的。链表由一系列节点（链表中每一个元素称为节点）组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p><p>链表作为C语言的一种基础数据结构，在平时写程序中用得并不多，但在操作系统中使用得非常多。如果需要读懂FreeRTOS系统的源码，必须弄懂链表，如果只是应用FreeRTOS系统，简要了解即可。</p><p>如下图：链表好比一个圆形的晾衣架，晾衣架上有很多钩子，钩子首尾相连；链表也是，链表由节点组成，节点与节点之间也是首尾相连。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_1.webp" alt=""></p><p>晾衣架的钩子本身不能代表很多东西，但钩子却可以挂载很多东西；同样，链表也类似，链表的节点本身不能储存很多内容，但节点跟晾衣架的钩子一样，可以挂载很多数据。</p><p>另外，链表分为单向链表与双向链表，单向链表很少用，用得较多的是双向链表。</p><h2 id="单向链表与双向链表"><a href="#单向链表与双向链表" class="headerlink" title="单向链表与双向链表"></a>单向链表与双向链表</h2><p>1、单向链表</p><p>单向链表如下图，该链表中共有n个节点，前一个节点都有一个指针指向后一个节点，首尾相连，组成一个圈。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_2.webp" alt=""></p><p>2、双链链表</p><p>双向链表如下图，该链表中共有n个节点，前一个节点都有两个指针分别指向前后节点，首尾相连，组成一个圈。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_3.webp" alt=""></p><p>3、链表与数组的差异</p><p>链表是通过节点把离散的数据(比如操作系统中任务)链接成一个表，通过对节点的插入与删除操作实现对数据的储存。 而数组是通过开辟一段连续的内存来储存数据，这是数组与链表的最大区别。</p><h2 id="FreeRTOS中链表实现代码"><a href="#FreeRTOS中链表实现代码" class="headerlink" title="FreeRTOS中链表实现代码"></a>FreeRTOS中链表实现代码</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对应C语言中的链表与节点。</p><p>1、列表项定义</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_4.webp" alt=""></p><p>列表项结构体参数含义如下：</p><blockquote><ul><li>用于检测列表数据是否完整</li><li>辅助值(比如用于任务的优先级)，用于帮助节点进行顺序排列</li><li>指向下一个节点的指针</li><li>指向上一个节点的指针</li><li>指向拥有该节点的内核对象，通常是TCB(任务控制块/任务句柄)</li><li>指向该节点所在的链表</li><li>用于检测列表数据是否完整</li></ul></blockquote><p>2、列表定义</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_5.webp" alt=""></p><p>列表结构体参数含义如下：</p><blockquote><ul><li>用于检测列表数据是否完整</li><li>链表节点计数器，用于记录该链表下有多少个节点，根节点除外</li><li>链表节点索引指针，用于遍历节点</li><li>链表最后一个节点。 链表是一个圈，首尾相连的，首就是尾，尾也是首。 从字面理解就是链表的最后一个节点，其实也是链表的第一个节点，称之为生产者。 该生产者的数据类型是一个精简的节点，具体如下图。</li><li>用于检测列表数据是否完整</li></ul></blockquote><p>节点(列表项)精简定义：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_6.webp" alt=""></p><h2 id="链表与节点初始化函数"><a href="#链表与节点初始化函数" class="headerlink" title="链表与节点初始化函数"></a>链表与节点初始化函数</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对C语言中的链表与节点。</p><p>1、列表项初始化函数</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_7.webp" alt=""></p><p>说明：</p><p>列表项初始化，只需将<code>pvContainer</code>初始化为NULL即可，表示该节点还没有插入到任何链表。 初始化后如下图：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_8.webp" alt=""></p><p>2、列表初始化函数</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_9.webp" alt=""></p><p>说明：</p><p>列表初始化，主要初始化索引指针，链表计数值，与内部精简列表项。初始化后如下图：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_10.webp" alt=""></p><h2 id="链表操作函数-尾部插入、升序插入、移除"><a href="#链表操作函数-尾部插入、升序插入、移除" class="headerlink" title="链表操作函数(尾部插入、升序插入、移除)"></a>链表操作函数(尾部插入、升序插入、移除)</h2><p>说明：FreeRTOS操作系统中的列表与列表项，分别对应C语言中的链表与节点。</p><p>1、将节点插入链表尾部</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_11.webp" alt=""></p><p>分析如下：</p><blockquote><ul><li>将新节点的<code>pxNext</code>指向根节点内的精简节点；</li><li>将新节点的<code>pxPrevious</code>指向之前的最后一个节点；</li><li>将之前最后一个节点的<code>pxNext</code>指向新节点；</li><li>将根节点内的精简节点<code>pxPrevious</code>指向新节点；</li><li>新节点的<code>pvContaner</code>指向链表；</li><li>链表的节点计数值加1</li></ul></blockquote><p>尾部插入详情如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_12.webp" alt=""></p><p>2、将节点按照升序插入链表</p><p>说明：如果两个节点的辅助值相同，则新节点在旧节点的后面插入。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_13.webp" alt=""></p><p>分析如下：</p><blockquote><ul><li>查找插入位置；</li><li>调整指向关系</li><li>新节点的pvContaner指向链表；</li><li>链表的节点计数值加1</li></ul></blockquote><p>升序插入详情如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_14.webp" alt=""></p><p>3、移除节点</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_15.webp" alt=""></p><p>分析如下：</p><blockquote><ul><li>通过节点获取链表；</li><li>调整指向关系</li><li>调整链表的索引指针</li><li>将删除节点的<code>pvContainer</code>指向NULL；</li><li>链表的节点计数值减1</li><li>返回链表的节点计数值</li></ul></blockquote><p>移除详情如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_16.webp" alt=""></p><h2 id="链表编程测试"><a href="#链表编程测试" class="headerlink" title="链表编程测试"></a>链表编程测试</h2><p><strong>说明：</strong>软件模拟仿真</p><p>1、只创建1个任务，在任务中进行链表测试</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_17.webp" alt=""></p><p>2、列表与列表项定义</p><p>说明：watch中查看变量值，需要定义为全局变量</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_18.webp" alt=""></p><p>3、任务1代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_19.webp" alt=""></p><p>4、设置为模拟仿真，避免仿真错误，删除硬件相关的初始化代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_20.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_21.webp" alt=""></p><p>5、增加断点</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_22.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_23.webp" alt=""></p><p>6、开始仿真，并在watch添加列表与列表项</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_24.webp" alt=""></p><p>7、全速仿真至任务1，再按F10单步执行，同时查看watch窗口</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free9_25.webp" alt=""></p><p>8、验证OK。</p><hr><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="消息队列的概念"><a href="#消息队列的概念" class="headerlink" title="消息队列的概念"></a>消息队列的概念</h2><p>1、消息队列的基本概念</p><p>消息队列简称队列，是一种常用于任务间通信的数据结构。</p><p>如下图：消息队列可以在任务与任务间、中断与任务间传递消息，实现任务接收来自其它任务或中断的不固定长度的消息。</p><p> &lt;队列用于任务与任务间&gt;</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_1.webp" alt=""></p><p>&lt;队列用于任务与中断间&gt;</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_2.webp" alt=""></p><p>相比于裸机的全局数组，使用消息队列有如下优势：</p><blockquote><ul><li>消息队列具有超时机制，可以让 FreeRTOS 内核有效地管理任务</li><li>使用消息队列可以防止多任务的访问冲突</li><li>使用消息队列可以有效地解决中断服务程序与任务之间消息传递的问题，使用全局数组的话，任务得不断去监测标志位以获取数据</li><li>消息队列具有FIFO与LIFO储存机制，方便处理数据</li></ul></blockquote><p>2、消息队列的通信机制</p><p>消息队列是一种<code>异步</code>的通信方式。</p><p>任务能够从队列中读取消息，当队列中的消息为空时，读取消息的任务将被阻塞。用户可以指定阻塞的任务时间 <code>xTicksToWait</code>，在这段时间中，如果队列为空，该任务将保持阻塞状态以等待队列数据有效。当队列中有新消息时，被阻塞的任务会被唤醒并处理新消息；当等待的时间超过指定的阻塞时间，即使队列中没有有效数据，任务也会自动从阻塞态转为就绪态。</p><p>通过消息队列服务，任务或中断服务可以将一条或多条消息放入消息队列中。同样，一个或多个任务可以从消息队列中获得消息。当有多个消息发送到消息队列时，通常是将先进入消息队列的消息先传给任务，也就是说，任务先得到的是最先进入消息队列的消息，即先进先出原则(<code>FIFO</code>)，FreeRTOS的队列也支持后进先出原则(<code>LIFO</code>)。</p><p>3、FreeRTOS中消息队列特性</p><blockquote><ul><li>消息支持先进先出方式排队，支持异步读写工作方式</li><li>读写队列均支持超时机制</li><li>消息支持后进先出方式排队，向队首发送消息(LIFO)</li><li>可以允许不同长度(不超过队列节点最大值)的任意类型消息</li><li>一个任务能够从任意一个消息队列接收和发送消息</li><li>多个任务能够从同一个消息队列接收和发送消息</li><li>当队列使用结束后，可以通过删除队列函数进行删除</li></ul></blockquote><p>4、消息队列运作流程图</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_3.webp" alt=""></p><p>5、消息队列应用场景</p><p>消息队列可用于发送不定长消息的场合。</p><p>队列是FreeRTOS 主要的任务间通信方式，可以在任务与任务间、中断和任务间传送信息，发送到队列的消息是通过<strong>复制方式</strong>实现的，这意味着队列存储的数据是原始数据，而不是原始数据的引用。</p><h2 id="消息队列常用API函数"><a href="#消息队列常用API函数" class="headerlink" title="消息队列常用API函数"></a>消息队列常用API函数</h2><p>消息队列全部API函数：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_4.webp" alt=""></p><p>使用消息队列的典型流程如下：</p><blockquote><ul><li>创建消息队列</li><li>发送消息队列</li><li>读取消息队列</li><li>删除消息队列</li></ul></blockquote><p>常用API函数如下：</p><blockquote><ul><li><code>xQueueCreate</code>()</li><li><code>xQueueSend</code>() 与 <code>xQueueSendFromISR</code>()</li><li><code>xQueueReceive</code>()</li><li><code>vQueueDelete</code>()</li></ul></blockquote><h2 id="消息队列创建与删除"><a href="#消息队列创建与删除" class="headerlink" title="消息队列创建与删除"></a>消息队列创建与删除</h2><p>1、消息队列控制块(句柄)</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_5.webp" alt=""></p><p>说明：句柄中的各个成员，稍微了解即可，Keil工程中有详细注释</p><p>2、队列创建</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QueueHandle_t <span class="title">xQueueCreate</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxQueueLength, <span class="comment">//队列长度，即消息个数   </span></span></span></span><br><span class="line"><span class="params"><span class="function">    UBaseType_t uxItemSize )</span></span>; <span class="comment">//类目大小，即消息大小，单位字节</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xQueueCreate</code>用于创建消息队列</p><p> 第 1 个参数是消息队列支持的消息个数</p><p> 第 2 个参数是每个消息的大小，单位字节</p><p> 返回值，如果创建成功会返回消息队列的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此消息队列提供所需的空间会返回 NULL</p><p><strong>队列创建示意图：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_6.webp" alt=""></p><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_7.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_8.webp" alt=""></p><p>3、队列删除</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vQueueDelete</span><span class="params">( QueueHandle_t xQueue)</span></span>; <span class="comment">//队列句柄 </span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vQueueDelete</code>用于删除消息队列</p><p> 第 1 个参数是需要删除的消息队列句柄</p><p>说明：</p><p>消息队列删除后，系统会清空此队列的全部消息，且不能再次使用此队列。     </p><h2 id="任务中消息队列发送"><a href="#任务中消息队列发送" class="headerlink" title="任务中消息队列发送"></a>任务中消息队列发送</h2><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">( </span></span><br><span class="line"><span class="params">    QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">void</span> * pvItemToQueue, <span class="comment">/* 要传递数据地址 */</span> </span></span><br><span class="line"><span class="params">    TickType_t xTicksToWait` <span class="comment">/* 等待消息队列有空间的最大等待时间 */</span> )</span>;</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xQueueSend</code>用于任务中消息发送。 </p><blockquote><ul><li>第 1 个参数是消息队列句柄</li><li>第 2 个参数要传递数据地址，每次发送都是将消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大 小复制到消息队列空间中</li><li>第 3 个参数是当消息队列已经满时，等待消息队列有空间时的最大等待时间，单位系统时钟节拍</li><li>返回值，如果消息成功发送返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code></li></ul></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><p>FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。</p><p> 此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xQueueSendFromISR</code>。</p><p>如果消息队列已经满且第三个参数为 0，那么此函数会立即返回。</p><p> 如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第三个参数配置为 <code>portMAX_DELAY</code>，那么此发送函数会永久等待直到消息队列有空间可以使用。</p><p> 消息队列还有两个函数 <code>xQueueSendToBack</code>和 <code>xQueueSendToFront</code>，函数 <code>xQueueSendToBack</code>实现的是 FIFO 方式的存取，函数 <code>xQueueSendToFront</code>实现的是 LIFO 方式的读写。我们这里说的函数 <code>xQueueSend</code>等效于 <code>xQueueSendToBack</code>，即实现的是 FIFO 方式的存取。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_9.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_10.webp" alt=""></p><h2 id="中断中消息队列发送"><a href="#中断中消息队列发送" class="headerlink" title="中断中消息队列发送"></a>中断中消息队列发送</h2><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xQueueSendFromISR</span> <span class="params">( </span></span><br><span class="line"><span class="params">QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,  <span class="comment">/* 要传递数据地址 */</span> </span></span><br><span class="line"><span class="params">    BaseType_t * pxHigherPriorityTaskWoken <span class="comment">/* 高优先级任务是否被唤醒的状态保存 */</span> )</span>;</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xQueueSendFromISR</code>用于中断服务程序中消息发送。 </p><blockquote><p>第 1 个参数是消息队列句柄。 </p><p>第 2 个参数要传递数据地址，每次发送都是将消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大 小复制到消息队列空间中。</p><p> 第 3 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p><p> 返回值，如果消息成功发送返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址。正因为这个原因，用户在创建消息队列时单个消息大小不可太大，因为一定程度上面会增加中断服务程序的执行时间。</p></li><li><p>此函数是用于中断服务程序中调用的，故不可以在任务代码中调用此函数，任务代码中使用的是<code>xQueueSend</code>。</p></li><li><p>消息队列还有两个函数 <code>xQueueSendToBackFromISR</code>和 <code>xQueueSendToFrontFromISR</code>，函数<code>xQueueSendToBackFromISR</code>实现的是 FIFO 方式的存取，函数 <code>xQueueSendToFrontFromISR</code>实现的是 <code>LIFO</code>方式的读写。我们这里说的函数 <code>xQueueSendFromISR</code>等效于<code>xQueueSendToBackFromISR</code>，即实现的是 <code>FIFO</code>方式的存取。</p></li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_11.webp" alt=""></p><h2 id="消息队列接收"><a href="#消息队列接收" class="headerlink" title="消息队列接收"></a>消息队列接收</h2><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xQueueReceive</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">QueueHandle_t xQueue, <span class="comment">/* 消息队列句柄 */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span> * pvBuffer, <span class="comment">/* 接收消息队列数据的缓冲地址 */</span> </span></span></span><br><span class="line"><span class="params"><span class="function">    TickType_t xTicksToWait <span class="comment">/* 等待消息队列有数据的最大等待时间 */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong>函数 <code>xQueueReceive</code>用于接收消息队列中的数据。 </p><blockquote><p>第 1 个参数是消息队列句柄。 </p><p>第 2 个参数是从消息队列中复制出数据后所储存的缓冲地址，缓冲区空间要大于等于消息队列创建函数 <code>xQueueCreate</code>所指定的单个消息大小，否则取出的数据无法全部存储到缓冲区，从而造成内存溢出。</p><p>第 3 个参数是消息队列为空时，等待消息队列有数据的最大等待时间，单位系统时钟节拍。 </p><p>返回值，如果接到到消息返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xQueueReceiveFromISR</code>。</p><p>如果消息队列为空且第三个参数为 0，那么此函数会立即返回。</p><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第三个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到消息队列有数据。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_12.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_13.webp" alt=""></p><h2 id="消息队列应用编程-任务与任务"><a href="#消息队列应用编程-任务与任务" class="headerlink" title="消息队列应用编程 - 任务与任务"></a>消息队列应用编程 - 任务与任务</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree10_1.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_14.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_15.webp" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义队列变量</span></span><br><span class="line"><span class="type">static</span> QueueHandle_t xQueue1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> QueueHandle_t xQueue2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">xQueue1 = <span class="built_in">xQueueCreate</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">  <span class="keyword">if</span> (xQueue1 == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列1失败\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列1成功\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xQueue2 = <span class="built_in">xQueueCreate</span>(<span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (xQueue2 == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列2失败\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建消息队列2成功\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulReceiveBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(xQueue1, &amp;ucRec_Data, ulReceiveBlockTime) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列1的数据：%u\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收消息队列1的数据超时！！！\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue2_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue2_Receive_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> ucRec_Data[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xQueueReceive</span>(xQueue2, ucRec_Data, portMAX_DELAY) == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列2的字符串: %s\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue2_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>];</span><br><span class="line">  <span class="type">uint32_t</span> ucSend_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulSendBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue1, &amp;ucSend_Data, ulSendBlockTime) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列1发送数据：%u\r\n&quot;</span>, ucSend_Data);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列1发送数据出现超时！！！\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      ucSend_Data += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue2, <span class="string">&quot;MCU1111111\r\n&quot;</span>, <span class="number">0</span>) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列2发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;MCU1111111&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列2发送字符串出现超时!!!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xQueueSend</span>(xQueue2, <span class="string">&quot;yjjy1111111\r\n&quot;</span>, <span class="number">0</span>) == pdTRUE)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功向消息队列2发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;yjjy1111111&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向消息队列2发送字符串出现超时!!!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="消息队列应用编程-中断与任务"><a href="#消息队列应用编程-中断与任务" class="headerlink" title="消息队列应用编程 - 中断与任务"></a>消息队列应用编程 - 中断与任务</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree10_2.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_16.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free10_17.webp" alt=""></p><ul><li>串口回调函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>ucUART3_Rec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(huart-&gt;Instance == huart3.Instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">LED.<span class="built_in">LED_Flip</span>(LED3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//向队列1发送数据</span></span><br><span class="line"><span class="built_in">xQueueSendFromISR</span>(myQueue01Handle, ucUART3_Rec_Data, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有高优先级任务就绪，执行一次任务切换</span></span><br><span class="line"><span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续通过串口3中断接收10个字符</span></span><br><span class="line"><span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>消息队列</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>ucUART3_Rec_Data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> ucRec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//通过串口3中断接收10个字符</span></span><br><span class="line"><span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">xQueueReceive</span>(myQueue01Handle, ucRec_Data, portMAX_DELAY) == pdPASS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成功接收消息队列1的数据：%s\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h1><h2 id="信号量的概念"><a href="#信号量的概念" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p><p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p><p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p><p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p><p>信号量是一个非负正数，<code>二值信号量</code>与<code>互斥信号量</code>取值范围为0-1，<code>计数信号量</code>取值范围是0-N(N&gt;1)</p><p><strong>0：</strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</p><p><strong>正数：</strong>表示有一个或多个信号量供获取</p><p>2、信号量的分类</p><blockquote><p>二值信号量(重点讲解同步应用)</p><p>计数信号量(重点讲解资源管理)</p><p>互斥信号量(重点讲解互斥访问)</p><p>递归互斥信号量(简要了解即可)</p></blockquote><h2 id="二值信号量的定义与应用"><a href="#二值信号量的定义与应用" class="headerlink" title="二值信号量的定义与应用"></a>二值信号量的定义与应用</h2><p>1、二值信号量的定义</p><p>当信号量被获取了，信号量值变为0；当信号量被释放了，信号量值变为1。 把这种取值只有0与1两种状态的信号量称之为二值信号量。</p><p>创建二值信号量时，系统会为创建的二值信号量分配内存，二值信号量创建完成后的示意图如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_1.webp" alt=""></p><p>从上图可以看出，二值信号量是一种长度为1，消息大小为0的特殊消息队列。 </p><p>因为这个队列只有空或满两种状态，而且消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p><p>2、二值信号量的应用</p><p>在嵌入式操作系统中，二值信号量是任务与任务或任务与中断间同步的重要手段。</p><p>Note：</p><p><strong>二值信号量也可以用于临界资源的访问，但不建议，因为存在任务优先级翻转问题，这个将在下一讲的互斥信号量(具有优先级继承机制)中进行详细讲解。</strong></p><p><strong>任务与任务中同步的应用场景:</strong></p><p>假设有一个温湿度传感器，每1s采集一次数据，那么让它在液晶屏中显示数据，这个周期也是1s，如果液晶屏刷新的周期是100ms，那么此时的温湿度数据还没更新，液晶屏根本无须刷新，只需要在1s后温湿度数据更新时刷新即可，否则CPU就是白白做了多次的无效数据更新操作，造成 CPU 资源浪费。如果液晶屏刷新的周期是 10s，那么温湿度的数据都变化了10次，液晶屏才来更新数据，那么这个产品测得的结果就是不准确的，所以还是需要同步协调工作，在温湿度采集完毕之后进行液晶屏数据的刷新，这样得到的结果才是最准确的，并且不会浪费 CPU 的资源。</p><p><strong>任务与中断中同步的应用场景:</strong></p><p>在串口接收中，我们不知道什么时候有数据发送过来，但如果设置一个任务专门时刻查询是否有数据到来，将会浪费CPU资源，所以在这种情况下使用二值信号量是很好的办法：当没有数据到来时，任务进入阻塞态，不参与任务的调度;等到数据到来了，释放一个二值信号量，任务就立即从阻塞态中解除，进入就绪态，然后在运行时处理数据，这样系统的资源就会得到很好的利用。</p><h2 id="二值信号量的运作机制"><a href="#二值信号量的运作机制" class="headerlink" title="二值信号量的运作机制"></a>二值信号量的运作机制</h2><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_2.webp" alt=""></p><p><strong>运行条件：</strong></p><ul><li><p>创建 2 个任务 Task1 和 Task2。 </p></li><li><p>创建二值信号量默认的初始值是 0，也就是没有可用资源。</p></li></ul><p><strong>运行过程描述如下：</strong></p><p>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，但是由于创建二值信号的初始值是 0，没有信号量可以用，任务 Task1 将由运行态转到阻塞状态。运行的过程中，任务 Task2 通过函数 <code>xSemaphoreGive</code>释放信号量，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态，实现Task1与Task2的同步功能。</p><p><strong>上面就是一个简单的 FreeRTOS 任务间二值信号量的同步使用过程。</strong></p><p>2、FreeRTOS 中断方式二值信号量的实现</p><p>FreeRTOS 中断方式二值信号量的实现是指中断与任务间使用信号量实现同步功能。下面我们通过如下的框图来说明一下 FreeRTOS 中断方式二值信号量的实现，让大家有一个形象的认识。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_3.webp" alt=""></p><p><strong>运行条件：</strong></p><ul><li><p>创建 1 个任务 Task1 和一个串口接收中断。 </p></li><li><p>二值信号量的初始值为 0，串口中断调用函数 <code>xSemaphoreGiveFromISR</code>释放信号量，任务 Task1调用函数 <code>xSemaphoreTake</code>获取信号量资源。</p></li></ul><p><strong>运行过程描述如下：</strong></p><p>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>，由于信号量的初始值是 0，没有信号量资源可用，任务 Task1 由运行态进入到阻塞态。</p><p>Task1 阻塞的情况下，串口接收到数据进入到了串口中断服务程序，在串口中断服务程序中调用函数<code>xSemaphoreGiveFromISR</code>释放信号量资源，信号量数值加 1，此时信号量计数值为 1，任务 Task1由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态，任务 Task1 获得信号量后，信号量数值减 1，此时信号量计数值又变成了 0。 </p><p>再次循环执行时，任务 Task1 调用函数 <code>xSemaphoreTake</code>由于没有资源可用再次进入到挂起态，等待串口释放二值信号量资源，如此往复循环。</p><p><strong>上面就是一个简单的 FreeRTOS 中断方式二值信号量同步过程。</strong></p><p>实际应用中，中断方式的消息机制要注意以下四个问题：</p><blockquote><p>中断函数的执行时间越短越好，防止其它低于这个中断优先级的异常不能得到及时响应</p><p>实际应用中，建议不要在中断中实现消息处理，用户可以在中断服务程序里面发送消息通知任务，在任务中实现消息处理，这样可以有效地保证中断服务程序的实时响应。同时此任务也需要设置为高优先级，以便退出中断函数后任务可以得到及时执行</p><p>中断服务程序中一定要调用专用于二值信号量设置函数，即以 <code>FromISR</code>结尾的函数</p><p>如果 FreeRTOS 工程的中断函数中调用了 FreeRTOS 的二值信号量的 API 函数，退出的时候要检测是否有高优先级任务就绪，如果有就绪的，需要在退出中断后进行任务切换</p></blockquote><h2 id="二值信号量常用的API函数"><a href="#二值信号量常用的API函数" class="headerlink" title="二值信号量常用的API函数"></a>二值信号量常用的API函数</h2><p> 1、使用二值信号量的典型流程如下：</p><blockquote><p>创建二值信号量</p><p>释放二值信号量</p><p>获取二值信号量</p><p>删除二值信号量</p></blockquote><p>2、常用API函数如下：</p><blockquote><p><code>xSemaphoreCreateBinary</code>()</p><p><code>xSemaphoreGive</code>() 与 <code>xSemaphoreGiveFromISR</code>() </p><p><code>xSemaphoreTake</code>()</p><p><code>vSemaphoreDelete</code>()</p></blockquote><p>3、二值信号量创建与删除</p><ul><li>二值信号量控制块(句柄)</li></ul><p>如下图：二值信号量的句柄为消息队列的句柄，因为二值信号量是一种长度为1，消息大小为0的特殊消息队列</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_4.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_5.webp" alt=""></p><ul><li>二值信号量创建</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateBinary</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreCreateBinary</code>用于创建二值信号量。 </p><p>返回值，如果创建成功会返回二值信号量的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此二值信号量提供所需的空间会返回 NULL。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_6.webp" alt=""></p><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_7.webp" alt=""></p><ul><li>二值信号量删除</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">vSemaphoreDelete</span><span class="params">(<span class="type">void</span>)</span></span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vSemaphoreDelete</code>可用于删除二值信号量。 </p><p>4、任务中二值信号量释放</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xSemaphoreGive</span>( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 *</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreGive</code>用于在任务代码中释放信号量。</p><p>第 1 个参数是信号量句柄。</p><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xSemaphoreGiveFromISR</code>。</p><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p><p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_8.webp" alt=""></p><p>5、中断中二值信号量释放</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGiveFromISR ( </span><br><span class="line">    SemaphoreHandle_t xSemaphore`, <span class="comment">/* 信号量句柄 */</span></span><br><span class="line"><span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken <span class="comment">/* 高优先级任务是否被唤醒的状态保存 */</span> )</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreGiveFromISR</code>用于中断服务程序中释放信号量。</p><blockquote><p>第 1 个参数是信号量句柄。</p><p>第 2 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数是基于消息队列函数 <code>xQueueGiveFromISR</code>实现的：</p><p><code>`#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken ) \xQueueGiveFromISR( ( QueueHandle_t )( xSemaphore ), ( pxHigherPriorityTaskWoken ))</code></p><p>此函数是用于中断服务程序中调用的，故不可以任务代码中调用此函数，任务代码中中使用的是<code>xSemaphoreGive</code>。</p><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>()或者 <code>xSemaphoreCreateCounting</code>()创建了信号量。</p><p>此函数不支持使用 <code>xSemaphoreCreateMutex</code>()创建的信号量。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_9.webp" alt=""></p><p>6、二值信号量获取</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake( </span><br><span class="line">SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">TickType_t xTicksToWait )`; <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p><blockquote><p>第 1 个参数是信号量句柄。 </p><p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p><p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xSemaphoreTakeFromISR</code>。</p><p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_10.webp" alt=""></p><h2 id="二值信号量的应用编程-任务与任务"><a href="#二值信号量的应用编程-任务与任务" class="headerlink" title="二值信号量的应用编程 - 任务与任务"></a>二值信号量的应用编程 - 任务与任务</h2><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_1.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_11.webp" alt=""></p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二值信号量</span></span><br><span class="line">osSemaphoreId xBinarySem = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(xBinarySem,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收到二值信号量同步信号，次数 = %u\r\n\r\n&quot;</span>,++TakeCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span> </span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>];  <span class="comment">//保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> GiveCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送同步信号\r\n&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreGive</span>(xBinarySem);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功发送二值信号量同步信号，次数 = %u\r\n&quot;</span>,++GiveCnt);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发送二值信号量同步信号失败&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>myinit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----二值信号量同步应用编程 - 任务与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：释放二值信号量，发送同步信号\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二值信号量的应用编程-中断与任务"><a href="#二值信号量的应用编程-中断与任务" class="headerlink" title="二值信号量的应用编程 - 中断与任务"></a>二值信号量的应用编程 - 中断与任务</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_2.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree11_3.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free11_12.webp" alt=""></p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>ucUART3_Rec_Data[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,<span class="number">0</span>); <span class="comment">//STM32CubeMX生成的FreeRTOS代码创建二值信号量时，默认为1，此处释放，避免串口误同步</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="comment">//通过串口3中断接收10个字符</span></span><br><span class="line">  <span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3, (<span class="type">uint8_t</span> *)ucUART3_Rec_Data, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line">xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成功接受到二值信号量同步信,次数 = %u\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;接收到的串口数据：%s\r\n\r\n&quot;</span>, ucUART3_Rec_Data);</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>CallBack.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>ucUART3_Rec_Data[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> osSemaphoreId myBinarySem01Handle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BaseType_t xHigherPriorityTaskWoken = pdFALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(huart-&gt;Instance == huart3.Instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试用</span></span><br><span class="line">LED.<span class="built_in">LED_Flip</span>(LED3); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送同步信号</span></span><br><span class="line"><span class="built_in">xSemaphoreGiveFromISR</span>(myBinarySem01Handle, &amp;xHigherPriorityTaskWoken);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有高优先级任务就绪，执行一次任务切换</span></span><br><span class="line"><span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----二值信号量同步应用编程 - 中断与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;通过RS-485接口向队列1发送10个字符\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_GPIO_WritePin</span>(RS485_DE_nRE_GPIO_Port,RS485_DE_nRE_Pin,GPIO_PIN_SET);</span><br><span class="line"><span class="built_in">HAL_UART_Transmit</span>(&amp;huart3, (<span class="type">uint8_t</span> *)<span class="string">&quot;通过RS-485接口向队列1发送10个字符\r\n&quot;</span>,<span class="number">33</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">HAL_GPIO_WritePin</span>(RS485_DE_nRE_GPIO_Port,RS485_DE_nRE_Pin,GPIO_PIN_RESET);</span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h1><h2 id="信号量的概念-1"><a href="#信号量的概念-1" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p><blockquote><p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p><p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p><p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p><p>信号量是一个非负正数，二值信号量与互斥信号量取值范围为0-1，计数信号量取值范围是0-N(N&gt;1)</p><p>0：<strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</strong></p><p><strong>正数：</strong>表示有一个或多个信号量供获取</p></blockquote><p>2、信号量的分类</p><p>二值信号量(重点讲解同步应用)</p><p>计数信号量(重点讲解资源管理)</p><p>互斥信号量(重点讲解互斥访问)</p><p>递归互斥信号量(简要了解即可)</p><h2 id="计数信号量的定义与应用"><a href="#计数信号量的定义与应用" class="headerlink" title="计数信号量的定义与应用"></a>计数信号量的定义与应用</h2><p>1、计数信号量的定义</p><blockquote><p>取值只有0与1两种状态的信号量称之为二值信号量</p><p>取值大于1的信号量称之为计数信号量</p></blockquote><p><strong>Note：</strong></p><blockquote><p>计数信号量的取值也可以为1，但通常大于1，如果取值为1，相当于只有0与1两种状态，用二值信号量即可。</p></blockquote><p>创建计数信号量时，系统会为创建的计数信号量分配内存，计数信号量创建完成后的示意图如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_1.webp" alt=""></p><p>从上图可以看出，计数信号量是一种长度大于1，消息大小为0的特殊消息队列。 </p><p>因为这个队列的消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p><p>2、计数信号量的应用</p><p>在嵌入式操作系统中，技术信号量是资源管理的重要手段，主要用于任务与任务间。</p><p><strong>应用场景:</strong></p><p>计数信号量允许多个任务对其进行操作，但限制了任务的数量。比如有一个停车场，里面只有50个车位，那么只能停50辆车，相当于我们的信号量有50 个。假如一开始停车场的车位还有50个，那么每进去一辆车就要消耗一个停车位，车位的数量就要减1，相应地，我们的信号量在使用之后也需要减 1。当停车场停满了50 辆车时，此时的停车位数量为 0，再来的车就不能停进去了，否则将没法停车了，也相当于我们的信号量为0，后面的任务对这个停车场资源的访问也无法进行。当有车从停车场离开时，车位又空余出来了，那么后面的车就能停进去了。信号量操作也是一样的，当我们释放了这个资源，后面的任务才能对这个资源进行访问。</p><h2 id="计数信号量的运作机制"><a href="#计数信号量的运作机制" class="headerlink" title="计数信号量的运作机制"></a>计数信号量的运作机制</h2><p>FreeRTOS 任务间计数信号量的实现</p><p>任务间信号量的实现是指各个任务之间使用信号量实现任务的同步或者资源共享功能。下面我们通过如下的框图来说明一下 FreeRTOS 计数信号量的实现，让大家有一个形象的认识。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_2.webp" alt=""></p><p><strong>运行条件：</strong></p><blockquote><ul><li>创建 任务 Task1 和 Task2至N。 </li><li>创建计数信号量可用资源为N。</li></ul></blockquote><p><strong>运行过程描述如下：</strong></p><blockquote><ul><li>任务 Task1 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，如果信号量大于0，Task1 将直接获取资源。如果信号量为0，任务 Task1 将由运行态转到阻塞状态，等待资源可用。一旦获取了资源并使用完毕后会通过函数 <code>xSemaphoreGive</code>释放掉资源。</li><li>任务 Task2至N 运行过程中调用函数 <code>xSemaphoreTake</code>获取信号量资源，如果信号量大于0，Task2至N 将直接获取资源。如果信号量为0，任务 Task2至N将由运行态转到阻塞状态，等待资源可用。一旦获取了资源并使用完毕后会通过函数 <code>xSemaphoreGive</code>释放掉资源。</li></ul></blockquote><p><strong>上面就是一个简单的 FreeRTOS 任务间计数信号量的使用过程。</strong></p><h2 id="计数信号量常用的API函数"><a href="#计数信号量常用的API函数" class="headerlink" title="计数信号量常用的API函数"></a>计数信号量常用的API函数</h2><p>1、使用计数信号量的典型流程如下：</p><blockquote><p>创建计数信号量</p><p>释放计数信号量</p><p>获取计数信号量</p><p>删除计数信号量</p></blockquote><p>2、常用API函数如下：</p><blockquote><p><code>xSemaphoreCreateCounting</code>()</p><p><code>xSemaphoreGive</code>() 与 <code>xSemaphoreGiveFromISR</code>() </p><p><code>xSemaphoreTake</code>()</p><p><code>vSemaphoreDelete</code>()</p></blockquote><p>3、二值信号量创建与删除</p><ul><li>二值信号量控制块(句柄)</li></ul><p>如下图：计数信号量的句柄为消息队列的句柄，因为计数信号量是一种长度大于1，消息大小为0的特殊消息队列</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_3.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_4.webp" alt=""></p><ul><li>计数信号量创建</li></ul><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(</span></span><br><span class="line"><span class="params">    UBaseType_t uxMaxCount, <span class="comment">/* 支持的最大计数值 */</span> </span></span><br><span class="line"><span class="params">    UBaseType_t uxInitialCount)</span>`;  <span class="comment">/* 初始计数值 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreCreateCounting</code>用于创建计数信号量。 </p><blockquote><p>第 1 个参数是设置此计数信号量支持的最大计数值。 </p><p>第 2 个参数是设置计数信号量的初始值。</p><p>返回值，如果创建成功会返回消息队列的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此消息队列提供所需的空间会返回 <code>NULL</code></p></blockquote><p>说明：此函数基于消息队列函数实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_5.webp" alt=""></p><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_6.webp" alt=""></p><ul><li>计数信号量删除</li></ul><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">(句柄)</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vSemaphoreDelete</code>可用于删除计数信号量。 </p><p>4、任务中计数信号量释放</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreGive</code>用于在任务代码中释放信号量。</p><ul><li><p>第 1 个参数是信号量句柄。</p></li><li><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p></li></ul><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xSemaphoreGiveFromISR</code>。</p></li><li><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p></li><li><p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p></li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_7.webp" alt=""></p><p>5、中断中计数信号量释放</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGiveFromISR (</span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span></span><br><span class="line">  <span class="type">signed</span> BaseType_t *pxHigherPriorityTaskWoken <span class="comment">/*  高优先级任务是否被唤醒的状态保存 */</span> )</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreGiveFromISR</code>用于中断服务程序中释放信号量。</p><blockquote><p>第 1 个参数是信号量句柄。</p><p>第 2 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</p><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>errQUEUE_FULL</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>此函数是基于消息队列函数 <code>xQueueGiveFromISR</code>实现的：</p><p> <code>#define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken ) \xQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) )</code></p></li><li><p>此函数是用于中断服务程序中调用的，故不可以任务代码中调用此函数，任务代码中中使用的是<code>xSemaphoreGive</code>。</p></li><li><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>()或者 <code>xSemaphoreCreateCounting</code>()创建了信号量。</p></li><li><p>此函数不支持使用 <code>xSemaphoreCreateMutex</code>()创建的信号量。</p></li></ol></blockquote><p>6、计数信号量获取</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake(</span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p><blockquote><p>第 1 个参数是信号量句柄。 </p><p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p><p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序使用的是<code>xSemaphoreTakeFromISR</code>。</p></li><li><p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p></li><li><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p></li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_8.webp" alt=""></p><h2 id="计数信号量的应用编程"><a href="#计数信号量的应用编程" class="headerlink" title="计数信号量的应用编程"></a>计数信号量的应用编程</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_10.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_11.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_12.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_13.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_14.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_15.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free12_9.webp" alt=""></p><p>我的代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> myCountingSem_ucMessagesWaiting = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,<span class="number">0</span>); <span class="comment">//STM32CubeMX生成的FreeRTOS代码创建二值信号量时，默认为1，此处释放，避免串口误同步</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (myCountingSem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建计数信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建计数信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无限等待同步信号更新显示，第%u次等待，等待中\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle,portMAX_DELAY);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;现在还有%d个车位\r\n\r\n&quot;</span>,myCountingSem_ucMessagesWaiting);</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;获取计数信号量，模拟车辆入库，申请停车位&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreTake</span>(myCountingSem01Handle, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取成功，成功申请停车位，发送同步显示信号\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting--;</span><br><span class="line"><span class="comment">// printf(&quot;现在还有%d个车位\r\n&quot;,myCountingSem_ucMessagesWaiting);</span></span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取失败，停车位已满\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;释放计数信号量，模拟车辆出库，让出停车位&quot;</span>);</span><br><span class="line">      xResult = <span class="built_in">xSemaphoreGive</span>(myCountingSem01Handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放成功，成功让出停车位，发送同步显示信号\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting++;</span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放失败，停车位以空&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>MyInit.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----计数信号量应用编程 - 模拟车库----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;默认车库可以停放20辆车，串口打印显示车位数量\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：获取信号量，模拟车辆入库，同时通过二值信号量发同步信号给显示任务\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：释放信号量，模拟车辆出库，同时通过二值信号量发同步信号给显示任务\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h1><h2 id="信号量的概念-2"><a href="#信号量的概念-2" class="headerlink" title="信号量的概念"></a>信号量的概念</h2><p>1、信号量的基本概念</p><blockquote><p><strong>消息队列</strong>是实现任务与任务或任务与中断间通信的<strong>数据结构</strong>，可类比裸机编程中的数组</p><p><strong>信号量</strong>是实现任务与任务或任务与中断间通信的<strong>机制</strong>，可以类比裸机编程中的标志位</p><p>信号量(semaphore)可以实现任务与任务或任务与中断间的同步功能(二值信号量)、资源管理(计数信号量)、临界资源的互斥访问(互斥信号量)等</p><p>信号量是一个非负正数，二值信号量与互斥信号量取值范围为0-1，计数信号量取值范围是0-N(N&gt;1)</p><p>0：<strong>信号量为空，所有试图获取它的任务都将处于阻塞状态，直到超时退出或其他任务释放信号量</strong></p><p><strong>正数：</strong>表示有一个或多个信号量供获取</p></blockquote><p>2、信号量的分类</p><p>二值信号量(重点讲解同步应用)</p><p>计数信号量(重点讲解资源管理)</p><p>互斥信号量(重点讲解互斥访问)</p><p>递归互斥信号量(简要了解即可)</p><h2 id="互斥信号量的定义与应用"><a href="#互斥信号量的定义与应用" class="headerlink" title="互斥信号量的定义与应用"></a>互斥信号量的定义与应用</h2><p>1、互斥信号量的定义</p><p>前面学过，取值只有0与1两种状态的信号量称之为二值信号量。 而互斥信号量是一种特殊的二值信号量，具有防止优先级翻转的特性。</p><p>创建互斥信号量时，系统会为创建的互斥信号量分配内存，<strong>互斥</strong>信号量创建完成后的示意图如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_1.webp" alt=""></p><p>从上图可以看出，互斥信号量是一种长度为1，消息大小为0的特殊消息队列。 </p><p>因为这个队列只有空或满两种状态，而且消息大小为0，因此在运用时，只需要知道队列中是否有消息即可，而无需关注消息是什么。</p><p>2、互斥信号量的应用</p><p>在嵌入式操作系统中，互斥信号量用于临界资源的独占式访问，只能用于任务与任务间，因为其特有的优先级继承机制只能在任务中起作用，在中断的上下文环境毫无意义。</p><p><strong>应用场景:</strong></p><p>比如有两个任务需要通过同一串口发送数据，其硬件资源只有一个，那么两个任务不能同时发送，否则会导致数据错误。此时就可以用互斥信号量对串口资源进行保护，当任务1正在使用串口发送数据时，互斥信号量变为无效，任务2无法使用串口，任务2必须等待互斥信号量有效(任务1释放信号量)，才能获得串口使用权，进而发送数据。</p><p>3、简要了解递归互斥信号量</p><p>递归互斥信号量是一种特殊的互斥信号量，支持拥有该信号量使用权的任务重复多次获取，而不会死锁。 </p><p>任务成功获取几次递归互斥信号量，就要返还几次，在此之前，递归互斥信号量都处于无效状态。</p><p>递归互斥信号量应用很少，简要了解即可。</p><h2 id="优先级翻转问题"><a href="#优先级翻转问题" class="headerlink" title="优先级翻转问题"></a>优先级翻转问题</h2><p>下面我们通过如下的框图来说明一下优先级翻转的问题，让大家有一个形象的认识。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_2.webp" alt=""></p><p><strong>运行条件：</strong></p><blockquote><ul><li>创建 3 个任务 Task1，Task2 和 Task3，优先级分别为 3，2，1。也就是 Task1 的优先级最高。 </li><li>任务 Task1 和 Task3 互斥访问串口打印 printf，采用二值信号实现互斥访问。</li><li>起初 Task3 通过二值信号量正在调用 printf，被任务 Task1 抢占，开始执行任务 Task1，也就是上图的起始位置。</li><li>任务 Task1 运行的过程需要调用函数 printf，发现任务 Task3 正在调用，任务 Task1 会被挂起，等待 Task3 释放函数 printf。 </li><li>在调度器的作用下，任务 Task3 得到运行，Task3 运行的过程中，由于任务 Task2 就绪，抢占了 Task3的运行。优先级翻转问题就出在这里了，<code>从任务执行的现象上看，任务 Task1 需要等待 Task2 执行完毕才有机会得到执行，这个与抢占式调度正好反了，正常情况下应该是高优先级任务抢占低优先级任务的执行，这里成了高优先级任务 Task1 等待低优先级任务 Task2 完成。这种情况被称之为</code><mark>优先级翻转问题</mark>。 </li><li>任务 Task2 执行完毕后，任务 Task3 恢复执行，Task3 释放互斥资源后，任务 Task1 得到互斥资源，从而可以继续执行。</li></ul></blockquote><p>上面就是一个产生优先级翻转问题的现象，想象一下，如果介于任务1与任务3之间的任务特别多，对于抢占式实时操作系统来说是致命的危害，有可能导致系统崩溃 ，下一讲通过编程进行验证。</p><p><mark>不过也不用担心，使用互斥信号量，可以有效的防止优先级翻转问题，后面会讲解。</mark></p><h2 id="优先级翻转编程测试"><a href="#优先级翻转编程测试" class="headerlink" title="优先级翻转编程测试"></a>优先级翻转编程测试</h2><p>串口输出信息：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree13_1.png" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* USER CODE BEGIN RTOS_SEMAPHORES */</span></span><br><span class="line">  <span class="comment">/* add semaphores, ... */</span></span><br><span class="line">  <span class="keyword">if</span> (myBinarySem01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建二值信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END RTOS_SEMAPHORES */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN HighPriority_Task */</span></span><br><span class="line"></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END HighPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN MidPriority_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END MidPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LowPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LowPriority_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_Delay</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LowPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----二值信号量—优先级翻转测试----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="互斥信号量的运作机制"><a href="#互斥信号量的运作机制" class="headerlink" title="互斥信号量的运作机制"></a>互斥信号量的运作机制</h2><p>互斥量处理不同任务对临界资源的访问时，任务要获得互斥量才能进行资源访问。一旦有任务成功获得了互斥量，则互斥量立即变为闭锁状态，此时其他任务会因为获取不到互斥量而不能访问这个资源。任务会根据用户自定义的等待时间进行等待，直到互斥量被持有的任务释放，其他任务才能获取互斥量从而得以访问该临界资源。此时互斥量再次上锁，如此一来就可以确保每个时刻只有一个任务正在访问这个临界资源，保证了临界资源操作的安全性，具体如下图所示。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_4.webp" alt=""></p><blockquote><p>①：因为互斥量具有优先级继承机制，一般选择使用互斥量对资源进行保护。当采用互斥量保护的资源被占用时，无论是什么优先级的任务，想要使用该资源都会被阻塞</p><p>②：假如正在使用该资源的任务1比阻塞中的任务2的优先级低，那么任务1的优先级将被系统临时提升到与高优先级任务2相等(任务1的优先级从L变成H),<mark>这个就是所谓的优先级继承，这样就有效地防止了优先级翻转问题，因为此时优先级介于任务1与任务2之间的任务，抢占不了CPU</mark>。</p><p>③：当任务1使用完资源之后，释放互斥量，此时任务1的优先级会从H变回原来的L</p><p>④~⑤：任务2此时可以获得互斥量，然后进行资源的访问，当任务2访问了资源时，该互斥量的状态又变为闭锁状态，其他任务无法获取互斥量。</p></blockquote><h2 id="互斥信号量常用的API函数"><a href="#互斥信号量常用的API函数" class="headerlink" title="互斥信号量常用的API函数"></a>互斥信号量常用的API函数</h2><p> 1、使用互斥信号量的典型流程如下：</p><blockquote><p>创建互斥信号量</p><p>释放互斥信号量</p><p>获取互斥信号量</p><p>删除互斥信号量</p></blockquote><p>2、常用API函数如下：</p><blockquote><p><code>xSemaphoreCreateMutex</code>()</p><p><code>xSemaphoreGive</code>()</p><p><code>xSemaphoreTake</code>()</p><p><code>vSemaphoreDelete</code>()</p></blockquote><p>3、互斥信号量创建与删除</p><ul><li>互斥信号量控制块(句柄)</li></ul><p>如下图：二值信号量的句柄为消息队列的句柄，因为二值信号量是一种长度为1，消息大小为0<strong>的特殊消息队列</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_5.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_6.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_7.webp" alt=""></p><ul><li>互斥信号量创建</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SemaphoreHandle_t <span class="title">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span></span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreCreateMutex</code>用于创建互斥信号量。</p><p> 返回值，如果创建成功会返回互斥信号量的句柄，如果由于 <code>FreeRTOSConfig.h</code> 文件中 <code>heap</code>大小不足，无法为此互斥信号量提供所需的空间会返回 NULL。</p><p>使用这个函数要注意以下问题</p><p>使用此函数要在 <code>FreeRTOSConfig.h</code> 文件中使能宏定义：</p><p><code>#define configUSE_MUTEXES 1</code></p><p>说明：此函数基于消息队列函数实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_8.png" alt=""></p><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_9.webp" alt=""></p><ul><li>互斥信号量删除</li></ul><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>; <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vSemaphoreDelete</code>可用于删除互斥信号量。 </p><p>4、互斥信号量释放</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive( SemaphoreHandle_t xSemaphore ); <span class="comment">/* 信号量句柄 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreGive</code> 用于在<mark>任务代码</mark>中释放信号量。</p><blockquote><p>第 1 个参数是信号量句柄。</p><p>返回值，如果信号量释放成功返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>，因为信号量的实现是基于消息队列，返回失败的主要原因是消息队列已经满了。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><p>此函数是用于任务代码中调用的，不可以在中断服务程序中调用此函数。</p><p>使用此函数前，一定要保证用函数 <code>xSemaphoreCreateBinary</code>(), <code>xSemaphoreCreateMutex</code>() 或者<code>xSemaphoreCreateCounting</code>()创建了信号量。</p><p>此函数不支持使用 <code>xSemaphoreCreateRecursiveMutex</code>()创建的信号量。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_10.webp" alt=""></p><p>5、互斥信号量获取</p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTake( </span><br><span class="line">    SemaphoreHandle_t xSemaphore, <span class="comment">/* 信号量句柄 */</span> </span><br><span class="line">    TickType_t xTicksToWait ); <span class="comment">/* 等待信号量可用的最大等待时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xSemaphoreTake</code>用于在任务代码中获取信号量。 </p><blockquote><p>第 1 个参数是信号量句柄。 </p><p>第 2 个参数是没有信号量可用时，等待信号量可用的最大等待时间，单位系统时钟节拍。</p><p>返回值，如果创建成功会获取信号量返回 <code>pdTRUE</code>，否则返回 <code>pdFALSE</code>。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>此函数是用于任务代码中调用的，不可以在中断服务程序中调用此函数。</p></li><li><p>如果消息队列为空且第 2 个参数为 0，那么此函数会立即返回。</p></li><li><p>如果用户将 <code>FreeRTOSConfig.h</code> 文件中的宏定义 <code>INCLUDE_vTaskSuspend</code>配置为 1 且第 2 个参数配置为 <code>portMAX_DELAY</code>，那么此函数会永久等待直到信号量可用。</p></li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_11.webp" alt=""></p><h2 id="互斥信号量的应用编程"><a href="#互斥信号量的应用编程" class="headerlink" title="互斥信号量的应用编程"></a>互斥信号量的应用编程</h2><p>视频讲解，互斥信号量应用于临界资源管理，解决优先级翻转问题</p><p>串口输出信息：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_12.png" alt=""></p><p>STM32cubeMX配置：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_13.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_14.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_15.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_16.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_17.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free13_18.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MX_FREERTOS_Init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (myMutex01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建互斥信号量失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建互斥信号量成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HighPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN HighPriority_Task */</span></span><br><span class="line"></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myMutex01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;高优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myMutex01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END HighPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MidPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN MidPriority_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;中优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END MidPriority_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LowPriority_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LowPriority_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务获取互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myMutex01Handle, portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务运行\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_Delay</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;低优先级任务释放互斥信号量\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreGive</span>(myMutex01Handle);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LowPriority_Task */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----互斥信号量—优先级翻转测试----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件的概念与应用"><a href="#事件的概念与应用" class="headerlink" title="事件的概念与应用"></a>事件的概念与应用</h2><p>1、事件的概念</p><p><strong>事件</strong>是实现任务与任务或任务与中断间通信的机制，用于同步，无数据传输。</p><p><mark>与信号量不同的是，事件可以实现一对多、多对多的同步，即一个任务可以等待多个事件的发生:可以是任意一个事件发生时唤醒任务进行事件处理;也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件</mark></p><p>FreeRTOS提供的事件具有如下特点:</p><blockquote><p>① 事件相互独立，一个32位的事件集合(<code>EventBitst</code>类型的变量，实际可用于表示事件的只有低24位)用于标识该任务发生的事件类型，其中每一位表示一种事件类型(0表示该事件类型未发生，1表示该事件类型已经发生)，一共有 24种事件类型。</p><p>②事件仅用于同步，不提供数据传输功能。</p><p>③ 事件无排队性，即多次向任务设置同一事件(如果任务还未来得及读取)，等效于只设置一次。</p><p>④允许多个任务对同一事件进行读写操作。</p><p>⑤ 支持事件等待超时机制。</p></blockquote><p>在FreeRTOS 事件中，获取每个事件时，用户可以选择感兴趣的事件，并且选择读取事件信息标记。它有3个属性，分别是逻辑与、逻辑或以及是否清除标记。当任务等待事件同步时，可以通过任务感兴趣的事件位和事件信息标记来判断当前接收的事件是否满足要求，如果满足，则说明任务等到对应的事件，系统将唤醒等待的任务;否则，任务会根据用户指定的阻塞超时时间继续等待下去。</p><p>2、事件的应用</p><p>FrecRTOS的事件用于任务与任务或任务与中断间的同步。为什么不直接用变量呢?那样岂不是更有效率?若是在裸机编程中，用全局变量是最有效的方法，但是在操作系统中，使用全局变量就要考虑以下问题了:</p><blockquote><p>①如何对全局变量进行保护?如何处理多任务同时对它进行访问的情况?</p><p>②如何让内核对事件进行有效管理?</p></blockquote><p>如果使用全局变量，就需要在任务中轮询查看事件是否发送，这会造成CPU 资源的浪费，此外，用户还需要自己去实现等待超时机制。所以，在操作系统中最好还是使用系统提供的通信机制，简单、方便、实用。</p><p>在某些场合，可能需要多个事件发生后才能进行下一步操作，比如一些危险机器的启动，需要检查各项指标，当指标不达标时就无法启动。但是检查各个指标时，不会立刻检测完毕，所以需要事件来做统一的等待。当所有的事件都完成了，那么机器才允许启动，这只是事件的应用之一</p><p>事件可用于多种场合，能够在一定程度上替代信号量，用于任务与任务间、中断与任务间的同步。一个任务或中断服务例程发送一个事件给事件对象，而后等待的任务被唤醒并对相应的事件进行处理。但是事件与信号量不同的是，事件的发送操作是不可累计的，而信号量的释放动作是可累计的。事件的另外一个特性是，接收任务可等待多种事件，即多个事件对应一个任务或多个任务。同时按照任务等待的参数，可选择是“逻辑或”触发还是“逻辑与”触发。这个特性也是信号量等所不具备的，信号量只能识别单一同步动作，而不能同时等待多个事件的同步。</p><p>各个事件可分别发送或一起发送给事件对象，而任务可以等待多个事件，任务仅对感兴趣的事件进行关注。当有它们感兴趣的事件发生并且符合条件时，任务将被唤醒并进行后续的处理动作。</p><h2 id="事件的运作机制"><a href="#事件的运作机制" class="headerlink" title="事件的运作机制"></a>事件的运作机制</h2><p>1、FreeRTOS中事件组的句柄</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">xEventGroupDefinition</span></span><br><span class="line">&#123;</span><br><span class="line">EventBits_t uxEventBits;</span><br><span class="line">List_t xTasksWaitingForBits;<span class="comment">/*&lt; List of tasks waiting for a bit to be set. */</span></span><br><span class="line"></span><br><span class="line">&#125; EventGroup_t;</span><br></pre></td></tr></table></figure><p><code>uxEventBits</code>: 对于STM32，此变量为32位，其中低24位用于事件位，高8位用于其他用途，暂时不必深究。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_2.webp" alt=""></p><p>2、FreeRTOS 任务间事件标志组的实现</p><p>任务间事件标志组的实现是指各个任务之间使用事件标志组实现任务的同步机制。</p><p>下面的框图说明FreeRTOS 事件标志的实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_3.webp" alt=""></p><p><strong>运行条件：</strong></p><p>创建 2 个任务：Task1 和 Task2</p><p><strong>运行过程描述如下：</strong></p><blockquote><ul><li>任务 Task1 运行过程中调用函数 <code>xEventGroupWaitBits</code>，等待事件标志位被设置，任务 Task1 由运行态进入到阻塞态。</li><li>任务 Task2 设置 Task1 等待的事件标志，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态。</li></ul></blockquote><p>上面就是一个简单的 FreeRTOS 任务间事件标志通信过程。</p><p>3、FreeRTOS 中断方式事件标志组的实现</p><p>FreeRTOS 中断方式事件标志组的实现是指中断函数和 FreeRTOS 任务之间使用事件标志。</p><p>下面的框图说明FreeRTOS 事件标志的实现：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_4.webp" alt=""></p><p><strong>运行条件：</strong></p><p>创建一个任务和一个串口接收中断</p><p><strong>运行过程描述如下：</strong></p><blockquote><p>任务 Task1 运行过程中调用函数 <code>xEventGroupWaitBits</code>，等待事件标志位被设置，任务 Task1 由运行态进入到阻塞态。</p><p>Task1 阻塞的情况下，串口接收到数据进入到了串口中断服务程序，在串口中断服务程序中设置 Task1等待的事件标志，任务 Task1 由阻塞态进入到就绪态，在调度器的作用下由就绪态又进入到运行态。</p></blockquote><p>上面就是一个简单的 FreeRTOS 中断方式事件标志通信过程。</p><p><mark>实际应用中，中断方式的消息机制要注意以下三个问题：</mark></p><blockquote><ul><li>中断函数的执行时间越短越好，防止其它低于这个中断优先级的异常不能得到及时响应。</li><li>实际应用中，建议不要在中断中实现消息处理，用户可以在中断服务程序里面发送消息通知任务，在任务中实现消息处理，这样可以有效地保证中断服务程序的实时响应。同时此任务也需要设置为高优先级，以便退出中断函数后任务可以得到及时执行。</li><li>中断服务程序中一定要调用专用于中断的事件标志设置函数，即以 <code>FromISR</code>结尾的函数。</li></ul></blockquote><h2 id="事件的API函数‍"><a href="#事件的API函数‍" class="headerlink" title="事件的API函数‍"></a>事件的API函数‍</h2><p> 1、使用事件的典型流程如下：</p><blockquote><p>创建事件组</p><p>置位事件组</p><p>等待事件组</p><p>删除事件组</p></blockquote><p>2、常用API函数如下：</p><blockquote><p><code>xEventGroupCreate</code>()</p><p><code>xEventGroupSetBits</code>() , <code>xEventGroupSetBitsFromISR</code>()</p><p><code>xEventGroupWaitBits</code>()</p><p><code>vEventGroupDelete</code>()</p></blockquote><p>3、事件组创建与删除</p><ul><li>事件组控制块(句柄)</li></ul><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_5.png" alt=""></p><p><code>uxEventBits</code>: 对于STM32，此变量为32位，其中低24位用于事件位</p><p><code>xTasksWaitingForBits</code>： 任务等待链表</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_6.png" alt=""></p><ul><li>创建事件组</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventGroupHandle_t <span class="title">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span></span>;</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xEventGroupCreate</code>用于创建事件标志组。</p><blockquote><p>返回值，如果创建成功，此函数返回事件标志组的句柄，如果 <code>FreeRTOSConfig.h</code> 文件中定义的 <code>heap</code>空间不足会返回 <code>NULL</code></p></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_7.webp" alt=""></p><ul><li>删除事件组</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vEventGroupDelete</span>(EventGroupHandle_t xEventGroup);</span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>vEventGroupDelete</code>可用于删除事件组。 </p><p>4、任务内置位事件组</p><p><strong>函数原型：</strong></p><p><code>EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,</code> /<em> 事件标志组句柄 </em>/</p><p><code>const EventBits_t uxBitsToSet )</code>; /<em> 事件标志位设置 </em>/</p><p><strong>函数描述：</strong></p><p>函数 <code>xEventGroupSetBits</code>用于设置指定的事件标志位为 1。</p><blockquote><ul><li>第 1 个参数是事件标志组句柄。</li><li>第 2 个参数表示 24 个可设置的事件标志位，<code>EventBits_t</code>是定义的 32 位变量，低 24 位用于事件标志设置。变量 <code>uxBitsToSet</code>的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 <code>uxBitsToSet</code>设置为 0 的位对事件标志相应位没有影响。比如设置变量 <code>uxBitsToSet</code> = 0x0003 就表示将事件标志的位 0 和位 1 设置为 1，其余位没有变化。</li><li>返回当前的事件标志组数值。</li></ul></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>使用前一定要保证事件标志组已经通过函数 <code>xEventGroupCreate</code>创建了。</p></li><li><p>此函数是用于任务代码中调用的，故不可以在中断服务程序中调用此函数，中断服务程序中使用的是<code>xEventGroupSetBitsFromISR</code></p></li><li><p>用户通过参数 <code>uxBitsToSet</code>设置的标志位并不一定会保留到此函数的返回值中，下面举两种情况：</p><ul><li>调用此函数的过程中，其它高优先级的任务就绪了，并且也修改了事件标志，此函数返回的事件标志位会发生变化。</li><li>调用此函数的任务是一个低优先级任务，通过此函数设置了事件标志后，让一个等待此事件标志的高优先级任务就绪了，会立即切换到高优先级任务去执行，相应的事件标志位会被函数<code>xEventGroupWaitBits</code> 清除掉，等从高优先级任务返回到低优先级任务后，函数<code>xEventGroupSetBits</code>的返回值已经被修改。</li></ul></li></ol></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_8.webp" alt=""></p><p>5、中断内置位事件组</p><p><strong>函数原型：</strong></p><p><code>BaseType_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup,</code> /<em> 事件标志组句柄 </em>/</p><p><code>const EventBits_t uxBitsToSet,</code> /<em> 事件标志位设置 </em>/</p><p><code>BaseType_t *pxHigherPriorityTaskWoken )</code>; / <em> 高优先级任务是否被唤醒的状态保存 </em>/</p><p><strong>函数描述：</strong></p><p>函数 <code>xEventGroupSetBits</code>用于设置指定的事件标志位为 1。</p><blockquote><ul><li>第 1 个参数是事件标志组句柄。</li><li>第 2 个参数表示 24 个可设置的事件标志位，<code>EventBits_t</code> 是定义的 32 位变量，低 24 位用于事件标志设置。变量 <code>uxBitsToSet</code> 的低 24 位的某个位设置为 1，那么被设置的事件标志组的相应位就设置为 1。变量 <code>uxBitsToSet</code>设置为 0 的位对事件标志相应位没有影响。比如设置变量 <code>uxBitsToSet</code>= 0x0003 就表示将事件标志的位 0 和位 1 设置为 1，其余位没有变化。</li><li>第 3 个参数用于保存是否有高优先级任务准备就绪。如果函数执行完毕后，此参数的数值是 <code>pdTRUE</code>，说明有高优先级任务要执行，否则没有。</li><li>返回值，如果消息成功发送给守护任务（就是FreeRTOS 的定时器服务任务）返回 <code>pdPASS</code>，否则返回 <code>pdFAIL</code>，另外守护任务中的消息队列满了也会返回 <code>pdFAIL</code>。</li></ul></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li>使用前一定要保证事件标志已经通过函数 <code>xEventGroupCreate</code>创建了。同时要在<code>FreeRTOSConfig.h</code></li></ol><p>文件中使能如下三个宏定义：</p><p><code>#define INCLUDE_xEventGroupSetBitFromISR 1</code></p><p><code>#define configUSE_TIMERS 1</code></p><p><code>#define INCLUDE_xTimerPendFunctionCall 1</code></p><ol><li><p>函数 <code>xEventGroupSetBitsFromISR</code>是用于中断服务程序中调用的，故不可以在任务代码中调用此函数，任务代码中使用的是 <code>xEventGroupSetBits</code>。</p></li><li><p>函数 <code>xEventGroupSetBitsFromISR</code>对事件标志组的操作是不确定性操作，因为不知道当前有多少个任务在等待此事件标志。而 FreeRTOS 不允许在中断服务程序和临界段中执行不确定性操作。为了不在中断服务程序中执行，就通过此函数给 FreeRTOS 的守护任务（就是 FreeRTOS 的定时器服务任务，内核自动创建的）发送消息，在守护任务中执行事件标志的置位操作。同时也为了不在临界段中执行此不确定操作，将临界段改成由调度锁来完成。这样不确定性操作在中断服务程序和临界段中执行的问题就都得到解决了。</p></li><li><p>由于函数 <code>xEventGroupSetBitsFromISR</code>对事件标志的置位操作是在守护任务里面执行的，如果想让置位操作立即生效，即让等此事件标志的任务能够得到及时执行，需要设置守护任务的优先级高于使用此事件标志组的所有其它任务。</p></li></ol></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_9.webp" alt=""></p><p>6、等待事件组</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventBits_t <span class="title">xEventGroupWaitBits</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> EventGroupHandle_t xEventGroup,` <span class="comment">/* 事件标志组句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> EventBits_t uxBitsToWaitFor,` <span class="comment">/* 等待被设置的事件标志位*/</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> BaseType_t xClearOnExit,` <span class="comment">/* 选择是否清零被置位的事件标志位 */</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> BaseType_t xWaitForAllBits,` <span class="comment">/* 选择是否等待所有标*/</span></span></span></span><br><span class="line"><span class="params"><span class="function">TickType_t xTicksToWait )</span>`</span>; <span class="comment">/* 设置等待时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xEventGroupWaitBits</code>等待事件标志被设置。</p><blockquote><ul><li>第 1 个参数是事件标志组句柄。</li><li>第 2 个参数表示等待 24 个事件标志位中的指定标志，<code>EventBits_t</code>是定义的 32 位变量，低 24 位用于事件标志设置。比如设置变量 <code>uxBitsToWaitFor</code>= 0x0003 就表示等待事件标志的位 0 和位 1 设置为 1。此参数切不可设置为 0。</li><li>第 3 个参数选择是否清除已经被置位的事件标志，如果这个参数设置为 <code>pdTRUE</code>，且函数<code>xEventGroupWaitBits</code>在参数 <code>xTicksToWait</code>设置的溢出时间内返回或等到满足任务唤醒的事件时，相应被设置的事件标志位会被清零。如果这个参数设置为 <code>pdFALSE</code>，对已经被设置的事件标志位没有影响。</li><li>第 4 个参数选择是否等待所有的标志位都被设置，如果这个参数设置为 <code>pdTRUE</code>，要等待第 2 个参数 <code>uxBitsToWaitFor</code>所指定的标志位全部被置 1，函数才可以返回。当然，超出了在参数<code>xTicksToWait</code>设置的溢出时间也是会返回的。如果这个参数设置为 <code>pdFALSE</code>，第 2 个参数<code>uxBitsToWaitFor</code>所指定的任何标志位被置 1，函数都会返回，超出溢出时间也会返回。</li><li>第 5 个参数设置等待时间，单位时钟节拍周期。如果设置为 <code>portMAX_DELAY</code>，表示永久等待。</li><li>返回值，由于设置的时间超时或者指定的事件标志位被置 1，导致函数退出时返回的事件标志组数值。</li></ul></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li><p>此函数切不可在中断服务程序中调用。</p></li><li><p>着重说明下这个函数的返回值，通过返回值用户可以检测是哪个事件标志位被置 1 了</p><ul><li>如果由于设置的等待时间超时，函数的返回值可会有部分事件标志位被置 1。</li><li>如果由于指定的事件标志位被置1而返回，并且设置了这个函数的参数<code>xClearOnExit</code>为<code>pdTRUE</code>，那么此函数的返回值是清零前的事件标志组数值。</li></ul></li></ol><p>另外，调用此函数的任务在离开阻塞状态到退出函数 <code>xEventGroupWaitBits</code>之间这段时间，如果一个高优先级的任务抢占执行了，并且修改了事件标志位，那么此函数的返回值会跟当前的事件标志组数值不同。</p></blockquote><p><strong>使用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_10.webp" alt=""></p><h2 id="事件的应用-任务与任务"><a href="#事件的应用-任务与任务" class="headerlink" title="事件的应用 - 任务与任务"></a>事件的应用 - 任务与任务</h2><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_11.png" alt=""></p><p>2、任务配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_12.png" alt=""></p><p>LED1_Task： 运行指示灯</p><p>KEY_Task：  按键，打印任务信息，触发事件</p><p>Event_Sync_Task:  等待事件，同步任务</p><p>3、创建事件组</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_13.webp" alt=""></p><p>4、按键任务部分代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_14.webp" alt=""></p><p>5、同步任务代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_15.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_EVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_EVENT (EventBits_t)(0x0001 &lt;&lt; 8)  <span class="comment">// 设置事件掩码8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_EVENT (EventBits_t)(0x0001 &lt;&lt; 16) <span class="comment">// 设置事件掩码16</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVent_WaitAllBits <span class="comment">// 用于预编译</span></span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键2事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键2事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY2_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键3事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键3事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY3_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 触发按键4事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;触发按键4事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, KEY4_EVENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line">  <span class="type">uint16_t</span> SyncCnt = <span class="number">0</span>; <span class="comment">// 同步计数</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EVent_WaitAllBits</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,                      <span class="comment">// 事件句柄</span></span><br><span class="line">        KEY2_EVENT | KEY3_EVENT | KEY4_EVENT, <span class="comment">// 事件 - 按键2，3，4</span></span><br><span class="line">        pdTRUE,                               <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdTRUE,                               <span class="comment">//&quot;逻辑与&quot; - 满足所有条件</span></span><br><span class="line">        portMAX_DELAY);                       <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((xEvent &amp; (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT)) == (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收事件同步信号，次数=%u\r\n\r\n&quot;</span>, ++SyncCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,                      <span class="comment">// 事件句柄</span></span><br><span class="line">        KEY2_EVENT | KEY3_EVENT | KEY4_EVENT, <span class="comment">// 事件 - 按键2，3，4</span></span><br><span class="line">        pdTRUE,                               <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdFALSE,                              <span class="comment">//&quot;逻辑或&quot; - 满足所有条件</span></span><br><span class="line">        portMAX_DELAY);                       <span class="comment">// 无限等待</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((xEvent &amp; KEY2_EVENT) == KEY2_EVENT) || ((xEvent &amp; KEY3_EVENT) == KEY3_EVENT) || ((xEvent &amp; KEY4_EVENT) == KEY4_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功接收事件同步信号，次数=%u\r\n\r\n&quot;</span>, ++SyncCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----事件组同步应用编程 - 任务与任务----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：打印按键事件2\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：打印按键事件3\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：打印按键事件4\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件的应用-中断与任务"><a href="#事件的应用-中断与任务" class="headerlink" title="事件的应用 - 中断与任务"></a>事件的应用 - 中断与任务</h2><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_16.png" alt=""></p><p>2、任务配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_17.png" alt=""></p><p>LED1_Task： 运行指示灯</p><p>KEY_Task：  按键，打印任务信息，触发事件</p><p>Event_Sync_Task:  等待事件，同步任务</p><p>3、开启FreeRTOS软件定时器</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_18.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_19.webp" alt=""></p><p>4、创建事件组</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_20.webp" alt=""></p><p>5、同步任务代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_21.webp" alt=""></p><p>6、串口3回调函数代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free14_22.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART3_RecEVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span>ucUART3_Rec_Data[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;  <span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;通过串口接口发送12个字符\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">HAL_UART_Receive_IT</span>(&amp;huart3,(<span class="type">uint8_t</span> *)ucUART3_Rec_Data,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待事件同步信号，无限等待\r\n&quot;</span>);</span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">      MyEvent01Handle,</span><br><span class="line">      UART3_RecEVENT,</span><br><span class="line">      pdTRUE,</span><br><span class="line">      pdTRUE,</span><br><span class="line">      portMAX_DELAY</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((xEvent&amp;UART3_RecEVENT)  == UART3_RecEVENT)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;接收到的串口数据: %s\r\n\r\n&quot;</span>,ucUART3_Rec_Data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>CallBack.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UART3_RecEVENT (EventBits_t)(0x0001 &lt;&lt; 0) <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="type">uint8_t</span> ucUART3_Rec_Data[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//存放串口数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> EventGroupHandle_t MyEvent01Handle;  <span class="comment">//事件组句柄</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BaseType_t xHigherPriorityTaskWoken = pdFALSE; <span class="comment">// 定义一个用于确定是否需要进行任务切换的变量，默认为pdFALSE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (huart-&gt;Instance == huart3.Instance) <span class="comment">// 检查接收数据的UART实例是否为huart3</span></span><br><span class="line">    &#123;</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED2); <span class="comment">// 如果是huart3，则翻转LED（假设LED为某种指示灯）</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">xEventGroupSetBitsFromISR</span>(MyEvent01Handle, UART3_RecEVENT, &amp;xHigherPriorityTaskWoken); <span class="comment">// 设置一个事件标志以通知其他任务数据已经接收完成，如果有高优先级任务被唤醒，则将xHigherPriorityTaskWoken设置为pdTRUE</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">portYIELD_FROM_ISR</span>(xHigherPriorityTaskWoken); <span class="comment">// 根据xHigherPriorityTaskWoken的值来决定是否进行任务切换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="软件定时器"><a href="#软件定时器" class="headerlink" title="软件定时器"></a>软件定时器</h1><h2 id="软件定时器的概念"><a href="#软件定时器的概念" class="headerlink" title="软件定时器的概念"></a>软件定时器的概念</h2><p>1、软件定时器的概念</p><p>FreeRTOS 软件定时器的时基是基于系统时钟节拍实现的，之所以叫软件定时器是因为它的实现不需要额外使用硬件定时器，而且可以创建很多个，综合这些因素，这个功能就被称之为软件定时器组。既然是定时器，那么它实现的功能与硬件定时器也是类似的。在硬件定时器中，我们是在定时器中断中实现需要的功能，而使用软件定时器时，我们是在创建软件定时器时指定软件定时器的回调函数，在回调函数中实现相应的功能。</p><p>2、FreeRTOS提供的软件定时器支持如下功能：</p><blockquote><p>① 裁剪，可通过宏关闭软件定时器功能</p><p>② 软件定时器创建</p><p>③ 软件定时器启动</p><p>④ 软件定时器停止</p><p>⑤ 软件定时器复位</p><p>⑥ 软件定时器删除</p></blockquote><p>软件定时器的使用相当于扩展了定时器的数量，允许创建更多的定时任务。 </p><p>3、单次模式与周期模式</p><p>FreeRTOS 提供的软件定时器支持单次模式和周期性模式，单次模式就是用户创建了定时器并启动了定时器后，定时时间到将不再重新执行，这就是单次模式软件定时器的含义。周期模式就是此定时器会按照设置的时间周期重复去执行，这就是周期模式软件定时器的含义。另外就是单次模式或者周期模式的定时时间到后会调用定时器的回调函数，用户可以回调函数中加入需要执行的工程代码。</p><p>4、定时器守护任务</p><p>FreeRTOS通过一个<code>prvTimerTask</code>任务(也叫作守护任务(<code>Daemon</code>))管理软件定时器，它是在启动调度器时自动创建的，以满足用户定时需求。<code>pryTimerTask</code>任务会在其执行期间检查用户启动的时间周期溢出的定时器，并调用其回调函数。只有设置 <code>FreeRTOSConfig.h</code>中的宏定义<code>configUSE_TIMERS</code>为<code>1</code>，将相关代码编译进来，才能正常使用软件定时器相关功能。</p><p>FreeRTOS 定时器组的大部分 API 函数都是通过消息队列给定时器任务发消息，在定时器任务里面执行实际的操作。为了更好的说明这个问题，我们将官方在线版手册中的这个截图贴出来进行说明：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_1.webp" alt=""></p><p>左侧图是用户应用程序，右侧是定时器任务。在用户应用程序里面调用了定时器组API函数<code>xTimerReset</code>，这个函数会通过消息队列给定时器任务发消息，在定时器任务里面执行实际操作。消息队列在此处的作用有一个专门的名字：<mark>Timer command queue</mark>，即专门发送定时器组命令的队列。</p><h2 id="软件定时器的应用"><a href="#软件定时器的应用" class="headerlink" title="软件定时器的应用"></a>软件定时器的应用</h2><p>1、应用场景</p><p>在很多应用中，我们需要用到一些定时器任务，硬件定时器受硬件的限制，数量上不足以满足用户的实际需求，无法提供更多的定时器，那么可以采用软件定时器来完成，由软件定时器任务代替硬件定时器任务。但需要注意的是，软件定时器的精度是无法和硬件定时器相比的，因为在软件定时器的定时过程中极有可能被其他中断所打断，这是由于软件定时器的执行上下文环境是任务<strong>(<code>prvTimerTask</code>任务)</strong>。所以，软件定时器更适用于对时间精度要求不高的任务，或一些辅助型的任务。</p><p>2、软件定时器的精度</p><p>在操作系统中，通常软件定时器以系统节拍周期为计时单位。系统节拍是系统的心跳节拍，表示系统时钟的频率，类似人的心跳 1s 能跳动多少下。系统节拍配置为 <code>configTICK_RATE</code>HZ，该宏在<code>FreeRTOSConfig.h</code> 中有定义，默认是<code>1000</code>。那么系统的时钟节拍周期就为1ms(1s 跳动 1000 下，每一下时长就为 1ms)。软件定时器的所定时数值必须是这个节拍周期的整数倍，例如节拍周期是10ms，那么上层软件定时器定时数值只能是 10ms、20ms、100ms 等，而不能取值为 15ms。由于节拍定义了系统中定时器能够分辨的精确度，系统可以根据实际CPU的处理能力和实时性需求设置合适的数值，系统节拍周期的值越小，精度越高，但是系统开销也将越大，因为这代表在1s 中系统进入时钟中断的次数也就越多。</p><p>3、回调函数</p><p>在<code>prvTimerTask</code>任务中检测软件定时器，一旦定时时间到，将执行回调函数(<mark>被作为参数传递的函数，间接调用</mark>)，以完成任务。 </p><p>详情如下面的图片：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_2.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_3.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_4.png" alt=""></p><p>4、使用时注意事项</p><blockquote><p>① <code>prvTimerTask</code>任务的优先级设置高些，以便及时处理软件定时器的相关指令；</p><p>② 定时器回调函数是在定时器任务中执行的，实际应用中不可在定时器回调函数中调用任何将定时器任务挂起的函数，比如<code>vTaskDelay</code>(), <code>vTaskDelayUntil</code>()以及非零延迟的消息队列和信号量相关的函数。将定时器任务挂起，会导致定时器任务负责的相关功能都不能正确执行了。</p></blockquote><h2 id="软件定时器的API函数‍"><a href="#软件定时器的API函数‍" class="headerlink" title="软件定时器的API函数‍"></a>软件定时器的API函数‍</h2><p> 1、使用软件定时器的典型流程如下：</p><blockquote><p>创建软件定时器</p><p>启动软件定时器</p><p>停止软件定时器</p><p>删除软件定时器</p><p>获取软件定时器ID</p></blockquote><p>2、常用API函数如下：</p><blockquote><p><code>xTimerCreate</code>()</p><p><code>xTimerStart</code>()</p><p><code>xTimerStop</code>()</p><p><code>xTimerDelete</code>()</p><p><code>pvTimerGetTimerID</code>()</p></blockquote><p>3、软件定时器的创建与删除</p><ul><li>软件定时器控制块(句柄)</li></ul><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_5.png" alt=""></p><p>结构体成员变量说明：</p><blockquote><p>① 软件定时器的名字，一般用于调试，因为控制定时器是通过句柄</p><p>② 软件定时器的列表项，用于插入定时器链表</p><p>③ 软件定时器的周期，单位为系统节拍(<code>tick</code>)</p><p>④ 软件定时器是否自动重置，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p><p>⑤ 软件定时器的数字ID，典型用法是多个定时器共用一个回调函数时，通过ID辨别</p><p>⑥ 软件定时器的回调函数，当定时时间到就会调用这个函数</p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_6.png" alt=""></p><ul><li>创建软件定时器</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerCreate</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName, <span class="comment">/* 定时器名字 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TickType_t xTimerPeriod, <span class="comment">/* 定时器周期，单位系统时钟节拍 */</span></span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="type">const</span> UBaseType_t uxAutoReload, <span class="comment">/* 选择单次模式或者周期模式 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">     <span class="type">void</span> * <span class="type">const</span> pvTimerID,        <span class="comment">/* 定时器 ID */</span></span></span></span><br><span class="line"><span class="params"><span class="function">     TimerCallbackFunction_t pxCallbackFunction )</span></span>; <span class="comment">/* 定时器回调函数 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xTimerCreate</code>用于创建软件定时器。</p><blockquote><p>第 1 个参数是定时器名字，用于调试目的，方便识别不同的定时器。</p><p>第 2 个参数是定时器周期，单位系统时钟节拍。</p><p>第 3 个参数是选择周期模式还是单次模式，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p><p>第 4 个参数是定时器 ID，当不同的定时器使用相同的回调函数时，在回调函数中通过不同的ID 号来区分不同的定时器。</p><p>第 5 个参数是定时器回调函数。</p><p>返回值，创建成功返回定时器的句柄，由于 <code>FreeRTOSCongfig.h</code> 文件中 <code>heap</code>空间不足，或者定时器周期设置为 0，会返回 NULL。</p></blockquote><p>使用这个函数要注意以下问题：</p><p>在 <code>FreeRTOSConfig.h</code> 文件中使能宏定义：</p><p><code>#define configUSE_TIMERS   1</code></p><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_7.webp" alt=""></p><ul><li>删除软件定时器</li></ul><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimerHandle_t <span class="title">xTimerDelede</span>    </span></span><br><span class="line"><span class="function">          <span class="params">(TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">          TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xTimerCreate</code>用于创建软件定时器。</p><blockquote><p>第 1 个参数是定时器句柄</p><p>第 2 个参数定时器队列消息发送超时间，定时器组的大部分 API函数不是直接运行的，而是通过消息队列给定时器任务发消息来实现的，此参数设置的等待时间就是当消息队列已经满的情况下，等待消息队列有空间时的最大等待时间。</p><p>返回值，返回 <code>pdFAIL</code>表示此函数向消息队列发送消息失败，返回 <code>pdPASS</code>表示此函数向消息队列发送消息成功。定时器任务实际执行消息队列发来的命令依赖于定时器任务的优先级，如果定时器任务是高优先级会及时得到执行，如果是低优先级，就要等待其余高优先级任务释放 CPU 权才可以得到执行。</p></blockquote><p><strong>应用举例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">xTimerDelede</span>(MyTimer01Handle, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>4、启动软件定时器</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTimerStart</span></span></span><br><span class="line"><span class="function">      <span class="params">( TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">       TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xTimerStart</code>用于启动软件定时器。</p><blockquote><p>第 1 个参数是定时器名字，用于调试目的，方便识别不同的定时器。</p><p>第 2 个参数是定时器周期，单位系统时钟节拍。</p><p>第 3 个参数是选择周期模式还是单次模式，<code>pdFALSE</code>-&gt;单次模式；<code>pdTRUE</code>-&gt;周期模式</p><p>第 4 个参数是定时器 ID，当不同的定时器使用相同的回调函数时，在回调函数中通过不同的ID 号来区分不同的定时器。</p><p>第 5 个参数是定时器回调函数。</p><p>返回值，创建成功返回定时器的句柄，由于 <code>FreeRTOSCongfig.h</code>文件中 <code>heap</code>空间不足，或者定时器周期设置为 0，会返回 NULL。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li>使用前一定要保证定时器组已经通过函数 <code>xTimerCreate</code>创建了。</li><li>对于已经被激活的定时器，即调用过函数 <code>xTimerStart</code>进行启动，再次调用此函数相当于调用了函数<code>xTimerReset</code>对定时器时间进行了复位。</li><li>如果在启动 FreeRTOS 调度器前调用了此函数，定时器是不会立即执行的，需要等到启动了 FreeRTOS调度器才会得到执行，即从此刻开始计时，达到 <code>xTimerCreate</code>中设置的单次或者周期性延迟时间才会执行相应的回调函数。</li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_8.webp" alt=""></p><p>5、停止软件定时器</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTimerStop</span></span></span><br><span class="line"><span class="function">      <span class="params">( TimerHandle_t xTimer, <span class="comment">/* 定时器句柄 */</span></span></span></span><br><span class="line"><span class="params"><span class="function">       TickType_t xBlockTime )</span></span>; <span class="comment">/* 定时器队列消息发送超时时间 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>xTimerStart</code>用于停止软件定时器。</p><blockquote><p>第 1 个参数是定时器句柄。</p><p>第 2 个参数定时器队列消息发送超时间</p><p>返回值，返回 <code>pdFAIL</code>表示此函数向消息队列发送消息失败，返回 <code>pdPASS</code>表示此函数向消息队列发送消息成功。才可以得到执行。</p></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_9.webp" alt=""></p><p>5、获取软件定时器ID</p><p><strong>函数原型：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span></span>; <span class="comment">/* 定时器句柄 */</span></span><br></pre></td></tr></table></figure><p><strong>函数描述：</strong></p><p>函数 <code>pvTimerGetTimerID</code>用于获取软件定时器ID。</p><blockquote><p>第 1 个参数是定时器句柄。</p><p>返回值，返回定时器 ID。</p></blockquote><p>使用这个函数要注意以下问题：</p><blockquote><ol><li>使用前一定要保证定时器组已经通过函数 <code>xTimerCreate</code>创建了。</li><li>创建不同的定时器时，可以对定时器使用相同的回调函数，在回调函数中通过此函数获取是哪个定时器的时间到了，这个功能就是此函数的主要作用。</li></ol></blockquote><p><strong>应用举例：</strong></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_10.png" alt=""></p><h2 id="软件定时器的应用编程"><a href="#软件定时器的应用编程" class="headerlink" title="软件定时器的应用编程"></a>软件定时器的应用编程</h2><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_11.png" alt=""></p><p>2、STM32CubeMX初始化</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_12.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_13.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_14.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_15.webp" alt=""></p><p>4、创建并启动软件定时器</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_16.webp" alt=""></p><p>5、软件定时器回调函数</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free15_17.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器ID</span></span><br><span class="line"><span class="type">uint8_t</span> Timer01_ID = <span class="number">1</span>;</span><br><span class="line"><span class="type">uint8_t</span> Timer02_ID = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义软件定时器</span></span><br><span class="line"><span class="type">static</span> TimerHandle_t MyTimer01Handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> TimerHandle_t MyTimer02Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//软件定时器回调函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">vMyTimerCallback</span><span class="params">(xTimerHandle pxTimer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> Timer_ID = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Timer01CallbackCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">uint16_t</span> Timer02CallbackCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检验形参</span></span><br><span class="line">  <span class="built_in">configASSERT</span>(pxTimer);</span><br><span class="line">  <span class="comment">// 获取软件定时器ID</span></span><br><span class="line">  Timer_ID = *((<span class="type">uint8_t</span> *)<span class="built_in">pvTimerGetTimerID</span>(pxTimer));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行软件定时器1任务</span></span><br><span class="line">  <span class="keyword">if</span> (Timer_ID == Timer01_ID)</span><br><span class="line">  &#123;</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;软件定时器1回调次数 = %u\r\n&quot;</span>, ++Timer01CallbackCnt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行软件定时器2任务</span></span><br><span class="line">  <span class="keyword">if</span> (Timer_ID == Timer02_ID)</span><br><span class="line">  &#123;</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;软件定时器2回调次数 = %u\r\n&quot;</span>, ++Timer02CallbackCnt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建软件定时器1并启动</span></span><br><span class="line">  MyTimer01Handle = <span class="built_in">xTimerCreate</span>(</span><br><span class="line">      <span class="string">&quot;timer01&quot;</span>,  <span class="comment">//名字</span></span><br><span class="line">      <span class="number">100</span>,  <span class="comment">//定时周期 - 100ms</span></span><br><span class="line">      pdTRUE,  <span class="comment">//周期模式</span></span><br><span class="line">      (<span class="type">void</span> *)&amp;Timer01_ID,  <span class="comment">//ID</span></span><br><span class="line">      (TimerCallbackFunction_t)vMyTimerCallback <span class="comment">//回调函数</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MyTimer01Handle != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建软件定时器1成功\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer01Handle, <span class="number">0</span>) == pdPASS)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;启动软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建软件定时器2并启动</span></span><br><span class="line">  MyTimer02Handle = <span class="built_in">xTimerCreate</span>(</span><br><span class="line">      <span class="string">&quot;timer02&quot;</span>,  <span class="comment">//名字</span></span><br><span class="line">      <span class="number">500</span>,  <span class="comment">//定时周期 - 500ms</span></span><br><span class="line">      pdTRUE,  <span class="comment">//周期模式</span></span><br><span class="line">      (<span class="type">void</span> *)&amp;Timer02_ID,  <span class="comment">//ID</span></span><br><span class="line">      vMyTimerCallback  <span class="comment">//回调函数</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (MyTimer02Handle != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建软件定时器2成功\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer02Handle, <span class="number">0</span>) == pdPASS)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;启动软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 关闭软件定时器1</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStop</span>(MyTimer01Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器1失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭软件定时器2</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStop</span>(MyTimer02Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;关闭软件定时器2失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 打开软件定时器1</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer01Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器1成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器1失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 打开软件定时器2</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">xTimerStart</span>(MyTimer02Handle, <span class="number">100</span>) == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器2成功\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开软件定时器2失败\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----软件定时器应用编程----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：停止软件定时器1和2\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：启动软件定时器1\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：启动软件定时器2\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h1><h2 id="任务通知的概念"><a href="#任务通知的概念" class="headerlink" title="任务通知的概念"></a>任务通知的概念</h2><p>FreeRTOS 从 V8.2.0 版本开始提供任务通知功能，每个任务都有一个 32位的通知值，在多数情况下，任务通可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列(可以保存一个 32位整数或指针值)。</p><p>相对于以前使用 FreeRTOS 内核通信的资源时必须创建队列、二进制信号量、计数信号量或事件组的情况，使用任务通知显然更灵活。按照 FreeRTOS 官方的说法，使用任务通知比通过信号量等ICP通信方式解除阻塞的任务速度快45%，并且更加省RAM内存空间，任务通知的使用无须创建队列。要想使用任务通知，必须将<code>FreeRTOSConfig.h</code>中的宏定义<code>configUSE_TASK_NOTIFICATIONS</code>设置为<code>1</code>。其实 FreeRTOS 默认是为1的，所以任务通知是默认可用的。</p><p>FreeRTOS 提供以下几种方式发送通知给任务：</p><blockquote><p>发送通知给任务，如果有通知未读，则不覆盖通知值。</p><p>发送通知给任务，直接覆盖通知值。</p><p>发送通知给任务， 设置通知值的一个或者多个位，可以当作事件组来使用。</p><p>发送通知给任务，递增通知值，可以当作信号量使用。</p></blockquote><p>通过对以上任务通知方式的合理使用，可以在一定场合下替代 FreeRTOS 的信号量、队列、事件组等。</p><p>当然，凡事都有利弊，消息通知虽然处理更快，RAM 开销更小，但也有以下限制:</p><blockquote><p>只能有一个任务接收通知消息，因为必须指定接收通知的任务。</p><p>只有等待通知的任务可以被阻塞，发送通知的任务在任何情况下都不会因为发送失败而进入阻塞态。</p></blockquote><h2 id="任务通知的运行机制"><a href="#任务通知的运行机制" class="headerlink" title="任务通知的运行机制"></a>任务通知的运行机制</h2><p>任务通知属于任务附带的资源，所以在任务被创建时，任务通知也被初始化，我们知道在使用队列、信号量前，必须先创建队列和信号量，目的是创建队列数据结构，比如使用<code>xQueueCreate</code>() 函数创建队列，用<code>xSemaphoreCreateBinary</code>()函数创建二值信号量等。再来看任务通知，由于任务通知的数据结构包含在任务控制块中，只要任务存在，任务通知数据结构就已经创建完毕，可以直接使用，所以使用时很方便</p><p>任务通知可以在任务中向指定任务发送通知，也可以在中断中向指定任务发送通知。FreeRTOS的每个任务都有一个32位的通知值，任务控制块中的成员变量<code>ulNotifiedValue</code>就是这个通知值。只有在任务中可以等待通知，而不允许在中断中等待通知。如果任务在等待的通知暂时无效，任务会根据用户指定的阻塞超时时间进入阻塞状态，我们可以将等待通知的任务看作消费者;其他任务和中断可以向等待通知的任务发送通知，发送通知的任务和中断服务函数可以看作生产者，当其他任务或者中断向这个任务发送任务通知，且任务获得通知以后，该任务就会从阻塞态中解除，这与 FreeRTOS 中内核的其他通信机制一致。</p><h2 id="任务通知的API函数‍"><a href="#任务通知的API函数‍" class="headerlink" title="任务通知的API函数‍"></a>任务通知的API函数‍</h2><p>1、任务通知的数据结构</p><p>任务通知是任务控制块的资源，属于任务控制块中的成员变量，具体如下：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_1.png" alt=""></p><p><code>ulNotifiedValue</code>: 任务通知值，用于保存一个32位整数或指针值</p><p><code>ucNotifyState</code>： 任务通知状态，用于标识任务的通知状态</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_2.png" alt=""></p><p>2、常用的API函数</p><p>① 替代二值信号量与计数信号量</p><p>发送任务通知：</p><p><code>xTaskNotifyGive</code>()</p><p><code>vTaskNotifyGiveFromISR</code>()</p><p>获取任务通知：</p><p><code>ulTaskNotifyTake</code>()</p><p>② 替代长为1的队列与事件组</p><p>发送任务通知：</p><p><code>xTaskNotify</code>()</p><p><code>vTaskNotifyFromISR</code>()</p><p>获取任务通知：</p><p><code>ulTaskNotifyWait</code>()</p><p>3、函数<code>xTaskNotifyGive</code>()</p><p>① 函数原型</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_3.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_4.png" alt=""></p><p><code>功能如下</code>：在任务中向指定任务发送通知，使任务通知值加1，这种方式用于信号量</p><p>②形参说明</p><blockquote><p>形参1：任务句柄</p><p>形参2： 任务通知值，取0</p><p>形参3： 指示任务控制块中的变量 <code>ulNotifiedValue</code>实现加一操作</p><p>形参4：空</p></blockquote><p>③返回值</p><p>没有超时机制，永远返回<code>pdPASS</code></p><p>4、函数<code>ulTaskNotifyTake</code>()</p><p>① 函数原型</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_5.webp" alt=""></p><p><code>功能如下</code>：在任务中获取通知，与<code>xTaskNotifyGive</code>()配套使用，用于替代二值信号量与计数信号量</p><p>②形参说明</p><blockquote><p>形参1：退出时是否清零计数。<code>pdTRUE</code>-&gt;清零， <code>pdFALSE</code>-&gt; 减1</p><p>形参2： 超时时间，单位为系统节拍</p></blockquote><p>③返回值</p><p>返回任务之前的任务通知值</p><p>5、函数<code>xTaskNotify</code>()</p><p>① 函数原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t <span class="title">xTaskGenericNotify</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    TaskHandle t xTaskToNotify</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulValue,</span></span></span><br><span class="line"><span class="params"><span class="function">    eNotifyAction eAction</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t *pulPreviousNotificationValue</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br></pre></td></tr></table></figure><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_7.png" alt=""></p><p><code>功能如下</code>：在任务中向指定任务发送通知，根据<code>eAction</code>的值完成不同操作</p><p>②形参说明</p><blockquote><p>形参1：任务句柄</p><p>形参2： 任务通知值</p><p>形参3： 如下图片</p><p>形参4：空</p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_8.webp" alt=""></p><p>③返回值</p><p>根据上面第 3 个形参的说明，将其设置为 <code>eSetValueWithoutOverwrite</code>，有可能返回<code>pdFALSE</code>，其余所有情况都返回值 <code>pdPASS</code></p><p>6、函数<code>ulTaskNotifyWait</code>()</p><p>① 函数原型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType t <span class="title">xTaskNotifyWait</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulBitsToClearOnEntry,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t ulBitsToClearOnExit,</span></span></span><br><span class="line"><span class="params"><span class="function">    uint32 t *pulNotificationValue,</span></span></span><br><span class="line"><span class="params"><span class="function">    TickType t xTicksToWait </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br></pre></td></tr></table></figure><p>功能如下：在任务中获取通知，与<code>xTaskNotify</code>()配套使用，用于替代长度位1的队列与事件组</p><p>②形参说明</p><blockquote><p>形参1：进入函数时，清除哪些位 -&gt; 0：无变化  1：清除相应位</p><p>形参2：退出函数时，清除哪些位 -&gt; 0：无变化  1：清除相应位</p><p>形参3：保存通知值</p><p>形参4： 超时时间，单位为系统节拍</p></blockquote><p>③返回值</p><blockquote><p><code>pdTRUE</code>： 获取任务通知成功</p><p><code>pdFALSE</code>：获取任务通知失败</p></blockquote><p>7、使用说明</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_10.webp" alt=""></p><h2 id="任务通知代替二值信号量的应用编程"><a href="#任务通知代替二值信号量的应用编程" class="headerlink" title="任务通知代替二值信号量的应用编程"></a>任务通知代替二值信号量的应用编程</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_1.png" alt=""></p><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_11.png" alt=""></p><p>2、发送任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_12.webp" alt=""></p><p>3、获取任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_13.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> GiveCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      xResult = <span class="built_in">xTaskNotifyGive</span>(BinarySem_SynHandle);</span><br><span class="line">      <span class="keyword">if</span>(xResult == pdPASS)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;任务通知发送成功，次数 = %u\r\n&quot;</span>,++GiveCnt);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinarySem_Syn_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN BinarySem_Syn_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span>(;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">ulTaskNotifyTake</span>(pdTRUE,portMAX_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xResult == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知，次数 = %u\r\n\r\n&quot;</span>,++TakeCnt);</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END BinarySem_Syn_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替二值信号量 - 任务与任务间得同步----\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：发送任务通知\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">//启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务通知代替计数信号量的应用编程"><a href="#任务通知代替计数信号量的应用编程" class="headerlink" title="任务通知代替计数信号量的应用编程"></a>任务通知代替计数信号量的应用编程</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_2.png" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_3.webp" alt=""></p><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_14.png" alt=""></p><p>2、发送任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_15.webp" alt=""></p><p>3、获取任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_16.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CountingSemMAX 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> myCountingSem_ucMessagesWaiting = CountingSemMAX;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TakeNotify_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN TakeNotify_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 获取任务通知，获取后，任务通知值减一</span></span><br><span class="line">      myCountingSem_ucMessagesWaiting = <span class="built_in">ulTaskNotifyTake</span>(pdFALSE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (myCountingSem_ucMessagesWaiting &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知成功，申请1个停车位，发送同步显示信号\r\n\r\n&quot;</span>);</span><br><span class="line">        myCountingSem_ucMessagesWaiting--;</span><br><span class="line">        <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知失败，停车位已满\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END TakeNotify_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GiveNotify_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN GiveNotify_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化计数信号量初始值</span></span><br><span class="line">  <span class="built_in">xTaskNotify</span>(TakeNotifyHandle, myCountingSem_ucMessagesWaiting, eSetValueWithOverwrite);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (myCountingSem_ucMessagesWaiting &lt; CountingSemMAX)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 发送任务通知</span></span><br><span class="line">        xResult = <span class="built_in">xTaskNotifyGive</span>(TakeNotifyHandle);</span><br><span class="line">        <span class="keyword">if</span> (xResult == pdPASS)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知成功，释放1个停车位\r\n&quot;</span>);</span><br><span class="line">          myCountingSem_ucMessagesWaiting++;</span><br><span class="line">          <span class="built_in">xSemaphoreGive</span>(myBinarySem01Handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放失败，停车位已空\r\n&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END GiveNotify_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Display_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint16_t</span> TakeCnt = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无限等待同步信号更新显示，第%u次等待，等待中\r\n&quot;</span>, ++TakeCnt);</span><br><span class="line">    xResult = <span class="built_in">xSemaphoreTake</span>(myBinarySem01Handle, portMAX_DELAY);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;现在还有%d个车位\r\n\r\n&quot;</span>, myCountingSem_ucMessagesWaiting);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Display_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替计数信号量 - 模拟车库----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;默认车库可以停放20辆车，串口打印显示车位数量\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：获取信号量，模拟车辆入库，同时通过二值信号量发同步信号给显示任务\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：释放信号量，模拟车辆出库，同时通过二值信号量发同步信号给显示任务\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务通知代替队列的应用编程"><a href="#任务通知代替队列的应用编程" class="headerlink" title="任务通知代替队列的应用编程"></a>任务通知代替队列的应用编程</h2><p>工程配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/myfree16_4.png" alt=""></p><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_20.png" alt=""></p><p>2、发送任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_21.webp" alt=""></p><p>3、获取任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_22.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue1_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue1_Receive_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> TickType_t ulReceiveBlockTime = <span class="built_in">pdMS_TO_TICKS</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">        <span class="number">0x00000000</span>,        <span class="comment">// 进入函数不清除任务通知值</span></span><br><span class="line">        <span class="number">0xFFFFFFFF</span>,        <span class="comment">// 退出函数清除任务通知值</span></span><br><span class="line">        &amp;ucRec_Data,       <span class="comment">// 保存任务通知值</span></span><br><span class="line">        ulReceiveBlockTime <span class="comment">// 阻塞时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知的数据: %u\r\n&quot;</span>, ucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知的数据超时！！\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue1_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Queue2_Receive_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN Queue2_Receive_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint8_t</span> *pucRec_Data = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">        <span class="number">0x00000000</span>,               <span class="comment">// 进入函数不清除任务通知值</span></span><br><span class="line">        <span class="number">0xFFFFFFFF</span>,               <span class="comment">// 退出函数清除任务通知值</span></span><br><span class="line">        (<span class="type">uint32_t</span> *)&amp;pucRec_Data, <span class="comment">// 保存任务通知值</span></span><br><span class="line">        portMAX_DELAY             <span class="comment">// 阻塞时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;成功获取任务通知的数据: %s\r\n&quot;</span>, pucRec_Data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END Queue2_Receive_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line">  <span class="type">uint32_t</span> ucRec_Data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送单个数据\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue1_ReceiveHandle, ucRec_Data, eSetValueWithoutOverwrite);</span><br><span class="line"></span><br><span class="line">      ucRec_Data += <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;MCU123123123&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue2_ReceiveHandle, (<span class="type">uint32_t</span>) <span class="string">&quot;MCU123123123&quot;</span>, eSetValueWithoutOverwrite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 模拟队列发送字符串：%s\r\n&quot;</span>, <span class="string">&quot;SUE333222111&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Queue2_ReceiveHandle, (<span class="type">uint32_t</span>) <span class="string">&quot;SUE333222111&quot;</span>, eSetValueWithoutOverwrite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替消息队列----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：向队列1发送单个数据\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：向队列2发送字符串\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务通知代替事件组的应用编程"><a href="#任务通知代替事件组的应用编程" class="headerlink" title="任务通知代替事件组的应用编程"></a>任务通知代替事件组的应用编程</h2><p>1、实验现象</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_17.png" alt=""></p><p>2、发送任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_18.webp" alt=""></p><p>3、获取任务通知</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free16_19.webp" alt=""></p><p>代码</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY2_EVENT (EventBits_t)(0x0001 &lt;&lt; 0)  <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY3_EVENT (EventBits_t)(0x0001 &lt;&lt; 8)  <span class="comment">// 设置事件掩码8</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY4_EVENT (EventBits_t)(0x0001 &lt;&lt; 16) <span class="comment">// 设置事件掩码16</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define EVent_WaitAllBits // 用于预编译</span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Event_Sync_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* USER CODE BEGIN Event_Sync_Task */</span></span><br><span class="line">  BaseType_t xResult;</span><br><span class="line">  <span class="type">uint32_t</span> Rec_Event = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> Last_Event = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint16_t</span> SyncCnt = <span class="number">0</span>; <span class="comment">// 同步计数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EVent_WaitAllBits</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">      <span class="number">0x00000000</span>,  <span class="comment">//进入函数时不清除任务通知值</span></span><br><span class="line">      <span class="number">0xFFFFFFFF</span>,  <span class="comment">//退出函数时清除任务通知值</span></span><br><span class="line">      &amp;Rec_Event,   <span class="comment">//保存任务通知值</span></span><br><span class="line">      portMAX_DELAY  <span class="comment">//阻塞时间</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      Last_Event |= Rec_Event; <span class="comment">//缓存</span></span><br><span class="line">      <span class="keyword">if</span>((Last_Event&amp;(KEY2_EVENT | KEY3_EVENT | KEY4_EVENT)) == (KEY2_EVENT | KEY3_EVENT | KEY4_EVENT))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功接收到任务通知同步信号（替代时间），次数= %u\r\n\r\n&quot;</span>,++SyncCnt);</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">        Last_Event = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;获取任务通知，无限等待\r\n&quot;</span>);</span><br><span class="line">    xResult = <span class="built_in">xTaskNotifyWait</span>(</span><br><span class="line">      <span class="number">0x00000000</span>,  <span class="comment">//进入函数时不清除任务通知值</span></span><br><span class="line">      <span class="number">0xFFFFFFFF</span>,  <span class="comment">//退出函数时清除任务通知值</span></span><br><span class="line">      &amp;Rec_Event,   <span class="comment">//保存任务通知值</span></span><br><span class="line">      portMAX_DELAY  <span class="comment">//阻塞时间</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span>(xResult == pdTRUE)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>( ((Rec_Event&amp;KEY2_EVENT) == KEY2_EVENT) || ((Rec_Event&amp;KEY3_EVENT) == KEY3_EVENT) || ((Rec_Event&amp;KEY4_EVENT) == KEY4_EVENT))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功接收到任务通知同步信号（替代时间），次数= %u\r\n\r\n&quot;</span>,++SyncCnt);</span><br><span class="line">        LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* USER CODE END Event_Sync_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KEY_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> * argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键2事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY2_EVENT,eSetBits);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键3事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY3_EVENT,eSetBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;发送任务通知 - 按键4事件\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">xTaskNotify</span>(Event_SyncHandle,KEY4_EVENT,eSetBits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Peripheral_Set</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----任务通知代替队列的应用编程----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：设置按键事件2\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：设置按键事件3\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：设置按键事件4\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HAL_TIM_Base_Start_IT</span>(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="综合应用1"><a href="#综合应用1" class="headerlink" title="综合应用1"></a>综合应用1</h1><p>实验现象</p><p>1、间隔1s获取传感器数据，通过数码管显示</p><p>2、按键2,3,4触发蜂鸣器状态改变</p><p>3、上位机通过RS-485接口与实战板通讯</p><p>4、USB串口打印收到的上位机数据</p><hr><h1 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h1><h2 id="动态内存管理介绍"><a href="#动态内存管理介绍" class="headerlink" title="动态内存管理介绍"></a>动态内存管理介绍</h2><p>动态内存管理是 FreeRTOS 非常重要的一项功能，前面章节讲解的任务创建、信号量、消息队列、事件标志组、互斥信号量、软件定时器组等需要的 RAM 空间都是通过动态内存管理从 <code>FreeRTOSConfig.h</code> 文件定义的 heap 空间中申请的。</p><p>FreeRTOS 支持 5 种动态内存管理方案，分别通过文件 <code>heap_1</code>，<code>heap_2</code>，<code>heap_3</code>，<code>heap_4</code>和 <code>heap_5</code>实现。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_1.webp" alt=""></p><ul><li>heap_1</li></ul><blockquote><p><code>heap_1</code>动态内存管理方式是五种动态内存管理方式中最简单的，这种方式的动态内存管理一旦申请了相应内存后，是不允许被释放的。</p><p>尽管如此，这种方式的动态内存管理还是满足大部分嵌入式应用的，因为这种嵌入式应用在系统启动阶段就完成了任务创建、事件标志组、信号量、消息队列等资源的创建，而且这些资源是整个嵌入式应用过程中一直要使用的，所以也就不需要删除，不需要释放内存。</p></blockquote><ul><li>heap_2</li></ul><blockquote><p>与 <code>heap_1</code>动态内存管理方式不同，<code>heap_2</code>动态内存管理利用了最适应算法，并且支持内存释放。但是 <code>heap_2</code>不支持内存碎片整理，动态内存管理方式<code>heap_4</code>支持内存碎片整理。</p></blockquote><ul><li>heap_3</li></ul><blockquote><p>这种方式实现的动态内存管理是对编译器提供的 <code>malloc</code>和 <code>free</code>函数进行了封装，保证是线程安全的。</p></blockquote><ul><li>heap_4</li></ul><blockquote><p>与 <code>heap_2</code>动态内存管理方式不同，<code>heap_4</code>动态内存管理利用了最适应算法，且支持内存碎片的回收并将其整理为一个大的内存块。</p></blockquote><ul><li>heap_5</li></ul><blockquote><p>有时候我们希望 <code>FreeRTOSConfig.h</code> 文件中定义的 heap 空间可以采用不连续的内存区，比如我们希望可以将其定义在内部 SRAM 一部分，外部 SRAM 一部分，此时我们就可以采用 <code>heap_5</code>动态内存管理方式。另外，<code>heap_5</code>动态内存管理是在 <code>heap_4</code>的基础上实现的。</p></blockquote><h2 id="动态内存总结与应用"><a href="#动态内存总结与应用" class="headerlink" title="动态内存总结与应用"></a>动态内存总结与应用</h2><p>五种动态内存管理方式简单总结如下，实际项目中，用户根据需要选择合适的：</p><blockquote><p><strong>heap_1：</strong>五种方式里面最简单的，但是申请的内存不允许释放</p><p>heap_2：支持动态内存的申请和释放，但是不支持内存碎片的处理</p><p>heap_3：将编译器自带的 malloc 和 free 函数进行简单的封装</p><p><strong>heap_4：</strong>支持动态内存的申请和释放，支持内存碎片处理</p><p><strong>heap_5：</strong>在 heap_4 的基础上支持将动态内存设置在不连续的区域上</p></blockquote><p><strong>1、heap_1：</strong></p><p>FreeRTOS 的动态内存大小在 <code>FreeRTOSConfig.h</code> 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) <span class="comment">//单位字节</span></span></span><br></pre></td></tr></table></figure><p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 FreeRTOS 动态内存的剩余，进而可以根据剩余情况优化动态内存的大小。</p><p>heap_1 方式的动态内存管理有以下特点：</p><blockquote><p>① 项目应用不需要删除任务、信号量、消息队列等已经创建的资源。</p><p>② 具有时间确定性，即申请动态内存的时间是固定的并且不会产生内存碎片。</p><p>③ 确切的说这是一种静态内存分配，因为申请的内存是不允许被释放掉的。</p></blockquote><p><strong>2、heap_4：</strong></p><p>FreeRTOS 的动态内存大小在 <code>FreeRTOSConfig.h</code> 文件中进行了定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) <span class="comment">//单位字节</span></span></span><br></pre></td></tr></table></figure><p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 FreeRTOS 动态内存的剩余，但是不提供动态内存是如何被分配成各个小内存块的信息。使用函数 <code>xPortGetMinimumEverFreeHeapSize</code>能够获取从系统启动到当前时刻的动态内存最小剩余，从而用户就可以根据剩余情况优化动态内存的大小。</p><p><strong>heap_4 方式的动态内存管理有以下特点：</strong></p><blockquote><p>① 可以用于需要重复的创建和删任务、信号量、事件标志组、软件定时器等内部资源的场合。</p><p>② 随机的调用 <code>pvPortMalloc</code>() 和 <code>vPortFree</code>()，且每次申请的大小都不同，也不会像 heap_2 那样产生很多的内存碎片。</p><p>③ 不具有时间确定性，即申请动态内存的时间不是确定的</p></blockquote><p><strong>3、heap_5：</strong></p><p>heap_5 动态内存管理是通过函数 <code>vPortDefineHeapRegions</code>进行初始化的，也就是说用户在创建任务 FreeRTOS 的内部资源前要优先级调用这个函数 <code>vPortDefineHeapRegions</code>，否则是无法通过函数<code>pvPortMalloc</code>申请到动态内存的。</p><p>函数 <code>vPortDefineHeapRegions</code>定义不同段的内存空间采用了下面这种结构体：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_2.webp" alt=""></p><p>定义的时候要注意三个问题，一个是内存段结束时要定义 <code>NULL</code>。另一个是内存段的地址是<mark>从低地址到高地址排列</mark>，最后，内存的区域与系统变量分开，尽量把地址放在后面，前面给系统用，避免冲突。</p><p>用户通过函数 <code>xPortGetFreeHeapSize</code>就能获得 <code>FreeRTOS</code>动态内存的剩余，但是不提供动态内存是如何被分配成各个小内存块的信息。使用函数 <code>xPortGetMinimumEverFreeHeapSize</code>能够获取从系统启动到当前时刻的动态内存最小剩余，从而用户就可以根据剩余情况优化动态内存的大小。</p><h2 id="内存管理编程测试"><a href="#内存管理编程测试" class="headerlink" title="内存管理编程测试"></a>内存管理编程测试</h2><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_3.webp" alt=""></p><p>分别测试heap_4，heap_1与heap_5。</p><p><strong>1、heap_4</strong></p><p>输出内存信息：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_4.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_5.png" alt=""></p><p><strong>2、heap_1</strong></p><p>输出内存信息：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_6.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_7.png" alt=""></p><p><code>Note</code>：</p><blockquote><p>KEY1按下后，系统会死机，原因是<code>vTaskList</code>()函数会调用<code>vPortFree</code>()函数释放内存，而<code>heap_1</code>内存管理方案不支持内存释放，导致死机，</p></blockquote><p><strong>3、heap_5</strong></p><p>定义内存区域：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_8.webp" alt=""></p><p>输出内存信息：</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_9.webp" alt=""></p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free18_10.png" alt=""></p><hr><h1 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h1><h2 id="独立看门狗介绍"><a href="#独立看门狗介绍" class="headerlink" title="独立看门狗介绍"></a>独立看门狗介绍</h2><p>IWDG主要性能</p><blockquote><ul><li>自由运行的递减计数器</li><li>时钟由独立的RC振荡器提供(可在停止和待机模式下工作)、</li><li>看门狗被激活后，则在计数器计数至0x000时产生复位</li></ul></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_1.webp" alt=""></p><h2 id="看门狗监测多任务执行思路"><a href="#看门狗监测多任务执行思路" class="headerlink" title="看门狗监测多任务执行思路"></a>看门狗监测多任务执行思路</h2><p>1、监测目标</p><blockquote><p>① 监测系统死机</p><p>② 监测任务执行</p></blockquote><p>2、监测方案</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_2.webp" alt=""></p><p>说明：</p><blockquote><p>①、监测任务通过独立看门狗监测自身，如果长时间得不到执行，看门狗将复位系统；</p><p>②、监测任务通过事件标志监控其它任务，如果任一任务长时间得不到执行，看门狗将复位系统；</p><p>③、监测任务收到全部被监测任务发来的事件标志后，才进行喂狗。</p></blockquote><p>3、应用注意事项</p><blockquote><p>①、监测任务优先级设置最高，以便及时喂狗</p><p>②、监测任务与被监测任务均不可以挂起或删除，否则，无法及时喂狗导致系统复位</p><p>③、喂狗时间由被监测任务的最大发送事件标志间隔时间确定，并且留有足够余量</p><p>④、考虑事件标志只有低24位可用，被监测任务最多24个，足够使用</p></blockquote><h2 id="看门狗监测多任务编程"><a href="#看门狗监测多任务编程" class="headerlink" title="看门狗监测多任务编程"></a>看门狗监测多任务编程</h2><p>1、STM32cubeMX配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_3.webp" alt=""></p><p>看门狗计数周期 = <code>(1/40000) * 64 * 3750</code> = 6s</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_4.webp" alt=""></p><p>2、监控任务代码</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_5.webp" alt=""></p><p>3、串口输出信息</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free19_6.png" alt=""></p><p>代码：</p><ul><li>freertos.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task01_EVENT (EventBits_t)(0x0001 &lt;&lt; 0) <span class="comment">// 设置事件掩码0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task02_EVENT (EventBits_t)(0x0002 &lt;&lt; 1) <span class="comment">// 设置事件掩码1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task03_EVENT (EventBits_t)(0x0003 &lt;&lt; 2) <span class="comment">// 设置事件掩码2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_Task04_EVENT (EventBits_t)(0x0004 &lt;&lt; 3) <span class="comment">// 设置事件掩码3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_TaskAll_EVENT BIT_Task01_EVENT | BIT_Task02_EVENT | BIT_Task03_EVENT | BIT_Task04_EVENT</span></span><br><span class="line"></span><br><span class="line">EventGroupHandle_t MyEvent01Handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建事件组</span></span><br><span class="line">  MyEvent01Handle = <span class="built_in">xEventGroupCreate</span>();</span><br><span class="line">  <span class="keyword">if</span> (MyEvent01Handle == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组失败\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建事件组成功\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IWDG_Monitor_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN IWDG_Monitor_Task */</span></span><br><span class="line">  EventBits_t xEvent;</span><br><span class="line">  <span class="type">const</span> TickType_t xTicksToWait = <span class="number">6000</span> / portTICK_PERIOD_MS; <span class="comment">// 设置等待时间为6s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    xEvent = <span class="built_in">xEventGroupWaitBits</span>(</span><br><span class="line">        MyEvent01Handle,   <span class="comment">// 事件句柄</span></span><br><span class="line">        BIT_TaskAll_EVENT, <span class="comment">// 事件</span></span><br><span class="line">        pdTRUE,            <span class="comment">// 退出时清除事件位</span></span><br><span class="line">        pdTRUE,            <span class="comment">//&quot;逻辑与&quot; - 满足所有事件</span></span><br><span class="line">        xTicksToWait       <span class="comment">// 等待时间</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((xEvent &amp; (BIT_TaskAll_EVENT)) == (BIT_TaskAll_EVENT))</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED3);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;喂狗，监测任务与被监测任务均正常运行\r\n&quot;</span>);</span><br><span class="line">      MyIWDG.<span class="built_in">FeedDog</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 用于调试</span></span><br><span class="line">      <span class="comment">// 关闭独立看门狗，通过变量xEvent判断哪个任务没有发送事件标志</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END IWDG_Monitor_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">KEY_Task</span>(<span class="type">void</span> <span class="type">const</span> *argument)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN KEY_Task */</span></span><br><span class="line">  <span class="type">uint8_t</span> CPU_RunInfo[<span class="number">500</span>]; <span class="comment">// 保存任务运行时间信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键检测</span></span><br><span class="line">    KEY.<span class="built_in">GetKeyCode</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY1处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY1)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">vTaskList</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名               任务状态  优先级   剩余栈 任务序号\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">vTaskGetRunTimeStats</span>((<span class="type">char</span> *)&amp;CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;任务名                 运行计数        利用率\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CPU_RunInfo);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY2处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY2)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;挂起Task01任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskSuspend</span>(task01Handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY3处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY3)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;删除Task01任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskDelete</span>(task01Handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KEY4处理</span></span><br><span class="line">    <span class="keyword">if</span> (KEY.KeyCode == KEY4)</span><br><span class="line">    &#123;</span><br><span class="line">      LED.<span class="built_in">LED_Flip</span>(LED2);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;挂起IWDG_Monitor任务\r\n&quot;</span>);</span><br><span class="line">      <span class="built_in">vTaskSuspend</span>(IWDG_MonitorHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞延时20ms</span></span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END KEY_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task01_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task01_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task01_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task01_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task02_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task02_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">2000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task02_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task02_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task03_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task03_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">3000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task03_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task03_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">task04_Entry</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN task04_Entry */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">4000</span>);</span><br><span class="line">    <span class="built_in">xEventGroupSetBits</span>(MyEvent01Handle, BIT_Task04_EVENT);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END task04_Entry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LED1_Task</span><span class="params">(<span class="type">void</span> <span class="type">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED1_Task */</span></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">osDelay</span>(<span class="number">1000</span>);</span><br><span class="line">    LED.<span class="built_in">LED_Flip</span>(LED1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED1_Task */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>MyInit.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----FreeRTOS操作系统----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----独立看门狗检测任务----\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按键功能如下：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1：打印任务只执行情况\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY2：挂起任务1\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY3：删除任务1\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY4：挂起事件任务\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim3); <span class="comment">// 启动定时器3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyIWDG.c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FeedDog</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">MyIWDG_t MyIWDG = </span><br><span class="line">&#123;</span><br><span class="line">TRUE,</span><br><span class="line"></span><br><span class="line">FeedDog</span><br><span class="line">&#125;;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FeedDog</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HAL_IWDG_Refresh</span>(&amp;hiwdg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>MyIWDG.h</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> FeedDog_Flag;  <span class="comment">//喂狗标志位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*FeedDog)(<span class="type">void</span>); <span class="comment">//喂狗</span></span><br><span class="line">&#125; MyIWDG_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  MyIWDG_t  MyIWDG;</span><br></pre></td></tr></table></figure><hr><h1 id="低功耗Tickless模式"><a href="#低功耗Tickless模式" class="headerlink" title="低功耗Tickless模式"></a>低功耗Tickless模式</h1><h2 id="STM32低功耗模式讲解"><a href="#STM32低功耗模式讲解" class="headerlink" title="STM32低功耗模式讲解"></a>STM32低功耗模式讲解</h2><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_1.webp" alt=""></p><blockquote><p>①电池类产品，一般要求低功耗设计，比如农业物联网的节点采集设备</p><p>②低功耗设计，除了MCU，软件， 硬件设计同等重要，以STC15低功耗实战为例说明 </p><p>③<code>Tickless</code>模式主要针对睡眠模式，当然，也可以自行使用停机模式，待机模式</p><p>④ 由于STM32物联网实战板的硬件没有低功耗设计，本例程只讲解<code>Tickless</code>模式原理与应用</p><p>⑤ STM32的3种低功耗详细讲解与应用编程，直接观看stm32物联网实战的视频，不再重复讲解，本例程重点讲解<code>FreeRTOS</code>的<code>Tickless</code>模式</p></blockquote><h2 id="Tickless模式介绍"><a href="#Tickless模式介绍" class="headerlink" title="Tickless模式介绍"></a>Tickless模式介绍</h2><p>1、<code>Tickless</code>模式介绍</p><p><code>Tickless</code>低功耗机制是当前小型 RTOS 所采用的通用低功耗方法，比如<code>FreeRTOS</code>，<code>RTX</code>和 <code>uCOS-III</code>等。</p><p><code>Tickless</code>是怎样一种模式呢？</p><p>仅从字母上看，<code>Tick</code>是滴答时钟的意思，<code>less</code>是 Tick<code> </code>的后缀，表示较少的，整体看就是表示减少滴答时钟节拍运行。</p><p>在FreeRTOS系统中，当用户任务都被挂起或者阻塞时，最低优先级的空闲任务会得到执行。那么 STM32 支持的低功耗模式就可以放在空闲任务里面实现。为了实现低功耗最优设计，我们还不能直接把睡眠模式放在空闲任务就可以了。由于Tick中断停止，将导致无法及时运行阻塞超时的任务，进入空闲任务后，首先要计算可以执行低功耗的最大时间，也就是求出下一个要执行的高优先级任务还剩多少时间。然后就是把低功耗的唤醒时间设置为这个求出的时间(其实就是重载<code>Systick</code>)，如果没有其它中断或事件唤醒STM32，到时间后<code>Systick</code>中断会将STM32唤醒，继续执行任务。</p><p>这个就是所谓的 <code>`Tickless</code>模式。从上面的讲解中可以看出，实现<code>Tickless</code>模式最麻烦的是计算低功耗可以执行的时间。这个难题，FreeRTOS 已为我们做好。</p><p>2、<code>Tickless</code>模式配置</p><blockquote><p>① 将宏定义<code>configUSE_TICKLESS_IDLE</code>设置为1即可</p><p>② 配置 <code>configEXPECTED_IDLE_TIME_BEFORE_SLEEP</code>，只有当系统可运行于低功耗模式的时钟节拍数大于等于这个参数时，系统才可以进入到低功耗模式。</p></blockquote><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_2.png" alt=""></p><p>此参数已在 <code>FreeRTOS.h</code>文件中定义了，默认为2，用户可以自定义时，不能小于2</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_3.webp" alt=""></p><h2 id="Tickless模式源码分析"><a href="#Tickless模式源码分析" class="headerlink" title="Tickless模式源码分析"></a>Tickless模式源码分析</h2><blockquote><ul><li>阅读源码</li><li>讲讲如何在进入低功耗模式前关闭外设，退出模式后恢复，进一步降低系统功耗</li><li>讲讲如何在<code>Tickless</code>框架中应用待机与停机模式</li></ul></blockquote><h2 id="Tickless模式编程"><a href="#Tickless模式编程" class="headerlink" title="Tickless模式编程"></a>Tickless模式编程</h2><p>1、STM32cubeMX配置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_4.webp" alt=""></p><p>2、<code>configEXPECTED_IDLE_TIME_BEFORE_SLEEP</code>设置</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_5.webp" alt=""></p><p>3、在进入与退出<code>Tickless</code>模式时增加代码，通常是关闭外设等，此例程是关闭数码管显示，作为演示用。</p><p><img src="https://blogblog-1322568013.cos.ap-guangzhou.myqcloud.com/image/free20_6.webp" alt=""></p><hr>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32HAL库</title>
      <link href="/2023/11/18/STM32HAL%E5%BA%93/"/>
      <url>/2023/11/18/STM32HAL%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><strong>==注==</strong> ：<strong>此教程代码为硬件家园开发板STM32ZET6，我用的开发板是江科大教程的面包板加stm32c8t6。参考代码，请注意板子引脚</strong></p><h3 id="STM32CubeMx"><a href="#STM32CubeMx" class="headerlink" title="STM32CubeMx"></a>STM32CubeMx</h3><p>软件下载直接去官网下载就行</p><h4 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h4><p>安装芯片软件包，用那款芯片就安装哪个就行，不安装会无法生成代码</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919093400569.png" alt="image-20230919093400569"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919093427400.png" alt="image-20230919093427400"></p><h4 id="时钟配置问题"><a href="#时钟配置问题" class="headerlink" title="时钟配置问题"></a>时钟配置问题</h4><p>要先在这里选择外部时钟</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919092925360.png" alt="image-20230919092925360"></p><p>不选择的话，是用不了72Mhz的，只能使用64Mhz，时钟越大跑的越快，但是功耗也会更大，看自己需求配置</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919093052210.png" alt="image-20230919093052210"></p><p>时钟失常恢复机制(CSS)，当系统选择HSE作系工作时钟，并打开了CSS功能后，当HSE由于外部原因而停震时，系统将自动切换到内部HSI运行，并产生NMI中断，于是可以在NMI中断中进行安全处理。在cubeMX中显示如下：</p><p>开启</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919095655175.png" alt="image-20230919095655175"></p><p>框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919143519746.png" alt="image-20230919143519746"></p><h4 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h4><p>配置时钟</p><p>配置调试端口</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919095214139.png" alt="image-20230919095214139"></p><p>配置GPIO口</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919101826081.png" alt="image-20230919101826081"></p><p>生成代码文件。这里选择MDK，版本看自己的版本选择</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919102416979.png" alt="image-20230919102416979"></p><p>这样就可以了，点击右上角生成代码</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919102626653.png" alt="image-20230919102626653"></p><p>配置烧录程序方式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919103417077.png" alt="image-20230919103417077"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919103434895.png" alt="image-20230919103434895"></p><p>下载进去，低电平点亮LED</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230919105532775.png" alt="image-20230919105532775"></p><h4 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h4><p>自己编写的代码注意写在区域里，不然重新生成 CubeMX 会没了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230626162723140.png" alt="image-20230626162723140"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230626162754993.png" alt="image-20230626162754993"></p><h3 id="全新的程序框架"><a href="#全新的程序框架" class="headerlink" title="全新的程序框架"></a>全新的程序框架</h3><h4 id="程序框架的构想"><a href="#程序框架的构想" class="headerlink" title="程序框架的构想"></a>程序框架的构想</h4><p>1、STM32cubeMX生成的代码与添加的应用代码分离；</p><p>2、利用STM32cubeMX重新生成代码，不影响应用代码；</p><p>3、应用代码的添加，移除与修改，不影响cube生成的代码；</p><p>4、代码架构方便阅读，编辑，修改与移植；</p><p>5、代码架构标准化，可以很方便的应用到产品开发中。</p><h4 id="程序框架的实现"><a href="#程序框架的实现" class="headerlink" title="程序框架的实现"></a>程序框架的实现</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230920144428234.png" alt="image-20230920144428234"></p><p>1、新增MyApplication文件夹，放置4个标准c文件，分别是公共文件，回调文件，系统文件，用户初始化文件，后续应用代码均放在此文件夹；</p><p>2、新增MyApplication.h文件，包含所有用户代码的头文件与外设头文件，调整外设或用户文件，只需要调整此文件内的相应头文件即可；</p><p>3、main.c文件标准化。</p><h4 id="MyApplication-h"><a href="#MyApplication-h" class="headerlink" title="MyApplication.h"></a>MyApplication.h</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230920144610053.png" alt="image-20230920144610053"></p><p> 1、此文件放置于main.c与应用代码文件中，作为头文件的集合；</p><p> 2、更改处理器外设或应用代码，此文件需要相应的增加或删除相应的头文件。</p><h4 id="main-c文件"><a href="#main-c文件" class="headerlink" title="main.c文件"></a>main.c文件</h4><p>添加头文件集合</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlHf1YKX9XtprczWZFaYH8VzaeMQKtvnliaQ6bmQvwRfic0N6eUlZaWD5w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、添加用户初始化函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlvVuEop3ANQgmg2LM0uos0Fgw9Ng00lvVjR34GZak0XnIz4NdT89Gnw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>3、标准化主循环</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlmIu67vZgpcO5V5N0U0aic0TGPMXzXXjNjro3hxGWRJZ3paHSjr1YgdQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、标准化错误处理函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlZ7ntF5WO5jywzDY0zTFicIzuRT0NcVvXNSBd9Rg1ibUz2zO28c3pCgHg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、标准化断言失败处理函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlhd19ib4lXPQbKV5P3AbTg6C0zY5ibkHvJsSmrFhHaUAg4Wpiaicy35ZKeA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="system文件"><a href="#system文件" class="headerlink" title="system文件"></a>system文件</h4><p>1、头文件</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlic3Rtott5bnzn90oCM8a9P9Ds6kWqC2ar0VDQWKuH4PVnXOOr0ia3W7w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>主要定义结构体类型System_t，包含3个函数指针，分别为函数运行，系统错误处理，断言失败处理，被main.c文件调用。</p><p>2、源文件</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzlia0X7Gb2xCO3ficicwgic0NQ71hTR11HCn1NgGCMqYS8JcHZjiaWzcE7qAQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>主要定义结构体System以及3个函数，并将3个函数的名称(首地址)赋值给System结构体，完成结构体的初始化。 如此一来，main.c文件可以通过System结构体的函数指针调用System.c文件的3个函数了。</p><p>Run函数：用户应用代码；</p><p>Error_Hander函数：系统错误处理代码；</p><p>Asset_Failed函数： 断言失败处理代码。</p><h4 id="Run函数"><a href="#Run函数" class="headerlink" title="Run函数"></a>Run函数</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdkc4BtBKDv5ibauMqSyXOzl2QbzrYQGxSFFK1ib4ApMAKxReZW4lOWFygd4a19lf3TrkubaCnOHzQQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>作为功能演示，简单的实现了LED1间隔1s闪烁。</p><h3 id="HAL库函数"><a href="#HAL库函数" class="headerlink" title="HAL库函数"></a>HAL库函数</h3><h4 id="常用c函数"><a href="#常用c函数" class="headerlink" title="常用c函数"></a>常用c函数</h4><h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p><code>volatile</code> 是一个在编程中使用的关键字，用于声明一个变量为“易变”的，指示编译器不要对该变量进行优化，强制在每次访问时都从内存中读取或写入该变量的值。</p><p>在多线程或嵌入式系统等特定环境下，使用 <code>volatile</code> 关键字可以确保对变量的读写操作是原子的，并且能够避免编译器对变量的优化，以防止出现意外的行为。</p><p>主要有两个方面需要注意：</p><ol><li>内存可见性：在多线程环境中，当一个线程修改了一个 <code>volatile</code> 变量的值时，其他线程可以立即看到这个修改，而不会使用缓存中的旧值。这保证了多线程之间对共享变量的正确读写。</li><li>编译器优化：编译器在进行代码优化时，可能会将读取同一个变量的多个操作合并，或者优化成常量。对于 <code>volatile</code> 变量，编译器会禁止这些优化，确保每次都从内存中读取或写入最新的值。</li></ol><p>需要注意的是，<code>volatile</code> 并不能保证对变量的操作是原子的，仅仅保证了内存的可见性和禁止了编译器的优化。如果需要原子操作，请使用适当的同步机制，如互斥锁或原子操作。</p><p>以下是 C 语言中使用 <code>volatile</code> 的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个线程中修改 flag 的值</span></span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个线程中读取 flag 的值</span></span><br><span class="line"><span class="type">int</span> value = flag;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，使用了 <code>volatile</code> 关键字来确保 <code>flag</code> 变量的可见性，从而保证了两个线程对 <code>flag</code> 的正确读写。</p><h5 id="weak"><a href="#weak" class="headerlink" title="_weak"></a>_weak</h5><p><strong>weak是一个用于声明弱符号（weak symbol）的关键字。在C语言中，可以使用</strong>weak来声明一个可选的、弱引用的函数或变量。<br>当你定义一个函数或变量时，如果该函数或变量被声明为<strong>weak，那么它将成为一个弱符号。弱符号表示这个符号的默认定义是弱的，可以被其他相同符号的强定义所替代。如果存在多个定义相同的弱符号，链接器会选择其中一个作为最终符号的实际定义。<br>使用</strong>weak关键字的一个常见场景是在编写嵌入式系统的驱动程序时。例如，某个外设驱动程序可能提供一个默认的中断处理函数，但用户也可以根据自己的需求定义一个具有相同名称的函数来替代默认的中断处理函数。在这种情况下，可以将默认的中断处理函数声明为弱符号，使得用户定义的中断处理函数能够替代默认的中断处理函数。</p><h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void HAL_GPIO_TogglePin()</td><td style="text-align:center">GPIO_TypeDef *GPIOx,<br />uint16_t GPIO_Pin</td><td style="text-align:center">翻转（切换）指定 GPIO 引脚的电平状态</td></tr><tr><td style="text-align:center">void HAL_GPIO_WritePin()</td><td style="text-align:center">GPIO_TypeDef *GPIOx, <br />uint16_t GPIO_Pin, <br />GPIO_PinState PinState</td><td style="text-align:center">设置或清除选定的数据端口位<br />GPIO_PIN_RESET：清除端口引脚（低电平，0）<br />GPIO_PIN_SET：设置端口引脚（高电平，1）</td></tr><tr><td style="text-align:center">HAL_GPIO_ReadPin()</td><td style="text-align:center">GPIO_TypeDef *GPIOx,<br /> uint16_t GPIO_Pin</td><td style="text-align:center">读取指定输入端口引脚。</td></tr></tbody></table></div><h4 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_UART_Transmit()</td><td style="text-align:center">UART_HandleTypeDef *huart, \</td><td style="text-align:center"><br />const uint8_t *pData, <br />uint16_t Size, <br />uint32_t Timeout</td><td>异步（中断方式）发送串口数据</td></tr><tr><td style="text-align:center">HAL_UART_Receive()</td><td style="text-align:center">UART_HandleTypeDef <em>huart,<br /> uint8_t </em>pData, <br />uint16_t Size,<br /> uint32_t Timeout</td><td style="text-align:center">异步（中断方式）接收串口数据</td></tr><tr><td style="text-align:center">HAL_UART_Receive_IT()</td><td style="text-align:center">UART_HandleTypeDef <em>huart, <br />uint8_t </em>pData, <br />uint16_t Size</td><td style="text-align:center">在非阻塞模式下接收大量数据。</td></tr></tbody></table></div><h4 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_TIM_Base_Start_IT()</td><td style="text-align:center">TIM_HandleTypeDef *htim</td><td style="text-align:center">启动定时器基本模式中断</td></tr><tr><td style="text-align:center">HAL_TIM_Base_Stop_IT()</td><td style="text-align:center">TIM_HandleTypeDef *htim</td><td style="text-align:center">关闭定时器基本模式中断</td></tr><tr><td style="text-align:center">HAL_TIM_PeriodElapsedCallback()</td><td style="text-align:center">TIM_HandleTypeDef *htim</td><td style="text-align:center">定时器中断回调函数</td></tr><tr><td style="text-align:center">HAL_StatusTypeDef HAL_TIM_Encoder_Start()</td><td style="text-align:center">TIM_HandleTypeDef *htim, <br />uint32_t Channel</td><td style="text-align:center">启动定时器的编码器模式</td></tr><tr><td style="text-align:center">__HAL_TIM_GET_COUNTER()</td><td style="text-align:center">HANDLE</td><td style="text-align:center">定时器计数器获取当前计数值</td></tr><tr><td style="text-align:center">__HAL_TIM_SET_COUNTER()</td><td style="text-align:center">HANDLE<strong>, </strong><br />COUNTER</td><td style="text-align:center">设置定时器计数器值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">__weak void HAL_GPIO_EXTI_Callback()</td><td style="text-align:center">uint16_t GPIO_Pin</td><td style="text-align:center">外部中断回调函数，检测引脚状态</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void HAL_NVIC_DisableIRQ()</td><td style="text-align:center">IRQn_Type IRQn</td><td style="text-align:center">禁用 NVIC 中断控制器中的设备特定中断。</td></tr><tr><td style="text-align:center">void HAL_NVIC_EnableIRQ()</td><td style="text-align:center">IRQn_Type IRQn</td><td style="text-align:center">启用 NVIC 中断控制器中的设备特定中断。</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_ADC_Start()</td><td style="text-align:center">ADC_HandleTypeDef* hadc</td><td style="text-align:center">启用 ADC，开始常规组的转换</td></tr><tr><td style="text-align:center">HAL_ADC_PollForConversion()</td><td style="text-align:center">ADC_HandleTypeDef* hadc, <br />uint32_t Timeout</td><td style="text-align:center">等待常规组转换完成。</td></tr><tr><td style="text-align:center">uint32_t HAL_ADC_GetValue()</td><td style="text-align:center">ADC_HandleTypeDef* hadc</td><td style="text-align:center">获取ADC常规组转换结果</td></tr><tr><td style="text-align:center">HAL_ADC_PollForConversion()</td><td style="text-align:center">ADC_HandleTypeDef* hadc, <br />uint32_t Timeout</td><td style="text-align:center">轮询地等待ADC转换完成并返回转换结果</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="DAC"><a href="#DAC" class="headerlink" title="DAC"></a>DAC</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_TIM_PWM_Start()</td><td style="text-align:center">TIM_HandleTypeDef *htim, <br />uint32_t Channel</td><td style="text-align:center">开启PWM</td></tr><tr><td style="text-align:center">HAL_TIM_PWM_Stop()</td><td style="text-align:center">TIM_HandleTypeDef *htim, <br />uint32_t Channel</td><td style="text-align:center">关闭PWM</td></tr><tr><td style="text-align:center">__HAL_TIM_SET_COMPARE()</td><td style="text-align:center">HANDLE<strong>, </strong><br />CHANNEL<strong>,<br /> </strong>COMPARE</td><td style="text-align:center">修改PWM占空比的值</td></tr></tbody></table></div><h4 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">uint32_t HAL_RTCEx_BKUPRead()</td><td style="text-align:center">RTC_HandleTypeDef *hrtc, <br />uint32_t BackupRegister</td><td style="text-align:center">从指定的 RTC 备份数据寄存器读取数据。</td></tr><tr><td style="text-align:center">void HAL_RTCEx_BKUPWrite()</td><td style="text-align:center">RTC_HandleTypeDef *hrtc, <br />uint32_t BackupRegister, <br />uint32_t Data</td><td style="text-align:center">在指定的 RTC 备份数据寄存器中写入数据。</td></tr><tr><td style="text-align:center">HAL_RTC_SetDate()</td><td style="text-align:center">RTC_HandleTypeDef <em>hrtc,<br />RTC_DateTypeDef </em>sDate,<br /> uint32_t Format</td><td style="text-align:center">设置 RTC 当前日期。</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="IWDG"><a href="#IWDG" class="headerlink" title="IWDG"></a>IWDG</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_IWDG_Refresh()</td><td style="text-align:center">IWDG_HandleTypeDef *hiwdg</td><td style="text-align:center">刷新（喂狗）独立看门狗定时器</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">__weak void HAL_SuspendTick()</td><td style="text-align:center">void</td><td style="text-align:center">暂停 Tick 增量,被调用时，SysTick 中断将被禁用</td></tr><tr><td style="text-align:center">__weak void HAL_ResumeTick()</td><td style="text-align:center">void</td><td style="text-align:center">恢复 Tick 增量,被调用时，SysTick 中断将被启用</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="PWR"><a href="#PWR" class="headerlink" title="PWR"></a>PWR</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">void HAL_PWR_EnterSLEEPMode()</td><td style="text-align:center">uint32_t Regulator, uint8_t SLEEPEntry</td><td style="text-align:center">进入睡眠模式</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">参数</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">HAL_SPI_Receive()</td><td style="text-align:center">SPI_HandleTypeDef <em>hspi, <br />uint8_t </em>pData, <br />uint16_t Size, <br />uint32_t Timeout</td><td style="text-align:center">通过SPI（串行外设接口）接收数据</td></tr><tr><td style="text-align:center">HAL_SPI_Transmit()</td><td style="text-align:center">SPI_HandleTypeDef <em>hspi, <br />uint8_t </em>pData,<br /> uint16_t Size, <br />uint32_t Timeout</td><td style="text-align:center">通过SPI（串行外设接口）发送数据</td></tr></tbody></table></div><h3 id="LED流水灯"><a href="#LED流水灯" class="headerlink" title="LED流水灯"></a>LED流水灯</h3><h4 id="普通编程"><a href="#普通编程" class="headerlink" title="普通编程"></a>普通编程</h4><p>硬件电路</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrM8cGnSYXI4PA9Wicz36NaaHdYVb0ODy5l2YWichqfHIIIpXanEQdJ9Sg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：</p><p>灯亮 - GPIO输出高电平</p><p>灯灭 - GPIO输出低电平</p><p>技术讲解</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrqPsvibwt1BBTkRS7VvqLbsoMXAysUicIGiaViaHmnjf30RXicNK6ccQddrw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrGEaibtDMcEZqUgG8AEn9JGgx65vf8AgWuyGxWyfTy6nChRfoHsn1y7Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：视频详细讲解各种模式以及应用情况。</p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrwxicJkicDSuTQ09QDhvjmE8g54plc6kXliahibiavyH691qniaCHWsny7qtA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：视频详细讲解各个函数以及应用情况。</p><p>编程说明</p><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKr5I3tUYRYICF6JeQypJKfUESH88G71sI6Ohx4tFtTvCSjgmRSr8iaOdw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：初始化3个LED灯为推挽输出，默认高电平，亮灯。</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrp6S4avsS09ic3zBKkfwd1w6GhiaQF2ZvQ8JDynGdaSSXUceF4mfEUBkw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrUTn666s2Jo5S7yaVZCan97E4QfMDQvwiaR1V7ZDcXPat1Rg5qVvSfMw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>本次直接调用HAL库函数，后续的代码，全部采用结构体调用。</p><h4 id="状态机流水灯"><a href="#状态机流水灯" class="headerlink" title="状态机流水灯"></a>状态机流水灯</h4><p>技术讲解</p><p>1、模块化编程</p><p>面向对象是软件开发方法，是相对于面向过程来讲的。通过把数据与方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式;</p><p>单片机C语言的面向对象编程，是利用结构体，将变量、指针、函数等进行封装，达到编程更加方便、程序可读性更好、方便移植等目的。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230920154241296.png" alt="image-20230920154241296"></p><p>有限状态机</p><p>有限状态机是一种概念思想，把复杂的控制逻辑分解成有限个稳定状态，组成闭环系统，通过事件触发，让状态机按设定的顺序处理事务;</p><p>单片机C语言的状态机编程，是利用条件选择语句(switch — case)切换状态，通过函数内部指令改变状态机状态，让程序按设定的顺序执行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJOyry9mWxGUBMkQBsGTxwiasCeZzsj5QMkT5nq5icKjgdxJbWEmmSYm4w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>状态机流水灯流程图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJIQllMley5sNibiagwOcTtX4KX8DcITUC5QMVK2iahKwyPIlaXbuhBMM8g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>状态机流水灯代码实现</p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrwxicJkicDSuTQ09QDhvjmE8g54plc6kXliahibiavyH691qniaCHWsny7qtA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>编程说明</p><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKr5I3tUYRYICF6JeQypJKfUESH88G71sI6Ohx4tFtTvCSjgmRSr8iaOdw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：初始化3个LED灯为推挽输出，默认高电平，亮灯。</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJqNn7mPDMZbiaIyKos0bk28Sw7OOAVhk2DbnkvfTnStgVBBWKESvIjRA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJWOJOs69IXe9Y1OkMhOV6tdVU597iak6Z71zYexWsGjZQFSJYRKoyppg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="回调函数流水灯"><a href="#回调函数流水灯" class="headerlink" title="回调函数流水灯"></a>回调函数流水灯</h4><p>技术讲解</p><p>1、回调函数</p><p>一般解释：</p><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的地址传递给中间函数的形参，中间函数通过函数指针调用其所指向的函数时，我们就说这是回调函数。</p><p>通俗解释：</p><p>函数Fun1调用函数Fun2，同时将函数Fun3作为形参传递给Fun2,此时，Fun1为应用层函数，Fun2为中间层函数，Fun3为回调函数，回调函数是一种说法而已。</p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fun1()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  Fun2(Fun3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>意义何在：</p><p>① 利于代码结构，将代码分为应用层，中间层，硬件驱动层，彼此独立，方便程序的编辑，阅读，修改与移植；</p><p>② 结构化编程时，结构体只需要定义中间函数，减小内存的开销。</p><p>为什么不在Fun2里面直接调用Fun3：</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Fun1()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  Fun2()</span><br><span class="line"></span><br><span class="line">  &#123;  </span><br><span class="line"></span><br><span class="line"> Fun3_1();</span><br><span class="line"></span><br><span class="line">     Fun3_2();</span><br><span class="line"></span><br><span class="line">     ...... </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过函数指针的好处是，Fun2与Fun3实现隔离，比如Fun3具有多个功能函数，增加或减少时，不需要修改Fun2的代码。</p><p>2、代码实现</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd7IsdeK8y3tnR5ShkrvK8eVeD2D2F6bbSicrEPoIHnziaMWjOPcqygZx4nX0kutDm3R1FKNaaiaXxMQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h文件><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd7IsdeK8y3tnR5ShkrvK8eeUnFxpflKicv1LTuGru64riaonco4uQGA21Ryb0eEG1fOf3e074GzZ0Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt; 中间函数&gt;</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd7IsdeK8y3tnR5ShkrvK8eU1BmXAvc2fd0INYCkHiaegl9rrHzibDwyc3XfsaTb4VGtmtGwyCazQzw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;底层驱动函数&gt;</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd7IsdeK8y3tnR5ShkrvK8eEIqEGaIL22g45pmF0GfUQKddhMq9ffs7y5wQZ1mDsu9ST8NyCVLvFw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;应用层&gt;</p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrwxicJkicDSuTQ09QDhvjmE8g54plc6kXliahibiavyH691qniaCHWsny7qtA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>编程说明</p><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKr5I3tUYRYICF6JeQypJKfUESH88G71sI6Ohx4tFtTvCSjgmRSr8iaOdw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：初始化3个LED灯为推挽输出，默认高电平，亮灯。</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJqNn7mPDMZbiaIyKos0bk28Sw7OOAVhk2DbnkvfTnStgVBBWKESvIjRA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeCl745KgCu4npdBsGPydoJWOJOs69IXe9Y1OkMhOV6tdVU597iak6Z71zYexWsGjZQFSJYRKoyppg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序"><a href="#6-1的程序" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置"><a href="#工程配置" class="headerlink" title="工程配置"></a>工程配置</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230920210024535.png" alt="image-20230920210024535"></p><h5 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230920203644796.png" alt="image-20230920203644796"></p><h5 id="软件代码"><a href="#软件代码" class="headerlink" title="软件代码"></a>软件代码</h5><h6 id="LED文件"><a href="#LED文件" class="headerlink" title="LED文件"></a>LED文件</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Fun</span><span class="params">(<span class="type">uint8_t</span>,<span class="type">void</span>(*Callback)(<span class="type">uint8_t</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">LED_t LED =</span><br><span class="line">&#123;</span><br><span class="line">    LED_Fun,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   LED_Fun</span></span><br><span class="line"><span class="comment">      * @brief  LED功能函数，中间虚拟函数</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @param  Num -&gt; 编号，Callback -&gt;回调函数指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LED_Fun</span><span class="params">(<span class="type">uint8_t</span> LED_Num,<span class="type">void</span>(*Callback)(<span class="type">uint8_t</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    (*Callback)(LED_Num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   LED_ON</span></span><br><span class="line"><span class="comment">      * @brief  打开LED</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @param  Num -&gt; 编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">uint8_t</span> LED_Num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//条件选择语句</span></span><br><span class="line">    <span class="keyword">switch</span> (LED_Num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LED1:HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_RESET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED2:HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_RESET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED3:HAL_GPIO_WritePin(LED3_GPIO_Port,LED3_Pin,GPIO_PIN_RESET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED4:HAL_GPIO_WritePin(LED4_GPIO_Port,LED4_Pin,GPIO_PIN_RESET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED5:HAL_GPIO_WritePin(LED5_GPIO_Port,LED5_Pin,GPIO_PIN_RESET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: System.Assert_Failed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   LED_OFF</span></span><br><span class="line"><span class="comment">      * @brief  关闭LED</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @param  Num -&gt; 编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_OFF</span><span class="params">(<span class="type">uint8_t</span> LED_Num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//条件选择语句</span></span><br><span class="line">    <span class="keyword">switch</span> (LED_Num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LED1:HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,GPIO_PIN_SET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED2:HAL_GPIO_WritePin(LED2_GPIO_Port,LED2_Pin,GPIO_PIN_SET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED3:HAL_GPIO_WritePin(LED3_GPIO_Port,LED3_Pin,GPIO_PIN_SET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED4:HAL_GPIO_WritePin(LED4_GPIO_Port,LED4_Pin,GPIO_PIN_SET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED5:HAL_GPIO_WritePin(LED5_GPIO_Port,LED5_Pin,GPIO_PIN_SET); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: System.Assert_Failed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   LED_Flip</span></span><br><span class="line"><span class="comment">      * @brief  取反LED</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @param  Num -&gt; 编号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Flip</span><span class="params">(<span class="type">uint8_t</span> LED_Num)</span></span><br><span class="line">&#123; <span class="comment">//条件选择语句</span></span><br><span class="line">    <span class="keyword">switch</span> (LED_Num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> LED1:HAL_GPIO_TogglePin(LED1_GPIO_Port,LED1_Pin); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED2:HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED3:HAL_GPIO_TogglePin(LED3_GPIO_Port,LED3_Pin); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED4:HAL_GPIO_TogglePin(LED4_GPIO_Port,LED4_Pin); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LED5:HAL_GPIO_TogglePin(LED5_GPIO_Port,LED5_Pin); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: System.Assert_Failed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LED_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LED_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LED1 = (<span class="type">uint8_t</span>)<span class="number">0x01</span>,</span><br><span class="line">    LED2 = (<span class="type">uint8_t</span>)<span class="number">0x02</span>,</span><br><span class="line">    LED3 = (<span class="type">uint8_t</span>)<span class="number">0x03</span>,</span><br><span class="line">    LED4 = (<span class="type">uint8_t</span>)<span class="number">0x04</span>,</span><br><span class="line">    LED5 = (<span class="type">uint8_t</span>)<span class="number">0x05</span>,</span><br><span class="line">&#125;LED_Num_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*LED_Fun)(<span class="type">uint8_t</span>,<span class="type">void</span>(*Callback)(<span class="type">uint8_t</span>));</span><br><span class="line">&#125;LED_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> LED_t LED;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LED_ON</span><span class="params">(<span class="type">uint8_t</span>)</span>; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LED_OFF</span><span class="params">(<span class="type">uint8_t</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">LED_Flip</span><span class="params">(<span class="type">uint8_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="状态机文件"><a href="#状态机文件" class="headerlink" title="状态机文件"></a>状态机文件</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA1</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA2</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA3</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA4</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA5</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA6</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Fun_STA7</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">STA_Machine_t STA_Machine = </span><br><span class="line">&#123;</span><br><span class="line">    STA1,</span><br><span class="line"></span><br><span class="line">    Fun_STA1,</span><br><span class="line">    Fun_STA2,</span><br><span class="line">    Fun_STA3,</span><br><span class="line">    Fun_STA4,</span><br><span class="line">    Fun_STA5,</span><br><span class="line">    Fun_STA6,</span><br><span class="line">    Fun_STA7</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Fun_STA 1 - 7</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  状态函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);    <span class="comment">//延时500ms</span></span><br><span class="line">    LED.LED_Fun(LED1,LED_OFF);  <span class="comment">//LED1灭灯</span></span><br><span class="line">    LED.LED_Fun(LED2,LED_OFF);  <span class="comment">//LED2灭灯</span></span><br><span class="line">    LED.LED_Fun(LED3,LED_OFF);  <span class="comment">//LED3灭灯</span></span><br><span class="line">    LED.LED_Fun(LED4,LED_OFF);  <span class="comment">//LED4灭灯</span></span><br><span class="line">    LED.LED_Fun(LED5,LED_OFF);  <span class="comment">//LED5灭灯</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态机切换至状态2</span></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);  <span class="comment">//延时500ms</span></span><br><span class="line">    LED.LED_Fun(LED1,LED_ON);  <span class="comment">//LED1亮灯</span></span><br><span class="line">    LED.LED_Fun(LED2,LED_OFF); <span class="comment">//LED2灭灯</span></span><br><span class="line">    LED.LED_Fun(LED3,LED_OFF); <span class="comment">//LED3灭灯</span></span><br><span class="line">    LED.LED_Fun(LED4,LED_OFF); <span class="comment">//LED4灭灯</span></span><br><span class="line">    LED.LED_Fun(LED5,LED_OFF); <span class="comment">//LED5灭灯</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态机切换至状态3</span></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    LED.LED_Fun(LED1,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED2,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED3,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED4,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED5,LED_OFF);</span><br><span class="line"></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    LED.LED_Fun(LED1,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED2,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED3,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED4,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED5,LED_OFF);</span><br><span class="line"></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    LED.LED_Fun(LED1,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED2,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED3,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED4,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED5,LED_OFF);</span><br><span class="line"></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA6</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    LED.LED_Fun(LED1,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED2,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED3,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED4,LED_OFF);</span><br><span class="line">    LED.LED_Fun(LED5,LED_ON);</span><br><span class="line"></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fun_STA7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_Delay(<span class="number">500</span>);</span><br><span class="line">    LED.LED_Fun(LED1,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED2,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED3,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED4,LED_ON);</span><br><span class="line">    LED.LED_Fun(LED5,LED_ON);</span><br><span class="line"></span><br><span class="line">    STA_Machine.ucSTA_Machine_Status = STA1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STA_MACHINE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STA_MACHINE_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    STA1 = (<span class="type">uint8_t</span>)<span class="number">0x01</span>,</span><br><span class="line">    STA2 = (<span class="type">uint8_t</span>)<span class="number">0x02</span>,</span><br><span class="line">    STA3 = (<span class="type">uint8_t</span>)<span class="number">0x03</span>,</span><br><span class="line">    STA4 = (<span class="type">uint8_t</span>)<span class="number">0x04</span>,</span><br><span class="line">    STA5 = (<span class="type">uint8_t</span>)<span class="number">0x05</span>,</span><br><span class="line">    STA6 = (<span class="type">uint8_t</span>)<span class="number">0x06</span>,</span><br><span class="line">    STA7 = (<span class="type">uint8_t</span>)<span class="number">0x07</span>,</span><br><span class="line"></span><br><span class="line">&#125; STA_Machine_Status_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    STA_Machine_Status_t ucSTA_Machine_Status;  <span class="comment">//状态机状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*Fun_STA1)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA2)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA3)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA4)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA5)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA6)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*Fun_STA7)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line">&#125; STA_Machine_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> STA_Machine_t STA_Machine;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Run()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">switch(STA_Machine.ucSTA_Machine_Status)</span><br><span class="line">&#123;</span><br><span class="line">case STA1: STA_Machine.Fun_STA1(); break;</span><br><span class="line">case STA2: STA_Machine.Fun_STA2(); break;</span><br><span class="line">case STA3: STA_Machine.Fun_STA3(); break;</span><br><span class="line">case STA4: STA_Machine.Fun_STA4(); break;</span><br><span class="line">case STA5: STA_Machine.Fun_STA5(); break;</span><br><span class="line">case STA6: STA_Machine.Fun_STA6(); break;</span><br><span class="line">case STA7: STA_Machine.Fun_STA7(); break;</span><br><span class="line">default:STA_Machine.ucSTA_Machine_Status = STA1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>主要是框架，流水灯怎么写都可以，注意引脚，注意在面包板上LED正负极别插反。</p><h3 id="串口打印"><a href="#串口打印" class="headerlink" title="串口打印"></a>串口打印</h3><p>只是先简单学习一下打印，让程序运行效果能够更好的理解，实现人机交互，有很多方法可以实现，不过我还是喜欢用OLED屏看效果</p><h4 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h4><p>实现串口打印功能，实现现象如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVUxzqzsiaGc4K62eJnz4ORre2L3XrTSXKtNHqDUWuWjEAMJVbgicnBsDg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVgVhV8T6icpcBMcuKrS4lIpKvvUu3adr1KeXPVZbO687aaW8CssOne3g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：</p><p>集成TTL转USB驱动，插入MicroUSB线即可。</p><h4 id="技术讲解"><a href="#技术讲解" class="headerlink" title="技术讲解"></a>技术讲解</h4><p> <strong>1、定义</strong></p><p>UART是一种通用串行数据总线，用于==异步通信==。该总线双向通信，可以实现==全双工传输==和接收。</p><p>在单片机产品设计中，UART主要用于设备与设备之间的通讯，设备与传感器之间的通信。例如通过RS-485接口，构成工业设备系统总线。</p><p><strong>2、协议</strong></p><p>UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位地传输。</p><p>其中各位的意义如下:</p><p><strong>==起始位==</strong>:先发出一个逻辑”0”的信号，表示传输字符的开始。</p><p><strong>==数据位==</strong>:紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符，从最低位开始传送。</p><p>==<strong>奇偶校验位</strong>==:数据位加上这一位后，使得”1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验资料传送的正确性。</p><p><strong>==停止位==</strong>:它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。</p><p><strong>==空闲位==</strong>:处于逻辑”1”状态，表示当前线路上没有资料传送。</p><p>==<strong>波特率</strong>==:衡量数据传送速率的指标。表示每秒钟传送的比特位。</p><p>3、STM32的UART框图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kV6GszXHvFTJGSUyjR7ia5uwaKWmjUBFh5vnDHu3nZXPMpIKBsHe0j0Gg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明"><a href="#编程说明" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVfUWa6SYRO1SGEa329iclcnLRPKfehsmPnpNHAy38nRZBzYJN8t2icE9g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：主要设置波特率，数据长度，校验位，停止位，数据方向等。</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVceEYhMMbkx3346Aotxg0ic8PR0iauVYia5jylFSxxKqp9PhVnrIQmnT1Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVjUWEPjmvDDBn09a52n4NyRrFZy6k3P24tCZiaLl0dLgys2pccFG3EcA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、fputc重映射函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZczMcoiaxaQ1mXdibfMTGA8kVcqqEXxzQBlbxt6xK3QVTes5d8ttxbZJ4pqrkOp5loAF9ysoYpTyapw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-1"><a href="#6-1的程序-1" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-1"><a href="#工程配置-1" class="headerlink" title="工程配置"></a>工程配置</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921133147376.png" alt="image-20230921133147376"></p><p>一定要勾选Use MicroLIB，不然程序跑不起来</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921151625203.png" alt="image-20230921151625203"></p><h5 id="硬件电路-2"><a href="#硬件电路-2" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921154923848.png" alt="image-20230921154923848"></p><h5 id="软件代码-1"><a href="#软件代码-1" class="headerlink" title="软件代码"></a>软件代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> STA_Cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(STA_Machine.ucSTA_Machine_Status == STA1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;状态机第%d次运行\r\n&quot;</span>,STA_Cnt++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(STA_Machine.ucSTA_Machine_Status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STA1: STA_Machine.Fun_STA1(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA1\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA2: STA_Machine.Fun_STA2(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA2\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA3: STA_Machine.Fun_STA3(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA3\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA4: STA_Machine.Fun_STA4(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA4\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA5: STA_Machine.Fun_STA5(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA5\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA6: STA_Machine.Fun_STA6(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA6\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STA7: STA_Machine.Fun_STA7(); <span class="built_in">printf</span>(<span class="string">&quot;状态机状态为STA7\r\n\r\n&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:STA_Machine.ucSTA_Machine_Status = STA1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序实现串口打印功能----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Software version is V%.1f\r\n\r\n&quot;</span>,SoftWare_Version);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;开始运行有限状态机:\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   fputc</span></span><br><span class="line"><span class="comment">    * @param  ch -&gt; 待发送字符</span></span><br><span class="line"><span class="comment">    * @retval ch -&gt; 已发送字符      </span></span><br><span class="line"><span class="comment">    * @brief  fputc映射物理串口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//通过查询的方式循环发送</span></span><br><span class="line">  HAL_UART_Transmit(&amp;huart_debug, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0x000A</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public define-------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftWare_Version (float)1.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>huart_debughuart1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>发送到串口中文乱码问题</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921151725289.png" alt="image-20230921151725289"></p><p>把编码改成ANSI，直接另存为就能改</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921152006816.png" alt="image-20230921152006816"> </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921152108140.png" alt="image-20230921152108140"></p><h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><h4 id="程序功能-1"><a href="#程序功能-1" class="headerlink" title="程序功能"></a>程序功能</h4><p>通过基本定时器6，让3个LED灯间隔1s闪烁。</p><h4 id="技术讲解-1"><a href="#技术讲解-1" class="headerlink" title="技术讲解"></a>技术讲解</h4><p> 基本定时器框图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaaxZIFESiaPgHD366RjTzCXFImOezY2H9B7ekEC034dWCkkZevNjqaUg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>NVIC</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaVYwkFQTTK67MI0U5wy3QLafZtpLCKEp070WS8oNxpAFb30124y0VsA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaiaiafnV9QicyOvhKFtlywQlYhukOXAjZkGib0eOSehcz6ckRGajFlDkViag/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFa3ibOVzeurQ3kseIE9vSkxP8YR2ib5siaS1EHxFCfxtuxocRZEGISI070g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaR8noiczib5bjezsaQ558ApR76HC6qwyA0gSFyvuWmRj40DOeGUv15Pag/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：视频详细讲解各个函数以及应用情况。</p><h4 id="编程说明-1"><a href="#编程说明-1" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaseY4OQP5b5ISvuu1esvqNpuJ9jTxqIbO0Pj85zS3y9RMlEhPzHhGLg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：初始化基本定时器6，自动重载，5ms中断一次。</p><p>计算如下：</p><p>1、定时器时钟 = 72MHz</p><p>2、计算时钟 = 72MHz/(71+1) = 1MHz</p><p>3、定时周期 = （（1/1000000Hz）*5000）s = (5/1000)s = 5ms </p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdodUJQfL7aBBlGSjRY2wKrp6S4avsS09ic3zBKkfwd1w6GhiaQF2ZvQ8JDynGdaSSXUceF4mfEUBkw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaYJCFl9QFRTv0Tc0ErWWudyTeuA6TO2SvtdeofbL79GxNGAYOAKIU4g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、定时器结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaE52lbTEribm4eHTEMQtxDFHaYVZenqbYdBUsSreH9pRHwYRs6PzbMkw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、定时器回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf2MxeupDjzgCEJAZTYytFaN9Cia5XrNsmT8akTeQ85j0kPMwbdyr3qYNRp4yV1NQmmJ3DoAzpEa5g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-2"><a href="#6-1的程序-2" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-2"><a href="#工程配置-2" class="headerlink" title="工程配置"></a>工程配置</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921210129467.png" alt="image-20230921210129467"></p><h5 id="硬件电路-3"><a href="#硬件电路-3" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921215213904.png" alt="image-20230921215213904"></p><h5 id="软件代码-2"><a href="#软件代码-2" class="headerlink" title="软件代码"></a>软件代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Timer2_Start_IT</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//定时器2以中断模式启动</span></span><br><span class="line"></span><br><span class="line">Timer2_t Timer2 =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    Timer2_Start_IT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Timer2_Start_IT</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  定时器2以中断模式启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Timer2_Start_IT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim2);  <span class="comment">//启动定时器2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TIMER2_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER2_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TIMER0_10ms  = (<span class="type">uint16_t</span>)<span class="number">2</span>,</span><br><span class="line">TIMER0_50ms  = (<span class="type">uint16_t</span>)<span class="number">10</span>,</span><br><span class="line">TIMER0_100ms= (<span class="type">uint16_t</span>)<span class="number">20</span>,</span><br><span class="line">TIMER0_200ms= (<span class="type">uint16_t</span>)<span class="number">40</span>,</span><br><span class="line">TIMER0_500ms= (<span class="type">uint16_t</span>)<span class="number">100</span>,</span><br><span class="line">TIMER0_1S       = (<span class="type">uint16_t</span>)<span class="number">200</span>,</span><br><span class="line">TIMER0_2S       = (<span class="type">uint16_t</span>)<span class="number">400</span>,</span><br><span class="line">TIMER0_3S       = (<span class="type">uint16_t</span>)<span class="number">600</span>,</span><br><span class="line">TIMER0_5S       = (<span class="type">uint16_t</span>)<span class="number">1000</span>,</span><br><span class="line">TIMER0_10S      = (<span class="type">uint16_t</span>)<span class="number">2000</span>,</span><br><span class="line">    TIMER0_30S      = (<span class="type">uint16_t</span>)<span class="number">6000</span>,</span><br><span class="line">TIMER0_1min     = (<span class="type">uint16_t</span>)<span class="number">12000</span>,</span><br><span class="line">TIMER0_3min     = (<span class="type">uint16_t</span>)<span class="number">36000</span>,</span><br><span class="line">&#125;TIMER0_Value_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> <span class="keyword">volatile</span> usMCU_Run_Timer;  <span class="comment">//系统运行定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>(*Timer2_Start_IT)(<span class="type">void</span>);  <span class="comment">//定时器2以中断模式启动</span></span><br><span class="line">&#125;Timer2_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">extern</span> Timer2_t  Timer2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   HAL_TIM_PeriodElapsedCallback</span></span><br><span class="line"><span class="comment">    * @param  *htim -&gt; 处理定时器的结构体指针</span></span><br><span class="line"><span class="comment">    * @retval None</span></span><br><span class="line"><span class="comment">    * @brief  定时器中断回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (htim-&gt;Instance == htim2.Instance)</span><br><span class="line">  &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (++Timer2.usMCU_Run_Timer &gt;= TIMER0_1S)</span><br><span class="line">    &#123;</span><br><span class="line">      Timer2.usMCU_Run_Timer = <span class="number">0</span>;</span><br><span class="line">      LED.LED_Flip(LED1);</span><br><span class="line">      LED.LED_Flip(LED2);</span><br><span class="line">      LED.LED_Flip(LED3);</span><br><span class="line">      LED.LED_Flip(LED4);</span><br><span class="line">      LED.LED_Flip(LED5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">Timer6.Timer6_Start_IT(); <span class="comment">//启动定时器6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>一定要开启我们自己的初始化函数。仔细的检查代码，因为不是一块板子，所以要认真点，不然烧进去没效果的时候真的很难搞。</p><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><p>硬件家园的是触摸按键，我的是机械按键</p><h4 id="程序功能-2"><a href="#程序功能-2" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、触摸按键1单击与长按，控制LED1；</p><p>2、触摸按键2单击与长按，控制LED2;</p><p>3、触摸按键3单击与长按，控制LED3;</p><p>4、触摸按键4单击与长按，控制继电器;</p><h4 id="硬件电路-4"><a href="#硬件电路-4" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibUoFL67n1wGdjxQoJf1eyTjyt3nEkDu5xzeHj9fLovcBKesk5Acz9hg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibJTToOvBVhcOac6CGTUgiaFAwdrLfoRVibTbMdqpbF2nDgsj2XkhtsStQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibjbmZCJzJMGpUblScukvNU5pHwVhNibHLm4xNCltE8XJpHFvM8X0GEMg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-2"><a href="#技术讲解-2" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibUpfqcX68dOpYzqGJ2dm3xLdFdrZ4cNQHhmBZnv1q6LPNtQhves2LkQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230921220509890.png" alt="image-20230921220509890"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibpbiarnpH7Jq85lI01ZUfoXwnc15snDukcRU8iaURmcMBrbgEDdmOdDhA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：视频详细讲解各个函数以及应用情况。</p><h4 id="编程说明-2"><a href="#编程说明-2" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibgbf9Kkh4rJgt3WYzaA62N7vgUaOMiaMibGtUia5HEtHPR94Y12Rbr5Qdw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibibd13EoY65kaU4q8A3F4fCibRmpYtLTMLAZ9XJs80j6yKoDH8d36l1Lg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibkzH9BSxncPl0bpEgnicpwegqjQm43vqpCETKtW9M9aGVhMKL0qMpfWw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、按键结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibF78WM3pxdW2ict6w0Ribrz4KehsvoOulYrWZNPCWs67pfyIVP8XK4hibw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、外部中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyI0f2j6jhUwmgRKIqwiceibPJl3zqdtxhRmX8oyVkYCvT3RqgTMibK39rAIqFlRAHibRuqLreX91Ckg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-3"><a href="#6-1的程序-3" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-3"><a href="#工程配置-3" class="headerlink" title="工程配置"></a>工程配置</h5><p>一定 一定 一定 使能中断，设置上拉。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230922200056237.png" alt="image-20230922200056237"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230922200112088.png" alt="image-20230922200112088"></p><h5 id="硬件电路-5"><a href="#硬件电路-5" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>怎么接都行，我这样接只是想试试能不能这样接，按键接一脚接负极就行，接正极没反应</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230922200606013.png" alt="image-20230922200606013"></p><h5 id="软件代码-3"><a href="#软件代码-3" class="headerlink" title="软件代码"></a>软件代码</h5><p>其他按键复制按键1改个名字跟引脚就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键1检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY2_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键2检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY3_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键3检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY4_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键4检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY5_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键5检测</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//结构体类型定义</span></span><br><span class="line">KEY_t KEY1 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY1_Detect&#125;;</span><br><span class="line">KEY_t KEY2 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY2_Detect&#125;;</span><br><span class="line">KEY_t KEY3 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY3_Detect&#125;;</span><br><span class="line">KEY_t KEY4 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY4_Detect&#125;;</span><br><span class="line">KEY_t KEY5 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY5_Detect&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Key_waitReadPin</span></span><br><span class="line"><span class="comment">      * @param  GPIOx  </span></span><br><span class="line"><span class="comment">      *         GPIO_Pin  </span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  等待按键释放,超时则跳出循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_waitReadPin</span><span class="params">(GPIO_TypeDef* GPIOx, <span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span> (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Timeout --;</span><br><span class="line"><span class="keyword">if</span> (Timeout == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY1_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键1检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (KEY1.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        KEY1.Click = FALSE;</span><br><span class="line">        KEY1.Press = TRUE;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按键长按检测</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延时1秒</span></span><br><span class="line">            HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果1s内，按键状态出现高电平，此时按键为单击，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin( KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_SET)</span><br><span class="line">            &#123;</span><br><span class="line">                KEY1.Click = TRUE;</span><br><span class="line">                KEY1.Press = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KEY1.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;检测到按键1点击\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            LED.LED_Flip(LED1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY1.Press == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;检测到按键1长按\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待按键释放,超时直接跳出循环</span></span><br><span class="line">Key_waitReadPin( KEY1_GPIO_Port, KEY1_Pin);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按键1长按动作</span></span><br><span class="line">LED.LED_Flip(LED1);</span><br><span class="line">HAL_Delay(<span class="number">200</span>);</span><br><span class="line">LED.LED_Flip(LED1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除按键状态</span></span><br><span class="line">KEY1.KEY_Flag = FALSE;</span><br><span class="line">KEY1.Click = FALSE;</span><br><span class="line">KEY1.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> <span class="keyword">volatile</span> KEY_Flag;  <span class="comment">//按键标志位</span></span><br><span class="line">    <span class="type">uint8_t</span> Click;  <span class="comment">//单击</span></span><br><span class="line">    <span class="type">uint8_t</span> Press;  <span class="comment">//长按</span></span><br><span class="line">    <span class="type">void</span> (*KEY_Deteck)(<span class="type">void</span>);  <span class="comment">//按键检测</span></span><br><span class="line">&#125; KEY_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY1;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY2;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY3;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY4;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序实现触摸按键单击与长按功能----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;等待触摸按键:\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   </span></span><br><span class="line"><span class="comment">    * @param  </span></span><br><span class="line"><span class="comment">    * @retval </span></span><br><span class="line"><span class="comment">    * @brief  中断回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> KEY1_Pin: KEY1.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY2_Pin: KEY2.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY3_Pin: KEY3.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY4_Pin: KEY4.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY5_Pin: KEY5.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;错误 - 外部中断回调函数中，触摸按键键值错误！\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Deteck();</span><br><span class="line">KEY2.KEY_Deteck();</span><br><span class="line">KEY3.KEY_Deteck();</span><br><span class="line">KEY4.KEY_Deteck();</span><br><span class="line">KEY5.KEY_Deteck();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>使能中断，不使能中断程序没效果，串口有信息发出来，按键是没有效果的，</p><p>设置上拉电阻，不设置上拉串口那边会一直发按键按下，自己按按键没反应，LED一直变换状态。</p><p>按键一脚接串口，另一脚只能接负极，不然没反应。</p><p>不知道为什么这个延时没效果，慢慢学吧，可能后面就清楚了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      * @name   Key_waitReadPin</span><br><span class="line">      * @param  GPIOx  </span><br><span class="line">      *         GPIO_Pin  </span><br><span class="line">      * @retval None</span><br><span class="line">      * @brief  等待按键释放,超时则跳出循环</span><br><span class="line">*/</span><br><span class="line">void Key_waitReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t Timeout;</span><br><span class="line">Timeout = 10000;</span><br><span class="line">    while (HAL_GPIO_ReadPin(GPIOx, GPIO_Pin) == GPIO_PIN_SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Timeout --;</span><br><span class="line">if (Timeout == 0)</span><br><span class="line">&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蜂鸣器"><a href="#蜂鸣器" class="headerlink" title="蜂鸣器"></a>蜂鸣器</h3><h4 id="程序功能-3"><a href="#程序功能-3" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电后，无源蜂鸣器发出警报声；</p><p>2、通过触摸按键1打开或关闭蜂鸣器;</p><h4 id="硬件电路-6"><a href="#硬件电路-6" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230922201939771.png" alt="image-20230922201939771"></p><h4 id="技术讲解-3"><a href="#技术讲解-3" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><strong>PWM</strong></p><p>英文全称，Pulse-Width Modulation，脉冲宽度调制。是利用微处理器的数字输出来对模拟电路进行控制的一种非常有效的技术。</p><p>PWM可用于驱动无源蜂鸣器，通过调整PWM的频率，可以改变蜂鸣器发出的声音，比如发出报警音，歌曲等。</p><p><strong>框图</strong></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230922202109368.png" alt="image-20230922202109368"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFnxN3F6qkZaNQsXkNNAUNkvjxflibRmOzFJKOwU0ohD5ofqEKMxV06kA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：视频详细讲解各个函数以及应用情况。</p><h4 id="编程说明-3"><a href="#编程说明-3" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFsR7PxgYZpVg4dZwIFibiceZp7PAjKNkubZj0AlfricyGibCpcmpDiaNk3Cg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdF4iaxmlyLYkBwS7kFMhZQMAWoNoGZbbaV7sHaBqPdTLtfj8sTjodThfQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFbaldMMtsqd7v1EaB8onoRfqHVY6QIXlCKfETveuicfTtPAc10FOibXRg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、蜂鸣器结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFyZb2HBKAXQcRwdZTl8R57c2rGJl6MYpCWH4dUaL02WCMubNOg36mYw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、定时器回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFFT5yNQ69OJ70S322UjBZLmLm7rrkI6gRcgE2R0rV5CRnO0pe5QfGnQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-4"><a href="#6-1的程序-4" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p>没有无源蜂鸣器，想写呼吸灯奈何技术不行，只能后面再写。</p><h5 id="工程配置-4"><a href="#工程配置-4" class="headerlink" title="工程配置"></a>工程配置</h5><h5 id="硬件电路-7"><a href="#硬件电路-7" class="headerlink" title="硬件电路"></a>硬件电路</h5><h5 id="软件代码-4"><a href="#软件代码-4" class="headerlink" title="软件代码"></a>软件代码</h5><h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><h4 id="程序功能-4"><a href="#程序功能-4" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电后，输出带死区的互补PWM；</p><p>2、触摸按键1调节PWM占空比；</p><p>3、刹车引脚高电平触发。</p><p>硬件电路</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccVzWG9hu5dicZEeusibKGzmJuTUtw7UVOWWiaCHQYUe5xXFpfetJJlqedA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-4"><a href="#技术讲解-4" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>  1<strong>、高级定时器</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccOv0AM2BztIUlLv7XTIp9ficcpraP1bIeaPgC4cBtsbS8xpUibJej6hNg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>2、框图</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccI4c0BM2LcxEOVibBvZ6fB7uQdJzzviarJEM47PYbYyxaXnocCBc43o7A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>3、重复计数器</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccjpiaYZiaKauF7DIPEkGkL61AWhu5Q7FxOPIBl6J0BO3UwVibcTo1oGAtw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFnxN3F6qkZaNQsXkNNAUNkvjxflibRmOzFJKOwU0ohD5ofqEKMxV06kA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_tim.h><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccGTIxuzsiaB0kZO6rJjLicRia6CLjzaEl2p2QnEWGLdBAyL4ABWBNJNoTA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_tim_ex.h><p>说明：视频详细讲解各个函数以及应用情况。</p><h4 id="编程说明-4"><a href="#编程说明-4" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccNGciaXKTXqeRjycJ1BWwVMChUqHpANPl8GpN0yvvrV4QceVFpHL3Reg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccPwUFFDBibDczAkEOojdI9BscYscbVricBbIcoBu6BENGO9UrIVOicR5xg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFbaldMMtsqd7v1EaB8onoRfqHVY6QIXlCKfETveuicfTtPAc10FOibXRg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、初始化代码</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccQAHA0NibLzCYesVTqPEPDF0hU6ncddZxvcb2WlAVeEnn5HfoTeKT5uw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、外部中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcRHHwSMzNDpG4j4Hq5qBccLZru1eSaBNibp6TI4TUjAwb1ysOwhjWxdSzs2EC2ZcPJorBPS5YnIgw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-5"><a href="#6-1的程序-5" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p>波形对不上，问题很大。</p><h3 id="NTC-ADC"><a href="#NTC-ADC" class="headerlink" title="NTC(ADC)"></a>NTC(ADC)</h3><h4 id="程序功能-5"><a href="#程序功能-5" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电后，数码管数码PCB板温度；</p><p>2、串口间隔1s打印温度信息。</p><h4 id="硬件电路-8"><a href="#硬件电路-8" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKrZbkGpkXhoVvDict1ZyvuBMZEcIHcVl4MnKSXIUgq1cUvCS69uCr0yA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-5"><a href="#技术讲解-5" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>1、ADC</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKq82wg6Hr3jGvGJO9XKyIp8NibAaic28vIe6micyhoJ01EpePRKE1iaIMFA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKjbJXRicJ1MbxoBn6Je4Yw08qaF2dONzWVUrM5bicsRNicnU5KrRia8dJxQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、自制的NTC的温度数据表</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKqQGNKGdBY27glodAblUsJk4liaibDQc4FJRLLr31rClylexW5YJkSopg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKNXickpoZhN91of2yVW0B0e803phIWJaicR4n7SBcpJFMAoNaUxpb18bw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKsUrtDMhrDaibCIdKYYQCPhljUuRc10kRBRbpx5RSl4mHsQ5y4uwIJaA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <stm32f1xx_hal_adc.h><h4 id="编程说明-5"><a href="#编程说明-5" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKxFjHaiaY4mIhcX0juVJFZNP94coEEf9VW0J2FuPbX0V7eyrV1WOx6cQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd9fsiacYEJNg9ZBSBlVQEPeGp4wVZkUgu6vRXibK1fJ1GrnxUSPFG8fr909ddsRNRjphssjIiaqE58w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKDXhKc4FPteAalDjDYP0wLYgBR5I888BB2N7hTCAW3HojqR6vOtfgHg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、NTC结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QK12pBIEdlUWzw4pYIGqNfibyM1nsiayxn16wdoSXClVxhibq94gv9h0lXg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、NTC相关函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKOTfrLmNUuzOusYM23qDCeSGiasBsNPSvfrU4Um9hgb4tVSRia0DZbCNA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKz7JkYMvHDMdLUxDZ1eeqpSeagmeUauWPgdpV84qaGjr5xOwlHUgBTA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-6"><a href="#6-1的程序-6" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-5"><a href="#工程配置-5" class="headerlink" title="工程配置"></a>工程配置</h5><p>ADC时钟最高14，配高了会出错，所以我们配置12</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230924173744486.png" alt="image-20230924173744486"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230924174102068.png" alt="image-20230924174102068"></p><h5 id="硬件电路-9"><a href="#硬件电路-9" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>在PA5加一个热敏电阻</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230925091344308.png" alt="image-20230925091344308"></p><h5 id="软件代码-5"><a href="#软件代码-5" class="headerlink" title="软件代码"></a>软件代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    NTC</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-25 09:15:13</span></span><br><span class="line"><span class="comment">  * @brief   存放热敏电阻函数文件</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////优化后的温度表，将不在数据表中的数据放入临近的数组</span></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span>  NTC_Table[<span class="number">101</span>][<span class="number">2</span>] = </span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">3850</span>,<span class="number">3867</span>&#125;,&#123;<span class="number">3837</span>,<span class="number">3854</span>&#125;,&#123;<span class="number">3822</span>,<span class="number">3840</span>&#125;,&#123;<span class="number">3807</span>,<span class="number">3826</span>&#125;,&#123;<span class="number">3791</span>,<span class="number">3810</span>&#125;,</span><br><span class="line">&#123;<span class="number">3774</span>,<span class="number">3795</span>&#125;,&#123;<span class="number">3757</span>,<span class="number">3778</span>&#125;,&#123;<span class="number">3739</span>,<span class="number">3761</span>&#125;,&#123;<span class="number">3721</span>,<span class="number">3743</span>&#125;,&#123;<span class="number">3701</span>,<span class="number">3724</span>&#125;,</span><br><span class="line">&#123;<span class="number">3681</span>,<span class="number">3704</span>&#125;,&#123;<span class="number">3660</span>,<span class="number">3684</span>&#125;,&#123;<span class="number">3638</span>,<span class="number">3663</span>&#125;,&#123;<span class="number">3616</span>,<span class="number">3641</span>&#125;,&#123;<span class="number">3592</span>,<span class="number">3618</span>&#125;,</span><br><span class="line">  &#123;<span class="number">3568</span>,<span class="number">3595</span>&#125;,&#123;<span class="number">3543</span>,<span class="number">3570</span>&#125;,&#123;<span class="number">3517</span>,<span class="number">3545</span>&#125;,&#123;<span class="number">3491</span>,<span class="number">3519</span>&#125;,&#123;<span class="number">3463</span>,<span class="number">3492</span>&#125;,</span><br><span class="line">&#123;<span class="number">3435</span>,<span class="number">3464</span>&#125;,&#123;<span class="number">3405</span>,<span class="number">3435</span>&#125;,&#123;<span class="number">3375</span>,<span class="number">3405</span>&#125;,&#123;<span class="number">3344</span>,<span class="number">3375</span>&#125;,&#123;<span class="number">3312</span>,<span class="number">3343</span>&#125;,</span><br><span class="line">&#123;<span class="number">3280</span>,<span class="number">3311</span>&#125;,&#123;<span class="number">3246</span>,<span class="number">3279</span>&#125;,&#123;<span class="number">3212</span>,<span class="number">3245</span>&#125;,&#123;<span class="number">3177</span>,<span class="number">3211</span>&#125;,&#123;<span class="number">3141</span>,<span class="number">3176</span>&#125;,</span><br><span class="line">&#123;<span class="number">3105</span>,<span class="number">3140</span>&#125;,&#123;<span class="number">3067</span>,<span class="number">3104</span>&#125;,&#123;<span class="number">3029</span>,<span class="number">3066</span>&#125;,&#123;<span class="number">2991</span>,<span class="number">3028</span>&#125;,&#123;<span class="number">2951</span>,<span class="number">2990</span>&#125;,</span><br><span class="line">&#123;<span class="number">2911</span>,<span class="number">2950</span>&#125;,&#123;<span class="number">2871</span>,<span class="number">2910</span>&#125;,&#123;<span class="number">2829</span>,<span class="number">2870</span>&#125;,&#123;<span class="number">2788</span>,<span class="number">2828</span>&#125;,&#123;<span class="number">2745</span>,<span class="number">2787</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2705</span>,<span class="number">2744</span>&#125;,&#123;<span class="number">2660</span>,<span class="number">2704</span>&#125;,&#123;<span class="number">2616</span>,<span class="number">2659</span>&#125;,&#123;<span class="number">2572</span>,<span class="number">2615</span>&#125;,&#123;<span class="number">2528</span>,<span class="number">2571</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2484</span>,<span class="number">2527</span>&#125;,&#123;<span class="number">2440</span>,<span class="number">2483</span>&#125;,&#123;<span class="number">2395</span>,<span class="number">2439</span>&#125;,&#123;<span class="number">2350</span>,<span class="number">2394</span>&#125;,&#123;<span class="number">2305</span>,<span class="number">2349</span>&#125;,</span><br><span class="line">&#123;<span class="number">2260</span>,<span class="number">2304</span>&#125;,  <span class="comment">//对应20℃  --下标为50</span></span><br><span class="line">  &#123;<span class="number">2216</span>,<span class="number">2259</span>&#125;,&#123;<span class="number">2171</span>,<span class="number">2215</span>&#125;,&#123;<span class="number">2126</span>,<span class="number">2170</span>&#125;,&#123;<span class="number">2082</span>,<span class="number">2125</span>&#125;,&#123;<span class="number">2037</span>,<span class="number">2081</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1992</span>,<span class="number">2036</span>&#125;,&#123;<span class="number">1947</span>,<span class="number">1991</span>&#125;,&#123;<span class="number">1903</span>,<span class="number">1946</span>&#125;,&#123;<span class="number">1859</span>,<span class="number">1902</span>&#125;,&#123;<span class="number">1815</span>,<span class="number">1858</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1772</span>,<span class="number">1814</span>&#125;,&#123;<span class="number">1729</span>,<span class="number">1771</span>&#125;,&#123;<span class="number">1687</span>,<span class="number">1728</span>&#125;,&#123;<span class="number">1646</span>,<span class="number">1687</span>&#125;,&#123;<span class="number">1604</span>,<span class="number">1645</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1564</span>,<span class="number">1603</span>&#125;,&#123;<span class="number">1524</span>,<span class="number">1563</span>&#125;,&#123;<span class="number">1484</span>,<span class="number">1523</span>&#125;,&#123;<span class="number">1446</span>,<span class="number">1483</span>&#125;,&#123;<span class="number">1408</span>,<span class="number">1445</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1370</span>,<span class="number">1407</span>&#125;,&#123;<span class="number">1334</span>,<span class="number">1369</span>&#125;,&#123;<span class="number">1297</span>,<span class="number">1333</span>&#125;,&#123;<span class="number">1262</span>,<span class="number">1296</span>&#125;,&#123;<span class="number">1228</span>,<span class="number">1261</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1194</span>,<span class="number">1227</span>&#125;,&#123;<span class="number">1161</span>,<span class="number">1193</span>&#125;,&#123;<span class="number">1128</span>,<span class="number">1160</span>&#125;,&#123;<span class="number">1096</span>,<span class="number">1129</span>&#125;,&#123;<span class="number">1062</span>,<span class="number">1095</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1035</span>,<span class="number">1067</span>&#125;,&#123;<span class="number">1006</span>,<span class="number">1038</span>&#125;,&#123;<span class="number">977</span> ,<span class="number">1009</span>&#125;,&#123;<span class="number">949</span> , <span class="number">981</span>&#125;,&#123;<span class="number">921</span> , <span class="number">953</span>&#125;,</span><br><span class="line">  &#123;<span class="number">895</span> , <span class="number">926</span>&#125;,&#123;<span class="number">869</span> , <span class="number">900</span>&#125;,&#123;<span class="number">843</span> , <span class="number">875</span>&#125;,&#123;<span class="number">819</span> , <span class="number">850</span>&#125;,&#123;<span class="number">795</span> , <span class="number">826</span>&#125;,</span><br><span class="line">  &#123;<span class="number">771</span> , <span class="number">802</span>&#125;,&#123;<span class="number">749</span> , <span class="number">779</span>&#125;,&#123;<span class="number">727</span> , <span class="number">757</span>&#125;,&#123;<span class="number">705</span> , <span class="number">735</span>&#125;,&#123;<span class="number">684</span> , <span class="number">714</span>&#125;,</span><br><span class="line">  &#123;<span class="number">664</span> , <span class="number">694</span>&#125;,&#123;<span class="number">644</span> , <span class="number">674</span>&#125;,&#123;<span class="number">625</span> , <span class="number">654</span>&#125;,&#123;<span class="number">607</span> , <span class="number">636</span>&#125;,&#123;<span class="number">589</span> , <span class="number">617</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_NTC_Voltage</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//获取温度电压</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_Temperature_Value</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//获取温度值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line">NTC_t NTC = </span><br><span class="line">&#123;</span><br><span class="line">    Get_NTC_Voltage,</span><br><span class="line">    .usADC_Value = <span class="number">0</span>,</span><br><span class="line">    .fNTC_Voltage = <span class="number">0.0</span>,</span><br><span class="line"></span><br><span class="line">    Get_Temperature_Value,</span><br><span class="line">    .fTemperature = <span class="number">0.0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Get_NTC_Voltage</span></span><br><span class="line"><span class="comment">* @brief  获取温度电压</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_NTC_Voltage</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">HAL_ADC_Start(&amp;hadc1);</span><br><span class="line"><span class="keyword">if</span>(HAL_ADC_PollForConversion(&amp;hadc1,<span class="number">10</span>) == HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">NTC.usADC_Value    = HAL_ADC_GetValue(&amp;hadc1);</span><br><span class="line">NTC.fNTC_Voltage   = (NTC.usADC_Value*<span class="number">3.3</span>)/<span class="number">4095</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AD转换原始值 = %d\r\n&quot;</span>,NTC.usADC_Value);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计算得出的电压值 = %.2fV\r\n&quot;</span>,NTC.fNTC_Voltage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AD转换错误或超时!!!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Get_Temperature_Value</span></span><br><span class="line"><span class="comment">* @brief  获取温度值</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Get_Temperature_Value</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Temp;</span><br><span class="line"></span><br><span class="line">NTC.Get_NTC_Voltage(); <span class="comment">//获取ADC采集值与NTC电压</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////临界温度处理</span></span><br><span class="line"><span class="keyword">if</span>(NTC.usADC_Value &lt; <span class="number">589</span>) <span class="comment">//最高70℃</span></span><br><span class="line">&#123;</span><br><span class="line">NTC.usADC_Value = <span class="number">589</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Temperature is higher than 70℃\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(NTC.usADC_Value &gt; <span class="number">3867</span>) <span class="comment">//最低-30℃</span></span><br><span class="line">&#123;</span><br><span class="line">NTC.usADC_Value = <span class="number">3867</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Temperature is below -30℃\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分法查表</span></span><br><span class="line"><span class="keyword">if</span>(NTC.usADC_Value &gt; NTC_Table[<span class="number">50</span>][<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查询0 - 49  对应-30℃至19℃摄氏度</span></span><br><span class="line"><span class="keyword">for</span>(Temp=<span class="number">0</span>;Temp&lt;=<span class="number">49</span>;Temp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((NTC.usADC_Value &gt;= NTC_Table[Temp][<span class="number">0</span>]) &amp;&amp; (NTC.usADC_Value &lt;= NTC_Table[Temp][<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(NTC.usADC_Value &lt; NTC_Table[<span class="number">50</span>][<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查询51 - 100  对应21℃至70℃摄氏度</span></span><br><span class="line"><span class="keyword">for</span>(Temp=<span class="number">51</span>;Temp&lt;=<span class="number">100</span>;Temp++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((NTC.usADC_Value &gt;= NTC_Table[Temp][<span class="number">0</span>]) &amp;&amp; (NTC.usADC_Value &lt;= NTC_Table[Temp][<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Temp = <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算温度</span></span><br><span class="line">NTC.fTemperature = (<span class="type">float</span>)Temp - <span class="number">30</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Temperature is :%.1f℃\r\n\r\n&quot;</span>,NTC.fTemperature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序实现ADC功能,获取PCB板温度----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Timer2.Timer2_Start_IT();  <span class="comment">//启动定时器2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">NTC.Get_Temperature_Value();</span><br><span class="line">HAL_Delay(<span class="number">1000</span>); <span class="comment">//延时1s采集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Timer2_Start_IT</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  定时器2以中断模式启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Timer2_Start_IT</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);  <span class="comment">//启动定时器2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   HAL_TIM_PeriodElapsedCallback</span></span><br><span class="line"><span class="comment">* @brief  定时器中断回调函数</span></span><br><span class="line"><span class="comment">* @param  *htim -&gt; 处理定时器的结构体指针</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance == htim2.Instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//程序支持运行，指示灯间隔1s闪烁</span></span><br><span class="line"><span class="keyword">if</span>(++Timer2.usMCU_Run_Timer &gt;= TIMER0_1S)</span><br><span class="line">&#123;</span><br><span class="line">Timer2.usMCU_Run_Timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED.LED_Flip(LED1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>程序现象没问题，就是我的热敏电阻的电压有点问题，不知道是什么问题</p><h3 id="DAC-1"><a href="#DAC-1" class="headerlink" title="DAC"></a>DAC</h3><h4 id="程序功能-6"><a href="#程序功能-6" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电后，输出正弦波；</p><p>2、触摸按键1调整正玄波频率。</p><h4 id="硬件电路-10"><a href="#硬件电路-10" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41tzmPfmBWphIFicz0GsFlmaujJCDJpxUHrjbgSDOWLtjhO7YaOR7yN1A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-6"><a href="#技术讲解-6" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO414tjBsroJKcia4ZGfOibYzlvY0uAf8YwS7dYN4Hg8qcoEPfWHdvnlQFKQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41bIFhY9kZ2I8PI3254mmJ7he4JF0vqY86rFVpN25mSHicd8oWOqvZVeQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41XjWhnyrsibNYBhanyeL3Sb6ruDswrH2tz8fFytRKf49tib5T7PgiajyAw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>HAL库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41RE9dK9szB3TCBVDfcfprjCXmeic7TctI2ASmBpv9I7e5KXJ3UtzKvoQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <stm32f1xx_hal_dac.h><h4 id="编程说明-6"><a href="#编程说明-6" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41y8Sv27t1yQKSfYt2xLKVJBc6xlknvBdjZ2LX61KCvMxktBich7XwBFA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41ibp9oOPMoeyxVXFTVARNEN2dtLgjqDWdpoUeoJ6w1tMnH63LXZkIicIQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41XsoXRq3JZDQeyEBanh5YnWqg9AV3fliawNkEObT8yrs96ZEgCC59ia6g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、DAC结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41Xs8AYhpNEu1iasstA3xK5YLvGYNLCDicuGV3iaevnIrHjSfxpGojWKX3w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、DAC相关函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41yOJhOTIppXWWbljOEwZLXncYwMdMZfAU8LEzeibrOgOfAQ626xIvxUg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-7"><a href="#6-1的程序-7" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p>c8t6没有DAC，下课。</p><h5 id="工程配置-6"><a href="#工程配置-6" class="headerlink" title="工程配置"></a>工程配置</h5><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><h4 id="程序功能-7"><a href="#程序功能-7" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、数码管显示PCB板温度；</p><p>2、SPI扩展接口的CS管脚(DAC_OUT1)输出1kHz的正弦波</p><p>3、触摸按键调整正弦波频率，在100Hz，1kHz，10kHz，100kHz，1MHz间切换；</p><p>4、串口打印温度信息与调整后的正弦波频率；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUS68Lt2OBnN1EfQthntFytFZib1BCvJyX29Mk58Ht5fEPiaMvXySlN5OQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-11"><a href="#硬件电路-11" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>ADC：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdiaI3ichCibFQcdWWzz6US8QKrZbkGpkXhoVvDict1ZyvuBMZEcIHcVl4MnKSXIUgq1cUvCS69uCr0yA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>DAC：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfP8icibpaHW6yxZCv9DpVO41tzmPfmBWphIFicz0GsFlmaujJCDJpxUHrjbgSDOWLtjhO7YaOR7yN1A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-7"><a href="#技术讲解-7" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUspmWEv2MV9ukO58aDOtQMnGIJ3re8AicVqwRKUnnese8stnthFffjWg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUUZWMxok7K629biaN1TMapcxJV6KSfUQiaGbSQiaNXc5XSQe8n185rKibBg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUib62zXIaicZlSpcCwt6IVUO1Q2ibXcKgPQrxxV33mGFRB3Zx9icNUod4Vw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUgK0CehuibYsCSD1gdxCXOtP4NPiaG8deLpSwxCldzqkEOjFAaKeoCsiag/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-1"><a href="#HAL库函数-1" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUsGHRDYqvf0hkuh4oqBYM77HHdmaoa1Tr7ZEYq3aj8w1jueCSNcORYQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <stm32f1xx_hal_adc.h><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNU0AiboT1WO15TiaYMECCubHvtuLFYFZMQcYxZozNSe6tbambbySNicnlxA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <stm32f1xx_hal_dac.h><h4 id="编程说明-7"><a href="#编程说明-7" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p>ADC部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNULl4JfCkkxuUnDAs0dJyK91t3DatsowLGs7s6E7L2q3tKGiaXZkHug9A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUlavWRE64VYNuBvzhzXCeOfHf677ll78rhoPhB12ShicBrhFe1ZUQjcQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>DAC部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUFF37jY9a5ZBkFG3SAcdrOOiaP3yC7VqFiaBqSMIh5icvPRRuddS8RerVQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNU9spkRku5xXAIMjfUbZupkZG1gCZT8jaHmQaMCNCricHI0dWfENM1Evg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>TIM5部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUYLYHjGYmjKKfhe3Gn7pvC5uELMDCMfQ6qB4ZrcpCR8gUiblGvYLF5dw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>NVIC部分：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUibzTdMf88zRfexxsnUds402YBjEgFGotSuKhwcfhdbWzAeibT0Nicibumw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUZ6L2iacX8Myr6t2Fae9EySpTHCUm7oMWxlwuLKTLdIibk6yKOVhGvWVg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUHjeMAOrkHjROLON5EQibyfibm0ASVaPiasRhghicDO8iaIYU2YwvLkxX9Sw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、用户初始化函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNUvnOA122a3p3UPFBiaFvZZTecGZMkibQDMzNyS7z83qJSy6kfTcKq40MQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcqHBzNGIJkLGoxAicys0kNU2ticiafEVjGVN8bpakwibVh4lCDSgKSOBtA42tbibmP1mFrbED5mFLPibuA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-8"><a href="#6-1的程序-8" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p>后面再写，现在的芯片没有DAC</p><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><h4 id="程序功能-8"><a href="#程序功能-8" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、软件模拟I2C协议与SHT30数字温湿度传感器通讯；</p><p>2、数码管显示环境温湿度；</p><p>3、串口打印环境温湿度。</p><p>图片如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUkRPkz410CSOE0p4ibdScibEPyZ4QULBydHW36gV7DeUtLiaIgogSaVDBw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-12"><a href="#硬件电路-12" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaYZ71vwsmcpGbymrk9ZC86gbMBSRiapVJOicC6gIoSradTXe3Mva04WLug/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-8"><a href="#技术讲解-8" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaYjyAt2w1iaEhIgVzOjWib803Z8r8gj5KWUuiaucouAFoXiaLGq3L5134PmQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaY54yYg3FVDaaA6gRibBxvzN9sAEx3AZTjOmick19ne0Bo5FOMUxBwXmAQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p> I2C协议特点</p><p>1、串行协议，多主机模式；</p><p>2、起始信号，SCL为高电平时，SDA下降沿，主机发出；</p><p>3、停止信号，SCL为高电平时，SDA上升沿，主机发出；</p><p>4、数据与地址按8位/字节传输，高位在前；</p><p>5、传输过程中，SCL为低电平时，SDA更改状态，SCL为高电平时，SDA状态需稳定；</p><p>6、每传输一个字节，接收器必须回应1个应答位(ACK)给发送器。</p><p>AT24Cxx传输图片：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaY806YmoJQnzNqMUlSDiaISjdcwRrwen5qhxRgbWqIu62cHoHUSBkmIbw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaYngGPIXvdt06YQjHUVCvZiaHSxjflYiayZSExia1FVS8xIJI7hEOxlWwCA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>SHT30手册阅读：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaYMMqFP8S4KgcVt0NfRBw4MRzCkEg6RtG6OuBaC6msO2KNc1dicUZfvHA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcrj76JvZpVax0ZswvVqicaYbEXMuphQRG2RCLANBtBzGAiaJAkibdIh3emRqKNbP2U39H4DQIv2IlYA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-2"><a href="#HAL库函数-2" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p>​    软件模拟IIC，用GPIO的库函数即可。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUviaCjllPAjJmVlWpY320QbDgcL3e4QW4GEsMbVzcNM3Jhe65Dpy5uPw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-8"><a href="#编程说明-8" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUjkC7ee4xVB8fBGMxFvmI5dQHlVQqZ8vuonMGPkZibiav8gRNM53jDOEw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：</p><p>SCL与SDA均配置为开漏输出，总线上均有上拉电阻。如此，SDA作为输出的同时，也可以作为输入使用。 与51内核的准双向口一样，作为输入使用时，需要先输出高电平，关闭内部的NMOS管。</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUe9waDUpMRNdPXUvVlB4y7ibCFBCJwoM23ojw3RzhDv6icCHzL6nLb3wg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUCQXYVoYVjw1nIdzicuUmMvvdQ2icH7LfAcsYlx8Oiafia71S0EKtTra7pQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、I2C结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEUc0xvOSp0Iu7YPxDUhahSI1OBibicxl5OpRQxHMFqXHRHv1hh2t0XUib8A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、SHT30结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZde5ttiaYmsaI0vlY6BvbBEU40Krm1aFwTsH4iaicED1y0gicdia8iaAaTYHGS9iaNkv0llwib6BCBPmLswUA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-9"><a href="#6-1的程序-9" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-7"><a href="#工程配置-7" class="headerlink" title="工程配置"></a>工程配置</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230925172621821.png" alt="image-20230925172621821"></p><h5 id="硬件电路-13"><a href="#硬件电路-13" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>没有芯片，也弄不出效果，就跟着模拟一遍I2C的流程，多打打，多熟悉熟悉。</p><h5 id="软件代码-6"><a href="#软件代码-6" class="headerlink" title="软件代码"></a>软件代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    MyI2C</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-25 15:55:20</span></span><br><span class="line"><span class="comment">  * @brief   软件模拟IIC</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//置位与清零SCL管脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SET_SCLHAL_GPIO_WritePin(SCL_GPIO_Port,SCL_Pin,GPIO_PIN_SET) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CLR_SCLHAL_GPIO_WritePin(SCL_GPIO_Port,SCL_Pin,GPIO_PIN_RESET)</span></span><br><span class="line"><span class="comment">//置位与清零SDA管脚</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>SET_SDAHAL_GPIO_WritePin(SDA_GPIO_Port,SDA_Pin,GPIO_PIN_SET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>CLR_SDAHAL_GPIO_WritePin(SDA_GPIO_Port,SDA_Pin,GPIO_PIN_RESET)</span></span><br><span class="line"><span class="comment">//读SDA管脚状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_SDAHAL_GPIO_ReadPin(SCL_GPIO_Port,SDA_Pin)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//I2C初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Start</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//I2C起始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Stop</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//I2C停止信号</span></span><br><span class="line">ACK_Value_t <span class="title function_">Write_Byte</span><span class="params">(<span class="type">uint8_t</span>)</span>;      <span class="comment">//I2C写字节</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Read_Byte</span> <span class="params">(ACK_Value_t)</span>;  <span class="comment">//I2C读字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line">MyI2C_t MyI2C =</span><br><span class="line">&#123;</span><br><span class="line">Init,</span><br><span class="line">Start,</span><br><span class="line">Stop,</span><br><span class="line">Write_Byte,</span><br><span class="line">Read_Byte</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">I2C_Delay_us</span><span class="params">(<span class="type">uint8_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Init</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  IIC初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SET_SCL;</span><br><span class="line">    SET_SDA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Start</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  IIC起始信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SET_SDA;</span><br><span class="line">    SET_SCL;</span><br><span class="line">    I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line">    CLR_SDA;</span><br><span class="line">    I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line">    CLR_SCL;</span><br><span class="line">    I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Stop</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  I2C停止信号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CLR_SDA;</span><br><span class="line">    SET_SCL; </span><br><span class="line">    I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line">    SET_SDA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Write_Byte</span></span><br><span class="line"><span class="comment">* @brief  I2C写字节</span></span><br><span class="line"><span class="comment">* @param  WR_Byte -&gt; 待写入数据</span></span><br><span class="line"><span class="comment">* @retval ACK_Value_t -&gt; 从机应答值      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> ACK_Value_t <span class="title function_">Write_Byte</span><span class="params">(<span class="type">uint8_t</span> WR_Byte)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line">ACK_Value_t  ACK_Rspond;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据</span></span><br><span class="line"><span class="comment">//数据按8位传输，高位在前，利用for循环逐个接收</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//SCL清零，主机SDA准备数据</span></span><br><span class="line">CLR_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>((WR_Byte&amp;BIT7) == BIT7)</span><br><span class="line">&#123;</span><br><span class="line">SET_SDA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CLR_SDA;</span><br><span class="line">&#125;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//SCL置高，传输数据</span></span><br><span class="line">SET_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备发送下一比特位</span></span><br><span class="line">WR_Byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CLR_SCL;</span><br><span class="line"><span class="comment">//释放SDA，等待从机应答</span></span><br><span class="line">SET_SDA;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">SET_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">ACK_Rspond = (ACK_Value_t)READ_SDA;</span><br><span class="line"></span><br><span class="line">CLR_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回从机的应答信号</span></span><br><span class="line"><span class="keyword">return</span> ACK_Rspond;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Write_Byte</span></span><br><span class="line"><span class="comment">* @brief  I2C读字节</span></span><br><span class="line"><span class="comment">* @param  ACK_Value -&gt; 主机回应值</span></span><br><span class="line"><span class="comment">* @retval 从机返回值      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">Read_Byte</span><span class="params">(ACK_Value_t ACK_Value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RD_Byte = <span class="number">0</span>,i;</span><br><span class="line"></span><br><span class="line"><span class="comment">////接收数据</span></span><br><span class="line"><span class="comment">//SCL为低电平时，SDA准备数据,接着SCL为高电平，读取SDA数据</span></span><br><span class="line"><span class="comment">//数据按8位传输，高位在前，利用for循环逐个接收</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//准备接收下一比特位</span></span><br><span class="line">RD_Byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCL清零，从机SDA准备数据</span></span><br><span class="line">CLR_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//SCL置高，获取数据</span></span><br><span class="line">SET_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">RD_Byte |= READ_SDA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//SCL清零，主机准备应答信号</span></span><br><span class="line">CLR_SCL;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//主机发送应答信号</span></span><br><span class="line"><span class="keyword">if</span>(ACK_Value == ACK)</span><br><span class="line">&#123;</span><br><span class="line">CLR_SDA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SET_SDA;</span><br><span class="line">  &#125;</span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SET_SCL; </span><br><span class="line">I2C_Delay_us(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Note:</span></span><br><span class="line">  <span class="comment">//释放SDA数据线</span></span><br><span class="line"><span class="comment">//SCL先清零，再释放SDA，防止连续传输数据时，从机错将SDA释放信号当成NACk信号</span></span><br><span class="line">CLR_SCL;</span><br><span class="line">  SET_SDA; </span><br><span class="line">I2C_Delay_us(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数据</span></span><br><span class="line"><span class="keyword">return</span> RD_Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   I2C_Delay</span></span><br><span class="line"><span class="comment">* @brief  I2C延时</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">I2C_Delay_us</span><span class="params">(<span class="type">uint8_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过示波器测量进行校准</span></span><br><span class="line"><span class="keyword">while</span>(us--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYI2C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYI2C_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  BIT0 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">0</span>),  </span><br><span class="line">BIT1 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>),  </span><br><span class="line">BIT2 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>),  </span><br><span class="line">BIT3 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>),  </span><br><span class="line">BIT4 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>),</span><br><span class="line">BIT5 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>),</span><br><span class="line">BIT6 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">6</span>),</span><br><span class="line">BIT7 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">7</span>),</span><br><span class="line">&#125;BIT_t;</span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ACK = GPIO_PIN_RESET,</span><br><span class="line">NACK = GPIO_PIN_SET,</span><br><span class="line">&#125;ACK_Value_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> (*Init)(<span class="type">void</span>);  <span class="comment">//I2C初始化</span></span><br><span class="line"><span class="type">void</span> (*Start)(<span class="type">void</span>); <span class="comment">//I2C起始信号</span></span><br><span class="line"><span class="type">void</span> (*Stop)(<span class="type">void</span>);  <span class="comment">//I2C停止信号</span></span><br><span class="line">ACK_Value_t (*Write_Byte)(<span class="type">uint8_t</span>);      <span class="comment">//I2C写字节</span></span><br><span class="line"><span class="type">uint8_t</span>     (*Read_Byte) (ACK_Value_t);  <span class="comment">//I2C读字节</span></span><br><span class="line">&#125;MyI2C_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> MyI2C_t MyI2C;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h3><h4 id="程序功能-9"><a href="#程序功能-9" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcibXGWtIIrTxicohBwHTPR0icDft14O8YiaOhrzMIxibJukKhUx2TYUj2qdw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-14"><a href="#硬件电路-14" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcSibsibibdok1LMeiacUR0VY9Y2reCQ1VUWvTf3p51p6FNFHf8V5ibXXA3UTgEuc8ibuCjOCk25CLahQCA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-9"><a href="#技术讲解-9" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>直流电动机是能将直流电能转换成机械能的旋转电机。</p><p>驱动方式一：只能打开或关闭，不能变速与换向，用继电器，BJT或MOS开关控制通断即可。</p><p>驱动方式二：可以打开或关闭，可以变速，但不能换向，用PWM控制电子开关即可，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfyXibX4t6zTic9hNZglgLV6ebaxpicfZ1jaicJGsIBqJaNyjkDicbEKe75vW88SRMmZq7jBetB0pUpsng/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>驱动方式三：可以打开或关闭，可以变速，也可以换向，用PWM控制桥路，如下图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcTMibR2QNHVEibSvPxzzZH4Caa5WhO1VSIOxIm8EvHPNmQGHVPo5jU9tQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-3"><a href="#HAL库函数-3" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p>   <img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZerVR0IFWtZtpjd6e31LSdFnxN3F6qkZaNQsXkNNAUNkvjxflibRmOzFJKOwU0ohD5ofqEKMxV06kA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-9"><a href="#编程说明-9" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcCT4lmchpSOY2aKxNaaNGC4TY8UmUml9xL4Wad0giaRghiczHqsppQExA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcI0cCf4nbiatow2UfymiaYM6KDEqV9yokMtwP31EVIyID1wWtrnyXqibsQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcmRDuIhV7ZCT8UCkyRPDKhR8ZzG4oa1DLD69QYqpLkn7RfHq1dWramw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、直流电机结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZc0T1oM9G06nfmmOmhxMQ6qicqiaXZzPe43ZyWb12V8DmF6zxqXiawwDxYQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、触摸按键中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZc5ncbAXLCLs4QaRuibaH4ic4D8lByCqW1F2EwxbINmpOQcCsVUIIYVJBA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-10"><a href="#6-1的程序-10" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-8"><a href="#工程配置-8" class="headerlink" title="工程配置"></a>工程配置</h5><p>主要配PWM，其他都是前面配过的</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230926132534998.png" alt="image-20230926132534998"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230926132630374.png" alt="image-20230926132630374"></p><h5 id="硬件电路-15"><a href="#硬件电路-15" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230926132702937.png" alt="image-20230926132702937"></p><p>这是我接的，接的很乱很杂，hhh，板子是旺哥今天给的，他之前画的，有这个板子我的面包板就有更多的位置了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230926133151018.png" alt="image-20230926133151018"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230926133205501.png" alt="image-20230926133205501"></p><h5 id="软件代码-7"><a href="#软件代码-7" class="headerlink" title="软件代码"></a>软件代码</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    DC_Motor</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-26 13:34:13</span></span><br><span class="line"><span class="comment">  * @brief   存放直流电机函数文件</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Start</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//直流电机启动</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Stop</span><span class="params">(<span class="type">void</span>)</span>;    <span class="comment">//直流电机停止</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Direction_Adjust</span><span class="params">(<span class="type">void</span>)</span>;        <span class="comment">//直流电机方向调整</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Speed_Adjust</span><span class="params">(Speed_Change_t)</span>;  <span class="comment">//直流电机速度调整</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义结构体类变量</span></span><br><span class="line">DC_Motor_t DC_Motor = </span><br><span class="line">&#123;</span><br><span class="line">  Stop_State,</span><br><span class="line">Forward_State, </span><br><span class="line">Speed_50,</span><br><span class="line"></span><br><span class="line">Start,</span><br><span class="line">Stop,</span><br><span class="line">Direction_Adjust,</span><br><span class="line">Speed_Adjust</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Start</span></span><br><span class="line"><span class="comment">* @brief  直流电机启动</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//启动电机</span></span><br><span class="line"><span class="keyword">if</span>(DC_Motor.Direction == Forward_State)</span><br><span class="line">&#123;</span><br><span class="line">HAL_TIM_PWM_Start(&amp;htim3,TIM_CHANNEL_3);</span><br><span class="line">        </span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12,GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新电机状态</span></span><br><span class="line">DC_Motor.Status = Start_State;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Stop</span></span><br><span class="line"><span class="comment">* @brief  直流电机停止</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//停止电机</span></span><br><span class="line">HAL_TIM_PWM_Stop(&amp;htim3,TIM_CHANNEL_3);</span><br><span class="line"><span class="comment">//更新电机状态</span></span><br><span class="line">DC_Motor.Status = Stop_State;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Direction_Adjust</span></span><br><span class="line"><span class="comment">* @brief  直流电机方向调整</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Direction_Adjust</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(DC_Motor.Status == Start_State)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(DC_Motor.Direction == Reverse_State)</span><br><span class="line">&#123;</span><br><span class="line">            HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11,GPIO_PIN_SET);</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12,GPIO_PIN_RESET);</span><br><span class="line"><span class="comment">//更新电机方向标识</span></span><br><span class="line">DC_Motor.Direction = Forward_State;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, GPIO_PIN_11,GPIO_PIN_RESET);</span><br><span class="line">    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12,GPIO_PIN_SET);</span><br><span class="line"><span class="comment">//更新电机方向标识</span></span><br><span class="line">DC_Motor.Direction = Reverse_State;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Speed_Adjust</span></span><br><span class="line"><span class="comment">* @brief  直流电机速度调整</span></span><br><span class="line"><span class="comment">* @param  Speed_Change -&gt; 速度变化</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Speed_Adjust</span><span class="params">(Speed_Change_t Speed_Change)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(DC_Motor.Status == Start_State)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Speed_Change == Speed_up)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//增大电机速度</span></span><br><span class="line"><span class="keyword">switch</span>(DC_Motor.Speed)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Speed_50:DC_Motor.Speed = Speed_60;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_60:DC_Motor.Speed = Speed_70;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_70:DC_Motor.Speed = Speed_80;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_80:DC_Motor.Speed = Speed_90;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_90:DC_Motor.Speed = Speed_100; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_100:DC_Motor.Speed = Speed_100; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: DC_Motor.Speed = Speed_50;         </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//减小电机速度</span></span><br><span class="line"><span class="keyword">switch</span>(DC_Motor.Speed)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> Speed_50:DC_Motor.Speed = Speed_50;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_60:DC_Motor.Speed = Speed_50;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_70:DC_Motor.Speed = Speed_60;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_80:DC_Motor.Speed = Speed_70;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_90:DC_Motor.Speed = Speed_80;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> Speed_100:DC_Motor.Speed = Speed_90;  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: DC_Motor.Speed = Speed_90;         </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新PWM占空比</span></span><br><span class="line">TIM3-&gt;CCR3 = DC_Motor.Speed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序实现直流电机的启停、正反转与加减速功能----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Software version is V%.1f\r\n\r\n&quot;</span>,SoftWare_Version);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;触摸按键1控制启停\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;触摸按键2控制正反转\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;触摸按键3控制加速\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;触摸按键4控制减速\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Timer2.Timer2_Start_IT();  <span class="comment">//启动定时器2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    CallBack</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-21 19:54:53</span></span><br><span class="line"><span class="comment">  * @brief   存放回调函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define-------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   </span></span><br><span class="line"><span class="comment">    * @param  </span></span><br><span class="line"><span class="comment">    * @retval </span></span><br><span class="line"><span class="comment">    * @brief  中断回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//控制启停</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">&#123;</span><br><span class="line">LED.LED_Flip(LED2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(DC_Motor.Status == Stop_State) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电机启动\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//启动电机</span></span><br><span class="line">DC_Motor.Start(); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电机停止\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//停止电机</span></span><br><span class="line">DC_Motor.Stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电机调整转动方向</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY2_Pin)</span><br><span class="line">&#123;</span><br><span class="line">LED.LED_Flip(LED2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电机改变转向\r\n&quot;</span>);</span><br><span class="line">DC_Motor.Direction_Adjust();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电机加速</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY3_Pin)</span><br><span class="line">&#123;</span><br><span class="line">LED.LED_Flip(LED2);</span><br><span class="line"></span><br><span class="line">DC_Motor.Speed_Adjust(Speed_up);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电机加速，当前速度为：%d\r\n&quot;</span>,DC_Motor.Speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电机减速</span></span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY4_Pin)</span><br><span class="line">&#123;</span><br><span class="line">LED.LED_Flip(LED2);</span><br><span class="line"></span><br><span class="line">DC_Motor.Speed_Adjust(Speed_down);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;电机减速，当前速度为：%d\r\n&quot;</span>,DC_Motor.Speed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   HAL_TIM_PeriodElapsedCallback</span></span><br><span class="line"><span class="comment">* @brief  定时器中断回调函数</span></span><br><span class="line"><span class="comment">* @param  *htim -&gt; 处理定时器的结构体指针</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance == htim2.Instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//程序支持运行，指示灯间隔1s闪烁</span></span><br><span class="line"><span class="keyword">if</span>(++Timer2.usMCU_Run_Timer &gt;= TIMER0_1S)</span><br><span class="line">&#123;</span><br><span class="line">Timer2.usMCU_Run_Timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED.LED_Flip(LED1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>电机和电机驱动照着江科大这样接就行，PWMA哪个端口接到你自己配置的PWM端口，比如我用的是PB0口，我就把PWMA接到PB0，接线很简单的，自己看着接就行，注意端口，其他AIN1 2随便接两个接口，这个没有要求，主要就是PWMA的口。</p><p>按键LED那些代码前面有，就算没有我也相信现在的你肯定可以轻松写出按键控制led的程序</p><p>程序运行起来还是有问题的，比如按键不灵敏，按下按键电机没反应，按键失灵然后会多按好几下，不知道的代码问题还是硬件电路问题，往前先学吧，后面在回头看。</p><h5 id="按键问题"><a href="#按键问题" class="headerlink" title="按键问题"></a>按键问题</h5><p>==<strong>注</strong>== ：按键不灵敏是因为代码没有消抖，硬件家园的是触摸按键，我的是机械按键，没有消抖导致按键不灵敏，因为有个key文件，导致我认为调用的是按键检测，其实根本没有用到按键检测函数，问题都是没有消抖导致的。软件消抖需要延时，但是延时不建议放在中断，容易程序卡死</p><p>建议在回调函数获取按键标志位，然后在主程序调用检测按键函数，但是按键按下要干嘛，则需要去key文件修改，有点麻烦</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   </span></span><br><span class="line"><span class="comment">    * @param  </span></span><br><span class="line"><span class="comment">    * @retval </span></span><br><span class="line"><span class="comment">    * @brief  中断回调函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> KEY1_Pin: KEY1.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY2_Pin: KEY2.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY3_Pin: KEY3.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY4_Pin: KEY4.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY5_Pin: KEY5.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;错误 - 外部中断回调函数中，触摸按键键值错误！\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Deteck();</span><br><span class="line">KEY2.KEY_Deteck();</span><br><span class="line">KEY3.KEY_Deteck();</span><br><span class="line">KEY4.KEY_Deteck();</span><br><span class="line">KEY5.KEY_Deteck();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="单极性步进电机"><a href="#单极性步进电机" class="headerlink" title="单极性步进电机"></a>单极性步进电机</h3><h4 id="程序功能-10"><a href="#程序功能-10" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mdEk4ROdRyjMLsRE5zrBo8ekM1RpsSSWayUWjeJVpB818480UMU1m6A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-16"><a href="#硬件电路-16" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0meps0oMZbK72tnrCkUGcaB5uRiag5o3ykmIFA8Pq7pyaKL6cnPGcXr9g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-10"><a href="#技术讲解-10" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>步进电机是将电脉冲信号转变为角位移或线位移的开环控制元件。在非超载的情况下，电机的转速、停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度，称为”步距角”，它的旋转是以固定的角度一步一步运行的。可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的;同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。</p><p><strong>单极性4相5线步进电机：</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mjQ9Xmm0EgN6MlUDqc4894GV7iaQ2t7EWgoQbKQgtIZzvyOJYibib83jMw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0miclQ0L8otWr9rJjQgxeh0ZUErzDACcWLiasKW5OXYDicGyRaTHl8hoWBQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mv45vRY6iaMwH0PG31WIsicCMzMjkGfvaE6AFr4O3rBlhSicuaRw9dzf2A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>驱动方式：</strong></p><p>1、单四拍  A - B - C -D - A - 循环往复</p><p>特点：步距角5.625/32， 电流最小，扭矩最小</p><p>2、双四拍 AB - BC - CD - DA - AB - 循环往复</p><p>特点：步距角5.625/32， 电流最大，扭矩最大</p><p>3、八拍 A - AB - B - BC - C - CD - D - DA - A - 循环往复</p><p>特点：步距角5.625/64， 电流居中，扭矩居中</p><h4 id="HAL库函数-4"><a href="#HAL库函数-4" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mznshF7voe2s8L2S2x5cjMfciciaibOCllEMibtLyHDtWuoQ2h4LHTQQCEg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mTSJGJT0aKgKI6ulBO2CFFCgVgXIUUht090ZyhM0DPewIQ3nA6a46pw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-10"><a href="#编程说明-10" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mJ0G9yx37ACicAaQt5J5xiaHmO6tPCxPtLvVrFO3c0U3AOXt4AAY7SmiaQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mkiaQrJGcrszdF0r2QeHfuib5IYMjPzwwO0fIaCn7bq5LRSMQbVSmm7YA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mNkasODtMA26uibYxFWa6iaqJkOD3iagoWg8Cia4oVZAhM6W9RctKTtNibEg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcmRDuIhV7ZCT8UCkyRPDKhR8ZzG4oa1DLD69QYqpLkn7RfHq1dWramw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、单极性步进电机结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mYSFm5HQ2Ygltn9CMMh4kXAp9yvaGumQ3abu5icPoMBoZfTR7USVllOA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、定时器7中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mHs2se0oqyHvSQ4oLiaaPH0gLjHUNxaeNpHcibY0mo9a7Bo4aW79Hz8Yw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>电机没反应，下课</p><h3 id="双极性步进电机"><a href="#双极性步进电机" class="headerlink" title="双极性步进电机"></a>双极性步进电机</h3><p>没有这个电机，看看视频了解了解就行</p><h4 id="程序功能-11"><a href="#程序功能-11" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7cDW7icPGd0T8jPskPcdqTY7rP6anRlxG6kSsGicFrJvictwdZNtBibNvlQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-17"><a href="#硬件电路-17" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7CoQe6icYAggULljC4SAV8d6M1ccsCKjdyPwXPsngXzjlE12Q3ms8GDQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-11"><a href="#技术讲解-11" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>步进电机是将电脉冲信号转变为角位移或线位移的开环控制元件。在非超载的情况下，电机的转速、停止的位置只取决于脉冲信号的频率和脉冲数，而不受负载变化的影响，当步进驱动器接收到一个脉冲信号，它就驱动步进电机按设定的方向转动一个固定的角度，称为”步距角”，它的旋转是以固定的角度一步一步运行的。可以通过控制脉冲个数来控制角位移量，从而达到准确定位的目的;同时可以通过控制脉冲频率来控制电机转动的速度和加速度，从而达到调速的目的。</p><p><strong>双极性2相4线步进电机：</strong></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7u0HXhIIVOQOhcO8cMkqBSrggG0Nqib9RkU9ibamU5209eDBqdNO8IrTw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP76acmJ9N8acjFHGjff8Ty4AibYyZaarz1QqtkiaS8sBYCP1NArt9t9ROg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>驱动方式：</strong></p><p>1、单四拍  A+ , B+ , A- , B-  循环往复</p><p>特点：步距角7.5°， 电流最小，扭矩最小</p><p>2、双四拍 A+B+，B+A-，A-B-，B-A+ 循环往复</p><p>特点：步距角7.5°， 电流最大，扭矩最大</p><p>3、八拍 A+，A+B+，B+ , B+A-，A- , A-B-，B-，B-A+循环往复</p><p>特点：步距角3.75°， 电流居中，扭矩居中</p><h4 id="HAL库函数-5"><a href="#HAL库函数-5" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mznshF7voe2s8L2S2x5cjMfciciaibOCllEMibtLyHDtWuoQ2h4LHTQQCEg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mTSJGJT0aKgKI6ulBO2CFFCgVgXIUUht090ZyhM0DPewIQ3nA6a46pw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-11"><a href="#编程说明-11" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7ynn58ys8rgTd5c6oSueyp8PpO3GTd6oxITdRB78b22ORZplI4nuI3w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZd5dvZnM1ueu0q8peBlcF0mkiaQrJGcrszdF0r2QeHfuib5IYMjPzwwO0fIaCn7bq5LRSMQbVSmm7YA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7njlRGDQhKibmPeQtVI5SLnkzbWR85q6b7V2iaybHOE2E1s3rQXGMQ6qg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeuF1icciaO3pV2uiaRSP2kmZcmRDuIhV7ZCT8UCkyRPDKhR8ZzG4oa1DLD69QYqpLkn7RfHq1dWramw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、双极性步进电机结构体封装</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7A6w8vQBskyL3pzvwt2hw4iaE960Wa9Jha5ibtWAC6YcE7e18icgFFaFIw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、定时器7中断回调函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfzgZzDkzj44xfibC9Z0lAP7KA9h054chDceQDw9bwbgO6lA9icZJFFsYp13ib1GJiaQdtqWU6IkxAeWA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="HMI智能串口屏"><a href="#HMI智能串口屏" class="headerlink" title="HMI智能串口屏"></a>HMI智能串口屏</h3><p>没屏幕，了解了解</p><h4 id="程序功能-12"><a href="#程序功能-12" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、HMI智能串口屏同步显示数码管计数；</p><p>2、HMI智能串口屏与主板同时控制步进电机。</p><p>图片：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHplfEQLyib4QnyQSb1q4GSfrt0iaWsuYyfshII2KK6QcVgUIbORDH4tCZA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-18"><a href="#硬件电路-18" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpeWCqSTlGV4HCpg347VYkYUBodtHsjhEKDfia6E6wXnCvCjmZzJPBTuw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpYRS8b2Ekc4TBonglt5IrbzpBd6jibTd0Kx8BYHuKFP5BMb2bJNKrjiaA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>双排针H11接线说明：</p><p>1、MicroUSB口连接到STM32，用于打印程序信息</p><p> 短路帽短接3与1,4与2</p><p>2、HMI智能串口屏连接到STM32</p><p> 短路帽短接3与5,4与6</p><p>3、MicroUSB口连接到HMI智能串口屏，用于更新串口屏程序与调试串口屏</p><p>杜邦线短接1与6，5与2</p><h4 id="技术讲解-12"><a href="#技术讲解-12" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>资料网址：<a href="http://wiki.tjc1688.com/doku.php">http://wiki.tjc1688.com/doku.php</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpB6lJvtfaedFIExvAFIbCPq3KHLcZjKmAiaCh1W9UjzddeC5wblt6kAg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>应用：</p><p>1、充电桩</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpQPKv8tdpJ2e13nUicGUIGrtqdib80tJGXgZu480kXqjicRL4YiapCwdkTw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、仪器仪表</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHptawhYln86DUjOemHByR4mhcJf2yibogBRFawjvBEK1CcK2HlxjUAE2g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>3、工业产品</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpcQC3b02VxicSKZefJgV4RrWOh4JTAXjXNnMfprn60BPu5TZKW7Vupgw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>技术讲解</p><p>资料网址：<a href="http://wiki.tjc1688.com/doku.php">http://wiki.tjc1688.com/doku.php</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpB6lJvtfaedFIExvAFIbCPq3KHLcZjKmAiaCh1W9UjzddeC5wblt6kAg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>应用：</p><p>1、充电桩</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpQPKv8tdpJ2e13nUicGUIGrtqdib80tJGXgZu480kXqjicRL4YiapCwdkTw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、仪器仪表</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHptawhYln86DUjOemHByR4mhcJf2yibogBRFawjvBEK1CcK2HlxjUAE2g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>3、工业产品</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpcQC3b02VxicSKZefJgV4RrWOh4JTAXjXNnMfprn60BPu5TZKW7Vupgw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-12"><a href="#编程说明-12" class="headerlink" title="编程说明"></a>编程说明</h4><p>0、智能串口屏GUI设计</p><p>视频详细讲解</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpYuBccqiakTtyTQqzEJibw7JlmLjOrzG9XAgxBRscRCicic4X1L2KjfAoNg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>1、STM32cubeMX初始化</p><p>主要配置串口1，DMA接收+空闲中断</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpyUSrHnPibKl2vdfNSfuv5yYtzQLicKx3aukAFSYh0xZLsN5VFWXebyibg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpFQCwJ1f7IQYIMRibA29dEHzsMtgYPLG6DmjTZRLHrrPdjaLDKx8uByg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpIBYufxelWiaAib7ezI7dJY21vjn32XqtxPG4zHazAEZ9OgV6wTSoedVA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpfcp7Xh576FmvsQUxr6aeueBXxgIyI7LXv7lmNhmzfmEypnee2s1Clw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHpqFb17YbU4lbmPM0hf2lHjs2WpTQ4047TCCgDutoFibalC28kjD20tow/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、HMI串口屏结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHp8DunbwdiaP86qIO9KbcIsUXvu3BAPPhd67k5VhAxFkuxrCZagBJOCkA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、串口1空闲中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHphU53mIsLfiaURMg7e3n3QxIyYQl8WDxhPcc7510Vs17K8j42QmszIxA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、接口协议解析函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeQLFMibmrbEiauR4GfCPAvHppziaBPxfXG1vmc2S2eWa7BqcBIWhNyg1uqY1ib5Lrp8vsg0fCl7ibuAkA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="RS-485通信-modbus协议"><a href="#RS-485通信-modbus协议" class="headerlink" title="RS-485通信 modbus协议"></a>RS-485通信 modbus协议</h3><h4 id="程序功能-13"><a href="#程序功能-13" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、主板与数码管均可以显示SHT30的温湿度；</p><p>2、主板与数码管均可以控制继电器与蜂鸣器；</p><h4 id="硬件电路-19"><a href="#硬件电路-19" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfDBOlre5aI2HJLzsvHK2CxafcVeGGl1N1Iia2Zdx6gh4426ZGg69EDGeN2KcbcwYgqT6mnXMKiauCw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-13"><a href="#技术讲解-13" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>Modbus是一种串行通信协议，是Modicon公司(现在的施耐德电气 Schneider Electric)于1979年为使用可编程逻辑控制器(PLC)通信而发表。Modbus已经成为工业领域通信协议的业界标准(De facto)，并且现在是工业电子设备之间常用的连接方式。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4ggUUgggHzb8fibdGcicAI1mxugXIqN5BgVUpolDtu76KymSrPxqW790lQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gDCsFZHI97iaOsxibyKkuohYdiaiacwbiajfJIOV8RXvPicnLbttAt8nPkdKQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4ge08gEkgaYSo3ldaWtaDeflSqYxeQbefJibCYdjicUAX1iaic2kFC2vTJWA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-6"><a href="#HAL库函数-6" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gjCvsiatqQkFeewaAJGwa6aduLSyWjrkRoIyBh78zQeTWO8eniauV2VOw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>发送：采用DMA+TC中断</p><p>接收：采用DMA+空闲中断</p><h4 id="编程说明-13"><a href="#编程说明-13" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p>配置串口3：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gxbL1UAOPk1XNiawtIMZA0Cl2aHyGDxniaziaZCvicic0mAicmibONzAqFIMOw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>配置DMA：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gaK39YPAn0u2W1gJ6g6aOopI47qg5KrXwwBB91FwicbRkibdfVMSabbJQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>配置中断：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4goeLHMJDodeU42K1K8cLJAA3icH65mFbT9p6aROkdbHZfy0ibRqL6FwpA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gbllgAqIWeMaiaHGmtBZ6NMsy6mq7BBPicsMBsQibzTNFrpC8BWbxxCYtw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gW9AKYxvlyCZDZaCzQyYMzqIlVUWx0dSLVn4wXAmce5Jm9Az21z18IQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、串口结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4g2kbazou8yibnTqSNmMqrCD7avfMjPvZLl4X3TA3bPnW84s1RXfqv3Bg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、串口3发送完成与空闲中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gbaQhKugO0ODaKTRA0DSljIZIEWqKgN3zm8JPtatMtV6vsGicu82IVkw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gN1efmicgwm8l0GM9SibqZ6sR7xWvKWfbVooFAbz99jIE2qO3AjXF6ItQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、modbus结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gBsRNOOrfVdB4Fkjz1iaafh7RiaTymMw5ZvzQ9veqPlQmKEnXgyuKIMaQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="WIFI无线通信"><a href="#WIFI无线通信" class="headerlink" title="WIFI无线通信"></a>WIFI无线通信</h3><h4 id="程序功能-14"><a href="#程序功能-14" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、智能配网；</p><p>2、上电自动连接WIFI与TCP服务器；</p><p>3、间隔1s推送SHT30的温湿度至TCP服务器；</p><p>4、接收TCP服务器指令，控制继电器与蜂鸣器。</p><p>图片：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3hNmfJlFQoibPK7qpmRl4xFrmicuq1VP4onzVtndCDe9kibiaxGIuibherpQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>串口信息</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3UIiaYNDvomRSSsSpaKs6wA0wlVpVDFP3tIWUjxF61lJxaFV4ebeMQ3w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>电脑端模拟TCP</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3x7KNRDdiaNIzYoKrInIHicKBQLzdQD3302d1PEfYib3tvESjaLtsfVv1w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>手机端模拟TCP</p><h4 id="硬件电路-20"><a href="#硬件电路-20" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdNWak8jLavmCDsHQNxZE4I0yCPKHuyHibebiblsgIb00ypLNKMOAQwS1AFI5FrMhPFXmZoZZAyRf8Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdNWak8jLavmCDsHQNxZE4IATA3csougZWP6Px9pUegadLXlnQtlKjf5ly486F5oPK4y8ZwokiclsQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-14"><a href="#技术讲解-14" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>视频讲解WIFI模块资料以及如何熟悉AT指令</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3VoQIP7XqKsxUkdWF8ia0L1icTUqsQd7Tia9x02JMvBxicdKgPKYqE5zk1g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-7"><a href="#HAL库函数-7" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p> 主要使用串口的DMA收发，以及空闲中断。 <img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gjCvsiatqQkFeewaAJGwa6aduLSyWjrkRoIyBh78zQeTWO8eniauV2VOw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-14"><a href="#编程说明-14" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA38L38Fh2IgdgRzyzzErxIpoicyDoAYCowAt70HicPh14qNypES88SITOA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3chsPfdfOXXcVeibmVt7wvVxAECAcdeGKLxtk54Pibia1giaylOyicJSTBqg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA36kOcXCdY6siamhLOXIpPianmbgnMwAXcrtIBIQZwBNmt4Matl4Pz0MdQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3rg66HyItERvdS1MZph7gvmQ33YWO6Hs8wxMkZWicwQsO5YwVV784qpg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、串口结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3tTm5uqu8iaTuLUPR2T8GHK2rHJZFxGzPSIKuMhkDCe7uudBbFzPZkfg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、ESP8266结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3AX9IXR7mLxBJtz82JXb3djt6G2PnibLZrlZqMzBtZrTvXX5uxQ9SByw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、WIFI模块配网函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA36os0soKAwgjLM2UMjqZnvib0TeAwwUhINy57O5JGYwjj4NMStnrrbQw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-11"><a href="#6-1的程序-11" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p><strong>代码运行有问题，不知道是什么问题。</strong> 后面在弄吧</p><p>测试AT指令<br>关闭回显功能<br>设置工作模式为STA<br>连接AP<br>查询本地IP地址<br>建立TCP连接<br>设置透传模式<br>开始发送数据<br>退出发送数据</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231006122257308.png" alt="image-20231006122257308"></p><p>需要连接同一个路由才能成功连接TCP</p><h5 id="工程配置-9"><a href="#工程配置-9" class="headerlink" title="工程配置"></a>工程配置</h5><h5 id="硬件电路-21"><a href="#硬件电路-21" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>TX连RX,RX连TX,GND接GND，3.3V接3.3V，我接串口的3.3没反应，接stlink的3.3就行</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230927202707862.png" alt="image-20230927202707862"></p><h3 id="GPRS无线通信"><a href="#GPRS无线通信" class="headerlink" title="GPRS无线通信"></a>GPRS无线通信</h3><p>没有模块，看看就好</p><h4 id="程序功能-15"><a href="#程序功能-15" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电通过GPRS模块自动连接TCP服务器；</p><p>2、间隔1s推送SHT30的温湿度至TCP服务器；</p><p>3、接收TCP服务器指令，控制继电器与蜂鸣器。</p><p>图片：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJOR8pUYsTia82owdyibOiaUoNCneNDPmVvHdIEJpELcxuuR2pyfghWKlSw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>串口信息</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3UIiaYNDvomRSSsSpaKs6wA0wlVpVDFP3tIWUjxF61lJxaFV4ebeMQ3w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>电脑端模拟TCP</p><h4 id="硬件电路-22"><a href="#硬件电路-22" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeKFmPMGPFJHAQRjqVJrUHZ8vibhxxicykqXwRycfdhp4JaKUosWbmGvNSib2zTrTSFKgUhFGhEnCMTQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdNWak8jLavmCDsHQNxZE4IATA3csougZWP6Px9pUegadLXlnQtlKjf5ly486F5oPK4y8ZwokiclsQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-15"><a href="#技术讲解-15" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJ40OlnOmNRgZjXDfGOowcdF9ua7Ih5Kn8kB9icID4poRo5Q5EKezibjtw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>视频讲解GPRS模块资料以及如何熟悉AT指令</p><h4 id="HAL库函数-8"><a href="#HAL库函数-8" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p> 主要使用串口的DMA收发，以及空闲中断。 <img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfIdk5w2kwQRUeibMWDJrl4gjCvsiatqQkFeewaAJGwa6aduLSyWjrkRoIyBh78zQeTWO8eniauV2VOw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-15"><a href="#编程说明-15" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA38L38Fh2IgdgRzyzzErxIpoicyDoAYCowAt70HicPh14qNypES88SITOA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3chsPfdfOXXcVeibmVt7wvVxAECAcdeGKLxtk54Pibia1giaylOyicJSTBqg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJWx5Izo5xtNn00BIiaqzlIQpFVqYbGejic4icPtKxH04SwicvQ95yraKCHg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJzb6vHHLwwgicfNibtlwmWcp4aXkU9boUrh5wkdy2PlI4IlLmpTRz6O6Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、串口结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdmHGd1tdM0ibVN0ccIKIkA3tTm5uqu8iaTuLUPR2T8GHK2rHJZFxGzPSIKuMhkDCe7uudBbFzPZkfg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、SIM800C结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJib7q8sXTibRXeUXkGols4Hr51orWQerjuMYcQDMCm4PDyt0SIp2poy5A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、SIM800C模块AT指令</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZeY6UIFl1N6e8AofDTHmuJJPD8uzwh4WwsI7DnCV02iaB6oWhntvB2GpIMDwEZxFAfSdhsdR2epp0Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="RTC时钟"><a href="#RTC时钟" class="headerlink" title="RTC时钟"></a>RTC时钟</h3><h4 id="程序功能-16"><a href="#程序功能-16" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、通过串口设置RTC的时间与日期；</p><p>2、通过串口打印RTC的时间与日期；</p><p>3、数码管显示RTC时间；</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCa8W2QGibiazOvTzhUsUaFgd7VKemv8ugY6CghIK1Ko7Ddx5Qf4RSURkQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-23"><a href="#硬件电路-23" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdAL0IRvoht8PqlKHdDdiaCvomwniaGyvlKqLBexQ79wFpzOa4XiajfJGQOZeKOSummkyGQrHnNhpkJQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZdAL0IRvoht8PqlKHdDdiaCvibGwOl7qMQEcovnEpk4vBmVAfnicjicicH5T9OlacIBKF6wxXTkHGuM7vA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-16"><a href="#技术讲解-16" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCHO1fiafYx3SoJxm0GcEzpchY5FtITD8U6tASgBJ3QoItm7WHbSvplQA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>分析框图，RTC的后备区域没有日期寄存器，断电后恢复后，没法直接读取日期；如果需要读取断电恢复后日期更新值，方法有二：</p><p>1、使用高级些的MCU，比如STM32F4，RTC自带日期寄存器。</p><p>缺点：MCU成本贵</p><p>2、利用32位可编程计数器进行计算。具体方法是：假定计数器为0时，为一个起始日期，比如2000年1月1日； 设定日期后，减去起始日期，换算成秒钟初始化给计数器； 断电后，计数器值不重新装载，与设定日期对比，换算出当前日期。</p><p>缺点：</p><p>①、不能使用HAL库编程；</p><p>②、需要CPU大量计算，效率低；</p><p>③、RTC溢出与闹钟功能不可用。</p><h4 id="HAL库函数-9"><a href="#HAL库函数-9" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCufA2jyvyiawD4AgyXaKiba6FEPnC3FMozy5GvV8cLRmRgjusJ6ZMrib4A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_rtc><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlChXrnibEmEefXCnpWoPzfrwNxrjwVibiaKPuTXg1V2F0vceTYA4eKUe4kw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_rtc_ex><h4 id="编程说明-16"><a href="#编程说明-16" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlC2m9jDBLfDmQlNbdAqQUQgDh4vSc8KNib5OnZc1QkrPxWy0lWnIYR53A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCZgVeX5d9cEiaHtzTBI6PtnjtoR9ekUrzZMZJxZ0jlqfC7iayI271bvDA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCbgsl0iaeAP0IhwKmLN6YuiaXg5JRYE3hmyLtzyyUKIIeMe516Ts6AyibQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCibwkRR1vTtQeXe9SXfQxUmMG1GhOZjf1bDmkxdAK4HCYQMsb87hXyfA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCibuZhHftcK874P2TngPOUQ2MItbKoPNGCswMworjHxIDNmWdicphsic4Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、MyRTC结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCWS3n7mUsANDvwp2gyU2lpO9hibKxNXdbhthvLiaa5kjJROFNMEOCZibhQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、RTC设置日历</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCWl3GCqX1jozdWG7mVONq28XR1RSgeUFl2Bf1rsPFDCiatJywD3O2ahA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、RTC显示日历</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc3po3xoLCQvCmy38ibFqVlCNAV6KfbPb3g3XwicGrRDoR8qicenMdmBszo6fXiauVoMB02gUQic0621Gg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-12"><a href="#6-1的程序-12" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-10"><a href="#工程配置-10" class="headerlink" title="工程配置"></a>工程配置</h5><p>选择这个晶振，没有LSE晶振，用LSE会卡死在程序里，用LSI就行，就是时间不准，不过也没什么关系，勾选串口的接收发送</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231007205021385.png" alt="image-20231007205021385"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231007210142644.png" alt="image-20231007210142644"></p><h5 id="硬件电路-24"><a href="#硬件电路-24" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>不用接OLED，在接个LED灯就行，</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231007210013438.png" alt="image-20231007210013438"></p><h5 id="软件代码-8"><a href="#软件代码-8" class="headerlink" title="软件代码"></a>软件代码</h5><h6 id="RTC-1"><a href="#RTC-1" class="headerlink" title="RTC"></a>RTC</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYRTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYRTC_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">uint8_t</span> RTC_SetValue_Flag;   <span class="comment">//RTC设置标志位</span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef *pRTC_TimeStruct;  <span class="comment">//RTC时间结构体指针</span></span><br><span class="line">RTC_DateTypeDef *pRTC_DateStruct;  <span class="comment">//RTC日期结构体指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*Calendar_Set)(<span class="type">void</span>);  <span class="comment">//设置日历</span></span><br><span class="line"><span class="type">void</span> (*Calendar_Get)(<span class="type">void</span>);  <span class="comment">//获取日历</span></span><br><span class="line"><span class="type">void</span> (*Calendar_Show)(<span class="type">void</span>); <span class="comment">//获取日历</span></span><br><span class="line">&#125; MyRTC_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span>  MyRTC_t  MyRTC;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">RTC_TimeTypeDef RTC_TimeStruct_CurrentValue; <span class="comment">//RTC当前时间</span></span><br><span class="line">RTC_DateTypeDef RTC_DateStruct_CurrentValue; <span class="comment">//RTC当前日期</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> *Week_Str[<span class="number">7</span>] = </span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;日&quot;</span>,</span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;一&quot;</span>, </span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;二&quot;</span>, </span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;三&quot;</span>, </span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;四&quot;</span>, </span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;五&quot;</span>, </span><br><span class="line">(<span class="type">uint8_t</span>*)<span class="string">&quot;六&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Set</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//设置日历</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Get</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//获取日历</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Show</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">//显示日历</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">Input_RTC_SetValue</span><span class="params">(<span class="type">uint8_t</span>)</span>; <span class="comment">//输入RTC设置值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>    <span class="title function_">RTC_Time_Set</span><span class="params">(<span class="type">void</span>)</span>;          <span class="comment">//RTC时间设置</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>    <span class="title function_">RTC_Date_Set</span><span class="params">(<span class="type">void</span>)</span>;          <span class="comment">//RTC日期设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">MyRTC_t MyRTC = </span><br><span class="line">&#123;</span><br><span class="line">TRUE,</span><br><span class="line"></span><br><span class="line">&amp;RTC_TimeStruct_CurrentValue,</span><br><span class="line">&amp;RTC_DateStruct_CurrentValue,</span><br><span class="line"></span><br><span class="line">Calendar_Set,</span><br><span class="line">Calendar_Get,</span><br><span class="line">Calendar_Show</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Calendar_Set</span></span><br><span class="line"><span class="comment">* @brief  设置日历</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//上电复位时，读取RTC备份寄存器1的数据，如果为0x1688，则不需要通过串口重新设置日期与时间</span></span><br><span class="line"><span class="keyword">if</span>(HAL_RTCEx_BKUPRead(&amp;hrtc,RTC_BKP_DR1) != <span class="number">0x1688</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;^_^^_^开始设置RTC的日期与时间^_^^_^\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">RTC_Date_Set(); <span class="comment">//设置日期</span></span><br><span class="line">RTC_Time_Set(); <span class="comment">//设置时间</span></span><br><span class="line"></span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR1,<span class="number">0x1688</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;^_^^_^RTC的日期与时间已设置！^_^^_^\r\n\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;重新设置的方法如下:\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;方法一：长按触摸按键2s以上；\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;方法二：系统断电，同时拔掉RTC电池。\r\n\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Calendar_Get</span></span><br><span class="line"><span class="comment">* @brief  显示日历</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">HAL_RTC_GetTime(&amp;hrtc,MyRTC.pRTC_TimeStruct,RTC_FORMAT_BIN);</span><br><span class="line"><span class="comment">//获取当前日期</span></span><br><span class="line">HAL_RTC_GetDate(&amp;hrtc,MyRTC.pRTC_DateStruct,RTC_FORMAT_BIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Calendar_Show</span></span><br><span class="line"><span class="comment">* @brief  显示日历</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Calendar_Show</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//串口打印日期</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;当前时间为: %02u年%02d月%02d日(星期%s)  &quot;</span>, <span class="number">2000</span>+MyRTC.pRTC_DateStruct-&gt;Year,MyRTC.pRTC_DateStruct-&gt;Month,MyRTC.pRTC_DateStruct-&gt;Date,Week_Str[MyRTC.pRTC_DateStruct-&gt;WeekDay]);</span><br><span class="line"><span class="comment">//串口打印时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02u:%02u:%02u\r\n&quot;</span>,MyRTC.pRTC_TimeStruct-&gt;Hours,MyRTC.pRTC_TimeStruct-&gt;Minutes,MyRTC.pRTC_TimeStruct-&gt;Seconds);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Input_RTC_SetValue</span></span><br><span class="line"><span class="comment">* @brief  输入RTC设置值</span></span><br><span class="line"><span class="comment">* @param  MAX_Value -&gt; 输入最大值</span></span><br><span class="line"><span class="comment">* @retval SetValue  -&gt; 返回输入字符对应的数值     </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">Input_RTC_SetValue</span><span class="params">(<span class="type">uint8_t</span> MAX_Value)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> SetValue = <span class="number">0</span>;  <span class="comment">//返回值</span></span><br><span class="line"><span class="type">uint8_t</span> Value_Arr[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> Index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以等待方式从串口接收2个有效字符</span></span><br><span class="line"><span class="keyword">while</span>(Index &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//等待接收串口数据</span></span><br><span class="line">Value_Arr[Index++] = getchar();</span><br><span class="line"><span class="comment">//校验字符有效性</span></span><br><span class="line"><span class="keyword">if</span>((Value_Arr[Index <span class="number">-1</span>] &lt; <span class="string">&#x27;0&#x27;</span>) || (Value_Arr[Index <span class="number">-1</span>] &gt; <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入 0 到 9 之间的数字 --&gt;:\n&quot;</span>);</span><br><span class="line">Index--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到的2个字符转化为数值</span></span><br><span class="line">SetValue = (Value_Arr[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (Value_Arr[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验数值有效行</span></span><br><span class="line"><span class="keyword">if</span>(SetValue &gt; MAX_Value)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入 0 到 %d 之间的数字\n&quot;</span>, MAX_Value);</span><br><span class="line">SetValue = <span class="number">0xFF</span>; <span class="comment">//SetValue设置为无效数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数据</span></span><br><span class="line"><span class="keyword">return</span> SetValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   RTC_Date_Set</span></span><br><span class="line"><span class="comment">* @brief  RTC日期设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RTC_Date_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  RTC_DateTypeDef RTC_DateStruct_SetValue;</span><br><span class="line"><span class="type">uint8_t</span> SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=========================日期设置==================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入年份(00-99): 20\n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">99</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;年份被设置为:  20%02u\n&quot;</span>, SetValue);</span><br><span class="line">RTC_DateStruct_SetValue.Year = SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入月份(01-12):  \n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SetValue == <span class="number">0x00</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;月份不能设置为0，请重新输入月份：\r\n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;月份被设置为:  %02u\n&quot;</span>, SetValue);</span><br><span class="line">RTC_DateStruct_SetValue.Month = SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入日期(01-31):  \n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">31</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SetValue == <span class="number">0x00</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;日期不能设置为0，请重新输入日期：\r\n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;日期被设置为:  %02u\r\n&quot;</span>, SetValue);</span><br><span class="line">RTC_DateStruct_SetValue.Date = SetValue;</span><br><span class="line"><span class="comment">//设置日期</span></span><br><span class="line">HAL_RTC_SetDate(&amp;hrtc,&amp;RTC_DateStruct_SetValue,RTC_FORMAT_BIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   RTC_Time_Set</span></span><br><span class="line"><span class="comment">* @brief  RTC时间设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">RTC_Time_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">RTC_TimeTypeDef RTC_TimeStruct_SetValue;</span><br><span class="line"><span class="type">uint8_t</span> SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=========================时间设置==================\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入时钟(00-23):  \n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;时钟被设置为:  %02u\n&quot;</span>, SetValue);</span><br><span class="line">RTC_TimeStruct_SetValue.Hours = SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入分钟(00-59):  \n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">59</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;分钟被设置为:  %02u\n&quot;</span>, SetValue);</span><br><span class="line">RTC_TimeStruct_SetValue.Minutes = SetValue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入秒钟(00-59):  \n&quot;</span>);</span><br><span class="line">SetValue = <span class="number">0xFF</span>;</span><br><span class="line"><span class="keyword">while</span> (SetValue == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">SetValue = Input_RTC_SetValue(<span class="number">59</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;秒钟被设置为:  %02u\n&quot;</span>, SetValue);</span><br><span class="line">RTC_TimeStruct_SetValue.Seconds = SetValue;</span><br><span class="line"><span class="comment">//设置时间</span></span><br><span class="line">HAL_RTC_SetTime(&amp;hrtc,&amp;RTC_TimeStruct_SetValue,RTC_FORMAT_BIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="PUBLIC"><a href="#PUBLIC" class="headerlink" title="PUBLIC"></a>PUBLIC</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __PUBLIC_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PUBLIC_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public define-------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SoftWare_Version (float)1.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>huart_debughuart1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  BIT0 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">0</span>),  </span><br><span class="line">BIT1 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">1</span>),  </span><br><span class="line">BIT2 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">2</span>),  </span><br><span class="line">BIT3 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">3</span>),  </span><br><span class="line">BIT4 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">4</span>),</span><br><span class="line">BIT5 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">5</span>),</span><br><span class="line">BIT6 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">6</span>),</span><br><span class="line">BIT7 = (<span class="type">uint8_t</span>)(<span class="number">0x01</span> &lt;&lt; <span class="number">7</span>),</span><br><span class="line">&#125;BIT_t;</span><br><span class="line"><span class="comment">//定义枚举类型 -&gt; TRUE/FALSE位</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FALSE = <span class="number">0U</span>, </span><br><span class="line">  TRUE = !FALSE</span><br><span class="line">&#125; FlagStatus_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FAILED = <span class="number">0U</span>, </span><br><span class="line">  PASSED = !FAILED</span><br><span class="line">&#125; TestStatus_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******预编译宏定义*******/</span></span><br><span class="line"><span class="comment">//#define Monitor_Run_Code   //代码运行监控器 </span></span><br><span class="line"><span class="comment">//#define Hardware_TEST      //硬件测试</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    Public</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-21 19:56:59</span></span><br><span class="line"><span class="comment">  * @brief   存放公共函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private define-------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Memory_Clr</span><span class="params">(<span class="type">uint8_t</span>*,<span class="type">uint16_t</span>)</span>;   <span class="comment">//内存清除函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   fputc</span></span><br><span class="line"><span class="comment">* @brief  fputc映射物理串口</span></span><br><span class="line"><span class="comment">* @param  ch -&gt; 待发送字符</span></span><br><span class="line"><span class="comment">* @retval ch -&gt; 已发送字符      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE* f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//通过查询的方式循环发送</span></span><br><span class="line">HAL_UART_Transmit(&amp;huart_debug, (<span class="type">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0x000A</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   fgetc</span></span><br><span class="line"><span class="comment">* @brief  fgetc映射物理串口</span></span><br><span class="line"><span class="comment">* @param  none</span></span><br><span class="line"><span class="comment">* @retval ch -&gt; 已接收字符      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE * f)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint8_t</span> ch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过查询的方式等待接收</span></span><br><span class="line">  HAL_UART_Receive(&amp;huart_debug,&amp;ch, <span class="number">1</span>, <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="回调函数与运行函数"><a href="#回调函数与运行函数" class="headerlink" title="回调函数与运行函数"></a>回调函数与运行函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  EXTI line detection callbacks.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: Specifies the pins connected EXTI line</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Flag = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   HAL_TIM_PeriodElapsedCallback</span></span><br><span class="line"><span class="comment">* @brief  定时器中断回调函数</span></span><br><span class="line"><span class="comment">* @param  *htim -&gt; 处理定时器的结构体指针</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(htim-&gt;Instance == htim2.Instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//程序支持运行，指示灯间隔1s闪烁</span></span><br><span class="line"><span class="keyword">if</span>(++Timer2.usMCU_Run_Timer &gt;= TIMER2_1S)</span><br><span class="line">&#123;</span><br><span class="line">Timer2.usMCU_Run_Timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">LED.LED_Flip(LED1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Deteck();</span><br><span class="line">    <span class="keyword">if</span>(MyRTC.RTC_SetValue_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">MyRTC.RTC_SetValue_Flag = FALSE;</span><br><span class="line">MyRTC.Calendar_Set(); <span class="comment">//设置日历</span></span><br><span class="line">&#125;</span><br><span class="line">MyRTC.Calendar_Get();  <span class="comment">//获取日历</span></span><br><span class="line">MyRTC.Calendar_Show(); <span class="comment">//显示日历</span></span><br><span class="line"><span class="comment">//延时1s</span></span><br><span class="line">HAL_Delay(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="按键-1"><a href="#按键-1" class="headerlink" title="按键"></a>按键</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> <span class="keyword">volatile</span> KEY_Flag;  <span class="comment">//按键标志位</span></span><br><span class="line">    <span class="type">uint8_t</span> Click;  <span class="comment">//单击</span></span><br><span class="line">    <span class="type">uint8_t</span> Press;  <span class="comment">//长按</span></span><br><span class="line">    <span class="type">void</span> (*KEY_Deteck)(<span class="type">void</span>);  <span class="comment">//按键检测</span></span><br><span class="line">&#125; KEY_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键1检测</span></span><br><span class="line">KEY_t KEY1 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY1_Detect&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY1_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键1检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (KEY1.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        KEY1.Click = FALSE;</span><br><span class="line">        KEY1.Press = TRUE;</span><br><span class="line">MyRTC.RTC_SetValue_Flag = TRUE;</span><br><span class="line"><span class="comment">//长按2s重新设置RTC</span></span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按键长按检测</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">200</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延时1秒</span></span><br><span class="line">            HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果1s内，按键状态出现高电平，此时按键为单击，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin( KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_SET)</span><br><span class="line">            &#123;</span><br><span class="line">                KEY1.Click = TRUE;</span><br><span class="line">                KEY1.Press = FALSE;</span><br><span class="line">MyRTC.RTC_SetValue_Flag = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KEY1.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;检测到按键1点击\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            LED.LED_Flip(LED1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY1.Press == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">MyRTC.RTC_SetValue_Flag = TRUE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n触摸按键1长按了2s，重新设置RTC的日期与时间。\r\n&quot;</span>);</span><br><span class="line">HAL_RTCEx_BKUPWrite(&amp;hrtc,RTC_BKP_DR1,<span class="number">0x00</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除按键状态</span></span><br><span class="line">KEY1.KEY_Flag = FALSE;</span><br><span class="line">KEY1.Click = FALSE;</span><br><span class="line">KEY1.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>时钟选择LSI，不要选择LSE，选择LSE卡死在程序，按键检测函数不要放中断，会导致程序卡死，串口勾选接收与发送，多了一个接收定向函数。感谢旺哥帮我看了半个小时程序，不然又找不出问题。</p><h3 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h3><h4 id="程序功能-17"><a href="#程序功能-17" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGDok4ictwCCNaC3ZSV5WyFEukegztiasJGN77CXFQZJIcibj223FDtS3Zg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-25"><a href="#硬件电路-25" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>无</p><h4 id="技术讲解-17"><a href="#技术讲解-17" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGcLvV2of0kGmuzVIXWOPggvYWcnZOvPT2ic9QkBqmzwoQR5C3QebQURg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGvdia6KqNsWbZRibjVbvJAd1zaxxvBglcdq2mLYqCfQhtG33na8D4KWRw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-10"><a href="#HAL库函数-10" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGMiaEtsrxtWtib2WfFjEx1XrWRAQbtldYk4f7iaicqcwk8O1r1XOqGcxHwg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_iwdg.h><h4 id="编程说明-17"><a href="#编程说明-17" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGsEFaZa0AqiaJQLbsIX03icuX03LmSTldQgS9WnprOQmJJsvYVN08FjRg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>独立看门狗超时时间计算：</p><p>LSI = 40kHz</p><p>超出时间 = (1/(40/32)) * 2500ms = 2s</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGtwqicy6sHvXVqVAIiaoI8vP9kYdicgyp7vxTBg0SxKYxCqr7eibwDblGMQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGDc02NP2cicuxSkywgQ85QYIdLdxunHAxRoWiadFjWPibRS7gTuyTcjk8Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、MyIWDG结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGurkL5795MshsnASad2gK2DXZJMnnlgCicibkskib6GBY9PfQibMcax5vsw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、触摸按键1回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGGB2bwgRw07IXVeyibP5Z77MJOWYMg81s9j6yQc6dbdtE3SYPyia13KaA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-13"><a href="#6-1的程序-13" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-11"><a href="#工程配置-11" class="headerlink" title="工程配置"></a>工程配置</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231007222325435.png" alt="image-20231007222325435"></p><h5 id="硬件电路-26"><a href="#硬件电路-26" class="headerlink" title="硬件电路"></a>硬件电路</h5><h5 id="软件代码-9"><a href="#软件代码-9" class="headerlink" title="软件代码"></a>软件代码</h5><p>按键代码看之前的就好了现在的按键代码都是这样弄，因为按键要消抖，延时不能放中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYIWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYIWDG_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> FeedDog_Flag;  <span class="comment">//喂狗标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>(*FeedDog)(<span class="type">void</span>);  <span class="comment">//喂狗</span></span><br><span class="line">&#125; MyIWDG_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> MyIWDG_t MyIWDG;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FeedDog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">MyIWDG_t MyIWDG =</span><br><span class="line">&#123;</span><br><span class="line">    TRUE,</span><br><span class="line"></span><br><span class="line">    FeedDog</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   FeedDog</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  喂狗</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FeedDog</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_IWDG_Refresh(&amp;hiwdg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  EXTI line detection callbacks.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: Specifies the pins connected EXTI line</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_Pin == KEY1_Pin)</span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Flag = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(KEY1.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;检测到按键1点击\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//清除喂狗标志位</span></span><br><span class="line">    MyIWDG.FeedDog_Flag = FALSE;</span><br><span class="line">    LED.LED_ON(LED2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n停止喂狗，系统复位！\r\n\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">KEY1.KEY_Deteck();</span><br><span class="line">    <span class="keyword">if</span>(MyIWDG.FeedDog_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;喂狗，程序正常运行\r\n&quot;</span>);</span><br><span class="line">MyIWDG.FeedDog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HAL_Delay(<span class="number">1500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h3><h4 id="程序功能-18"><a href="#程序功能-18" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMAj73IJU52YROKEYdkCA9icV742K3cyiaEoUZuS9UheASE4QGYpEm8dTw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-18"><a href="#技术讲解-18" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGo4TrAPv6FObjLRaVwmhRq1iabqMbxbUBOq0kBAIgwmMV0kjECjus7Xg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcia8CJzUMXylnZic6bHia12kGhWrjY6GYeY94hbg2j5KMRbTmCGusRdFT5uVOlEYFFVOTz79VE9w23w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-11"><a href="#HAL库函数-11" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMy1iaZTMsLBxibo8a6VLiceHP0QtVia27eicUHwjmkZ3K6GLDwDmd3ZxsKMw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_wwdg.h><h4 id="编程说明-18"><a href="#编程说明-18" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMuKsrr4Glsya9TLBPo6LiciaJUVrda62HT0HrOeicRFbFz4YJxnvCW85iaQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMATOvHm6uRT9WcNYO13QahiafAic055nwNT0rdp3rNeeSG3ZH9oDk0nHw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>窗口看门狗超时时间计算：</p><p>PCLK1 = 36MHz</p><p>超出时间 = (1/36000000) <em> 4096 </em> 8 * (63+1)us = 58.25ms</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMNTnNgyyFFiaSkibgJuDMZ0p61UZHqAhkFvc7K26TuqicicCEIzT9jmmMbQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMibnXlxicKKmibfsDfEib6g2cvyEDaBc5lWJ7G4iaGoc8oPpzhwpBmFa7T9Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、MyWWDG结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMLdnpCictn9rjSTWKjIpauriczWS0RlUnp1icvreP1iaYsiacSQEcIqPmEmQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、窗口看门狗提前唤醒中断回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZe0W7A7X7SHCbA06q8SgmaMlsLNYqYicGYE7UTTqCvFEzmjN4iapGhJx0RRxgZB8kAwiaFNibEyUTyvRA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-14"><a href="#6-1的程序-14" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-12"><a href="#工程配置-12" class="headerlink" title="工程配置"></a>工程配置</h5><p>配置就是这样配，需要注意的是把LSE时钟那关了，不然看门狗的喂狗时间会不对，隔几秒复位一次，因为我的工程做过RTC所以是打开的，然后找了很久的bug才发现这个时钟。记得使能看门狗中断</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008115149487.png" alt="image-20231008115149487"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008115214286.png" alt="image-20231008115214286"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008115224344.png" alt="image-20231008115224344"></p><h5 id="软件代码-10"><a href="#软件代码-10" class="headerlink" title="软件代码"></a>软件代码</h5><p>代码非常简单，跟上一个独立看门狗差不多，就多了个中断，因为是使用提前唤醒中断回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MYWWDG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MYWWDG_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> FeedDog_Flag;  <span class="comment">//喂狗标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>(*FeedDog)(<span class="type">void</span>);  <span class="comment">//喂狗</span></span><br><span class="line">&#125; MyWWDG_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> MyWWDG_t MyWWDG;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FeedDog</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">MyWWDG_t MyWWDG = </span><br><span class="line">&#123;</span><br><span class="line">  TRUE,</span><br><span class="line"></span><br><span class="line">  FeedDog</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   FeedDog</span></span><br><span class="line"><span class="comment">    * @param  None</span></span><br><span class="line"><span class="comment">    * @retval None</span></span><br><span class="line"><span class="comment">    * @brief  喂狗</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">FeedDog</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_WWDG_Refresh(&amp;hwwdg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序测试窗口看门狗----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Software version is V%.1f\r\n\r\n&quot;</span>,SoftWare_Version);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;程序功能：\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;上电后，系统正常运行，利用窗口看门狗提前唤醒中断回调函数喂狗。\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;单击触摸按键1，停止喂狗，系统重启！\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">Timer2.Timer2_Start_IT(); <span class="comment">//启动定时器6</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(KEY1.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;检测到按键点击&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//清除喂狗标志位</span></span><br><span class="line">MyWWDG.FeedDog_Flag = FALSE;</span><br><span class="line">LED.LED_ON(LED2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n停止喂狗，系统复位！\r\n\r\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @name   HAL_WWDG_EarlyWakeupCallback</span></span><br><span class="line"><span class="comment">  * @brief  窗口看门狗提前唤醒中断回调函数</span></span><br><span class="line"><span class="comment">  * @param  hwwdg : pointer to a WWDG_HandleTypeDef structure that contains</span></span><br><span class="line"><span class="comment">  *                the configuration information for the specified WWDG module.</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_WWDG_EarlyWakeupCallback</span><span class="params">(WWDG_HandleTypeDef *hwwdg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(MyWWDG.FeedDog_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;喂狗\r\n&quot;</span>);</span><br><span class="line">MyWWDG.FeedDog();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h3><h4 id="程序功能-19"><a href="#程序功能-19" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJicHD8ibaeoNZTG82mbj3bzONbuvVthzVRuoc8mCufDmZxKbts16f892w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-19"><a href="#技术讲解-19" class="headerlink" title="技术讲解"></a>技术讲解</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJvsgKibibuwsibt5GXbiaHTbHmNFWzrgx7ccgsKiccHI8Yic2uwxfJDzRCJqw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-12"><a href="#HAL库函数-12" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJeUkWF13S9NQF5sUNekD0bI5viax0NuibOOom4uvOIQ5ThImoiaXKxebPQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_pwr.h><h4 id="编程说明-19"><a href="#编程说明-19" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJibHJHhD0Xq3Gfu5m41h8Ria3tr1dMW0sqK9PSBAa8pKve1PdmhjXeo4w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJWWibrVPxrhNvBfgPwIbog56R9sccsibsVIJoqrm79mB8ONl0JibTiaF7Ag/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJpEDK68NR5oQLstDDJGbg5Cf4ALpTg45ohIMDgxzXkNmvDSEmiate6Mw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、LowPowerConsumption结构体封装</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZc2KnyrF0LoB9hAiaOYibL7PJtvcPWIDvfIE5bRVagNxicD6PGLGymmKE10Q1rEdFqEeh7rQWmo1dfSQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、进入睡眠模式函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfcdEQtlmtVzdJ6NiaI98XZul9DxRHZTTeGw3EHVQiavictGsibic4XeVibcxRxFuY0nR3J7NiaxxbeWrepQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-15"><a href="#6-1的程序-15" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h5 id="工程配置-13"><a href="#工程配置-13" class="headerlink" title="工程配置"></a>工程配置</h5><p>配按键跟LED灯的口就行了，按键使用中断，还有一个定时器2</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008181914006.png" alt="image-20231008181914006"></p><h5 id="硬件电路-27"><a href="#硬件电路-27" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>无</p><h5 id="软件代码-11"><a href="#软件代码-11" class="headerlink" title="软件代码"></a>软件代码</h5><p>注意自己按键的中断通道，不要弄错通道了，程序弄好也可以自己试试用万用表测测电流看看是多少。</p><h6 id="LOWPOWRECONSUMPTION"><a href="#LOWPOWRECONSUMPTION" class="headerlink" title="LOWPOWRECONSUMPTION"></a>LOWPOWRECONSUMPTION</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOWPOWRECONSUMPTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOWPOWRECONSUMPTION_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//标志位</span></span><br><span class="line">    <span class="type">uint8_t</span> Enter_Sleep_Mode_Flag;</span><br><span class="line">    <span class="type">uint8_t</span> Enter_Stop_Mode_Flag;</span><br><span class="line">    <span class="type">uint8_t</span> Enter_Standby_Mode_Flag;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>(*Sleep_Mode)(<span class="type">void</span>);  <span class="comment">//睡眠模式</span></span><br><span class="line">    <span class="type">void</span>(*Stop_Mode)(<span class="type">void</span>);  <span class="comment">//停机模式</span></span><br><span class="line">    <span class="type">void</span>(*Standby_Mode)(<span class="type">void</span>);  <span class="comment">//待机模式</span></span><br><span class="line">&#125; LowPowerConsumption_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> LowPowerConsumption_t LowPowerConsumption;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Sleep_Mode</span><span class="params">()</span>;  <span class="comment">//睡眠模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Stop_Mode</span><span class="params">()</span>;  <span class="comment">//停机模式</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Standby_Mode</span><span class="params">()</span>;  <span class="comment">//待机模式</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">LowPowerConsumption_t LowPowerConsumption =</span><br><span class="line">&#123;</span><br><span class="line">    .Enter_Sleep_Mode_Flag = FALSE,</span><br><span class="line">    .Enter_Stop_Mode_Flag = FALSE,</span><br><span class="line">    .Enter_Standby_Mode_Flag = FALSE,</span><br><span class="line"></span><br><span class="line">    Sleep_Mode,</span><br><span class="line">    Stop_Mode,</span><br><span class="line">    Standby_Mode</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Sleep_Mode</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  睡眠模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Sleep_Mode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***Note:任意中断都可以将系统从睡眠模式中唤醒***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭Systick与定时器中断，否则，进入睡眠模式后立马被唤醒</span></span><br><span class="line">    HAL_SuspendTick();</span><br><span class="line">    HAL_TIM_Base_Stop_IT(&amp;htim2);</span><br><span class="line">    <span class="comment">//关闭按键1到3的外部中断，只允许按键4中断退出睡眠模式</span></span><br><span class="line">    HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入睡眠模式</span></span><br><span class="line">    HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON,PWR_SLEEPENTRY_WFI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复中断</span></span><br><span class="line">    HAL_ResumeTick();</span><br><span class="line">    HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line">    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Stop_Mode</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  停机模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Stop_Mode</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/***Note:外部中断可将系统从停机模式中唤醒***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭按键1到3的外部中断，只允许按键4中断退出停机模式</span></span><br><span class="line">    HAL_NVIC_DisableIRQ(EXTI9_5_IRQn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入停机模式</span></span><br><span class="line">    HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON,PWR_STOPENTRY_WFI);</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出停止模式时，HSI RC振荡器被选为系统时钟</span></span><br><span class="line"><span class="comment">//系统时钟需要重新初始化</span></span><br><span class="line">    SystemClock_Config();</span><br><span class="line">    <span class="comment">//恢复中断</span></span><br><span class="line">    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   Standby_Mode</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  待机模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Standby_Mode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HAL_PWR_EnterSTANDBYMode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="KEY"><a href="#KEY" class="headerlink" title="KEY"></a>KEY</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KEY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KEY_H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> <span class="keyword">volatile</span> KEY_Flag;  <span class="comment">//按键标志位</span></span><br><span class="line">    <span class="type">uint8_t</span> Click;  <span class="comment">//单击</span></span><br><span class="line">    <span class="type">uint8_t</span> Press;  <span class="comment">//长按</span></span><br><span class="line">    <span class="type">void</span> (*KEY_Deteck)(<span class="type">void</span>);  <span class="comment">//按键检测</span></span><br><span class="line">&#125; KEY_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY1;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY2;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY3;</span><br><span class="line"><span class="keyword">extern</span> KEY_t KEY4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">  * @file    KEY</span></span><br><span class="line"><span class="comment">  * @author  6+1</span></span><br><span class="line"><span class="comment">  * @date    2023-09-22 20:14:56</span></span><br><span class="line"><span class="comment">  * @brief   存放按键函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyApplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键1检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY2_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键2检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY3_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键3检测</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY4_Detect</span><span class="params">(<span class="type">void</span>)</span>;  <span class="comment">//机械按键4检测</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"><span class="comment">//结构体类型定义</span></span><br><span class="line">KEY_t KEY1 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY1_Detect&#125;;</span><br><span class="line">KEY_t KEY2 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY2_Detect&#125;;</span><br><span class="line">KEY_t KEY3 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY3_Detect&#125;;</span><br><span class="line">KEY_t KEY4 = &#123;.KEY_Flag = FALSE,.Click = FALSE,.Press = FALSE,KEY4_Detect&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* function prototypes--------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY1_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键1检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY1_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (KEY1.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到KEY1按下!\r\n&quot;</span>);</span><br><span class="line">        LED.LED_ON(LED2);</span><br><span class="line">        KEY1.Click = FALSE;</span><br><span class="line">        KEY1.Press = TRUE;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按键长按检测</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延时1秒</span></span><br><span class="line">            HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果1s内，按键状态出现高电平，此时按键为单击，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin( KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_SET)</span><br><span class="line">            &#123;</span><br><span class="line">                KEY1.Click = TRUE;</span><br><span class="line">                KEY1.Press = FALSE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;KEY1提前释放,系统正常运行！\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KEY1.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">LowPowerConsumption.Enter_Sleep_Mode_Flag = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY1.Press == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">LowPowerConsumption.Enter_Sleep_Mode_Flag = TRUE; </span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//清除按键状态</span></span><br><span class="line">KEY1.KEY_Flag = FALSE;</span><br><span class="line">KEY1.Click = FALSE;</span><br><span class="line">KEY1.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY2_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键2检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY2_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (KEY2.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到KEY2按下!\r\n&quot;</span>);</span><br><span class="line">        LED.LED_ON(LED2);</span><br><span class="line">        KEY2.Click = FALSE;</span><br><span class="line">        KEY2.Press = TRUE;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按键长按检测</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延时</span></span><br><span class="line">            HAL_Delay(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">//如果1s内，按键状态出现高电平，此时按键为单击，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY2_GPIO_Port,KEY2_Pin) == GPIO_PIN_SET)</span><br><span class="line">            &#123;</span><br><span class="line">                KEY2.Click = TRUE;</span><br><span class="line">                KEY2.Press = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KEY2.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;KEY2提前释放,系统正常运行！\r\n&quot;</span>);</span><br><span class="line">LowPowerConsumption.Enter_Stop_Mode_Flag = FALSE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY2.Press == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">            LowPowerConsumption.Enter_Stop_Mode_Flag = TRUE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除按键状态</span></span><br><span class="line">KEY2.KEY_Flag = FALSE;</span><br><span class="line">KEY2.Click = FALSE;</span><br><span class="line">KEY2.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY3_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键3检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY3_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (KEY3.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到KEY3按下!\r\n&quot;</span>);</span><br><span class="line">LED.LED_ON(LED2);</span><br><span class="line">        KEY3.Click = FALSE;</span><br><span class="line">        KEY3.Press = TRUE;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//触摸按键长按检测</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//延时</span></span><br><span class="line">            HAL_Delay(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//如果1s内，按键状态出现高电平，此时按键为单击，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span>(HAL_GPIO_ReadPin(KEY3_GPIO_Port,KEY3_Pin) == GPIO_PIN_SET)</span><br><span class="line">            &#123;</span><br><span class="line">                KEY3.Click = TRUE;</span><br><span class="line">                KEY3.Press = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KEY3.Click == TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;KEY3提前释放,系统正常运行！\r\n&quot;</span>);</span><br><span class="line">LowPowerConsumption.Enter_Standby_Mode_Flag = FALSE;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(KEY3.Press == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">LowPowerConsumption.Enter_Standby_Mode_Flag = TRUE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除按键状态</span></span><br><span class="line">KEY3.KEY_Flag = FALSE;</span><br><span class="line">KEY3.Click = FALSE;</span><br><span class="line">KEY3.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      * @name   KEY4_Detect</span></span><br><span class="line"><span class="comment">      * @param  None</span></span><br><span class="line"><span class="comment">      * @retval None</span></span><br><span class="line"><span class="comment">      * @brief  机械按键4检测</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">KEY4_Detect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (KEY4.KEY_Flag == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        KEY4.Click = TRUE;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">HAL_Delay(<span class="number">20</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;检测到按键4按下\r\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">KEY4.KEY_Flag = FALSE;</span><br><span class="line">KEY4.Click = FALSE;</span><br><span class="line">KEY4.Press = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="运行函数"><a href="#运行函数" class="headerlink" title="运行函数"></a>运行函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Peripheral_Set</span></span><br><span class="line"><span class="comment">* @brief  外设设置</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Peripheral_Set</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----此程序测试STM32低功耗模式----\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Initialization completed, system startup!\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Software version is V%.1f\r\n\r\n&quot;</span>,SoftWare_Version);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;长按KEY1超过1s,系统进入睡眠模式！\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;长按KEY2超过1s,系统进入停机模式！\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;长按KEY3超过1s,系统进入待机模式！\r\n\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">Timer2.Timer2_Start_IT(); <span class="comment">//启动定时器2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Run</span></span><br><span class="line"><span class="comment">* @brief  系统运行</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Run</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">KEY1.KEY_Deteck();</span><br><span class="line">KEY2.KEY_Deteck();</span><br><span class="line">KEY3.KEY_Deteck();</span><br><span class="line">KEY4.KEY_Deteck();</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//延时1s，期间间隔50ms检测是否需要进入低功耗模式</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//进入睡眠模式</span></span><br><span class="line"><span class="keyword">if</span>(LowPowerConsumption.Enter_Sleep_Mode_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">LowPowerConsumption.Enter_Sleep_Mode_Flag = FALSE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;系统进入睡眠模式,通过KEY4按键唤醒\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">LowPowerConsumption.Sleep_Mode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入停机模式</span></span><br><span class="line"><span class="keyword">if</span>(LowPowerConsumption.Enter_Stop_Mode_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">LowPowerConsumption.Enter_Stop_Mode_Flag = FALSE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;系统进入停机模式,通过KEY4按键唤醒\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">LowPowerConsumption.Stop_Mode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入待机模式</span></span><br><span class="line"><span class="keyword">if</span>(LowPowerConsumption.Enter_Standby_Mode_Flag == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">LowPowerConsumption.Enter_Standby_Mode_Flag = FALSE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;系统进入待机模式，通过复位按键唤醒\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;待机模式,外设不受STM32控制,系统功耗可能增加：\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">LowPowerConsumption.Standby_Mode();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//延时50ms</span></span><br><span class="line">HAL_Delay(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;系统正常运行\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  EXTI line detection callbacks.</span></span><br><span class="line"><span class="comment">  * @param  GPIO_Pin: Specifies the pins connected EXTI line</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span>(GPIO_Pin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> KEY1_Pin: KEY1.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY2_Pin: KEY2.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY3_Pin: KEY3.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> KEY4_Pin: KEY4.KEY_Flag = TRUE; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;错误 - 外部中断回调函数中，触摸按键键值错误！\r\n\r\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="万用表测单片机电流"><a href="#万用表测单片机电流" class="headerlink" title="万用表测单片机电流"></a>万用表测单片机电流</h3><p>我们单片机的是直流电流</p><p>开启万用表，调到测试直流电流200毫安的地方，黑笔接公共端，红笔接200毫安的端口</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008175409474.png" alt="image-20231008175409474"></p><p>STLINK需要连接电源，把STLINK连接单片机3.3V的线拔掉</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008180557201.png" alt="image-20231008180557201"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008180456184.png" alt="image-20231008180456184"></p><p>红笔接电流+极，黑笔接电流负极</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008175355803.png" alt="image-20231008175355803"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20231008180922737.png" alt="image-20231008180922737"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>根据待测电路的电流范围，选择适当的电流档位。如果电流不确定，可以从最大档位开始，然后逐渐减小档位。在选择电流档位时，初始选择较大的档位，再逐渐调整到适合电流范围的档位。选择过小的档位可能导致测量不准确或对万用表造成损坏。</li></ol><p>由于我们测试的单片机我是知道电流不大，要是测试其他东西自己不清楚的就直接用20A就好了</p><p>万用表是一种常见的电测量仪器，通常可以用来测量电压、电流和电阻等参数。要使用万用表来测量电流，需要将万用表的测量功能切换到电流档位，并连接正确的电路。</p><p>以下是一般测量电流的步骤：</p><ol><li>确保被测电路处于断开状态，以免损坏万用表或产生危险。</li><li>找到万用表上的电流测量插孔或端口。通常，它标有符号”A”表示电流测量。</li><li>将测量插头插入电流测量插孔。</li><li>根据待测电路的电流范围，选择适当的电流档位。如果电流不确定，可以从最大档位开始，然后逐渐减小档位。</li><li>如果万用表上有多个电流档位，选择最接近待测电流的一个档位。</li><li>断开电路中的连接，将万用表的两个探头连接到待测电路的两个断开处。</li><li>注意万用表的极性，确保正负极正确连接。</li><li>在合适的测量环境下，重新连接待测电路。电流将通过万用表流过，万用表将测量并显示电流值。</li></ol><p>请注意以下几点：</p><ul><li>在选择电流档位时，初始选择较大的档位，再逐渐调整到适合电流范围的档位。选择过小的档位可能导致测量不准确或对万用表造成损坏。</li><li>尽量避免测量过大的电流，以免超出万用表的额定测量范围，引发故障或安全风险。</li><li>如果待测电流是交流电流，需要注意万用表的测量范围是否包括交流电流。</li><li>在进行电流测量之前，最好参考万用表的使用手册或说明书，以了解特定仪器的操作方法和注意事项。</li></ul><p>请谨慎操作，确保安全并正确使用万用表进行电流测量。</p><h3 id="在线程序升级-IAP"><a href="#在线程序升级-IAP" class="headerlink" title="在线程序升级(IAP)"></a>在线程序升级(IAP)</h3><h4 id="程序功能-20"><a href="#程序功能-20" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、准备了3个程序，1个Boot引导程序+2个APP应用程序</p><p>2、Boot引导程序负责将APP应用程序写入内部FLASH，然后跳转到APP应用程序</p><p>3、APP应用程序通过软件复位也可以回到Boot引导程序</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMKpNDHqqsEEXyqNM5M5f176nYjg1kOEsCP4UpiaZbViaUXhOeaQDQibdUQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><Boot程序上电输出><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM2kuF1E0YabqjGr2qkunKroxT1UXceM9qX3f8MhCyKoPWsXVpSTbOsA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;升级程序并跳转至APP&gt;</p><h4 id="硬件电路-28"><a href="#硬件电路-28" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMfzKicCgiasVWNN1xKVHGbdJ031oS3KYOOM3y0mTK71Wfj3hd9QvibibDaw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-20"><a href="#技术讲解-20" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>一、编程技术</p><p>1、ICP</p><p>英文全称 - In  Circuit Programming，即在线电路编程。</p><p>需要将芯片取出，用专门的烧录器进行编程， 传统单片机编程模式。</p><p>2、ISP</p><p>英文全称 - In Syetem Programming，即在线系统编程。</p><p>可以在电路板上，通过接口对芯片编程 ，当前绝大部分单片机都支持此编程模式。</p><p>3、IAP</p><p>英文全称 - In Application Programming，即在线应用编程。</p><p>可以使用应用程序对芯片进行编程，方便远程升级，部分单片机支持此编程模式。</p><p>二、普通STM32程序运行过程</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMogFFSKlpqD4eQg3hIXFlqwrGUmdqibgS6NrRFuYiaEBSN6uuUUTrtK8g/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;图片来源于网络&gt;</p><p>三、带IAP升级的STM32程序运行过程</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMXQ2uGKJKENfnMDhXt6JP6JlOmRDmHLhvUibOHmpnO8MMoHoAMkfauNA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;图片来源于网络&gt;</p><p>四、Boot程序设计注意事项</p><p>1、APP应用程序数据格式采用Bin文件，因为HEX文件包含地址等信息，而Bin文件只包含数据，不需要额外处理</p><p>2、APP应用程序数据传输方式没硬性要求，可以采用有线通信(UART,SD卡，USB等)，也可以采用无线通信(蓝牙，GPRS，4G等)，实战代码采用UART</p><p>、APP应用数据可以分包传输，也可以一次性传输。 一次性传输方便代码小的APP，因为数据需要存放在RAM； 分包传输，对RAM要求低，同时，无线传输时，减小丢包的可能。 实战代码使用串口工具一次性传输</p><p>4、跳转至APP应用程序前，清除所有中断标志，关闭所有中断，否则，可能出现死机。</p><p>五、APP应用程序设计注意事项</p><p>1、先按正常情况调试好应用程序，再经过设置生成可供IAP升级的应用程序</p><p>2、设置第一步，ROM地址</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMQVmTOg9U3a3OkowJueBTqGBXW41eNY0nNwTkvT1IjFhHAbGfS4xibLQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>IROM1：start  = FLASH_BASE+预留给Boot程序尺寸 ，为了方便Boot代码擦写FLASH，要求进行页对齐(1k/2k)， 预留给Boot程序尺寸为2k的整数倍， 比如32k，64k等</p><p>IROM1：Size = 芯片FLASH总尺寸 - 预留给Boot程序尺寸</p><p>3、设置第二步，中断向量表的偏移地址</p><p>Note：必须设置ok，否则APP应用程序无法执行中断程序</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMwLazR33FNjUMkPuFibmPO4tIS0RCOPTLWRnzm1z3GJb2l6mwNtLZ2mA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、利用Keil软件自带的工具生产Bin文件</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMdTlclBic0Lxa2xVRnqC1c8DXiarMS69RYibHB7NQgEJqpMicTib0ibS7vPkw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>命令格式：C:\Keil_v5\ARM\ARMCC\bin\fromelf.exe —bin -o IAP-APP1.bin IAP-APP1\IAP-APP1.axf</p><p>注意：命令不要包含中文与空格</p><h4 id="HAL库函数-13"><a href="#HAL库函数-13" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM0H8sxR5RUr0MnApbLic9VhBpib35UC0gj4NMlLQuALAPcTSlckaePcHQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_flash.h><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM3URFNVEYaicaPdKRsGWA0oIDMNK1btDDibDn4CrdqQ5KaLPfphWiatjeQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_flash_ex.h><h4 id="编程说明-20"><a href="#编程说明-20" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMKkkudNINic01P1GVeX0XqYm6l5VSMGx504Z080IwKgSTjPwW3IHyfpg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>&lt;串口&gt;</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMrDPAxZGXrKS2Ncj65naDgmpnUJwfk9qKV1kL0jh3dJlDunm4lYhjHw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><NVIC><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMx7UNIoVjqemIKeEM6RcdnZajF2ib63LokicWr80F9ldBzALt8NKRibhqQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM2MyAwoqsC1nYuhRsGO2iaef0KCaZSeqczt8xpdgSibWFOiajaEKfY7lJg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、FLASH结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMN7s82FiaJOx88OibBrd6pamOf5GDsvbKqhK4Hjy4JLl4MyQDice47qSbA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、FLASH写页面函数(带校验)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM2kTaWQ2uRZ50h0tJWCUQmjWj44owXKm4drS37EQRdXshbYpv5Hxmxg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMNIK71vgkHQXNJY4bwAZGleCjicHJysyofdVRS69OAhnFia5f43QOyx4A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、IAP结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CMT6FI3g1vkS3CFuurBSNhJgGeO6KRsryMia1UlIvicSaeUaUhx2lSR3rQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>7、写APP应用程序函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNHlrxlVyIA93Af0dwv8CM9Uh4N2Cfz76Q6vcKr60x1NbDBw35dwe14ibkuHBKpabKZxZO3KCjrsQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-16"><a href="#6-1的程序-16" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><p>感觉现在用不上，用上的时候再弄吧</p><h3 id="CAN通信"><a href="#CAN通信" class="headerlink" title="CAN通信"></a>CAN通信</h3><h4 id="程序功能-21"><a href="#程序功能-21" class="headerlink" title="程序功能"></a>程序功能</h4><p>程序一：CAN工作模式 - 环回模式</p><p>说明：只需一块开发板，即可测试CAN的收发功能</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRv2qM6p6UHomswArrgW1gQbk8bXvsL8UXty4VMkNzCScINDqILxRpV0Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>程序二：CAN工作模式 - 正常模式</p><p>说明：至少两块开发板，组成CAN总线系统，测试CAN的收发功能</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvVFlGPmnq4ibONsmBOiaGv9ORSScXqoEYvYnm8CktpL46nOK5Ac3ibu1wA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-29"><a href="#硬件电路-29" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcswBKfQTxAyL06aBbqq7pC9yoTobob3nEicJ3OLW3GPrZQIpQxicHLk4vzZTReOiaAfBbBV8exjz8RQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明：CAN总线接口分隐形电平与显性电平</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvyAFj7UepXX1ZQ6Te9MVGduowEKVwicGKia8tEFBMhSCQGNzbGbF39OBg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-21"><a href="#技术讲解-21" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>一、CAN入门知识</p><p>阅读文档 - can入门教程.pdf</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvFvvWvzz6AZ43GgOSl06KLRZoXJg8914wDlibMa7BibWmngiaa2pFqTFeQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>二、STM32F103的bxCAN</p><p>阅读STM32F1手册 - bxCAN章节</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvicFznaQNp4GiaiaTKicz5iayS9lYntHZhm5Kjzicnk2M7CHUOHuafqYXibMYg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-14"><a href="#HAL库函数-14" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvxibBvW59Tcww5tFKGj5ZzvP48Ax8auEge7cpbibYicNB8rh4icu3yUFyZw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><stm32f1xx_hal_can.h><h4 id="编程说明-21"><a href="#编程说明-21" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvNkgVkxt2JbDhgtb7G5BC2wWKOkgZKrbkNDKYN0gyQEKmxCtMovtjqg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>①、位时序</p><p>波特率计算 = 36M/4/(1+11+6) = 500HKz</p><p>②、工作模式</p><p>环回模式与正常模式</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvbeOiabdFWzY0lkzBaMvMJKD9DRqUvGuPyt5e6Lg0bsJ97pq6IGMxang/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>发送采用查询，接收采用中断</p><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRviaQQ57SvhKlFnnAeRP5fawpictBWwGAFxlPM72Ljg1dEyaOmDjTxbQ8w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvQJ9ll9vremAAMGeibibmjoYXclLv8H4ibKmRwiayM3c0SMA2ZshtCfBlrQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、CAN结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRv98tJMovtz9bpvMMd7fiaVX0KibC86VaOsBRG5wy9lG4gU160fkbwy9tw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、CAN配置函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRv6RKLw9vSYO9EVMSicD1O4G7vz009L7QCZeAicKJWCibGAlQGm17ibACzpw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、CAN发送函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvyfmBPDXyAhdic6gw3odS6iaAVpOy6QI1PbTJHrKlK9TOd9W5sMdaPWmg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>7、CAN接收回调函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcNS4TqQhRcCRzL6ibBHstRvXxickyxPDImVTLuvDMGQMz183Cgf9BYlNXCEQ3hAMWsGibLWUbqgCEYQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="6-1的程序-17"><a href="#6-1的程序-17" class="headerlink" title="6+1的程序"></a>6+1的程序</h4><h3 id="FatFS文件系统-外部Flash读写"><a href="#FatFS文件系统-外部Flash读写" class="headerlink" title="FatFS文件系统(外部Flash读写)"></a>FatFS文件系统(外部Flash读写)</h3><h4 id="程序功能-22"><a href="#程序功能-22" class="headerlink" title="程序功能"></a>程序功能</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD587iaGgiat7rRjNhAiaDpF4pic50s77ZQ639wsaIsPFQk7pqZZDQwicicseIPw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-30"><a href="#硬件电路-30" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58xPPM7mwe9nGnyPBAYob0DkibzrwJsoVicFQplibpdxBZocEEc0y1vvohQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-22"><a href="#技术讲解-22" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>FatFs是用于小型嵌入式系统的通用FAT / exFAT文件系统模块。FatFs模块是按照ANSI C（C89）编写的，并且与磁盘I / O层完全分开。因此，它独立于平台。可以将其合并到资源有限的小型微控制器中，例如8051，PIC，AVR，ARM，Z80，RX等。还提供了适用于小型微控制器的Petit FatFs模块。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58hFX0pW9H0X7fHLYfPAhLB7Xib0ftXOMOGKCsW6EtEv3vXbbd2ApRVfA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><strong>带大家阅读官网资料：</strong><a href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a></p><h4 id="编程说明-22"><a href="#编程说明-22" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58NXKzqpmLWYWbRPHiakCUo6ic9VMm0hKuymhG8phC6Bm5BkmWWO53N9Sw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>Note：</p><p>①、支持长文件名</p><p>②、最大扇区尺寸，Flash为4096 bytes</p><p>③、支持设备的数量，此处为1</p><p>2、文件结构如下</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58ICZzhabnajibS0ogIgsj7c4HLTMPaDakyiaL040jYc6icGIKHe9rtBVeQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58ERdEoDxS4YFBC8TNWbPWwyKxmMrH9pIGJxD7VLarPicYXmm8SRSF5eg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、MyFatFS结构体</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD585sBDNFClTWhR5czUiaqZ9A56GeZ1vR2akDtziaE11X08ndtd4iaNyJW9Q/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、FatFS底层驱动初始化函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD58CCPd0EGqibUOGhoUKdOlzhibkX5A9FnlvY87pk9XU906zhRvGfibJpdTg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>6、FatFS底层驱动写数据函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD580QicWQnj7DPYjLVgMRL3ZwOQG629oeQfKVR0tZCMBW3U50bhPxzGaww/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>7、FatFS底层驱动读数据函数</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZcglePegn8VZWoGaPhEsD585bbdYQwqwqQpksXeezTevMC9J7vUV67YXGCddmzVs3APONVWhlpgXw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="SD卡-FatFS文件系统，IAP自动升级程序"><a href="#SD卡-FatFS文件系统，IAP自动升级程序" class="headerlink" title="SD卡(FatFS文件系统，IAP自动升级程序)"></a>SD卡(FatFS文件系统，IAP自动升级程序)</h3><h4 id="程序功能-23"><a href="#程序功能-23" class="headerlink" title="程序功能"></a>程序功能</h4><p>1、上电后，检测SD卡中是否有文件名为IAP-SD.bin的APP应用程序；</p><p>2、如果有，读取文件并写入flash,每次8k</p><p>3、跳转APP，运行应用程序</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLBJgZvFbxicEFibrYC2NZw0KTnuAibByYDqPXc2DRRNrCnOeIRDfyNly2A/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="硬件电路-31"><a href="#硬件电路-31" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLaSMCIfI3LmNtpTYRsKCgakzmMqZ9sDSOfVgRa7YreHbPvEicM5ax8QA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="技术讲解-23"><a href="#技术讲解-23" class="headerlink" title="技术讲解"></a>技术讲解</h4><p>1、SD卡介绍</p><p>方便储存数据，单片机系统需要大容量存储设备，通常用Flash芯片，SD卡，U盘。Flash芯片容量有限，通常16M-128M，需要专用设备烧录信息；U盘不适合嵌入到系统， SD卡容量可以几百M至32G，甚至更大，尺寸分SD卡与TF卡，通过电脑也方便写入信息，方便用于IAP升级与储存历史数据，图片数据等</p><p>SD卡支持SPI与SDIO驱动。只需几个IO便可可扩展高达32G以上的外部存储器，编程也方便，是单片机大容量存储设备的首选。</p><p>自行阅读下列文档，对SD卡有个大概认识：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsL5LicCaicqtEryHFKTRVGOE5HT5P3xWUthrxVjEicNpLa0PZWUGibmssSvg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、阅读STM32中文参考手册</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLEfnSAf5UB0xHoSDTTUgUB0jtrGb4uLmc1H9hFRI8MVgf7fl4qvC73w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLFJj8Kib3BibDsvWz2KWL4JqBNh8g8XG2oapw01vrDMd1AfxKaI6GuukA/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="HAL库函数-15"><a href="#HAL库函数-15" class="headerlink" title="HAL库函数"></a>HAL库函数</h4><p>视频：阅读SDIO库函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLjpjSbHG1O3vdLuMB8IsR4LgmhZELEe2TmRna2tBjNkghCDPkkQzknw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="编程说明-23"><a href="#编程说明-23" class="headerlink" title="编程说明"></a>编程说明</h4><p>1、STM32cubeMX初始化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLhOodrvpAz0M4DboaVeVOX51RiaQFrATj5AwT4TIqy45UpEV2ZicwIZUQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><SDIO><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsL4OLic6oWEugS2llF0juPcAnDFhMkHRZO4qfcibvRrUKXc8WFL49tHibdg/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><FatFS><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLVRd9yTg0JZxOrtfPRnoYqGZXq7JyaBooXWqd6mLAz25rPgP8iaeZTJQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><TF-CD><p>2、文件结构如下</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLkwUicLvRFbicJK0QHdevWFEqZBpia7Ix1lD1X1xNztgwtnU6khbZRibHJw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>说明，程序在标准的程序框架基础上设计。</p><p>3、运行函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsL2fJVbwsCGVXCg7qythvu8a1F5VuKF4TpaLC2ZmPhUdCHQTcE4q3NMQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、MyFatFS结构体</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLicmicyUUN081xRyWxfQfxWtthjubibVibqR7HZic9jB2q4OxbNaXd4PRDjQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>5、FatFS_IAP_SD自动升级程序函数</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZf1jSwQTWn6R3BSScsCficsLld6xFRaVrOMOhBINCSzGCj5SKuUtuwicK6gibLOcnmKzGRXom8Y7KMWQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="生产资料-项目结束"><a href="#生产资料-项目结束" class="headerlink" title="生产资料(项目结束)"></a>生产资料(项目结束)</h3><h4 id="生产资料"><a href="#生产资料" class="headerlink" title="生产资料"></a>生产资料</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfcMOC08X30VnQ8gzhk6l7SMXgYjODkwhQXcNo9vG5YSGEBTKLOoGYibbRkdn4Bkr0uibNROCrFDDbQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h4 id="资料介绍"><a href="#资料介绍" class="headerlink" title="资料介绍"></a>资料介绍</h4><p>1、BOM表</p><p>一般需要详细的列出元器件信息，包含位号、型号、封装、数量，安装方式等信息，另外，有必要的话，还可以列出图片，品牌等信息。</p><p>BOM表，一般公司有自己的规范，按照规范做好即可。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfcMOC08X30VnQ8gzhk6l7SKN9VhmbGTwH8v3BzpmowhGkSYk7GxeHBGKm8zAibd8Yo8qibpDia5KlHQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>2、gerber文件</p><p>Gerber文件是PCB生产制造文件，可以让PCB板厂帮忙拼板，提供gerber文件。 如果没有保密要求，也可以直接用PCB文件制板。</p><p>3、PCB文件</p><p>对于不需要保密的PCB文件，可以提供PCB原文件与拼板说明给到厂家，让厂家帮忙拼板，生产gerber文件。</p><p>制板说明：详细说明PCB板的生产工艺；</p><p>坐标文件：生产贴片用；</p><p>丝印图： 生产参照用</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uY9kIGsoHZfcMOC08X30VnQ8gzhk6l7Sibc7pLHiaMJ32soUFhNJ95OKuQK4UJAZhkY0O87PkvcePx94ugErpNLw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>4、<strong>pdf格式的PCB文件</strong></p><p>方便PCB厂家不熟悉pcb软件时，通过pdf格式的PCB文件，统计焊盘数量，提供贴片报价。</p><p><strong>5、原理图</strong></p><p>如果PCB厂帮忙测试与维修，可以提供pdf格式的原理图，有必要的话，还需提供维修文档。</p><p><strong>6、程序文件</strong></p><p>这个文件根据需要提供，一般公司都会保密，程序让单片机供应商代烧，或自行烧录，以确保产品安全。</p><p><strong>7、样机图</strong></p><p>最好提供样机图，有必要的话，需要提供样机实物，方便贴片厂参照，确保贴片无误。 另外，贴片出现问题时，也方便定位责任，如果是样机有误，你懂的。</p>]]></content>
      
      
      <categories>
          
          <category> 32单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32标准库</title>
      <link href="/2023/11/18/%E6%B1%9F%E7%A7%91%E5%A4%A7STM32/"/>
      <url>/2023/11/18/%E6%B1%9F%E7%A7%91%E5%A4%A7STM32/</url>
      
        <content type="html"><![CDATA[<h3 id="STM32F103C8T6"><a href="#STM32F103C8T6" class="headerlink" title="STM32F103C8T6"></a>STM32F103C8T6</h3><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230821211535035.png" alt="image-20230821211535035"></p><div class="table-container"><table><thead><tr><th>系列</th><th>主流系列</th><th>STM32F1</th></tr></thead><tbody><tr><td>内核</td><td></td><td>ARM Cortex-M3</td></tr><tr><td>主频</td><td></td><td>72MHz</td></tr><tr><td>RAM</td><td></td><td>20K（SRAM）</td></tr><tr><td>ROM</td><td></td><td>64K（Flash）</td></tr><tr><td>供电</td><td></td><td>2.0~3.6V（标准3.3V）</td></tr><tr><td>封装</td><td></td><td>LQFP48</td></tr></tbody></table></div><p><strong>==片上资源/外设==</strong></p><div class="table-container"><table><thead><tr><th><strong>英文缩写</strong></th><th><strong>名称</strong></th><th><strong>英文缩写</strong></th><th><strong>名称</strong></th></tr></thead><tbody><tr><td>NVIC</td><td>嵌套向量中断控制器</td><td>CAN</td><td>CAN通信</td></tr><tr><td>SysTick</td><td>系统滴答定时器</td><td>USB</td><td>USB通信</td></tr><tr><td>RCC</td><td>复位和时钟控制</td><td>RTC</td><td>实时时钟</td></tr><tr><td>GPIO</td><td>通用IO口</td><td>CRC</td><td>CRC校验</td></tr><tr><td>AFIO</td><td>复用IO口</td><td>PWR</td><td>电源控制</td></tr><tr><td>EXTI</td><td>外部中断</td><td>BKP</td><td>备份寄存器</td></tr><tr><td>TIM</td><td>定时器</td><td>IWDG</td><td>独立看门狗</td></tr><tr><td>ADC</td><td>模数转换器</td><td>WWDG</td><td>窗口看门狗</td></tr><tr><td>DMA</td><td>直接内存访问</td><td>DAC</td><td>数模转换器</td></tr><tr><td>USART</td><td>同步/异步串口通信</td><td>SDIO</td><td>SD卡接口</td></tr><tr><td>I2C</td><td>I2C通信</td><td>FSMC</td><td>可变静态存储控制器</td></tr><tr><td>SPI</td><td>SPI通信</td><td>USB OTG</td><td>USB主机接口</td></tr></tbody></table></div><p><strong>==命名规则==</strong></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824181708441.png" alt="image-20230824181708441"></p><p><strong>==系统结构==</strong></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824181733269.png" alt="image-20230824181733269"></p><p>==<strong>引脚定义</strong>==</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824182139409.png" alt="image-20230824182139409"></p><p>橙色是电源相关引脚        蓝色是最小系统相关引脚        绿色是IO口、功能口引脚</p><p>类型：S代表电源，I代表输入，O代表输出，IO代表输入输出</p><p>IO口电平代表IO口所能容忍的电压<br>FT代表能容忍5V的电压<br>没有FT代表只能容忍3.3V的电压<br>如果没有FT的需要接5V的电平，就需要加装电平转换电路。</p><p>推荐优先使用加粗的IO口</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824182352410.png" alt="image-20230824182352410"></p><p>详情请看数据手册引脚定义</p><p>启动配置</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824184031627.png" alt="image-20230824184031627"></p><p>最小系统电路</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824184058946.png" alt="image-20230824184058946"></p><p>•STM32是ST公司基于ARM Cortex-M内核开发的32位微控制器<br>•STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等<br>•STM32功能强大、性能优异、片上资源丰富、功耗低，是一款经典的嵌入式微控制器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230821211739575.png" alt="image-20230821211739575"></p><p>•ARM既指ARM公司，也指ARM处理器内核<br>•ARM公司是全球领先的半导体知识产权（IP）提供商，全世界超过95%的智能手机和平板电脑都采用ARM架构<br>•ARM公司设计ARM内核，半导体厂商完善内核周边电路并生产芯片</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230821211924208.png" alt="image-20230821211924208"></p><h3 id="硬件设备"><a href="#硬件设备" class="headerlink" title="硬件设备"></a>硬件设备</h3><p>STM32面包板入门套件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230823165120077.png" alt="image-20230823165120077"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824181334180.png" alt="image-20230824181334180"></p><p>123.18</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>安装Keil5 MDK跟之前下载keil C51一样，下载完记得破解，非常简单。</p><p>安装器件支持包</p><p>在线安装<br>点击这里进去</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824191639398.png" alt="image-20230824191639398"></p><p>找到STM32F1下载后缀为DFP的文件就可以了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824191811107.png" alt="image-20230824191811107"></p><p>这是安装好的</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824191514096.png" alt="image-20230824191514096"></p><p>需要其他型号的的芯片也是一样的，下载就好了</p><p>安装STLINK驱动</p><p>教学视频说安装目录自带驱动文件直接安装就行，但是我在文件目录没有找到，不过教学资料里有驱动文件，直接安装即可，非常简单</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230824193139317.png" alt="image-20230824193139317"></p><p>直接点进去安装就可以了</p><p>安装USB转串口驱动<br>之前学习51的时候安装过 ，不过多介绍，直接找驱动安装即可。</p><h3 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h3><h4 id="GPIO口问题"><a href="#GPIO口问题" class="headerlink" title="GPIO口问题"></a>GPIO口问题</h4><p>这是定时器外部时钟计次程序的GPIO代码，出现的错误是使用PB14口时输出效果数值一直飙升。</p><pre><code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);GPIO_InitTypeDef GPIO_InitStructure;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_Init(GPIOB,&amp;GPIO_InitStructure); </code></pre><p>这两段代码是反射红外模块的初始化GPIO口的代码，一个口是PA0，一个是PB14，当他们使用TIM2计数时，PA0口是正常现象，而PB14口数值则会一直飙升。研究了很久，发现是PB14口不支持TIM2。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907142407754.png" alt="image-20230907142407754"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907142427336.png" alt="image-20230907142427336"></p><p>可以看到PA0是支持TIM2，PB14支持TIM1，所以在使用GPIO口前需要查看一下当前端口是否支持该功能。不然效果不对，还找不到问题。</p><h3 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h3><p>准备库函数文件<br><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825000150262.png" alt="image-20230825000150262"></p><p>新建工程，选择芯片型号<br><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825000612981.png" alt="image-20230825000612981"></p><p>之后会弹出Keil软件的一个新建工程小助手，可以帮助我们快速新建工程，这里我们不需要的话就可以直接×掉</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825000643296.png" alt="image-20230825000643296"></p><p>现在工程就创建好了，里面是没有任何东西的，现在的工程是不能用的，我们还需要给它添加一点工程的必要文件<br><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825000936227.png" alt="image-20230825000936227"></p><p>把这些文件复制到我们刚刚新建的工程文件里</p><p>这些是stm32的启动文件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825001317358.png" alt="image-20230825001317358"></p><p>这里第一个文件是外设寄存器描述文件，作用与51单片机的头文件REGX.H一样，其他两个文件主要是用来配置时钟文件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825001905648.png" alt="image-20230825001905648"></p><p>因为STM32是内核和内核外围的设备组成的，内核的寄存器描述和外围设备的描述文件不是在一起的，所以我们还需要添加一个内核寄存器描述文件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825002705534.png" alt="image-20230825002705534"></p><p>现在我们的工程必要文件就复制完成了，我是建立一个名叫Start的文件夹把他们放在一起<br><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825002822168.png" alt="image-20230825002822168"></p><p>然后把进入keil添加为工程文件</p><p>我们先添加启动文件，启动文件有很多分类，但是我们只能添加其中一个，我们所用的芯片型号需要选择后缀为md.s的启动文件，启动文件怎么选择后面会写。然后把剩余的.c和.h文件全部添加进去。<img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825003129457.png" alt="image-20230825003129457"></p><p>添加完之后我们记得打开魔术棒添加文件路径，要不然软件找不到.h文件，添加完点击🆗就行了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825004522988.png" alt="image-20230825004522988"></p><p>然后我们测试一下工程行不行，建立一个文件夹叫User，然后在keil里，添加一个组改名也叫user</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825004843529.png" alt="image-20230825004843529"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825005021752.png" alt="image-20230825005021752"></p><p>新建一个main文件，记得选择文件路径，不选的话默认把文件放在文件夹外面</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825005040119.png" alt="image-20230825005040119"></p><p>弄好之后我们就可以用寄存器方法进行开发</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825180806126.png" alt="image-20230825180806126"></p><p>当然我们主要学习的是库函数开发，所以还要添加一些库函数文件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825202420311.png" alt="image-20230825202420311"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825202439350.png" alt="image-20230825202439350"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825202527248.png" alt="image-20230825202527248"></p><p>添加好这些文件我们还需要添加这个字符串，只有定义了这个字符串USE_STDPERIPH_DRIVER下面的”stm32f10x_conf.h”才能生效</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825202655729.png" alt="image-20230825202655729"></p><p>复制了字符串记得把文件的文件路径也添加进来</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825202710967.png" alt="image-20230825202710967"></p><p>选择对应的调试器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825203236995.png" alt="image-20230825203236995"></p><p>勾选Reset and Run</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825203257507.png" alt="image-20230825203257507"></p><p>这样我们的模板就弄好了，可以直接点灯了</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825203206988.png" alt="image-20230825203206988"></p><h4 id="接线图与代码"><a href="#接线图与代码" class="headerlink" title="接线图与代码"></a>接线图与代码</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825204813501.png" alt="image-20230825204813501"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOC, &amp;GPIO_InitStructure);</span><br><span class="line"><span class="comment">//GPIO_SetBits(GPIOC, GPIO_Pin_13); //关闭PA13LED灯</span></span><br><span class="line">GPIO_ResetBits(GPIOC, GPIO_Pin_13);  <span class="comment">//点亮PA13LED灯</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>型号分类及缩写</strong></p><div class="table-container"><table><thead><tr><th><strong>缩写</strong></th><th><strong>释义</strong></th><th><strong>Flash**</strong>容量**</th><th><strong>型号</strong></th></tr></thead><tbody><tr><td>LD_VL</td><td>小容量产品超值系列</td><td>16~32K</td><td>STM32F100</td></tr><tr><td>MD_VL</td><td>中容量产品超值系列</td><td>64~128K</td><td>STM32F100</td></tr><tr><td>HD_VL</td><td>大容量产品超值系列</td><td>256~512K</td><td>STM32F100</td></tr><tr><td>LD</td><td>小容量产品</td><td>16~32K</td><td>STM32F101/102/103</td></tr><tr><td>MD</td><td>中容量产品</td><td>64~128K</td><td>STM32F101/102/103</td></tr><tr><td>HD</td><td>大容量产品</td><td>256~512K</td><td>STM32F101/102/103</td></tr><tr><td>XL</td><td>加大容量产品</td><td>大于512K</td><td>STM32F101/102/103</td></tr><tr><td>CL</td><td>互联型产品</td><td>-</td><td>STM32F105/107</td></tr></tbody></table></div><p><strong>新建工程步骤</strong></p><p>•建立工程文件夹，Keil中新建工程，选择型号<br>•工程文件夹里建立Start、Library、User等文件夹，复制固件库里面的文件到工程文件夹•工程里对应建立Start、Library、User等同名称的分组，然后将文件夹内的文件添加到工程分组里<br>•工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹<br>•工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER<br>•工程选项，Debug，下拉列表选择对应调试器，Settings，Flash Download里勾选Reset and Run</p><p><strong>工程架构</strong></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825203916756.png" alt="image-20230825203916756"></p><p>==<strong>工程报错</strong>==<br>网上说是版本问题，这个库文件太老了。后面又装了一个keil5，就解决了报错问题</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825143253704.png" alt="image-20230825143253704"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825143336537.png" alt="image-20230825143336537"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230825150659852.png" alt="image-20230825150659852"></p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="外设时钟函数"><a href="#外设时钟函数" class="headerlink" title="外设时钟函数"></a>外设时钟函数</h4><p>外设时钟的开启或关闭。</p><ol><li><code>RCC_AHBPeriph</code>：表示要控制的外设的时钟。</li><li><code>NewState</code>：表示设置外设时钟的状态，可以是 <code>ENABLE</code>（使能）或 <code>DISABLE</code>（禁用）。</li></ol><p>void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);<br>void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);<br>void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);</p><h4 id="GPIO函数"><a href="#GPIO函数" class="headerlink" title="GPIO函数"></a>GPIO函数</h4><div class="table-container"><table><thead><tr><th>函数名</th><th>GPIO_Init</th></tr></thead><tbody><tr><td>函数原形</td><td>void GPIO_Init(GPIO_TypeDef<em> GPIOx, GPIO_InitTypeDef</em> GPIO_InitStruct)</td></tr><tr><td>功能描述</td><td>根据 GPIO_InitStruct 中指定的参数初始化外设 GPIOx 寄存器</td></tr><tr><td>输入参数 1</td><td>GPIOx： x 可以是 A， B， C， D 或者 E，来选择 GPIO 外设</td></tr><tr><td>输入参数 2</td><td>GPIO_InitStruct：指向结构 GPIO_InitTypeDef 的指针，包含了外设 GPIO 的配置信息 参阅 Section： GPIO_InitTypeDef 查阅更多该参数允许取值范围</td></tr><tr><td>输出参数</td><td>无</td></tr><tr><td>返回值</td><td>无</td></tr><tr><td>先决条件</td><td>无</td></tr><tr><td>被调用函数</td><td>无</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>GPIO_Pin</th><th>描述</th></tr></thead><tbody><tr><td>GPIO_Pin_None</td><td>无管脚被选中</td></tr><tr><td>GPIO_Pin_0</td><td>选中管脚 0</td></tr><tr><td>GPIO_Pin_1</td><td>选中管脚 1</td></tr><tr><td>GPIO_Pin_2</td><td>选中管脚 2</td></tr><tr><td>GPIO_Pin_3</td><td>选中管脚 3</td></tr><tr><td>GPIO_Pin_4</td><td>选中管脚 4</td></tr><tr><td>GPIO_Pin_5</td><td>选中管脚 5</td></tr><tr><td>GPIO_Pin_6</td><td>选中管脚 6</td></tr><tr><td>GPIO_Pin_7</td><td>选中管脚 7</td></tr><tr><td>GPIO_Pin_8</td><td>选中管脚 8</td></tr><tr><td>GPIO_Pin_9</td><td>选中管脚 9</td></tr><tr><td>GPIO_Pin_10</td><td>选中管脚 10</td></tr><tr><td>GPIO_Pin_11</td><td>选中管脚 11</td></tr><tr><td>GPIO_Pin_12</td><td>选中管脚 12</td></tr><tr><td>GPIO_Pin_13</td><td>选中管脚 13</td></tr><tr><td>GPIO_Pin_14</td><td>选中管脚 14</td></tr><tr><td>GPIO_Pin_15</td><td>选中管脚 15</td></tr><tr><td>GPIO_Pin_All</td><td>选中全部管脚</td></tr></tbody></table></div><p>通常情况下，如果引脚为逻辑高电平，则返回 1；如果引脚为逻辑低电平，则返回 0。</p><p>用于读取指定 GPIO 引脚的输入状态。该函数将返回一个 <code>uint8_t</code> 类型的值，表示指定引脚的输入状态。<br>uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p><p>用于读取指定 GPIO 端口的输入数据。该函数将返回一个 <code>uint16_t</code> 类型的值，表示指定 GPIO 端口的输入数据。<br>uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);</p><p>读取指定 GPIO 引脚的输出状态。该函数将返回一个 <code>uint8_t</code> 类型的值，表示指定引脚的输出状态。<br>uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p><p>读取指定 GPIO 引脚的输出状态。该函数将返回一个 <code>uint16_t</code> 类型的值，表示指定引脚的输出状态。<br>uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);</p><p>将指定的 GPIO 引脚的输出设置为逻辑高电平（1）<br>void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p><p>将指定的 GPIO 引脚的输出位重置为逻辑低电平（0）<br>void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);</p><p>用于设置指定 GPIO 引脚的输出状态。该函数将根据 <code>BitVal</code> 参数设置指定引脚的输出状态。<code>BitVal</code>：要设置的输出状态，可以是 <code>Bit_RESET</code>（低电平）或 <code>Bit_SET</code>（高电平）<br>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);</p><p>用于将指定值写入 GPIO 端口的输出寄存器。<code>PortVal</code>：要写入输出寄存器的值.该函数将把 <code>PortVal</code> 的值写入指定 GPIO 端口的输出寄存器，从而设置该端口的所有引脚的输出状态。例如，如果将 <code>PortVal</code> 设置为二进制数 <code>0000 0011</code>，则会将 GPIO 端口的前两个引脚设置为高电平，而其他引脚保持低电平状态。<br>void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);</p><h4 id="中断函数"><a href="#中断函数" class="headerlink" title="中断函数"></a>中断函数</h4><p>选择用作 EXTI 线的 GPIO 引脚。<br>void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)</p><p>设置优先级分组：先占优先级和从优先级<br>void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)<br>NVIC_PriorityGroup 值</p><div class="table-container"><table><thead><tr><th>NVIC_PriorityGroup</th><th>描述</th></tr></thead><tbody><tr><td>NVIC_PriorityGroup_0</td><td>先占优先级 0 位 从优先级 4 位</td></tr><tr><td>NVIC_PriorityGroup_1</td><td>先占优先级 1 位 从优先级 3 位</td></tr><tr><td>NVIC_PriorityGroup_2</td><td>先占优先级 2 位 从优先级 2 位</td></tr><tr><td>NVIC_PriorityGroup_3</td><td>先占优先级 3 位 从优先级 1 位</td></tr><tr><td>NVIC_PriorityGroup_4</td><td>先占优先级 4 位 从优先级 0 位</td></tr></tbody></table></div><p>获取外部中断的中断触发状态<br>EXTI_Line 的状态（SET 或者 RESET）</p><p>EXTI_GetITStatus(uint32_t EXTI_Line)</p><div class="table-container"><table><thead><tr><th>EXTI_Line</th><th>描述</th></tr></thead><tbody><tr><td>EXTI_Line0</td><td>外部中断线 0</td></tr><tr><td>EXTI_Line1</td><td>外部中断线 1</td></tr><tr><td>EXTI_Line2</td><td>外部中断线 2</td></tr><tr><td>EXTI_Line3</td><td>外部中断线 3</td></tr><tr><td>EXTI_Line4</td><td>外部中断线 4</td></tr><tr><td>EXTI_Line5</td><td>外部中断线 5</td></tr><tr><td>EXTI_Line6</td><td>外部中断线 6</td></tr><tr><td>EXTI_Line7</td><td>外部中断线 7</td></tr><tr><td>EXTI_Line8</td><td>外部中断线 8</td></tr><tr><td>EXTI_Line9</td><td>外部中断线 9</td></tr><tr><td>EXTI_Line10</td><td>外部中断线 10</td></tr><tr><td>EXTI_Line11</td><td>外部中断线 11</td></tr><tr><td>EXTI_Line12</td><td>外部中断线 12</td></tr><tr><td>EXTI_Line13</td><td>外部中断线 13</td></tr><tr><td>EXTI_Line14</td><td>外部中断线 14</td></tr><tr><td>EXTI_Line15</td><td>外部中断线 15</td></tr><tr><td>EXTI_Line16</td><td>外部中断线 16</td></tr><tr><td>EXTI_Line17</td><td>外部中断线 17</td></tr><tr><td>EXTI_Line18</td><td>外部中断线 18</td></tr></tbody></table></div><h4 id="定时器函数"><a href="#定时器函数" class="headerlink" title="定时器函数"></a>定时器函数</h4><p>将外设 TIM1 寄存器重设为缺省值（默认值）<br>void TIM_DeInit(TIM_TypeDef* TIMx)<br>TIMx： x 可以是 2， 3 或者 4，来选择 TIM 外设<br>例：<br>TIM_DeInit(TIM2);  </p><p> 启用或禁用指定的 TIM 外设<br>void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)</p><p>根据 TIM_TimeBaseInitStruct 中指定的参数初始化 TIMx 的时间基数单位</p><p>void TIM_TimeBaseInit(TIM_TypeDef<em> TIMx, TIM_TimeBaseInitTypeDef</em> TIM_TimeBaseInitStruct)</p><p>TIM_TimeBaseInitTypeDef structure<br>TIM_TimeBaseInitTypeDef 定义于文件“stm32f10x_tim.h”：<br>typedef struct<br>{<br>u16 TIM_Period;<br>u16 TIM_Prescaler;<br>u8 TIM_ClockDivision;<br>u16 TIM_CounterMode;<br>} TIM_TimeBaseInitTypeDef;<br>TIM_Period<br>TIM_Period 设置了在下一个更新事件装入活动的自动重装载寄存器周期的值。它的取值必须在 0x0000 和<br>0xFFFF 之间。<br>TIM_Prescaler<br>TIM_Prescaler 设置了用来作为 TIMx 时钟频率除数的预分频值。它的取值必须在 0x0000 和 0xFFFF 之间。<br>TIM_ClockDivision<br>TIM_ClockDivision 设置了时钟分割。该参数取值见下表。  Table 461. TIM_ClockDivision 值</p><div class="table-container"><table><thead><tr><th>TIM_ClockDivision</th><th>描述</th></tr></thead><tbody><tr><td>TIM_CKD_DIV1</td><td>TDTS = Tck_tim</td></tr><tr><td>TIM_CKD_DIV2</td><td>TDTS = 2Tck_tim</td></tr><tr><td>TIM_CKD_DIV4</td><td>TDTS = 4Tck_tim</td></tr></tbody></table></div><p>TIM_CounterMode<br>TIM_CounterMode 选择了计数器模式。该参数取值见下表。<br>Table 462. TIM_CounterMode 值</p><div class="table-container"><table><thead><tr><th>TIM_CounterMode</th><th>描述</th></tr></thead><tbody><tr><td>TIM_CounterMode_Up</td><td>TIM 向上计数模式</td></tr><tr><td>TIM_CounterMode_Down</td><td>TIM 向下计数模式</td></tr><tr><td>TIM_CounterMode_CenterAligned1</td><td>TIM 中央对齐模式 1 计数模式</td></tr><tr><td>TIM_CounterMode_CenterAligned2</td><td>TIM 中央对齐模式 2 计数模式</td></tr><tr><td>TIM_CounterMode_CenterAligned3</td><td>TIM 中央对齐模式 3 计数模式</td></tr></tbody></table></div><p>例：<br>TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;<br>TIM_TimeBaseStructure.TIM_Period = 0xFFFF;<br>TIM_TimeBaseStructure.TIM_Prescaler = 0xF;<br>TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;<br>TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>TIM_TimeBaseInit(TIM2, &amp; TIM_TimeBaseStructure);</p><p>高级定时器<br>TIM1_RepetitionCounter<br>TIM1_RepetitionCounter设置了周期计数器值。 RCR向下计数器每次计数至0，会产生一个更新事件且计数<br>器重新由RCR值（N）开始计数。<br>这意味着在PWM模式（N+1）对应着：<br>z 边沿对齐模式下PWM周期数<br>z 中央对齐模式下PWM半周期数<br>它的取值必须在0x00和0xFF之间。  </p><p>配置 TIMx 内部时钟<br>void TIM_InternalClockConfig(TIM_TypeDef* TIMx)</p><p>清除 TIMx 的挂起标志。<br>void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)</p><p>启用或禁用指定的 TIM 中断。<br>void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)</p><p>检查是否发生了 TIM 中断<br>TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)</p><ul><li>SET：表示中断状态已被触发或设置。</li><li>RESET：表示中断状态未被触发或复位。</li></ul><p>通过检查中断状态，可以确定是否发生了特定的中断事件，或者对中断进行操作或处理。</p><p>清除 TIMx 的中断标志位。</p><p>void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)</p><p>TIM_IT<br>输入参数 TIM_IT 使能或者失能 TIM 的中断。可以取下表的一个或者多个取值的组合作为该参数的值。</p><div class="table-container"><table><thead><tr><th>TIM_IT</th><th>描述</th></tr></thead><tbody><tr><td>TIM_IT_Update</td><td>TIM 中断源</td></tr><tr><td>TIM_IT_CC1</td><td>TIM 捕获/比较 1 中断源</td></tr><tr><td>TIM_IT_CC2</td><td>TIM 捕获/比较 2 中断源</td></tr><tr><td>TIM_IT_CC3</td><td>TIM 捕获/比较 3 中断源</td></tr><tr><td>TIM_IT_CC4</td><td>TIM 捕获/比较 4 中断源</td></tr><tr><td>TIM_IT_Trigger</td><td>TIM 触发中断源</td></tr></tbody></table></div><p>获得 TIMx 计数器的值<br>uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)</p><p>设置 TIMx 计数器寄存器值<br>void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)</p><p>配置外部时钟模式2<br>void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)</p><p>根据 TIM_OCInit中指定的参数初始化 TIM 通道<br>TIM_OCInitTypeDe</p><p>根据指定的 TIMx 通道 1/2/3/4 初始化,根据GPIO口选择支持的通道。</p><p> TIMx：其中 x 可以是 1 到 17，但 6 和 7 除外<br>void TIM_OC1Init(TIM_TypeDef<em> TIMx, TIM_OCInitTypeDef</em> TIM_OCInitStruct)</p><p>TIMx：其中 x 可以是 1、2、3、4、5、8、9、12 或 15<br>oid TIM_OC2Init(TIM_TypeDef<em> TIMx, TIM_OCInitTypeDef</em> TIM_OCInitStruct)</p><p>其中 x 可以是 1、2、3、4、5 或 8<br>void TIM_OC3Init(TIM_TypeDef<em> TIMx, TIM_OCInitTypeDef</em> TIM_OCInitStruct)</p><p>TIMx：其中 x 可以是 1、2、3、4、5 或 8 以选择 TIM 外设。<br>void TIM_OC4Init(TIM_TypeDef<em> TIMx, TIM_OCInitTypeDef</em> TIM_OCInitStruct)</p><p>用默认值填充每个值<br>TIM_OCStructInit(&amp;TIM_OCInitStructure); </p><p>设置 TIMx 捕获比较 1 寄存器值<br>void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)</p><p>设置 TIMx 预分频<br>void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)</p><div class="table-container"><table><thead><tr><th>TIM_PSCReloadMode</th><th>描述</th></tr></thead><tbody><tr><td>TIM_PSCReloadMode_Update</td><td>TIM 预分频值在更新事件装入</td></tr><tr><td>TIM_PSCReloadMode_Immediate</td><td>TIM 预分频值即时装入</td></tr></tbody></table></div><p>输入捕捉初始化<br>void TIM_ICInit(TIM_TypeDef<em> TIMx, TIM_ICInitTypeDef</em> TIM_ICInitStruct)</p><p>选择输入触发器源<br>void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)</p><p>选择 TIMx 从模式<br>void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)</p><p>配置输入捕获（Input Capture）模式下的定时器,配置相反的参数<br>（并未在库函数手册找到这个函数）<br>void TIM_PWMIConfig(TIM_TypeDef<em> TIMx, TIM_ICInitTypeDef</em> TIM_ICInitStruct)</p><p>设置 TIMx 编码界面<br>void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,<br>                                                        uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)</p><h4 id="ADC函数"><a href="#ADC函数" class="headerlink" title="ADC函数"></a>ADC函数</h4><p>定义ADC时钟分频器<br>void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)</p><p>设置指定 ADC 的规则组通道，设置它们的转化顺序和采样时间<br>void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)</p><p>重置指定的 ADC 的校准寄存器<br>void ADC_ResetCalibration(ADC_TypeDef* ADCx)</p><p>开始指定 ADC 的校准状态<br>void ADC_StartCalibration(ADC_TypeDef* ADCx)</p><p>获取 ADC 重置校准寄存器的状态<br>ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)</p><p>启用或禁用选定的ADC软件开始转换<br>void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)</p><p>检查是否设置了指定的 ADC 标志位<br>ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)</p><p>返回常规通道的最后一个 ADCx 转换结果数据<br>uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)</p><p>使能或者失能指定的 ADC 的 DMA 请求<br>void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)</p><h4 id="DMA函数"><a href="#DMA函数" class="headerlink" title="DMA函数"></a>DMA函数</h4><p>DMA初始化<br>void DMA_Init(DMA_Channel_TypeDef<em> DMAy_Channelx, DMA_InitTypeDef</em> DMA_InitStruct)</p><p>使能或失能指定的 DMAx 通道<br>void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)</p><p>设置当前 DMAx 通道 传输中的数据单元数<br>void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber)</p><p>清除 DMAy 通道 x 的挂起标志。<br>void DMA_ClearFlag(uint32_t DMAy_FLAG)</p><p>检查是否设置了指定的 DMAy 通道x 标志<br>* @arg DMA1_FLAG_GL1：DMA1 通道 1 全局标志。<br>* @arg DMA1_FLAG_TC1：DMA1 通道 1 传输完成标志。<br>* @arg DMA1_FLAG_HT1：DMA1 通道 1 半传输标志。<br>DMA_GetFlagStatus(uint32_t DMAy_FLAG)</p><h4 id="USART函数"><a href="#USART函数" class="headerlink" title="USART函数"></a>USART函数</h4><p>根据指定的初始化 USARTx 外设<br>void USART_Init(USART_TypeDef<em> USARTx, USART_InitTypeDef</em> USART_InitStruct)</p><p>启用或禁用指定的 USART 外围设备<br>void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)</p><p>检查指定的 USART 中断是否已发生<br>USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)</p><p>返回 USARTx 最近接收的数据<br>uint16_t USART_ReceiveData(USART_TypeDef* USARTx)</p><p>清除 USARTx 的中断挂起位<br>void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)</p><p>通过 USARTx 外设传输单个数据<br>void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)</p><h4 id="I2C函数"><a href="#I2C函数" class="headerlink" title="I2C函数"></a>I2C函数</h4><p>检查最近一次 I2C 事件是否是输入的事件ErrorStatus<br>枚举值： SUCCESS：最近一次 I2C 事件是 I2C_Event ERROR：最近一次 I2C 事件不是 I2C_Event<br>ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)</p><p>I2Cx 通信启动条件<br>void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)</p><p>向指定的从 I2C 设备传送地址字<br>void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)</p><div class="table-container"><table><thead><tr><th>I2C_Direction</th><th>描述</th></tr></thead><tbody><tr><td>I2C_Direction_Transmitter</td><td>选择发送方向</td></tr><tr><td>I2C_Direction_Receiver</td><td>选择接收方向</td></tr></tbody></table></div><p>通过外设 I2Cx 发送一个数据<br>void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)</p><p> I2Cx 通信停止条件<br>void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)</p><p>使能或者失能指定 I2C 的应答功能<br>void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)</p><p>返回 I2Cx 外设最近接收的数据。<br>uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)</p><p>初始化 I2Cx 外设<br>void I2C_Init(I2C_TypeDef<em> I2Cx, I2C_InitTypeDef</em> I2C_InitStruct)</p><h4 id="SPI函数"><a href="#SPI函数" class="headerlink" title="SPI函数"></a>SPI函数</h4><p>初始化 SPIx 外设<br>void SPI_Init(SPI_TypeDef<em> SPIx, SPI_InitTypeDef</em> SPI_InitStruct)</p><p>检查是否设置了指定的 SPI/I2S 标志。<br>FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)</p><p>通过 SPIx/I2Sx 外设传输数据。<br>void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)</p><p>返回 SPIx/I2Sx 外设最近接收的数据。<br>uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)</p><h4 id="BKP"><a href="#BKP" class="headerlink" title="BKP"></a>BKP</h4><p>将用户数据写入指定的数据备份寄存器<br>void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)</p><p>从指定的数据备份寄存器读取数据<br>uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)</p><h4 id="PWR"><a href="#PWR" class="headerlink" title="PWR"></a>PWR</h4><p>启用或禁用对 RTC 和备份寄存器的访问<br>void PWR_BackupAccessCmd(FunctionalState NewState)</p><p>进入待机（STANDBY）模式<br>void PWR_EnterSTANDBYMode(void)</p><p>进入停止（STOP）模式</p><p>void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)</p><p>__WFI();   睡眠模式，中断唤醒</p><p>__WFE();  睡眠模式，事件唤醒</p><p>使能或者失能唤醒管脚功能<br>void PWR_WakeUpPinCmd(FunctionalState NewState)</p><h4 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h4><p>获取 RTC 计数器的值<br>uint32_t RTC_GetCounter(void)</p><p>等待 RTC 注册<br>void RTC_WaitForSynchro(void)</p><p>等待最近一次对 RTC 寄存器的写操作完成<br>void RTC_WaitForLastTask(void)</p><p>设置 RTC 计数器的值<br>void RTC_SetCounter(uint32_t CounterValue)</p><p>设置 RTC 闹钟的值<br>void RTC_SetAlarm(uint32_t AlarmValue)</p><h4 id="System"><a href="#System" class="headerlink" title="System"></a>System</h4><p>设置微控制器系统<br>* 初始化嵌入式闪存接口、PLL并更新<br>* 系统核心时钟变量<br>void SystemInit (void)</p><h3 id="C语言知识"><a href="#C语言知识" class="headerlink" title="C语言知识"></a>C语言知识</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>在32位单片机中，int类型通常被定义为占用32位，也就是4个字节的存储空间。这是因为在这种架构下，处理器的数据总线宽度通常为32位，也就是说，处理器能够一次读写32位的数据，而不需要进行多次操作。因此，将int类型定义为32位可以提高数据的处理速度和效率。</p><div class="table-container"><table><thead><tr><th style="text-align:center">关键字</th><th style="text-align:center">位数</th><th style="text-align:center">表示范围</th><th style="text-align:center">stdint关键字</th><th style="text-align:center">ST关键字</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">8</td><td style="text-align:center">-128 ~ 127</td><td style="text-align:center">int8_t</td><td style="text-align:center">s8</td></tr><tr><td style="text-align:center">unsigned char</td><td style="text-align:center">8</td><td style="text-align:center">0 ~ 255</td><td style="text-align:center">uint8_t</td><td style="text-align:center">u8</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">-32768 ~ 32767</td><td style="text-align:center">int16_t</td><td style="text-align:center">s16</td></tr><tr><td style="text-align:center">unsigned short</td><td style="text-align:center">16</td><td style="text-align:center">0 ~ 65535</td><td style="text-align:center">uint16_t</td><td style="text-align:center">u16</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">==32==</td><td style="text-align:center">-2147483648 ~ 2147483647</td><td style="text-align:center">int32_t</td><td style="text-align:center">s32</td></tr><tr><td style="text-align:center">unsigned int</td><td style="text-align:center">32</td><td style="text-align:center">0 ~ 4294967295</td><td style="text-align:center">uint32_t</td><td style="text-align:center">u32</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">32</td><td style="text-align:center">-2147483648 ~ 2147483647</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">unsigned long</td><td style="text-align:center">32</td><td style="text-align:center">0 ~ 4294967295</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">64</td><td style="text-align:center">-(2^64)/2 ~ (2^64)/2-1</td><td style="text-align:center">int64_t</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">unsigned long long</td><td style="text-align:center">64</td><td style="text-align:center">0 ~ (2^64)-1</td><td style="text-align:center">uint64_t</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">-3.4e38 ~ 3.4e38</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">-1.7e308 ~ 1.7e308</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>•关键字：==#define==</p><p>•用途：用一个字符串代替一个数字，便于理解，防止出错；提取程序中经常出现的参数，便于快速修改</p><p>•定义宏定义：</p><p> #define ABC 12345</p><p>•引用宏定义：</p><p> int a = ABC; //等效于int a = 12345;</p><h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>•关键字：typedef</p><p>•用途：将一个比较长的变量类型名换个名字，便于使用</p><p>•定义typedef：</p><p> typedef unsigned char uint8_t;</p><p>•引用typedef：</p><p>  uint8_t a; //等效于unsigned char a;</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>•关键字：struct</p><p>•用途：数据打包，不同类型变量的集合</p><p>•定义结构体变量：</p><p> struct{char x; int y; float z;} StructName;</p><p> 因为结构体变量类型较长，所以通常用typedef更改变量类型名</p><p>•引用结构体成员：</p><p> StructName.x = ‘A’;</p><p> StructName.y = 66;</p><p> StructName.z = 1.23;</p><p>或 pStructName-&gt;x = ‘A’; //pStructName为结构体的地址 pStructName-&gt;y = 66;</p><p> pStructName-&gt;z = 1.23;</p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>•关键字：enum</p><p>•用途：定义一个取值受限制的整型变量，用于限制变量取值范围；宏定义的集合</p><p>•定义枚举变量：</p><p> enum{FALSE = 0, TRUE = 1} EnumName;</p><p> 因为枚举变量类型较长，所以通常用typedef更改变量类型名</p><p>•引用枚举成员：</p><p> EnumName = FALSE;</p><p> EnumName = TRUE;</p><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>GPIO（General Purpose Input Output）通用输入输出口</p><ul><li>可配置为8种输入输出模式</li><li>引脚电平：0V~3.3V，部分引脚可容忍5V</li><li>输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等</li><li>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</li></ul><h4 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h4><p>STM32是32位的单片机，所以寄存器都是32位的，但是端口只有16位，所以这个寄存器只有低16位对应的有端口，高16位是没有用到的。寄存器只负责存储数据，如果要进行电灯这样的操作，需要驱动器来增加驱动能力</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831021526708.png" alt="image-20230831021526708"></p><h4 id="GPIO位结构"><a href="#GPIO位结构" class="headerlink" title="GPIO位结构"></a>GPIO位结构</h4><p>肖特基触发器是翻译错误，实际是施密特触发器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831022147467.png" alt="image-20230831022147467"></p><p>施密特触发器（Schmitt Trigger）是一种常用的电子电路，用于去除输入信号的噪声和抖动，并形成稳定的输出信号。它具有两个阈值电压：上阈值和下阈值。</p><ul><li>==当输入信号高于上阈值时，输出信号被拉高；当输入信号低于下阈值时，输出信号被拉低。在输入信号处于两个阈值之间时，输出信号将保持其先前的状态。==</li><li>施密特触发器可以用于消除输入信号中的干扰和毛刺，以确保稳定的输出。它在数字电路、模拟电路和通信系统中都有广泛的应用，例如信号整形、频率分割、模数转换等。</li><li>在数字电路中，施密特触发器常用于消除开关抖动、去除无效信号和进行边沿检测。它通常由一个比较器和一个正反馈网络组成，通过调整正反馈电路的阈值电压来控制触发器的灵敏度。</li></ul><h4 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h4><p>• 通过配置GPIO的端口配置寄存器，端口可以配置成以下8种模式</p><div class="table-container"><table><thead><tr><th><strong>模式名称</strong></th><th><strong>性质</strong></th><th style="text-align:center">特征</th><th style="text-align:center">Code</th></tr></thead><tbody><tr><td>浮空输入</td><td>数字输入</td><td style="text-align:center">可读取引脚电平，若引脚悬空，则电平不确定</td><td style="text-align:center">GPIO_Mode_IN_FLOATING</td></tr><tr><td>上拉输入</td><td>数字输入</td><td style="text-align:center">可读取引脚电平，内部连接上拉电阻，悬空时默认高电平</td><td style="text-align:center">GPIO_Mode_IPU</td></tr><tr><td>下拉输入</td><td>数字输入</td><td style="text-align:center">可读取引脚电平，内部连接下拉电阻，悬空时默认低电平</td><td style="text-align:center">GPIO_Mode_IPD</td></tr><tr><td>模拟输入</td><td>模拟输入</td><td style="text-align:center">GPIO无效，引脚直接接入内部ADC</td><td style="text-align:center">GPIO_Mode_AIN</td></tr><tr><td>开漏输出</td><td>数字输出</td><td style="text-align:center">可输出引脚电平，高电平为高阻态，低电平接VSS</td><td style="text-align:center">GPIO_Mode_Out_OD</td></tr><tr><td>推挽输出</td><td>数字输出</td><td style="text-align:center">可输出引脚电平，高电平接VDD，低电平接VSS</td><td style="text-align:center">GPIO_Mode_Out_PP</td></tr><tr><td>复用开漏输出</td><td>数字输出</td><td style="text-align:center">由片上外设控制，高电平为高阻态，低电平接VSS</td><td style="text-align:center">GPIO_Mode_AF_OD</td></tr><tr><td>复用推挽输出</td><td>数字输出</td><td style="text-align:center">由片上外设控制，高电平接VDD，低电平接VSS</td><td style="text-align:center">GPIO_Mode_AF_PP</td></tr></tbody></table></div><p>一个端口只能有一个输出，但可以有多个输入</p><p><strong>输入配置</strong></p><p>当I/O端口配置为输入时：<br>● 输出缓冲器被禁止<br>● 施密特触发输入被激活<br>● 根据输入配置(上拉，下拉或浮动)的不同，弱上拉和下拉电阻被连接<br>● 出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器<br>● 对输入数据寄存器的读访问可得到I/O状态  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831023243194.png" alt="image-20230831023243194"></p><p><strong>输出配置</strong>  </p><p>当I/O端口被配置为输出时：<br>● 输出缓冲器被激活<br>─ 开漏模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将端口置于高阻状态(P<br>MOS从不被激活)。<br>─ 推挽模式：输出寄存器上的’0’激活N-MOS，而输出寄存器上的’1’将激活P-MOS。<br>● 施密特触发输入被激活<br>● 弱上拉和下拉电阻被禁止<br>● 出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器<br>● 在开漏模式时，对输入数据寄存器的读访问可得到I/O状态<br>● 在推挽式模式时，对输出数据寄存器的读访问得到最后一次写的值。<br>下图给出了I/O端口位的输出配置。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831023702920.png" alt="image-20230831023702920"></p><p><strong>复用功能配置</strong></p><p>当I/O端口被配置为复用功能时：<br>● 在开漏或推挽式配置中，输出缓冲器被打开<br>● 内置外设的信号驱动输出缓冲器(复用功能输出)<br>● 施密特触发输入被激活<br>● 弱上拉和下拉电阻被禁止<br>● 在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器<br>● 开漏模式时，读输入数据寄存器时可得到I/O口状态<br>● 在推挽模式时，读输出数据寄存器时可得到最后一次写的值<br>下图示出了I/O端口位的复用功能配置。详见8.4节-AFIO寄存器描述。<br>一组复用功能I/O寄存器允许用户把一些复用功能重新映象到不同的引脚。  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831023716250.png" alt="image-20230831023716250"></p><p><strong>模拟输入配置</strong></p><p>当I/O端口被配置为模拟输入配置时：<br>● 输出缓冲器被禁止；<br>● 禁止施密特触发输入，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置<br>为’0’；<br>● 弱上拉和下拉电阻被禁止；<br>● 读取输入数据寄存器时数值为’0’  </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831023443776.png" alt="image-20230831023443776"></p><h3 id="LED-amp-蜂鸣器"><a href="#LED-amp-蜂鸣器" class="headerlink" title="LED&amp;蜂鸣器"></a>LED&amp;蜂鸣器</h3><p>LED和蜂鸣器简介</p><p>•LED：发光二极管，正向通电点亮，反向通电不亮</p><p>•有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定<br>•无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025339519.png" alt="image-20230831025339519"></p><h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025849446.png" alt="image-20230831025849446"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025902242.png" alt="image-20230831025902242"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025908208.png" alt="image-20230831025908208"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025913447.png" alt="image-20230831025913447"></p><p>面包板</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831025948757.png" alt="image-20230831025948757"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831030002760.png" alt="image-20230831030002760"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831030007734.png" alt="image-20230831030007734"></p><p>LED闪烁</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230831030126285.png" alt="image-20230831030126285"></p><p>LED流水灯</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230903150956007.png" alt="image-20230903150956007"></p><p>蜂鸣器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230903151015374.png" alt="image-20230903151015374"></p><h4 id="软件代码"><a href="#软件代码" class="headerlink" title="软件代码"></a>软件代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line"><span class="comment">// GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"> GPIO_ResetBits(GPIOA,GPIO_Pin_0);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">   GPIO_SetBits(GPIOA,GPIO_Pin_0);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,(BitAction)<span class="number">0</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_WriteBit(GPIOA,GPIO_Pin_0,(BitAction)<span class="number">1</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0001</span>);  <span class="comment">//0000 0000 0000 0001</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0002</span>);  <span class="comment">//0000 0000 0000 0010</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0004</span>);  <span class="comment">//0000 0000 0000 0100</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0008</span>);  <span class="comment">//0000 0000 0000 1000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0010</span>);  <span class="comment">//0000 0000 0001 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0020</span>);  <span class="comment">//0000 0000 0010 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0040</span>);  <span class="comment">//0000 0000 0100 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">GPIO_Write(GPIOA, ~<span class="number">0x0080</span>);  <span class="comment">//0000 0000 1000 0000</span></span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">100</span>); </span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">Delay_ms(<span class="number">700</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h3><p>传感器模块简介</p><p>•传感器模块：传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化，通过与定值电阻分压即可得到模拟电压输出，再通过电压比较器进行二值化即可得到数字电压输出</p><p>从左到右依次是  光敏电阻传感器，热敏电阻传感器，红外对射，对射式红外传感器，反射式红外传感器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230904101607674.png" alt="image-20230904101607674"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230904101621909.png" alt="image-20230904101621909"></p><h3 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h3><p>按键简介</p><ul><li>按键：常见的输入设备，按下导通，松手断开</li><li>按键抖动：由于按键内部使用的是机械式弹簧片来进行通断的，所以在按下和松手的瞬间会伴随有一连串的抖动</li></ul><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230904101515501.png" alt="image-20230904101515501"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230904101526700.png" alt="image-20230904101526700"></p><h4 id="硬件电路-1"><a href="#硬件电路-1" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230904103103343.png" alt="image-20230904103103343"></p><p>接线图</p><p>按键控制LED        </p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905070056947.png" alt="image-20230905070056947"></p><p>光敏电阻控制蜂鸣器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905070107337.png" alt="image-20230905070107337"></p><h4 id="软件代码-1"><a href="#软件代码-1" class="headerlink" title="软件代码"></a>软件代码</h4><h5 id="按键控制LED"><a href="#按键控制LED" class="headerlink" title="按键控制LED"></a>按键控制LED</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">LED.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   LED_Init</span></span><br><span class="line"><span class="comment">* @brief  LED初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line">    </span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_1 | GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点亮LED1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭LED1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转LED1状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOA,GPIO_Pin_1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//点亮LED2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭LED2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻转LED2状态</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOA,GPIO_Pin_2) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_SetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        GPIO_ResetBits(GPIOA,GPIO_Pin_2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line">LED.h</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED1_Turn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED2_Turn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">Key.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Includes ------------------------------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;main.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private variables----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Public variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Key_Init</span></span><br><span class="line"><span class="comment">* @brief  Key初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructrue;</span><br><span class="line">    GPIO_InitStructrue.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructrue.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;</span><br><span class="line">    GPIO_InitStructrue.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructrue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Key_GetNum</span></span><br><span class="line"><span class="comment">* @brief  获取按键的值</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval 返回按键的值      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> Key_GetNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay_ms(<span class="number">20</span>);  <span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_1) == <span class="number">0</span>)  <span class="comment">//松开按键响应</span></span><br><span class="line">        Delay_ms(<span class="number">20</span>);  <span class="comment">//消抖</span></span><br><span class="line">        Key_GetNum = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Delay_ms(<span class="number">20</span>);  <span class="comment">//消抖</span></span><br><span class="line">        <span class="keyword">while</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11) == <span class="number">0</span>)  <span class="comment">//松开按键响应</span></span><br><span class="line">        Delay_ms(<span class="number">20</span>);  <span class="comment">//消抖</span></span><br><span class="line">        Key_GetNum = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Key_GetNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line">Key.h</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> <span class="title function_">Key_GetNum</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   main</span></span><br><span class="line"><span class="comment">* @brief  主函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  LED_Init();</span><br><span class="line">  Key_Init();</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum = Key_GetNum();</span><br><span class="line">        <span class="keyword">if</span>(KeyNum == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LED1_Turn();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(KeyNum == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          LED2_Turn();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="光敏电阻控制蜂鸣器"><a href="#光敏电阻控制蜂鸣器" class="headerlink" title="光敏电阻控制蜂鸣器"></a>光敏电阻控制蜂鸣器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">buzzer.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStucture;</span><br><span class="line">GPIO_InitStucture.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStucture.GPIO_Pin = GPIO_Pin_12;</span><br><span class="line">GPIO_InitStucture.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStucture);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Turn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(GPIO_ReadOutputDataBit(GPIOB,GPIO_Pin_12)== <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_SetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOB,GPIO_Pin_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buzzer.h</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_ON</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_OFF</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Buzzer_Turn</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">LightSensor.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LightSensor.h</span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">LightSensor_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">LightSensor_Get</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  Buzzer_Init();</span><br><span class="line">  LightSensor_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(LightSensor_Get() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          Buzzer_ON();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">          Buzzer_OFF();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h3><h4 id="OLED简介"><a href="#OLED简介" class="headerlink" title="OLED简介"></a>OLED简介</h4><p>•OLED（Organic Light Emitting Diode）：有机发光二极管</p><p>•OLED显示屏：性能优异的新型显示屏，具有功耗低、相应速度快、宽视角、轻薄柔韧等特点</p><p>•0.96寸OLED模块：小巧玲珑、占用接口少、简单易用，是电子设计中非常常见的显示屏模块</p><p>•供电：3~5.5V，通信协议：I2C/SPI，分辨率：128*64</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905072641111.png" alt="image-20230905072641111"></p><h4 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h4><ul><li><p>串口调试：通过串口通信，将调试信息发送到电脑端，电脑使用串口助手显示调试信息</p></li><li><p>显示屏调试：直接将显示屏连接到单片机，将调试信息打印在显示屏上</p></li><li><p>Keil调试模式：借助Keil软件的调试模式，可使用单步运行、设置断点、查看寄存器及变量等功能</p></li></ul><h4 id="OLED驱动函数"><a href="#OLED驱动函数" class="headerlink" title="OLED驱动函数"></a>OLED驱动函数</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905072955489.png" alt="image-20230905072955489"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905073030765.png" alt="image-20230905073030765"></p><div class="table-container"><table><thead><tr><th><strong>函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>OLED_Init();</td><td>初始化</td></tr><tr><td>OLED_Clear();</td><td>清屏</td></tr><tr><td>OLED_ShowChar(1, 1, ‘A’);</td><td>显示一个字符</td></tr><tr><td>OLED_ShowString(1, 3,  “HelloWorld!”);</td><td>显示字符串</td></tr><tr><td>OLED_ShowNum(2, 1, 12345, 5);</td><td>显示十进制数字</td></tr><tr><td>OLED_ShowSignedNum(2, 7, -66, 2);</td><td>显示有符号十进制数字</td></tr><tr><td>OLED_ShowHexNum(3, 1, 0xAA55, 4);</td><td>显示十六进制数字</td></tr><tr><td>OLED_ShowBinNum(4, 1, 0xAA55, 16);</td><td>显示二进制数字</td></tr></tbody></table></div><h4 id="硬件电路-2"><a href="#硬件电路-2" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905072814414.png" alt="image-20230905072814414"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905072823097.png" alt="image-20230905072823097"></p><p>接线图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905073133961.png" alt="image-20230905073133961"></p><h3 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h3><h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>•中断：在主程序运行过程中，出现了特定的中断触发条件（中断源），使得CPU暂停当前正在运行的程序，转而去处理中断程序，处理完成后又返回原来被暂停的位置继续运行</p><p>•中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p><p>•中断嵌套：当一个中断程序正在运行时，又有新的更高优先级的中断源申请中断，CPU再次暂停当前中断程序，转而去处理新的中断程序，处理完成后依次进行返回</p><h4 id="中断执行流程"><a href="#中断执行流程" class="headerlink" title="中断执行流程"></a>中断执行流程</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905094907300.png" alt="image-20230905094907300"></p><h4 id="STM32中断"><a href="#STM32中断" class="headerlink" title="STM32中断"></a>STM32中断</h4><p>•68个可屏蔽中断通道，包含EXTI、TIM、ADC、USART、SPI、I2C、RTC等多个外设</p><p>•使用NVIC统一管理中断，每个中断通道都拥有16个可编程的优先等级，可对优先级进行分组，进一步设置抢占优先级和响应优先级</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095236990.png" alt="image-20230905095236990"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095358820.png" alt="image-20230905095358820"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095418988.png" alt="image-20230905095418988"></p><h4 id="NVIC基本结构"><a href="#NVIC基本结构" class="headerlink" title="NVIC基本结构"></a>NVIC基本结构</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095536049.png" alt="image-20230905095536049"></p><p>NVIC优先级分组</p><p>•NVIC的中断优先级由优先级寄存器的4位（0~15）决定，这4位可以进行切分，分为高n位的抢占优先级和低4-n位的响应优先级</p><p>•抢占优先级高的可以中断嵌套，响应优先级高的可以优先排队，抢占优先级和响应优先级均相同的按中断号排队</p><div class="table-container"><table><thead><tr><th><strong>分组方式</strong></th><th><strong>抢占优先级</strong></th><th><strong>响应优先级</strong></th></tr></thead><tbody><tr><td>分组0</td><td>0位，取值为0</td><td>4位，取值为0~15</td></tr><tr><td>分组1</td><td>1位，取值为0~1</td><td>3位，取值为0~7</td></tr><tr><td>分组2</td><td>2位，取值为0~3</td><td>2位，取值为0~3</td></tr><tr><td>分组3</td><td>3位，取值为0~7</td><td>1位，取值为0~1</td></tr><tr><td>分组4</td><td>4位，取值为0~15</td><td>0位，取值为0</td></tr></tbody></table></div><h4 id="EXTI简介"><a href="#EXTI简介" class="headerlink" title="EXTI简介"></a>EXTI简介</h4><p>•EXTI（Extern Interrupt）外部中断</p><p>•EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO口产生电平变化时，EXTI将立即向NVIC发出中断申请，经过NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p><p>•支持的触发方式：上升沿/下降沿/双边沿/软件触发</p><p>•支持的GPIO口：所有GPIO口，但相同的Pin不能同时触发中断</p><p>•通道数：16个GPIO_Pin，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p><p>•触发响应方式：中断响应/事件响应</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905100742481.png" alt="image-20230905100742481"></p><h4 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h4><p>•AFIO主要用于引脚复用功能的选择和重定义</p><p>•在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095730738.png" alt="image-20230905095730738"></p><h4 id="EXTI框图"><a href="#EXTI框图" class="headerlink" title="EXTI框图"></a>EXTI框图</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095647375.png" alt="image-20230905095647375"></p><h3 id="旋转编码器"><a href="#旋转编码器" class="headerlink" title="旋转编码器"></a>旋转编码器</h3><p>旋转编码器简介</p><p>•旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</p><p>•类型：机械触点式/霍尔传感器式/光栅式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905095939699.png" alt="image-20230905095939699"></p><h4 id="硬件电路-3"><a href="#硬件电路-3" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905100117976.png" alt="image-20230905100117976"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905100124273.png" alt="image-20230905100124273"></p><p>接线图</p><p>对射式红外传感器计次</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905100302777.png" alt="image-20230905100302777"></p><p>旋转编码器计次</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905100315301.png" alt="image-20230905100315301"></p><h4 id="软件代码-2"><a href="#软件代码-2" class="headerlink" title="软件代码"></a>软件代码</h4><p>对射式红外传感器计次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">CountSensor.c </span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> CountSensor_Count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   CountSensor_Init</span></span><br><span class="line"><span class="comment">* @brief  对射红外初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);</span><br><span class="line"></span><br><span class="line">    EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">    EXTI_InitStructure.EXTI_Line = EXTI_Line14;</span><br><span class="line">    EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">    EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line">     </span><br><span class="line">     NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">     NVIC_InitStructure.NVIC_IRQChannel =  EXTI15_10_IRQn;</span><br><span class="line">     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">     NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">     NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> CountSensor_Count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI15_10_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line14) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_14) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CountSensor_Count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line14);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CountSensor.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COUNTSENSOR_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COUNTSENSOR_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/********************************************************</span></span><br><span class="line"><span class="comment">  End Of File</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Name :&quot;</span>);</span><br><span class="line">  OLED_ShowString(<span class="number">1</span>,<span class="number">7</span>,<span class="string">&quot;6+1&quot;</span>);</span><br><span class="line">  CountSensor_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;Count:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    OLED_ShowNum(<span class="number">2</span>,<span class="number">7</span>,CountSensor_Get(),<span class="number">5</span>);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p> 旋转编码器计次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">Encoder.c</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Encoder_Count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Encoder_Init </span></span><br><span class="line"><span class="comment">* @brief  旋转译码器初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int16_t</span> Encoder_Count;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource0);</span><br><span class="line">GPIO_EXTILineConfig(GPIO_PortSourceGPIOB, GPIO_PinSource1);</span><br><span class="line"></span><br><span class="line">EXTI_InitTypeDef EXTI_InitStructure;</span><br><span class="line">EXTI_InitStructure.EXTI_Line = EXTI_Line0 | EXTI_Line1;</span><br><span class="line">EXTI_InitStructure.EXTI_LineCmd = ENABLE;</span><br><span class="line">EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;</span><br><span class="line">EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;</span><br><span class="line">EXTI_Init(&amp;EXTI_InitStructure);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int16_t</span> Temp;</span><br><span class="line">Temp = Encoder_Count;</span><br><span class="line">Encoder_Count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line0) == SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Encoder_Count --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (EXTI_GetITStatus(EXTI_Line1) == SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*如果出现数据乱跳的现象，可再次判断引脚电平，以避免抖动*/</span></span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">Encoder_Count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXTI_ClearITPendingBit(EXTI_Line1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Encoder.h</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ENCODER_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ENCODER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern variables-----------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extern function prototypes-------------------------------------------------*/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    </span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @name   main</span></span><br><span class="line"><span class="comment">* @brief  主函数</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  OLED_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Name :&quot;</span>);</span><br><span class="line">  OLED_ShowString(<span class="number">1</span>,<span class="number">7</span>,<span class="string">&quot;6+1&quot;</span>);</span><br><span class="line">  CountSensor_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&quot;Count:&quot;</span>);</span><br><span class="line">  Encoder_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;Num+ :&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    OLED_ShowNum(<span class="number">2</span>,<span class="number">7</span>,CountSensor_Get(),<span class="number">5</span>);  </span><br><span class="line">    Num += Encoder_Get();</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">7</span>, Num, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="TIM"><a href="#TIM" class="headerlink" title="TIM"></a>TIM</h3><h4 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h4><p>•TIM（Timer）定时器</p><p>•定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断</p><p>•16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p><p>•不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能</p><p>•根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p><p>定时器类型</p><div class="table-container"><table><thead><tr><th><strong>类型</strong></th><th><strong>编号</strong></th><th><strong>总线</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>高级定时器</td><td>TIM1、TIM8</td><td>APB2</td><td>拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td></tr><tr><td>通用定时器</td><td>TIM2、TIM3、TIM4、TIM5</td><td>APB1</td><td>拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td></tr><tr><td>基本定时器</td><td>TIM6、TIM7</td><td>APB1</td><td>拥有定时中断、主模式触发DAC的功能</td></tr></tbody></table></div><p>•STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4</p><h4 id="定时器框架图"><a href="#定时器框架图" class="headerlink" title="定时器框架图"></a>定时器框架图</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905201948300.png" alt="image-20230905201948300"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202222722.png" alt="image-20230905202222722"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202325535.png" alt="image-20230905202325535"></p><h4 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202413149.png" alt="image-20230905202413149"></p><h4 id="预分频器时序图"><a href="#预分频器时序图" class="headerlink" title="预分频器时序图"></a>预分频器时序图</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202743870.png" alt="image-20230905202743870"></p><p>•计数器计数频率：CK_CNT = CK_PSC / (PSC + 1)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202809569.png" alt="image-20230905202809569"></p><p>•计数器溢出频率：CK_CNT_OV = CK_CNT / (ARR + 1)  = CK_PSC / (PSC + 1) / (ARR + 1)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905202841059.png" alt="image-20230905202841059"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905203103092.png" alt="image-20230905203103092"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230905203513958.png" alt="image-20230905203513958"></p><h4 id="定时器定时中断-amp-定时器外部时钟"><a href="#定时器定时中断-amp-定时器外部时钟" class="headerlink" title="定时器定时中断&amp;定时器外部时钟"></a>定时器定时中断&amp;定时器外部时钟</h4><h5 id="硬件电路-4"><a href="#硬件电路-4" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>接线图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907165834868.png" alt="image-20230907165834868"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907165848885.png" alt="image-20230907165848885"></p><h5 id="软件代码-3"><a href="#软件代码-3" class="headerlink" title="软件代码"></a>软件代码</h5><p>定时器定时中断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">timer.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">7200</span> - <span class="number">1</span>;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ClearFlag(TIM2, TIM_FLAG_Update);</span><br><span class="line">TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);</span><br><span class="line"></span><br><span class="line">NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    <span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Num:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, Num, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">Num ++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定时器外部时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">timer.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,<span class="number">0x0f</span>);</span><br><span class="line"></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">10</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_ClearFlag(TIM2,TIM_FLAG_Update);</span><br><span class="line">    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);</span><br><span class="line"></span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">2</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   TIM2_IRQHandler</span></span><br><span class="line"><span class="comment">* @brief  定时器中断函数，需要用时直接复制</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">void TIM2_IRQHandler(void)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        TIM_ClearITPendingBit(TIM2,TIM_IT_Update);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   CountSensor_Init</span></span><br><span class="line"><span class="comment">* @brief  对射红外初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">CountSensor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//PB14口用不了定时器2，代码烧进去效果不一样所以要用PA0</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">CountSensor_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// return CountSensor_Count;</span></span><br><span class="line">    <span class="keyword">return</span> TIM_GetCounter(TIM2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> Num;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Num:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;CNT:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, Num, <span class="number">5</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">5</span>, Timer_GetCounter(), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">Num ++;</span><br><span class="line">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TIM输出比较-输入捕获"><a href="#TIM输出比较-输入捕获" class="headerlink" title="TIM输出比较/输入捕获"></a>TIM输出比较/输入捕获</h3><h4 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h4><p>•OC（Output Compare）输出比较</p><p>•输出比较可以通过比较CNT与CCR寄存器值的关系，来对输出电平进行置1、置0或翻转的操作，用于输出一定频率和占空比的PWM波形</p><p>•每个高级定时器和通用定时器都拥有4个输出比较通道</p><p>•高级定时器的前3个通道额外拥有死区生成和互补输出的功能</p><h4 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h4><p>•PWM（Pulse Width Modulation）脉冲宽度调制</p><p>•在具有惯性的系统中，可以通过对一系列脉冲的宽度进行调制，来等效地获得所需要的模拟参量，常应用于电机控速等领域</p><p>•PWM参数：</p><p>   频率 = 1 / TS      占空比 = TON / TS      分辨率 = 占空比变化步距</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907171254558.png" alt="image-20230907171254558"></p><p>输出比较通道(高级)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907171439462.png" alt="image-20230907171439462"></p><p>输出比较通道(通用)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907171534103.png" alt="image-20230907171534103"></p><p>输出比较模式</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>模式</strong></th><th style="text-align:center"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:center">冻结</td><td style="text-align:center">CNT=CCR时，REF保持为原状态</td></tr><tr><td style="text-align:center">匹配时置有效电平</td><td style="text-align:center">CNT=CCR时，REF置有效电平</td></tr><tr><td style="text-align:center">匹配时置无效电平</td><td style="text-align:center">CNT=CCR时，REF置无效电平</td></tr><tr><td style="text-align:center">匹配时电平翻转</td><td style="text-align:center">CNT=CCR时，REF电平翻转</td></tr><tr><td style="text-align:center">强制为无效电平</td><td style="text-align:center">CNT与CCR无效，REF强制为无效电平</td></tr><tr><td style="text-align:center">强制为有效电平</td><td style="text-align:center">CNT与CCR无效，REF强制为有效电平</td></tr><tr><td style="text-align:center">PWM模式1</td><td style="text-align:center">向上计数：CNT<CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平  向下计数：CNT>CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平</td></tr><tr><td style="text-align:center">PWM模式2</td><td style="text-align:center">向上计数：CNT<CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平  向下计数：CNT>CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平</td></tr></tbody></table></div><p>PWM基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172018568.png" alt="image-20230907172018568"></p><p>参数计算</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172205179.png" alt="image-20230907172205179"></p><ul><li><code>Freq</code>：PWM的频率。</li><li><code>CK_PSC</code>：输入到预分频器的时钟频率，通常是系统时钟的频率。 72MKz</li><li><code>PSC</code>：预分频器的分频因子。</li><li><code>ARR</code>：自动重载寄存器的值。</li></ul><p>•PWM频率： Freq = CK_PSC / (PSC + 1) / (ARR + 1)</p><p>•PWM占空比： Duty = CCR / (ARR + 1)</p><p>•PWM分辨率： Reso = 1 / (ARR + 1)</p><h4 id="输入捕获简介"><a href="#输入捕获简介" class="headerlink" title="输入捕获简介"></a>输入捕获简介</h4><p>•IC（Input Capture）输入捕获</p><p>•输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p><p>•每个高级定时器和通用定时器都拥有4个输入捕获通道</p><p>•可配置为PWMI模式，同时测量频率和占空比</p><p>可配合主从触发模式，实现硬件全自动测量</p><p>频率测量</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909175804902.png" alt="image-20230909175804902"></p><p>•测频法：在闸门时间T内，对上升沿计次，得到N，则频率</p><p>f_x=N / T</p><p>•测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率</p><p>f_x=f_c / N</p><p>•中界频率：测频法与测周法误差相等的频率点</p><p>f_m=√(f_c / T)</p><p>输入捕获通道</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909191753221.png" alt="image-20230909191753221"></p><p>主从触发模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909191814696.png" alt="image-20230909191814696"></p><p>输入捕获基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909191933873.png" alt="image-20230909191933873"></p><p>PWMI基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909191950392.png" alt="image-20230909191950392"></p><h4 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h4><p>编码器接口简介</p><p>•Encoder Interface 编码器接口</p><p>•编码器接口可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p><p>•每个高级定时器和通用定时器都拥有1个编码器接口</p><p>•两个输入引脚借用了输入捕获的通道1和通道2</p><p>正交编码器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909192119617.png" alt="image-20230909192119617"></p><p>工作模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909192454408.png" alt="image-20230909192454408"></p><p>实例</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909192522896.png" alt="image-20230909192522896"></p><p>均不反相</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909192509516.png" alt="image-20230909192509516"></p><p>TI1反相</p><p>反相的意思就是TI1电平反过来，高电平变低电平</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909192515995.png" alt="image-20230909192515995"></p><h4 id="硬件电路-5"><a href="#硬件电路-5" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>输入捕获模式测频率&amp;PWMI模式测频率占空比</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909215120344.png" alt="image-20230909215120344"></p><p>编码器接口测速</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230909215139702.png" alt="image-20230909215139702"></p><h4 id="软件代码-4"><a href="#软件代码-4" class="headerlink" title="软件代码"></a>软件代码</h4><p>输入捕获模式测频率</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">PWM.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);</span></span><br><span class="line"><span class="comment">//GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);</span></span><br><span class="line"><span class="comment">//GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);</span></span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<span class="comment">//GPIO_Pin_15;</span></span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;<span class="comment">//CCR</span></span><br><span class="line">TIM_OC1Init(TIM2, &amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare1(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetPrescaler</span><span class="params">(<span class="type">uint16_t</span> Prescaler)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_PrescalerConfig(TIM2, Prescaler, TIM_PSCReloadMode_Immediate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IC.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM3);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">72</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;</span><br><span class="line">TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;</span><br><span class="line">TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;</span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_SelectInputTrigger(TIM3, TIM_TS_TI1FP1);</span><br><span class="line">TIM_SelectSlaveMode(TIM3, TIM_SlaveMode_Reset);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetFreq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1000000</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">PWM_Init();</span><br><span class="line">IC_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Freq:00000Hz&quot;</span>);</span><br><span class="line"></span><br><span class="line">PWM_SetPrescaler(<span class="number">720</span> - <span class="number">1</span>);<span class="comment">//Freq = 72M / (PSC + 1) / 100</span></span><br><span class="line">PWM_SetCompare1(<span class="number">50</span>);<span class="comment">//Duty = CCR / 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, IC_GetFreq(), <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PWMI模式测频率占空比</span><br><span class="line">IC.c</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">IC_GetDuty</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (TIM_GetCapture2(TIM3) + <span class="number">1</span>) * <span class="number">100</span> / (TIM_GetCapture1(TIM3) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">PWM_Init();</span><br><span class="line">IC_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Freq:00000Hz&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Duty:00%&quot;</span>);</span><br><span class="line"></span><br><span class="line">PWM_SetPrescaler(<span class="number">720</span> - <span class="number">1</span>);<span class="comment">//Freq = 72M / (PSC + 1) / 100</span></span><br><span class="line">PWM_SetCompare1(<span class="number">50</span>);<span class="comment">//Duty = CCR / 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, IC_GetFreq(), <span class="number">5</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, IC_GetDuty(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编码器接口测速</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">Encoder.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Encoder_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">65536</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">1</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_ICInitTypeDef TIM_ICInitStructure;</span><br><span class="line">TIM_ICStructInit(&amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line">TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;</span><br><span class="line">TIM_ICInitStructure.TIM_ICFilter = <span class="number">0xF</span>;</span><br><span class="line">TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM3, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> <span class="title function_">Encoder_Get</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int16_t</span> Temp;</span><br><span class="line">Temp = TIM_GetCounter(TIM3);</span><br><span class="line">TIM_SetCounter(TIM3, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int16_t</span> Speed;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Timer_Init();</span><br><span class="line">Encoder_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Speed:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowSignedNum(<span class="number">1</span>, <span class="number">7</span>, Speed, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIM2_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)</span><br><span class="line">&#123;</span><br><span class="line">Speed = Encoder_Get();</span><br><span class="line">TIM_ClearITPendingBit(TIM2, TIM_IT_Update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="舵机-amp-直流电机及驱动"><a href="#舵机-amp-直流电机及驱动" class="headerlink" title="舵机&amp;直流电机及驱动"></a>舵机&amp;直流电机及驱动</h3><h4 id="舵机简介"><a href="#舵机简介" class="headerlink" title="舵机简介"></a>舵机简介</h4><p>•舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p><p>•输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172407197.png" alt="image-20230907172407197"></p><h4 id="直流电机及驱动简介"><a href="#直流电机及驱动简介" class="headerlink" title="直流电机及驱动简介"></a>直流电机及驱动简介</h4><p>•直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转</p><p>•直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作</p><p>•TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172533240.png" alt="image-20230907172533240"></p><h4 id="硬件电路-6"><a href="#硬件电路-6" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>舵机</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172638055.png" alt="image-20230907172638055"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172641990.png" alt="image-20230907172641990"></p><p>直流电机驱动芯片</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172750253.png" alt="image-20230907172750253"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230907172801513.png" alt="image-20230907172801513"></p><p>接线图</p><p>PWM驱动LED 呼吸灯</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230908205211015.png" alt="image-20230908205211015"></p><p>PWM驱动舵机</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230908205217372.png" alt="image-20230908205217372"></p><p>PWM驱动直流电机</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230908205223586.png" alt="image-20230908205223586"></p><h4 id="软件代码-5"><a href="#软件代码-5" class="headerlink" title="软件代码"></a>软件代码</h4><p>LED 呼吸灯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   PWM_Init</span></span><br><span class="line"><span class="comment">* @brief  PWM驱动初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);  <span class="comment">//启用APB1外设时钟。</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);   <span class="comment">//启用APB2外设时钟。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//启用复用功能重映射PA15口</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);  </span></span><br><span class="line"><span class="comment">GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2, ENABLE);  //更改指定引脚的映射。</span></span><br><span class="line"><span class="comment">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  <span class="comment">//复用推挽输出</span></span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = PWM_GPIO;  </span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM2);  <span class="comment">//配置 TIMx 内部时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//TIM 时基初始化结构定义</span></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;  <span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">720</span> - <span class="number">1</span>;  <span class="comment">//PSC</span></span><br><span class="line">    TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出比较初始化</span></span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">    TIM_OCStructInit(&amp;TIM_OCInitStructure);  <span class="comment">//用默认值填充每个值</span></span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;  <span class="comment">//CCR</span></span><br><span class="line">    TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定捕获比较 1 寄存器新值。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare1</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare1(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PWM控制LED亮度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_PWM</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PWM_SetCompare1(i);</span><br><span class="line">        Delay_ms(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">PWM_SetCompare1(<span class="number">100</span> - i);</span><br><span class="line">Delay_ms(<span class="number">5</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PWM_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED_PWM()；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PWM控制舵机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Servo_Init</span></span><br><span class="line"><span class="comment">* @brief  PWM驱动舵机初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = Servo_GPIO;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_InternalClockConfig(TIM2);  <span class="comment">//配置内部时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//时基初始化结构定义</span></span><br><span class="line">    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitstructure;</span><br><span class="line">    TIM_TimeBaseInitstructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">    TIM_TimeBaseInitstructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">    TIM_TimeBaseInitstructure.TIM_Period = <span class="number">20000</span><span class="number">-1</span>;  <span class="comment">//ARR</span></span><br><span class="line">    TIM_TimeBaseInitstructure.TIM_Prescaler = <span class="number">72</span><span class="number">-1</span>;  <span class="comment">//PSC</span></span><br><span class="line">    TIM_TimeBaseInitstructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitstructure);</span><br><span class="line"></span><br><span class="line">    TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">    TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">    TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">    TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;  <span class="comment">//CCR</span></span><br><span class="line">    TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">    TIM_Cmd(TIM2,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定捕获比较 12寄存器新值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare2</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare2(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//舵机控制角度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Servo_SetAngle</span><span class="params">(<span class="type">float</span> Angle)</span></span><br><span class="line">&#123;</span><br><span class="line">    PWM_SetCompare2(Angle / <span class="number">180</span> * <span class="number">2000</span> + <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Key_Servo</span></span><br><span class="line"><span class="comment">* @brief  按键控制舵机</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Servo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> Key_Num;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> Angle;</span><br><span class="line">    Key_Num = Key_GetNum();</span><br><span class="line">    <span class="keyword">if</span>(Key_Num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Angle += <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">if</span>(Angle &gt; <span class="number">180</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Angle = <span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    Servo_SetAngle(Angle);</span><br><span class="line"></span><br><span class="line">    OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, Angle, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Servo_Init();</span><br><span class="line">Key_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Angle:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Key_Servo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PWM驱动直流电机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Motor_Init</span></span><br><span class="line"><span class="comment">* @brief  PWM驱动直流电机初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PWM</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure2;</span><br><span class="line">GPIO_InitStructure2.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure2.GPIO_Pin = GPIO_Pin_2;</span><br><span class="line">GPIO_InitStructure2.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure2);</span><br><span class="line"></span><br><span class="line">TIM_InternalClockConfig(TIM2);</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;</span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Period = <span class="number">100</span> - <span class="number">1</span>;<span class="comment">//ARR</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="number">36</span> - <span class="number">1</span>;<span class="comment">//PSC</span></span><br><span class="line">TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="number">0</span>;</span><br><span class="line">TIM_TimeBaseInit(TIM2, &amp;TIM_TimeBaseInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_OCInitTypeDef TIM_OCInitStructure;</span><br><span class="line">TIM_OCStructInit(&amp;TIM_OCInitStructure);</span><br><span class="line">TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;</span><br><span class="line">TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;</span><br><span class="line">TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;</span><br><span class="line">TIM_OCInitStructure.TIM_Pulse = <span class="number">0</span>;<span class="comment">//CCR</span></span><br><span class="line">TIM_OC3Init(TIM2, &amp;TIM_OCInitStructure);</span><br><span class="line"></span><br><span class="line">TIM_Cmd(TIM2, ENABLE);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PWM_SetCompare3</span><span class="params">(<span class="type">uint16_t</span> Compare)</span></span><br><span class="line">&#123;</span><br><span class="line">TIM_SetCompare3(TIM2, Compare);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Motor_SetSpeed</span></span><br><span class="line"><span class="comment">* @brief  电机速度</span></span><br><span class="line"><span class="comment">* @param  Speed</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Motor_SetSpeed</span><span class="params">(<span class="type">int8_t</span> Speed)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Speed &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//控制电机旋转方向，高低电平由自己决定。</span></span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_4);</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_5);</span><br><span class="line">PWM_SetCompare3(Speed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_ResetBits(GPIOA,GPIO_Pin_4);</span><br><span class="line">GPIO_SetBits(GPIOA,GPIO_Pin_5);</span><br><span class="line">PWM_SetCompare3(-Speed);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Key_Motor</span></span><br><span class="line"><span class="comment">* @brief  按键控制直流电机</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None     </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Key_Motor</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> Key_Num;</span><br><span class="line">    <span class="type">static</span> <span class="type">int8_t</span> Speed;</span><br><span class="line"></span><br><span class="line">    Key_Num = Key_GetNum();</span><br><span class="line">    <span class="keyword">if</span>(Key_Num == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Speed += <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">if</span>(Speed &gt; <span class="number">100</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Speed = <span class="number">-100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Motor_SetSpeed(Speed);</span><br><span class="line"></span><br><span class="line">    OLED_ShowSignedNum(<span class="number">1</span>,<span class="number">7</span>,Speed,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  OLED_Init();</span><br><span class="line">  Motor_Init();</span><br><span class="line">  Key_Init();</span><br><span class="line">  OLED_ShowString(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&quot;Speed:&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Key_Motor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ADC模数转换器"><a href="#ADC模数转换器" class="headerlink" title="ADC模数转换器"></a>ADC模数转换器</h3><h4 id="ADC简介"><a href="#ADC简介" class="headerlink" title="ADC简介"></a>ADC简介</h4><p>•ADC（Analog-Digital Converter）模拟-数字转换器</p><p>•ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p><p>•12位逐次逼近型ADC，1us转换时间</p><p>•输入电压范围：0~3.3V，转换结果范围：0~4095</p><p>•18个输入通道，可测量16个外部和2个内部信号源</p><p>•规则组和注入组两个转换单元</p><p>•模拟看门狗自动监测输入电压范围</p><p>==•== STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p><h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p>逐次逼近型ADC</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910162508105.png" alt="image-20230910162508105"></p><p>ADC框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910162553677.png" alt="image-20230910162553677"  /></p><p>ADC基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910162732339.png" alt="image-20230910162732339"></p><h5 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h5><div class="table-container"><table><thead><tr><th><strong>通道</strong></th><th><strong>ADC1</strong></th><th><strong>ADC2</strong></th><th><strong>ADC3</strong></th></tr></thead><tbody><tr><td>通道0</td><td>PA0</td><td>PA0</td><td>PA0</td></tr><tr><td>通道1</td><td>PA1</td><td>PA1</td><td>PA1</td></tr><tr><td>通道2</td><td>PA2</td><td>PA2</td><td>PA2</td></tr><tr><td>通道3</td><td>PA3</td><td>PA3</td><td>PA3</td></tr><tr><td>通道4</td><td>PA4</td><td>PA4</td><td>PF6</td></tr><tr><td>通道5</td><td>PA5</td><td>PA5</td><td>PF7</td></tr><tr><td>通道6</td><td>PA6</td><td>PA6</td><td>PF8</td></tr><tr><td>通道7</td><td>PA7</td><td>PA7</td><td>PF9</td></tr><tr><td>通道8</td><td>PB0</td><td>PB0</td><td>PF10</td></tr><tr><td>通道9</td><td>PB1</td><td>PB1</td><td></td></tr><tr><td>通道10</td><td>PC0</td><td>PC0</td><td>PC0</td></tr><tr><td>通道11</td><td>PC1</td><td>PC1</td><td>PC1</td></tr><tr><td>通道12</td><td>PC2</td><td>PC2</td><td>PC2</td></tr><tr><td>通道13</td><td>PC3</td><td>PC3</td><td>PC3</td></tr><tr><td>通道14</td><td>PC4</td><td>PC4</td><td></td></tr><tr><td>通道15</td><td>PC5</td><td>PC5</td><td></td></tr><tr><td>通道16</td><td>温度传感器</td><td></td><td></td></tr><tr><td>通道17</td><td>内部参考电压</td><td></td></tr></tbody></table></div><h5 id="转换模式"><a href="#转换模式" class="headerlink" title="转换模式"></a>转换模式</h5><p>•单次转换，非扫描模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163006660.png" alt="image-20230910163006660"></p><p>•连续转换，非扫描模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163044181.png" alt="image-20230910163044181"></p><p>•单次转换，扫描模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163054490.png" alt="image-20230910163054490"></p><p>•连续转换，扫描模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163117438.png" alt="image-20230910163117438"></p><h5 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163223717.png" alt="image-20230910163223717"></p><h5 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h5><p>•数据右对齐：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163425274.png" alt="image-20230910163425274"></p><p>•数据左对齐：</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163435666.png" alt="image-20230910163435666"></p><h5 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h5><p>•AD转换的步骤：采样，保持，量化，编码</p><p>•STM32 ADC的总转换时间为：</p><p> TCONV = 采样时间 + 12.5个ADC周期</p><p>•例如：当ADCCLK=14MHz，采样时间为1.5个ADC周期</p><p> TCONV = 1.5 + 12.5 = 14个ADC周期 = 1μs</p><h5 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h5><p>•ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p><p>•建议在每次上电后执行一次校准</p><p>•启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p><h4 id="硬件电路-7"><a href="#硬件电路-7" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163600474.png" alt="image-20230910163600474"></p><p>接线图</p><p>ADC单通道</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163748171.png" alt="image-20230910163748171"></p><p>ADC单通道</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910163826841.png" alt="image-20230910163826841"></p><h4 id="软件代码-6"><a href="#软件代码-6" class="headerlink" title="软件代码"></a>软件代码</h4><p>ADC单通道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">ADC.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = DISABLE;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">1</span>;</span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br><span class="line"><span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    </span><br><span class="line"><span class="type">uint16_t</span> ADValue;</span><br><span class="line"><span class="type">float</span> Voltage;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ADValue:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Volatge:0.00V&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ADValue = AD_GetValue();</span><br><span class="line">Voltage = (<span class="type">float</span>)ADValue / <span class="number">4095</span> * <span class="number">3.3</span>;</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">9</span>, ADValue, <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, Voltage, <span class="number">1</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">11</span>, (<span class="type">uint16_t</span>)(Voltage * <span class="number">100</span>) % <span class="number">100</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ADC多通道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> <span class="title function_">AD_GetValue</span><span class="params">(<span class="type">uint8_t</span> ADC_Channel)</span></span><br><span class="line">&#123;</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);</span><br><span class="line"><span class="keyword">return</span> ADC_GetConversionValue(ADC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD0, AD1, AD2, AD3;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;AD0:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;AD1:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;AD2:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;AD3:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">AD0 = AD_GetValue(ADC_Channel_0);</span><br><span class="line">AD1 = AD_GetValue(ADC_Channel_1);</span><br><span class="line">AD2 = AD_GetValue(ADC_Channel_2);</span><br><span class="line">AD3 = AD_GetValue(ADC_Channel_3);</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, AD0, <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">5</span>, AD1, <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">5</span>, AD2, <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">4</span>, <span class="number">5</span>, AD3, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="DMA直接存储器存取"><a href="#DMA直接存储器存取" class="headerlink" title="DMA直接存储器存取"></a>DMA直接存储器存取</h3><h4 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h4><p>•DMA（Direct Memory Access）直接存储器存取</p><p>•DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源</p><p>•12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）</p><p>•每个通道都支持软件触发和特定的硬件触发</p><p>==•==STM32F103C8T6 DMA资源：DMA1（7个通道）</p><h5 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h5><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>类型</strong></th><th style="text-align:center"><strong>起始地址</strong></th><th style="text-align:center"><strong>存储器</strong></th><th style="text-align:center"><strong>用途</strong></th></tr></thead><tbody><tr><td style="text-align:center">ROM</td><td style="text-align:center">0x0800 0000</td><td style="text-align:center">程序存储器Flash</td><td style="text-align:center">存储C语言编译后的程序代码</td></tr><tr><td style="text-align:center">0x1FFF F000</td><td style="text-align:center">系统存储器</td><td style="text-align:center">存储BootLoader，用于串口下载</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0x1FFF F800</td><td style="text-align:center">选项字节</td><td style="text-align:center">存储一些独立于程序代码的配置参数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">RAM</td><td style="text-align:center">0x2000 0000</td><td style="text-align:center">运行内存SRAM</td><td style="text-align:center">存储运行过程中的临时变量</td></tr><tr><td style="text-align:center">0x4000 0000</td><td style="text-align:center">外设寄存器</td><td style="text-align:center">存储各个外设的配置参数</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">0xE000 0000</td><td style="text-align:center">内核外设寄存器</td><td style="text-align:center">存储内核各个外设的配置参数</td></tr></tbody></table></div><h5 id="框图"><a href="#框图" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165543437.png" alt="image-20230910165543437"></p><h5 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165730773.png" alt="image-20230910165730773"></p><h5 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165815186.png" alt="image-20230910165815186"></p><h5 id="数据宽度与对齐"><a href="#数据宽度与对齐" class="headerlink" title="数据宽度与对齐"></a>数据宽度与对齐</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165905117.png" alt="image-20230910165905117"></p><h5 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165931247.png" alt="image-20230910165931247"></p><h5 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230910165959334.png" alt="image-20230910165959334"></p><h4 id="硬件电路-8"><a href="#硬件电路-8" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>DMA数据转运</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230911153923403.png" alt="image-20230911153923403"></p><p>DMA+AD多通道</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230911153945697.png" alt="image-20230911153945697"></p><h4 id="软件代码-7"><a href="#软件代码-7" class="headerlink" title="软件代码"></a>软件代码</h4><p>DMA数据转运</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">DMA.c</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> MyDMA_Size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DMA初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Init</span><span class="params">(<span class="type">uint32_t</span> AddrA, <span class="type">uint32_t</span> AddrB, <span class="type">uint16_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">MyDMA_Size = Size;</span><br><span class="line"></span><br><span class="line">    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);</span><br><span class="line"></span><br><span class="line">    DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    DMA_InitStructure.DMA_PeripheralBaseAddr = AddrA;</span><br><span class="line">    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Enable;</span><br><span class="line">    DMA_InitStructure.DMA_MemoryBaseAddr = AddrB;</span><br><span class="line">    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">    DMA_InitStructure.DMA_BufferSize = Size;</span><br><span class="line">    DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">    DMA_InitStructure.DMA_M2M = DMA_M2M_Enable;</span><br><span class="line">    DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">    DMA_Init(DMA1_Channel1,&amp;DMA_InitStructure);</span><br><span class="line"></span><br><span class="line">    DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyDMA_Transfer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DMA_Cmd(DMA1_Channel1,DISABLE);</span><br><span class="line">    DMA_SetCurrDataCounter(DMA1_Channel1,MyDMA_Size);</span><br><span class="line">    DMA_Cmd(DMA1_Channel1,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(DMA_GetFlagStatus(DMA1_FLAG_TC1) == RESET);</span><br><span class="line">    DMA_ClearFlag(DMA1_FLAG_TC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> DataA[] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> DataB[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">MyDMA_Init((<span class="type">uint32_t</span>)DataA, (<span class="type">uint32_t</span>)DataB, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;DataA&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;DataB&quot;</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, (<span class="type">uint32_t</span>)DataA, <span class="number">8</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">8</span>, (<span class="type">uint32_t</span>)DataB, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">DataA[<span class="number">0</span>] ++;</span><br><span class="line">DataA[<span class="number">1</span>] ++;</span><br><span class="line">DataA[<span class="number">2</span>] ++;</span><br><span class="line">DataA[<span class="number">3</span>] ++;</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, DataA[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, DataA[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, DataA[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, DataA[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, DataB[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, DataB[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, DataB[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, DataB[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">MyDMA_Transfer();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, DataA[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, DataA[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, DataA[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, DataA[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, DataB[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, DataB[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, DataB[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, DataB[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DMA+AD多通道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">AD.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> AD_Value[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AD_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);</span><br><span class="line"></span><br><span class="line">RCC_ADCCLKConfig(RCC_PCLK2_Div6);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_0, <span class="number">1</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_1, <span class="number">2</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_2, <span class="number">3</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line">ADC_RegularChannelConfig(ADC1, ADC_Channel_3, <span class="number">4</span>, ADC_SampleTime_55Cycles5);</span><br><span class="line"></span><br><span class="line">ADC_InitTypeDef ADC_InitStructure;</span><br><span class="line">ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;</span><br><span class="line">ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;</span><br><span class="line">ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;</span><br><span class="line">ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</span><br><span class="line">ADC_InitStructure.ADC_ScanConvMode = ENABLE;</span><br><span class="line">ADC_InitStructure.ADC_NbrOfChannel = <span class="number">4</span>;</span><br><span class="line">ADC_Init(ADC1, &amp;ADC_InitStructure);</span><br><span class="line"></span><br><span class="line">DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;ADC1-&gt;DR;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)AD_Value;</span><br><span class="line">DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;</span><br><span class="line">DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">DMA_InitStructure.DMA_BufferSize = <span class="number">4</span>;</span><br><span class="line">DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;</span><br><span class="line">DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;</span><br><span class="line">DMA_Init(DMA1_Channel1, &amp;DMA_InitStructure);</span><br><span class="line"></span><br><span class="line">DMA_Cmd(DMA1_Channel1, ENABLE);</span><br><span class="line">ADC_DMACmd(ADC1, ENABLE);</span><br><span class="line">ADC_Cmd(ADC1, ENABLE);</span><br><span class="line"></span><br><span class="line">ADC_ResetCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetResetCalibrationStatus(ADC1) == SET);</span><br><span class="line">ADC_StartCalibration(ADC1);</span><br><span class="line"><span class="keyword">while</span> (ADC_GetCalibrationStatus(ADC1) == SET);</span><br><span class="line"></span><br><span class="line">ADC_SoftwareStartConvCmd(ADC1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">AD_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;AD0:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;AD1:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;AD2:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;AD3:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">5</span>, AD_Value[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">5</span>, AD_Value[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">5</span>, AD_Value[<span class="number">2</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">4</span>, <span class="number">5</span>, AD_Value[<span class="number">3</span>], <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FlyMcu串口下载-amp-STLINK"><a href="#FlyMcu串口下载-amp-STLINK" class="headerlink" title="FlyMcu串口下载&amp;STLINK"></a>FlyMcu串口下载&amp;STLINK</h3><h4 id="FlyMcu下载流程"><a href="#FlyMcu下载流程" class="headerlink" title="FlyMcu下载流程"></a>FlyMcu下载流程</h4><p>接线图 需要连接串口模块，这款芯片只能用USART1连接，所以只能接PA9 10</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913150033150.png" alt="image-20230913150033150"></p><p>生成Hex文件</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913142120120.png" alt="image-20230913142120120"></p><p>搜索串口，波特率默认115200就行，    其他配置先保持默认</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913142227891.png" alt="image-20230913142227891"></p><p>开始编程前，还需要配置BOOT引脚,让STM32执行BootLoader程序，否则点击开始编程，会一直卡在这个位置</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913142541742.png" alt="image-20230913142541742"></p><p>怎么进入BootLoader，这两个跳线帽是配置BOOT引脚的</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913142727493.png" alt="image-20230913142727493"></p><p>把上面的跳线帽拔下来移过去，配置BOOT脚为1，按一下复位键，让程序重新运行，切换引脚一定要按一下复位键，只有在刚复位时才会读取BOOT引脚，程序运行之后切换BOOT引脚是无效的</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913142836302.png" alt="image-20230913142836302"></p><p>配置好后，开始编程</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913143312373.png" alt="image-20230913143312373"></p><p>回到STM32，目前LED还没有亮起来，这是因为目前STM32还在执行Boot loader的刷机程序，我们还需要把BOOT引脚换回来，拔掉跳线帽，换回之前的位置，然后按一下复位，程序就运行了。</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913144548066.png" alt="image-20230913144548066"></p><p>由于没有一键下载电路，只能手动切换跳线帽，如果有一键下载电路就可以配置是高电平复位还是其他什么等等配置，这些配置根据一键下载电路选择</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913145013963.png" alt="image-20230913145013963"></p><p>这个软件还有很多东西，就不一一介绍了，比如读取保护防止程序泄露，写保护，</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913145528079.png" alt="image-20230913145528079"></p><h5 id="STLINK-Utility"><a href="#STLINK-Utility" class="headerlink" title="STLINK Utility"></a>STLINK Utility</h5><p>接线图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913150629745.png" alt="image-20230913150629745"></p><p>这个软件是需要安装的，全部点yes就行</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913145844533.png" alt="image-20230913145844533"></p><p>点击这里进行连接</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913150521363.png" alt="image-20230913150521363"></p><p>点击这里下载</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913150910543.png" alt="image-20230913150910543"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230913150932142.png" alt="image-20230913150932142"></p><h3 id="通信协议的通信速率"><a href="#通信协议的通信速率" class="headerlink" title="通信协议的通信速率"></a>通信协议的通信速率</h3><h4 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h4><p>UART（Universal Asynchronous Receiver/Transmitter）是一种常见的串行通信协议，用于在计算机和外部设备之间进行串行数据传输。UART的通信速率通常以波特率（Baud Rate）来表示，它决定了每秒钟传输的比特数。</p><p>UART的波特率可以根据需要进行设置，典型的波特率包括 9600、19200、38400、57600、115200 等。除了这些常见的波特率外，UART还支持更高或更低的波特率，具体范围取决于硬件的能力和通信需求。</p><p>需要注意的是，通信双方必须使用相同的波特率才能正确地进行数据传输。如果波特率设置不匹配，将导致数据接收错误或无法正常解析。因此，在使用UART进行通信时，确保发送端和接收端都设置相同的波特率非常重要。</p><p>总的来说，UART的波特率是用来衡量串行数据传输速率的重要参数，它直接影响着通信的稳定性和效率。</p><h4 id="i2C"><a href="#i2C" class="headerlink" title="i2C"></a>i2C</h4><p>2C（Inter-Integrated Circuit）是一种串行通信协议，用于连接芯片之间进行通信。在I2C中，数据通过两根线路传输：Serial Data Line（SDA）和Serial Clock Line（SCL）。</p><p>I2C的速率可以根据需要进行调整，主要由时钟频率来决定。</p><p>I2C协议可以工作在以下5种速率模式下，不同的器件可能支持不同的速率。</p><ul><li>标准模式(Standard)：100kbps</li><li>快速模式(Fast)：400kbps</li><li>快速模式+(Fast-Plus)：1Mbps</li><li>高速模式(High-speed)：3.4Mbps</li><li>超快模式(Ultra-Fast)：5Mbps（单向传输）</li></ul><p>需要注意的是，实际的数据传输速率可能会低于这些最大时钟频率，因为在通信中还需要考虑到设备的响应时间和总线负载等因素。</p><p>总之，I2C的速率可以根据具体的应用需求和硬件支持进行选择和配置。</p><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>SPI（Serial Peripheral Interface）是一种基于主从模式的同步串行通信协议，用于在微控制器和外围设备之间进行数据传输。SPI总线上的数据传输速率由时钟频率来决定。</p><p>SPI总线有四根信号线：SCLK（时钟信号）、MOSI（主设备输出从设备输入）、MISO（主设备输入从设备输出）和SS（片选信号）。其中，时钟信号SCLK由主设备产生，并控制数据传输的时序，而片选信号SS则用于选择从设备进行通信。</p><p>SPI的时钟频率可以根据需要进行调整，通常由主设备产生并控制。在实际应用中，SPI的时钟频率可以从几百kHz到几十MHz不等，取决于具体的硬件限制和应用需求。一般来说，SPI的最大时钟频率越高，传输速率就越快，但同时也会带来更高的电磁噪声和功耗等问题。</p><p>需要注意的是，在选择SPI的时钟频率时，还需要考虑到从设备的响应时间和总线负载等因素，以保证数据传输的正确性和稳定性。</p><h3 id="USART串口"><a href="#USART串口" class="headerlink" title="USART串口"></a>USART串口</h3><h4 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h4><h5 id="通信接口"><a href="#通信接口" class="headerlink" title="通信接口"></a>通信接口</h5><p>•通信的目的：将一个设备的数据传送到另一个设备，扩展硬件系统</p><p>•通信协议：制定通信的规则，通信双方按照协议规则进行数据收发</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>名称</strong></th><th style="text-align:center"><strong>引脚</strong></th><th style="text-align:center"><strong>双工</strong></th><th style="text-align:center"><strong>时钟</strong></th><th style="text-align:center"><strong>电平</strong></th><th style="text-align:center"><strong>设备</strong></th></tr></thead><tbody><tr><td style="text-align:center">USART</td><td style="text-align:center">TX、RX</td><td style="text-align:center">全双工</td><td style="text-align:center">异步</td><td style="text-align:center">单端</td><td style="text-align:center">点对点</td></tr><tr><td style="text-align:center">I2C</td><td style="text-align:center">SCL、SDA</td><td style="text-align:center">半双工</td><td style="text-align:center">同步</td><td style="text-align:center">单端</td><td style="text-align:center">多设备</td></tr><tr><td style="text-align:center">SPI</td><td style="text-align:center">SCLK、MOSI、MISO、CS</td><td style="text-align:center">全双工</td><td style="text-align:center">同步</td><td style="text-align:center">单端</td><td style="text-align:center">多设备</td></tr><tr><td style="text-align:center">CAN</td><td style="text-align:center">CAN_H、CAN_L</td><td style="text-align:center">半双工</td><td style="text-align:center">异步</td><td style="text-align:center">差分</td><td style="text-align:center">多设备</td></tr><tr><td style="text-align:center">USB</td><td style="text-align:center">DP、DM</td><td style="text-align:center">半双工</td><td style="text-align:center">异步</td><td style="text-align:center">差分</td><td style="text-align:center">点对点</td></tr></tbody></table></div><h5 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h5><p>•串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信</p><p>•单片机的串口可以使单片机与单片机、单片机与电脑、单片机与各式各样的模块互相通信，极大地扩展了单片机的应用范围，增强了单片机系统的硬件实力</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912163618822.png" alt="image-20230912163618822"></p><h5 id="硬件电路-9"><a href="#硬件电路-9" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>•简单双向串口通信有两根通信线（发送端TX和接收端RX）</p><p>•TX与RX要交叉连接</p><p>•当只需单向的数据传输时，可以只接一根通信线</p><p>当电平标准不一致时，需要加电平转换芯片</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912163643465.png" alt="image-20230912163643465"></p><h5 id="电平标准"><a href="#电平标准" class="headerlink" title="电平标准"></a>电平标准</h5><p>•电平标准是数据1和数据0的表达方式，是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：</p><p>•TTL电平：+3.3V或+5V表示1，0V表示0</p><p>•RS232电平：-3 ~ -15V表示1，+3 ~ +15V表示0</p><p>•RS485电平：两线压差+2 ~ +6V表示1，-2 ~ -6V表示0（差分信号）</p><h5 id="串口参数及时序"><a href="#串口参数及时序" class="headerlink" title="串口参数及时序"></a>串口参数及时序</h5><p>•波特率：串口通信的速率</p><p>•起始位：标志一个数据帧的开始，固定为低电平</p><p>•数据位：数据帧的有效载荷，1为高电平，0为低电平，<mark>低位先行</mark></p><p>•校验位：用于数据验证，根据数据位计算得来</p><p>停止位：用于数据帧间隔，固定为高电平</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912163841666.png" alt="image-20230912163841666"></p><h5 id="串口时序"><a href="#串口时序" class="headerlink" title="串口时序"></a>串口时序</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912163913452.png" alt="image-20230912163913452"></p><h4 id="USART简介"><a href="#USART简介" class="headerlink" title="USART简介"></a>USART简介</h4><p>•USART（Universal Synchronous/Asynchronous Receiver/Transmitter）通用同步/异步收发器</p><p>•USART是STM32内部集成的硬件外设，可根据数据寄存器的一个字节数据自动生成数据帧时序，从TX引脚发送出去，也可自动接收RX引脚的数据帧时序，拼接为一个字节数据，存放在数据寄存器里</p><p>•自带波特率发生器，最高达4.5Mbits/s</p><p>•可配置数据位长度（8/9）、停止位长度（0.5/1/1.5/2）</p><p>•可选校验位（无校验/奇校验/偶校验）</p><p>•支持同步模式、硬件流控制、DMA、智能卡、IrDA、LIN</p><p>•STM32F103C8T6 USART资源： USART1、 USART2、 USART3</p><h5 id="框图-1"><a href="#框图-1" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164139347.png" alt="image-20230912164139347"></p><p> USART基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164207522.png" alt="image-20230912164207522"></p><p> 数据帧</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164320685.png" alt="image-20230912164320685"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164510481.png" alt="image-20230912164510481"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164554945.png" alt="image-20230912164554945"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164713071.png" alt="image-20230912164713071"></p><h5 id="波特率发生器"><a href="#波特率发生器" class="headerlink" title="波特率发生器"></a>波特率发生器</h5><p>•发送器和接收器的波特率由波特率寄存器BRR里的DIV确定</p><p>•计算公式：波特率 = fPCLK2/1 / (16 * DIV)</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912164829245.png" alt="image-20230912164829245"></p><h5 id="数据模式"><a href="#数据模式" class="headerlink" title="数据模式"></a>数据模式</h5><ul><li><p>HEX模式/十六进制模式/二进制模式：以原始数据的形式显示</p></li><li><p>文本模式/字符模式：以原始数据编码后的形式显示</p></li></ul><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165109152.png" alt="image-20230912165109152"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165201135.png" alt="image-20230912165201135"></p><h5 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h5><p>HEX数据包</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165336578.png" alt="image-20230912165336578"></p><p>文本数据包</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165350494.png" alt="image-20230912165350494"></p><p>HEX数据包接收</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165404340.png" alt="image-20230912165404340"></p><p>文本数据包接收</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165427339.png" alt="image-20230912165427339"></p><h4 id="硬件电路-10"><a href="#硬件电路-10" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>接线图</p><p>串口发送&amp;串口发送+接收</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165636620.png" alt="image-20230912165636620"></p><p>串口收发HEX数据包</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165648438.png" alt="image-20230912165648438"></p><p>串口收发文本数据包</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912165656296.png" alt="image-20230912165656296"></p><h4 id="软件代码-8"><a href="#软件代码-8" class="headerlink" title="软件代码"></a>软件代码</h4><p>printf函数重定向</p><p>勾选Use MicroLIB</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230912111106536.png" alt="image-20230912111106536"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用函数前添加头文件 stdio.h</span></span><br><span class="line"><span class="comment">//printf函数打印是默认打印到屏幕，我们的单片机没有屏幕，所以要重定向</span></span><br><span class="line"><span class="comment">//fpuct是printf函数的底层，所以要先定向fpuct函数到串口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    Serial_SendByte(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用函数前添加头文件 stdarg.h</span></span><br><span class="line"><span class="comment">//c语言可变参数（没学过，看不懂）</span></span><br><span class="line"><span class="comment">//封装sprintf</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg,format);</span><br><span class="line">    <span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>串口发送</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">Serial.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_InitTypeDef USART_InitStructure;</span><br><span class="line">USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">USART_InitStructure.USART_Mode = USART_Mode_Tx;</span><br><span class="line">USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line"></span><br><span class="line">USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">USART_SendData(USART1, Byte);</span><br><span class="line"><span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(Array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; String[i] != <span class="string">&#x27;\0&#x27;</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(String[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X, <span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (Y --)</span><br><span class="line">&#123;</span><br><span class="line">Result *= X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number, <span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Length; i ++)</span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>, Length - i - <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(ch);</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">va_list arg;</span><br><span class="line">va_start(arg, format);</span><br><span class="line"><span class="built_in">vsprintf</span>(String, format, arg);</span><br><span class="line">va_end(arg);</span><br><span class="line">Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line">Serial_SendByte(<span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> MyArray[] = &#123;<span class="number">0x42</span>, <span class="number">0x43</span>, <span class="number">0x44</span>, <span class="number">0x45</span>&#125;;</span><br><span class="line">Serial_SendArray(MyArray, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Serial_SendString(<span class="string">&quot;\r\nNum1=&quot;</span>);</span><br><span class="line"></span><br><span class="line">Serial_SendNumber(<span class="number">111</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\nNum2=%d&quot;</span>, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(String, <span class="string">&quot;\r\nNum3=%d&quot;</span>, <span class="number">333</span>);</span><br><span class="line">Serial_SendString(String);</span><br><span class="line"></span><br><span class="line">Serial_Printf(<span class="string">&quot;\r\nNum4=%d&quot;</span>, <span class="number">444</span>);</span><br><span class="line">Serial_Printf(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>串口发送+接收</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">Serial.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxData;</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes------------------------------------------------*/</span>      </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @name   Serial_Init</span></span><br><span class="line"><span class="comment">* @brief  串口初始化</span></span><br><span class="line"><span class="comment">* @param  None</span></span><br><span class="line"><span class="comment">* @retval None      </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">    USART_InitTypeDef USART_InitStructure;</span><br><span class="line">    USART_InitStructure.USART_BaudRate = <span class="number">9600</span>;</span><br><span class="line">    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">    USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;</span><br><span class="line">    USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">    USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">    USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">    USART_Init(USART1,&amp;USART_InitStructure);</span><br><span class="line"></span><br><span class="line">    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</span><br><span class="line"></span><br><span class="line">    NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">1</span>;</span><br><span class="line">    NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line"></span><br><span class="line">    USART_Cmd(USART1,ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    USART_SendData(USART1,Byte);</span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1,USART_FLAG_TXE) == RESET);</span><br><span class="line">    <span class="comment">//不需要手动清除标志位，详情请查看数据手册</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一个数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendArray</span><span class="params">(<span class="type">uint8_t</span> *Array,<span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(Array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendString</span><span class="params">(<span class="type">char</span> *String)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;String[i] != <span class="string">&#x27;\0&#x27;</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(String[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//次方函数 </span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">Serial_Pow</span><span class="params">(<span class="type">uint32_t</span> X,<span class="type">uint32_t</span> Y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> Result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(Y--)</span><br><span class="line">    &#123;</span><br><span class="line">        Result *= X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一个数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendNumber</span><span class="params">(<span class="type">uint32_t</span> Number,<span class="type">uint8_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_SendByte(Number / Serial_Pow(<span class="number">10</span>,Length -i <span class="number">-1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//printf重定向</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch,FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    Serial_SendByte(ch);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装Sprintf</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_Printf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> String[<span class="number">100</span>];</span><br><span class="line">    va_list arg;</span><br><span class="line">    va_start(arg,format);</span><br><span class="line">    <span class="built_in">vsprintf</span>(String,format,arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">    Serial_SendString(String);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除标志位</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装读取数据函数</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Serial_RxData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(USART_GetITStatus(USART1,USART_IT_RXNE) == SET)</span><br><span class="line">    &#123;</span><br><span class="line">        Serial_RxData = USART_ReceiveData(USART1);</span><br><span class="line">        Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">        USART_ClearITPendingBit(USART1,USART_IT_RXNE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RxData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>串口收发HEX数据包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> Serial_TxPacket[<span class="number">4</span>];<span class="comment">//FF 01 02 03 04 FE</span></span><br><span class="line"><span class="type">uint8_t</span> Serial_RxPacket[<span class="number">4</span>];</span><br><span class="line"><span class="type">uint8_t</span> Serial_RxFlag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Serial_SendPacket</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_SendByte(<span class="number">0xFF</span>);</span><br><span class="line">Serial_SendArray(Serial_TxPacket, <span class="number">4</span>);</span><br><span class="line">Serial_SendByte(<span class="number">0xFE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Serial_GetRxFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="number">0xFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">pRxPacket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_RxPacket[pRxPacket] = RxData;</span><br><span class="line">pRxPacket ++;</span><br><span class="line"><span class="keyword">if</span> (pRxPacket &gt;= <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="number">0xFE</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    </span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;TxPacket&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RxPacket&quot;</span>);</span><br><span class="line"></span><br><span class="line">Serial_TxPacket[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">Serial_TxPacket[<span class="number">1</span>] = <span class="number">0x02</span>;</span><br><span class="line">Serial_TxPacket[<span class="number">2</span>] = <span class="number">0x03</span>;</span><br><span class="line">Serial_TxPacket[<span class="number">3</span>] = <span class="number">0x04</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum = Key_GetNum();</span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Serial_TxPacket[<span class="number">0</span>] ++;</span><br><span class="line">Serial_TxPacket[<span class="number">1</span>] ++;</span><br><span class="line">Serial_TxPacket[<span class="number">2</span>] ++;</span><br><span class="line">Serial_TxPacket[<span class="number">3</span>] ++;</span><br><span class="line"></span><br><span class="line">Serial_SendPacket();</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">1</span>, Serial_TxPacket[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">4</span>, Serial_TxPacket[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">7</span>, Serial_TxPacket[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">10</span>, Serial_TxPacket[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">1</span>, Serial_RxPacket[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">4</span>, Serial_RxPacket[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">7</span>, Serial_RxPacket[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">4</span>, <span class="number">10</span>, Serial_RxPacket[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>串口收发文本数据包</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> Serial_RxPacket[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> RxState = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> pRxPacket = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (USART_GetITStatus(USART1, USART_IT_RXNE) == SET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> RxData = USART_ReceiveData(USART1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RxState == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;@&#x27;</span> &amp;&amp; Serial_RxFlag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">1</span>;</span><br><span class="line">pRxPacket = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_RxPacket[pRxPacket] = RxData;</span><br><span class="line">pRxPacket ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (RxState == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (RxData == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxState = <span class="number">0</span>;</span><br><span class="line">Serial_RxPacket[pRxPacket] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">Serial_RxFlag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USART_ClearITPendingBit(USART1, USART_IT_RXNE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">LED_Init();</span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;TxPacket&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;RxPacket&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_RxFlag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, Serial_RxPacket);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LED_ON&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1_ON();</span><br><span class="line">Serial_SendString(<span class="string">&quot;LED_ON_OK\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LED_ON_OK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(Serial_RxPacket, <span class="string">&quot;LED_OFF&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">LED1_OFF();</span><br><span class="line">Serial_SendString(<span class="string">&quot;LED_OFF_OK\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;LED_OFF_OK&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Serial_SendString(<span class="string">&quot;ERROR_COMMAND\r\n&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;                &quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ERROR_COMMAND&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Serial_RxFlag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h3><h4 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h4><p>•I2C（Inter IC Bus）是由Philips公司开发的一种通用数据总线</p><p>•两根通信线：SCL（Serial Clock）、SDA（Serial Data）</p><p>•同步，半双工</p><p>•带数据应答</p><p>支持总线挂载多设备（一主多从、多主多从）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185322435.png" alt="image-20230915185322435"></p><p>硬件电路</p><p>•所有I2C设备的SCL连在一起，SDA连在一起</p><p>•设备的SCL和SDA均要配置成开漏输出模式</p><p>SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185356680.png" alt="image-20230915185356680"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185401838.png" alt="image-20230915185401838"></p><h4 id="IIC总线接上拉电阻的原因"><a href="#IIC总线接上拉电阻的原因" class="headerlink" title="IIC总线接上拉电阻的原因"></a>IIC总线接上拉电阻的原因</h4><p> I2C为什么要接上拉电阻？因为它是开漏输出。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/bsiaOicpwT9tLKtB3MTcY5owMYHwTQIhialIMZibuocicHl9XaVw8Qdn5Lo7S61NU6zyiagYZZxUR69CQ6Xv292ttibpA/640?wx_fmt=jpeg&amp;wxfrom=13&amp;tp=wxpic" alt="图片"></p><p><strong>为什么是开漏输出？</strong></p><p> I2C协议支持多个主设备与多个从设备在一条总线上，如果不用开漏输出，而用推挽输出，会出现主设备之间短路的情况。所以总线一般会使用开漏输出。</p><p><strong>为什么要接上拉电阻？</strong></p><p>  接上拉电阻是因为I2C通信需要输出高电平的能力。一般开漏输出无法输出高电平，如果在漏极接上拉电阻，则可以进行电平转换。</p><p>  I2C由两条总线SDA和SCL组成。连接到总线的器件的输出级必须是漏极开路，都通过上拉电阻连接到电源，这样才能够实现“线与”功能。当总线空闲时，这两条线路都是高电平。</p><p><strong>上拉电阻阻值怎么确定？</strong></p><p>  一般IO端口的驱动能力在2mA～4mA量级。</p><ul><li><p>考虑到功耗问题，阻值不能过小</p><p>  如果上拉阻值过小，VDD灌入端口的电流将较大，功耗会很大，导致端口输出的低电平值增大(I2C协议规定，端口输出低电平的最高允许值为0.4V)。故通常上拉电阻应选取不低于1K的电阻（当VDD＝3V时，灌入电流不超过3mA）。</p></li><li><p>考虑到速度问题，阻值不能过大</p><p>  它取决于上拉电阻和线上电容形成的RC延时，RC延时越大，波形越偏离方波趋向于正弦波，数据读写正确的概率就越低，所以上拉电阻不能过大。</p><p>  I2C总线上的负载电容不能超过400pF。当I2C总线上器件逐渐增多时，总线负载电容也相应增加。当总的负载电容大于400pF时，就不能可靠的工作。这也是I2C的局限性。</p><p>  建议上拉电阻可选用1.5K，2.2K，4.7K。</p></li></ul><p><strong>I2C总线基本操作</strong></p><p>  根据I2C总线规范，总线空闲时两根线都必须为高。假设主设备A需要启动I2C，他需要在SCL高电平时，将SDA由高电平转换为低电平作为启动信号。</p><p>  主设备A在把SDA拉高后，它需要再检查一下SDA的电平。为什么? 因为线与，如果主设备A拉高SDA时，已经有其他主设备将SDA拉低了，由于 1 &amp; 0 = 0 那么主设备A在检查SDA电平时, 会发现不是高电平，而是低电平。说明其他主设备抢占总线的时间比它早，主设备A只能放弃占用总线。如果SDA是高电平，说明主设备A可以占用总线，然后主设备A将SDA拉低，开始通信。</p><p>  因此，模拟I2C一定要将GPIO端口设置为开漏输出并加上拉电阻。</p><h4 id="I2C时序基本单元"><a href="#I2C时序基本单元" class="headerlink" title="I2C时序基本单元"></a>I2C时序基本单元</h4><h5 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h5><p>•起始条件：SCL高电平期间，SDA从高电平切换到低电平</p><p>•终止条件：SCL高电平期间，SDA从低电平切换到高电平</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185442981.png" alt="image-20230915185442981"></p><p>•发送一个字节：SCL低电平期间，主机将数据位依次放到SDA线上（高位先行），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185512193.png" alt="image-20230915185512193"></p><p>•接收一个字节：SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185527631.png" alt="image-20230915185527631"></p><p>•发送应答：主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</p><p>•接收应答：主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185546127.png" alt="image-20230915185546127"></p><h5 id="波形图"><a href="#波形图" class="headerlink" title="波形图"></a>波形图</h5><p> 指定地址写</p><p>•对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185635827.png" alt="image-20230915185635827"></p><p>•当前地址读</p><p>•对于指定设备（Slave Address），在当前地址指针指示的地址下，读取从机数据（Data）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185809384.png" alt="image-20230915185809384"></p><p>•指定地址读</p><p>•对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185818982.png" alt="image-20230915185818982"></p><h4 id="MPU6050"><a href="#MPU6050" class="headerlink" title="MPU6050"></a>MPU6050</h4><h5 id="MPU6050简介"><a href="#MPU6050简介" class="headerlink" title="MPU6050简介"></a>MPU6050简介</h5><p>•MPU6050是一个6轴姿态传感器，可以测量芯片自身X、Y、Z轴的加速度、角速度参数，通过数据融合，可进一步得到姿态角，常应用于平衡车、飞行器等需要检测自身姿态的场景</p><p>•3轴加速度计（Accelerometer）：测量X、Y、Z轴的加速度</p><p>3轴陀螺仪传感器（Gyroscope）：测量X、Y、Z轴的角速度</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915185905869.png" alt="image-20230915185905869"></p><p>MPU6050参数</p><p>•16位ADC采集传感器的模拟信号，量化范围：-32768~32767</p><p>•加速度计满量程选择：±2、±4、±8、±16（g）</p><p>•陀螺仪满量程选择： ±250、±500、±1000、±2000（°/sec）</p><p>•可配置的数字低通滤波器</p><p>•可配置的时钟源</p><p>•可配置的采样分频</p><p>•I2C从机地址：1101000（AD0=0）</p><p>​                         1101001（AD0=1）</p><h5 id="硬件电路-11"><a href="#硬件电路-11" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190000879.png" alt="image-20230915190000879"></p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>引脚</strong></th><th style="text-align:center"><strong>功能</strong></th></tr></thead><tbody><tr><td style="text-align:center">VCC、GND</td><td style="text-align:center">电源</td></tr><tr><td style="text-align:center">SCL、SDA</td><td style="text-align:center">I2C通信引脚</td></tr><tr><td style="text-align:center">XCL、XDA</td><td style="text-align:center">主机I2C通信引脚</td></tr><tr><td style="text-align:center">AD0</td><td style="text-align:center">从机地址最低位</td></tr><tr><td style="text-align:center">INT</td><td style="text-align:center">中断信号输出</td></tr></tbody></table></div><h5 id="框图-2"><a href="#框图-2" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190034148.png" alt="image-20230915190034148"></p><h4 id="I2C外设简介"><a href="#I2C外设简介" class="headerlink" title="I2C外设简介"></a>I2C外设简介</h4><p>•STM32内部集成了硬件I2C收发电路，可以由硬件自动执行时钟生成、起始终止条件生成、应答位收发、数据收发等功能，减轻CPU的负担</p><p>•支持多主机模型</p><p>•支持7位/10位地址模式</p><p>•支持不同的通讯速度，标准速度(高达100 kHz)，快速(高达400 kHz)</p><p>•支持DMA</p><p>•兼容SMBus协议</p><p>•STM32F103C8T6 硬件I2C资源：I2C1、I2C2</p><h5 id="框图-3"><a href="#框图-3" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190153604.png" alt="image-20230915190153604"></p><h5 id="I2C基本结构"><a href="#I2C基本结构" class="headerlink" title="I2C基本结构"></a>I2C基本结构</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190219412.png" alt="image-20230915190219412"></p><h5 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h5><p>主机发送</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190341187.png" alt="image-20230915190341187"></p><p>主机接收</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190458034.png" alt="image-20230915190458034"></p><h4 id="软件-硬件波形对"><a href="#软件-硬件波形对" class="headerlink" title="软件/硬件波形对"></a>软件/硬件波形对</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190528763.png" alt="image-20230915190528763"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190532312.png" alt="image-20230915190532312"></p><h4 id="硬件电路-12"><a href="#硬件电路-12" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230915190643610.png" alt="image-20230915190643610"></p><h4 id="软件代码-9"><a href="#软件代码-9" class="headerlink" title="软件代码"></a>软件代码</h4><p>MPU6050_REG.H</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __MPU6050_REG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MPU6050_REG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_SMPLRT_DIV0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_CONFIG0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_CONFIG0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_CONFIG0x1C</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_H0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_XOUT_L0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_H0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_YOUT_L0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_H0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_ACCEL_ZOUT_L0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_H0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_TEMP_OUT_L0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_H0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_XOUT_L0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_H0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_YOUT_L0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_H0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_GYRO_ZOUT_L0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_10x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_PWR_MGMT_20x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>MPU6050_WHO_AM_I0x75</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 软件I2C读写MPU6050</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">MyI2C.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue);</span><br><span class="line">Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue);</span><br><span class="line">Delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> BitValue;</span><br><span class="line">BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11);</span><br><span class="line">Delay_us(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> BitValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SDA(<span class="number">0</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i, Byte = <span class="number">0x00</span>;</span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (MyI2C_R_SDA() == <span class="number">1</span>)&#123;Byte |= (<span class="number">0x80</span> &gt;&gt; i);&#125;</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Byte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_W_SDA(AckBit);</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> AckBit;</span><br><span class="line">MyI2C_W_SDA(<span class="number">1</span>);</span><br><span class="line">MyI2C_W_SCL(<span class="number">1</span>);</span><br><span class="line">AckBit = MyI2C_R_SDA();</span><br><span class="line">MyI2C_W_SCL(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> AckBit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MPU6050.c</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS0xD0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Start();</span><br><span class="line">MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">MyI2C_SendByte(Data);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">MyI2C_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">MyI2C_SendByte(MPU6050_ADDRESS);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">MyI2C_SendByte(RegAddress);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line"></span><br><span class="line">MyI2C_Start();</span><br><span class="line">MyI2C_SendByte(MPU6050_ADDRESS | <span class="number">0x01</span>);</span><br><span class="line">MyI2C_ReceiveAck();</span><br><span class="line">Data = MyI2C_ReceiveByte();</span><br><span class="line">MyI2C_SendAck(<span class="number">1</span>);</span><br><span class="line">MyI2C_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MyI2C_Init();</span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG, <span class="number">0x06</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ, </span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> DataH, DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    <span class="type">uint8_t</span> ID;</span><br><span class="line"><span class="type">int16_t</span> AX, AY, AZ, GX, GY, GZ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ID:&quot;</span>);</span><br><span class="line">ID = MPU6050_GetID();</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">4</span>, ID, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPU6050_GetData(&amp;AX, &amp;AY, &amp;AZ, &amp;GX, &amp;GY, &amp;GZ);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, AX, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">1</span>, AY, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">1</span>, AZ, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">8</span>, GX, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">8</span>, GY, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">8</span>, GZ, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>硬件I2C读写MPU6050</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">MPU6050.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MPU6050_Reg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MPU6050_ADDRESS0xD0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WaitEvent</span><span class="params">(I2C_TypeDef* I2Cx, <span class="type">uint32_t</span> I2C_EVENT)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">Timeout = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> (I2C_CheckEvent(I2Cx, I2C_EVENT) != SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">Timeout --;</span><br><span class="line"><span class="keyword">if</span> (Timeout == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_WriteReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress, <span class="type">uint8_t</span> Data)</span></span><br><span class="line">&#123;</span><br><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);</span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, RegAddress);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTING);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, Data);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);</span><br><span class="line"></span><br><span class="line">I2C_GenerateSTOP(I2C2, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_ReadReg</span><span class="params">(<span class="type">uint8_t</span> RegAddress)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> Data;</span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);</span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Transmitter);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED);</span><br><span class="line"></span><br><span class="line">I2C_SendData(I2C2, RegAddress);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED);</span><br><span class="line"></span><br><span class="line">I2C_GenerateSTART(I2C2, ENABLE);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT);</span><br><span class="line"></span><br><span class="line">I2C_Send7bitAddress(I2C2, MPU6050_ADDRESS, I2C_Direction_Receiver);</span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);</span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C2, DISABLE);</span><br><span class="line">I2C_GenerateSTOP(I2C2, ENABLE);</span><br><span class="line"></span><br><span class="line">MPU6050_WaitEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED);</span><br><span class="line">Data = I2C_ReceiveData(I2C2);</span><br><span class="line"></span><br><span class="line">I2C_AcknowledgeConfig(I2C2, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">I2C_InitTypeDef I2C_InitStructure;</span><br><span class="line">I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;</span><br><span class="line">I2C_InitStructure.I2C_ClockSpeed = <span class="number">50000</span>;</span><br><span class="line">I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;</span><br><span class="line">I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;</span><br><span class="line">I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;</span><br><span class="line">I2C_InitStructure.I2C_OwnAddress1 = <span class="number">0x00</span>;</span><br><span class="line">I2C_Init(I2C2, &amp;I2C_InitStructure);</span><br><span class="line"></span><br><span class="line">I2C_Cmd(I2C2, ENABLE);</span><br><span class="line"></span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_PWR_MGMT_2, <span class="number">0x00</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_SMPLRT_DIV, <span class="number">0x09</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_CONFIG, <span class="number">0x06</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_GYRO_CONFIG, <span class="number">0x18</span>);</span><br><span class="line">MPU6050_WriteReg(MPU6050_ACCEL_CONFIG, <span class="number">0x18</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MPU6050_GetID</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> MPU6050_ReadReg(MPU6050_WHO_AM_I);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MPU6050_GetData</span><span class="params">(<span class="type">int16_t</span> *AccX, <span class="type">int16_t</span> *AccY, <span class="type">int16_t</span> *AccZ, </span></span><br><span class="line"><span class="params"><span class="type">int16_t</span> *GyroX, <span class="type">int16_t</span> *GyroY, <span class="type">int16_t</span> *GyroZ)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> DataH, DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L);</span><br><span class="line">*AccX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L);</span><br><span class="line">*AccY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L);</span><br><span class="line">*AccZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L);</span><br><span class="line">*GyroX = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L);</span><br><span class="line">*GyroY = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line"></span><br><span class="line">DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H);</span><br><span class="line">DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L);</span><br><span class="line">*GyroZ = (DataH &lt;&lt; <span class="number">8</span>) | DataL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ID;</span><br><span class="line"><span class="type">int16_t</span> AX, AY, AZ, GX, GY, GZ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">MPU6050_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;ID:&quot;</span>);</span><br><span class="line">ID = MPU6050_GetID();</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">4</span>, ID, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPU6050_GetData(&amp;AX, &amp;AY, &amp;AZ, &amp;GX, &amp;GY, &amp;GZ);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">1</span>, AX, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">1</span>, AY, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">1</span>, AZ, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">2</span>, <span class="number">8</span>, GX, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">3</span>, <span class="number">8</span>, GY, <span class="number">5</span>);</span><br><span class="line">OLED_ShowSignedNum(<span class="number">4</span>, <span class="number">8</span>, GZ, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SPI-1"><a href="#SPI-1" class="headerlink" title="SPI"></a>SPI</h3><h4 id="SPI通信"><a href="#SPI通信" class="headerlink" title="SPI通信"></a>SPI通信</h4><p>•SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线</p><p>•四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）</p><p>•同步，全双工</p><p>支持总线挂载多设备（一主多从）</p><h5 id="硬件电路-13"><a href="#硬件电路-13" class="headerlink" title="硬件电路"></a>硬件电路</h5><p>•所有SPI设备的SCK、MOSI、MISO分别连在一起</p><p>•主机另外引出多条SS控制线，分别接到各从机的SS引脚</p><p>•输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131154278.png" alt="image-20230916131154278"></p><p>移位示意图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131318297.png" alt="image-20230916131318297"></p><h4 id="SPI时序基本单元"><a href="#SPI时序基本单元" class="headerlink" title="SPI时序基本单元"></a>SPI时序基本单元</h4><p>•起始条件：SS从高电平切换到低电平</p><p>•终止条件：SS从低电平切换到高电平</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131339072.png" alt="image-20230916131339072"></p><p>•交换一个字节（模式0）</p><p>•CPOL=0：空闲状态时，SCK为低电平</p><p>CPHA=0：SCK第一个边沿移入数据，第二个边沿移出数据</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131408347.png" alt="image-20230916131408347"></p><p>•交换一个字节（模式1）</p><p>•CPOL=0：空闲状态时，SCK为低电平</p><p>•CPHA=1：SCK第一个边沿移出数据，第二个边沿移入数据</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131427285.png" alt="image-20230916131427285"></p><p>•交换一个字节（模式2）</p><p>•CPOL=1：空闲状态时，SCK为高电平</p><p>CPHA=0：SCK第一个边沿移入数据，第二个边沿移出数据</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131445026.png" alt="image-20230916131445026"></p><p>•交换一个字节（模式3）</p><p>•CPOL=1：空闲状态时，SCK为高电平</p><p>•CPHA=1：SCK第一个边沿移出数据，第二个边沿移入数据</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131502615.png" alt="image-20230916131502615"></p><h5 id="波形图-1"><a href="#波形图-1" class="headerlink" title="波形图"></a>波形图</h5><p>•发送指令</p><p>•向SS指定的设备，发送指令（0x06）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131520533.png" alt="image-20230916131520533"></p><p>•指定地址写</p><p>•向SS指定的设备，发送写指令（0x02），</p><p>   随后在指定地址（Address[23:0]）下，写入指定数据（Data）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131603848.png" alt="image-20230916131603848"></p><p>•指定地址读</p><p>•向SS指定的设备，发送读指令（0x03），</p><p>   随后在指定地址（Address[23:0]）下，读取从机数据（Data）</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131614064.png" alt="image-20230916131614064"></p><h4 id="W25Q64"><a href="#W25Q64" class="headerlink" title="W25Q64"></a>W25Q64</h4><p>•W25Qxx系列是一种低成本、小型化、使用简单的非易失性存储器，常应用于数据存储、字库存储、固件程序存储等场景</p><p>•存储介质：Nor Flash（闪存）</p><p>•时钟频率：80MHz / 160MHz (Dual SPI) / 320MHz (Quad SPI)</p><p>•存储容量（24位地址）：</p><p> W25Q40：  4Mbit / 512KByte</p><p> W25Q80：  8Mbit / 1MByte</p><p> W25Q16：  16Mbit / 2MByte</p><p> W25Q32：  32Mbit / 4MByte</p><p> W25Q64：  64Mbit / 8MByte</p><p> W25Q128： 128Mbit / 16MByte</p><p> W25Q256： 256Mbit / 32MByte</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131646416.png" alt="image-20230916131646416"></p><h5 id="硬件电路-14"><a href="#硬件电路-14" class="headerlink" title="硬件电路"></a>硬件电路</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131704642.png" alt="image-20230916131704642"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131711167.png" alt="image-20230916131711167"></p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>引脚</strong></th><th style="text-align:center"><strong>功能</strong></th></tr></thead><tbody><tr><td style="text-align:center">VCC、GND</td><td style="text-align:center">电源（2.7~3.6V）</td></tr><tr><td style="text-align:center">CS（SS）</td><td style="text-align:center">SPI片选</td></tr><tr><td style="text-align:center">CLK（SCK）</td><td style="text-align:center">SPI时钟</td></tr><tr><td style="text-align:center">DI（MOSI）</td><td style="text-align:center">SPI主机输出从机输入</td></tr><tr><td style="text-align:center">DO（MISO）</td><td style="text-align:center">SPI主机输入从机输出</td></tr><tr><td style="text-align:center">WP</td><td style="text-align:center">写保护</td></tr><tr><td style="text-align:center">HOLD</td><td style="text-align:center">数据保持</td></tr></tbody></table></div><h5 id="框图-4"><a href="#框图-4" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916131853655.png" alt="image-20230916131853655"></p><p>Flash操作注意事项</p><p>写入操作时：</p><p>•写入操作前，必须先进行写使能</p><p>•每个数据位只能由1改写为0，不能由0改写为1</p><p>•写入数据前必须先擦除，擦除后，所有数据位变为1</p><p>•擦除必须按最小擦除单元进行</p><p>•连续写入多字节时，最多写入一页的数据，超过页尾位置的数据，会回到页首覆盖写入</p><p>•写入操作结束后，芯片进入忙状态，不响应新的读写操作</p><p>读取操作时：</p><p>•直接调用读取时序，无需使能，无需额外操作，没有页的限制，读取操作结束后不会进入忙状态，但不能在忙状态时读取</p><h4 id="SPI外设简介"><a href="#SPI外设简介" class="headerlink" title="SPI外设简介"></a>SPI外设简介</h4><p>•STM32内部集成了硬件SPI收发电路，可以由硬件自动执行时钟生成、数据收发等功能，减轻CPU的负担</p><p>•可配置8位/16位数据帧、高位先行/低位先行</p><p>•时钟频率： fPCLK / (2, 4, 8, 16, 32, 64, 128, 256)</p><p>•支持多主机模型、主或从操作</p><p>•可精简为半双工/单工通信</p><p>•支持DMA</p><p>•兼容I2S协议</p><p>•STM32F103C8T6 硬件SPI资源：SPI1、SPI2</p><h5 id="框图-5"><a href="#框图-5" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132114179.png" alt="image-20230916132114179"></p><p>SPI基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132155518.png" alt="image-20230916132155518"></p><p>主模式全双工连续传输</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132336207.png" alt="image-20230916132336207"></p><p>非连续传输</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132438364.png" alt="image-20230916132438364"></p><p>软件/硬件波形对比</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132543750.png" alt="image-20230916132543750"  /></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230916132459267.png" alt="image-20230916132459267"></p><h4 id="硬件电路-15"><a href="#硬件电路-15" class="headerlink" title="硬件电路"></a>硬件电路</h4><p>接线图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917114204978.png" alt="image-20230917114204978"></p><h4 id="软件代码-10"><a href="#软件代码-10" class="headerlink" title="软件代码"></a>软件代码</h4><p>W25Q64指令封装头文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __W25Q64_INS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __W25Q64_INS_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_ENABLE0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_DISABLE0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_10x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_STATUS_REGISTER_20x35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_WRITE_STATUS_REGISTER0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_PAGE_PROGRAM0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_QUAD_PAGE_PROGRAM0x32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_64KB0xD8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_BLOCK_ERASE_32KB0x52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_SECTOR_ERASE_4KB0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CHIP_ERASE0xC7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_SUSPEND0x75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_ERASE_RESUME0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_POWER_DOWN0xB9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_HIGH_PERFORMANCE_MODE0xA3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_CONTINUOUS_READ_MODE_RESET0xFF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_RELEASE_POWER_DOWN_HPM_DEVICE_ID0xAB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_MANUFACTURER_DEVICE_ID0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_UNIQUE_ID0x4B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_JEDEC_ID0x9F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_READ_DATA0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ0x0B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_OUTPUT0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_DUAL_IO0xBB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_OUTPUT0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_FAST_READ_QUAD_IO0xEB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_OCTAL_WORD_READ_QUAD_IO0xE3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> W25Q64_DUMMY_BYTE0xFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>软件SPI读写W25Q64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">SPI.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SCK</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_5, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_MOSI</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_7, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_R_MISO</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> i, ByteReceive = <span class="number">0x00</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_MOSI(ByteSend &amp; (<span class="number">0x80</span> &gt;&gt; i));</span><br><span class="line">MySPI_W_SCK(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (MySPI_R_MISO() == <span class="number">1</span>)&#123;ByteReceive |= (<span class="number">0x80</span> &gt;&gt; i);&#125;</span><br><span class="line">MySPI_W_SCK(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ByteReceive;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">W25Q64.c</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MySPI.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;W25Q64_Ins.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadID</span><span class="params">(<span class="type">uint8_t</span> *MID, <span class="type">uint16_t</span> *DID)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_JEDEC_ID);</span><br><span class="line">*MID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);</span><br><span class="line">*DID = MySPI_SwapByte(W25Q64_DUMMY_BYTE);</span><br><span class="line">*DID &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">*DID |= MySPI_SwapByte(W25Q64_DUMMY_BYTE);</span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WriteEnable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_WRITE_ENABLE);</span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> Timeout;</span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_READ_STATUS_REGISTER_1);</span><br><span class="line">Timeout = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> ((MySPI_SwapByte(W25Q64_DUMMY_BYTE) &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>)</span><br><span class="line">&#123;</span><br><span class="line">Timeout --;</span><br><span class="line"><span class="keyword">if</span> (Timeout == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageProgram</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint16_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> i;</span><br><span class="line"></span><br><span class="line">W25Q64_WriteEnable();</span><br><span class="line"></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_PAGE_PROGRAM);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">MySPI_SwapByte(Address);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i ++)</span><br><span class="line">&#123;</span><br><span class="line">MySPI_SwapByte(DataArray[i]);</span><br><span class="line">&#125;</span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_SectorErase</span><span class="params">(<span class="type">uint32_t</span> Address)</span></span><br><span class="line">&#123;</span><br><span class="line">W25Q64_WriteEnable();</span><br><span class="line"></span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_SECTOR_ERASE_4KB);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">MySPI_SwapByte(Address);</span><br><span class="line">MySPI_Stop();</span><br><span class="line"></span><br><span class="line">W25Q64_WaitBusy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_ReadData</span><span class="params">(<span class="type">uint32_t</span> Address, <span class="type">uint8_t</span> *DataArray, <span class="type">uint32_t</span> Count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> i;</span><br><span class="line">MySPI_Start();</span><br><span class="line">MySPI_SwapByte(W25Q64_READ_DATA);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">16</span>);</span><br><span class="line">MySPI_SwapByte(Address &gt;&gt; <span class="number">8</span>);</span><br><span class="line">MySPI_SwapByte(Address);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i ++)</span><br><span class="line">&#123;</span><br><span class="line">DataArray[i] = MySPI_SwapByte(W25Q64_DUMMY_BYTE);</span><br><span class="line">&#125;</span><br><span class="line">MySPI_Stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line"><span class="type">uint8_t</span> MID;</span><br><span class="line"><span class="type">uint16_t</span> DID;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> ArrayWrite[] = &#123;<span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> ArrayRead[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">W25Q64_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;MID:   DID:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;W:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;R:&quot;</span>);</span><br><span class="line"></span><br><span class="line">W25Q64_ReadID(&amp;MID, &amp;DID);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">5</span>, MID, <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">12</span>, DID, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">W25Q64_SectorErase(<span class="number">0x000000</span>);</span><br><span class="line">W25Q64_PageProgram(<span class="number">0x000000</span>, ArrayWrite, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">W25Q64_ReadData(<span class="number">0x000000</span>, ArrayRead, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">3</span>, ArrayWrite[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">6</span>, ArrayWrite[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">9</span>, ArrayWrite[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">12</span>, ArrayWrite[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">3</span>, ArrayRead[<span class="number">0</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">6</span>, ArrayRead[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">9</span>, ArrayRead[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">3</span>, <span class="number">12</span>, ArrayRead[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>硬件SPI读写W25Q64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">SPI.c</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_W_SS</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">GPIO_WriteBit(GPIOA, GPIO_Pin_4, (BitAction)BitValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);</span><br><span class="line"></span><br><span class="line">GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;</span><br><span class="line">GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;</span><br><span class="line">GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line"></span><br><span class="line">SPI_InitTypeDef SPI_InitStructure;</span><br><span class="line">SPI_InitStructure.SPI_Mode = SPI_Mode_Master;</span><br><span class="line">SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;</span><br><span class="line">SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;</span><br><span class="line">SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;</span><br><span class="line">SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;</span><br><span class="line">SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;</span><br><span class="line">SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;</span><br><span class="line">SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line"></span><br><span class="line">SPI_Cmd(SPI1, ENABLE);</span><br><span class="line"></span><br><span class="line">MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MySPI_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">MySPI_W_SS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MySPI_SwapByte</span><span class="params">(<span class="type">uint8_t</span> ByteSend)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET);</span><br><span class="line"></span><br><span class="line">SPI_I2S_SendData(SPI1, ByteSend);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RTC实时时钟"><a href="#RTC实时时钟" class="headerlink" title="RTC实时时钟"></a>RTC实时时钟</h3><h4 id="Unix时间戳"><a href="#Unix时间戳" class="headerlink" title="Unix时间戳"></a>Unix时间戳</h4><p> •Unix 时间戳（Unix Timestamp）定义为从UTC/GMT的1970年1月1日0时0分0秒开始所经过的秒数，不考虑闰秒</p><p>•时间戳存储在一个秒计数器中，秒计数器为32位/64位的整型变量</p><p>•世界上所有时区的秒计数器相同，不同时区通过添加偏移来得到当地时间</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151025089.png" alt="image-20230917151025089"></p><p>UTC/GMT</p><p>•GMT（Greenwich Mean Time）格林尼治标准时间是一种以地球自转为基础的时间计量系统。它将地球自转一周的时间间隔等分为24小时，以此确定计时标准</p><p>•UTC（Universal Time Coordinated）协调世界时是一种以原子钟为基础的时间计量系统。它规定铯133原子基态的两个超精细能级间在零磁场下跃迁辐射9,192,631,770周所持续的时间为1秒。当原子钟计时一天的时间与地球自转一周的时间相差超过0.9秒时，UTC会执行闰秒来保证其计时与地球自转的协调一致</p><h5 id="时间戳转换"><a href="#时间戳转换" class="headerlink" title="时间戳转换"></a>时间戳转换</h5><p>•C语言的time.h模块提供了时间获取和时间戳转换的相关函数，可以方便地进行秒计数器、日期时间和字符串之间的转换</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>函数</strong></th><th style="text-align:center"><strong>作用</strong></th></tr></thead><tbody><tr><td style="text-align:center">time_t time(time_t*);</td><td style="text-align:center">获取系统时钟</td></tr><tr><td style="text-align:center">struct tm<em> gmtime(const time_t</em>);</td><td style="text-align:center">秒计数器转换为日期时间（格林尼治时间）</td></tr><tr><td style="text-align:center">struct tm<em> localtime(const time_t</em>);</td><td style="text-align:center">秒计数器转换为日期时间（当地时间）</td></tr><tr><td style="text-align:center">time_t mktime(struct tm*);</td><td style="text-align:center">日期时间转换为秒计数器（当地时间）</td></tr><tr><td style="text-align:center">char<em> ctime(const time_t</em>);</td><td style="text-align:center">秒计数器转换为字符串（默认格式）</td></tr><tr><td style="text-align:center">char<em> asctime(const struct tm</em>);</td><td style="text-align:center">日期时间转换为字符串（默认格式）</td></tr><tr><td style="text-align:center">size_t strftime(char<em>, size_t, const  char</em>, const struct tm*);</td><td style="text-align:center">日期时间转换为字符串（自定义格式）</td></tr></tbody></table></div><h5 id="时间戳转换-1"><a href="#时间戳转换-1" class="headerlink" title="时间戳转换"></a>时间戳转换</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151202743.png" alt="image-20230917151202743"></p><h4 id="BKP简介"><a href="#BKP简介" class="headerlink" title="BKP简介"></a>BKP简介</h4><p>•BKP（Backup Registers）备份寄存器</p><p>•BKP可用于存储用户应用程序数据。当VDD（2.0 ~ 3.6V）电源被切断，他们仍然由VBAT（1.8 ~ 3.6V）维持供电。当系统在待机模式下被唤醒，或系统复位或电源复位时，他们也不会被复位</p><p>•TAMPER引脚产生的侵入事件将所有备份寄存器内容清除</p><p>•RTC引脚输出RTC校准时钟、RTC闹钟脉冲或者秒脉冲</p><p>•存储RTC时钟校准寄存器</p><p>•用户数据存储容量：</p><p> 20字节（中容量和小容量）/ 84字节（大容量和互联型）</p><p>BKP基本结构</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151249848.png" alt="image-20230917151249848"></p><h4 id="RTC简介"><a href="#RTC简介" class="headerlink" title="RTC简介"></a>RTC简介</h4><p>•RTC（Real Time Clock）实时时钟</p><p>•RTC是一个独立的定时器，可为系统提供时钟和日历的功能</p><p>•RTC和时钟配置系统处于后备区域，系统复位时数据不清零，VDD（2.0 ~ 3.6V）断电后可借助VBAT（1.8 ~ 3.6V）供电继续走时</p><p>•32位的可编程计数器，可对应Unix时间戳的秒计数器</p><p>•20位的可编程预分频器，可适配不同频率的输入时钟</p><p>•可选择三种RTC时钟源：</p><p> HSE时钟除以128（通常为8MHz/128）</p><p> LSE振荡器时钟（通常为32.768KHz）</p><p> LSI振荡器时钟（40KHz）</p><h5 id="框图-6"><a href="#框图-6" class="headerlink" title="框图"></a>框图</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151326627.png" alt="image-20230917151326627"></p><h5 id="RTC基本结构"><a href="#RTC基本结构" class="headerlink" title="RTC基本结构"></a>RTC基本结构</h5><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151355425.png" alt="image-20230917151355425"></p><h5 id="RTC操作注意事项"><a href="#RTC操作注意事项" class="headerlink" title="RTC操作注意事项"></a>RTC操作注意事项</h5><p>•执行以下操作将使能对BKP和RTC的访问：</p><p> 设置RCC_APB1ENR的PWREN和BKPEN，使能PWR和BKP时钟</p><p> 设置PWR_CR的DBP，使能对BKP和RTC的访问</p><p>•若在读取RTC寄存器时，RTC的APB1接口曾经处于禁止状态，则软件首先必须等待RTC_CRL寄存器中的RSF位（寄存器同步标志）被硬件置1</p><p>•必须设置RTC_CRL寄存器中的CNF位，使RTC进入配置模式后，才能写入RTC_PRL、RTC_CNT、RTC_ALR寄存器</p><p>•对RTC任何寄存器的写操作，都必须在前一次写操作结束后进行。可以通过查询RTC_CR寄存器中的RTOFF状态位，判断RTC寄存器是否处于更新中。仅当RTOFF状态位是1时，才可以写入RTC寄存器</p><h4 id="硬件电路-16"><a href="#硬件电路-16" class="headerlink" title="硬件电路"></a>硬件电路</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151455312.png" alt="image-20230917151455312"></p><p>纽扣电池</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151510419.png" alt="image-20230917151510419"></p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917151515952.png" alt="image-20230917151515952"></p><p>接线图</p><p>BKP读写备份寄存器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917162914333.png" alt="image-20230917162914333"></p><p>实时时钟</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230917163030334.png" alt="image-20230917163030334"></p><h4 id="软件代码-11"><a href="#软件代码-11" class="headerlink" title="软件代码"></a>软件代码</h4><p>BKP读写备份寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Key.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> KeyNum;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> ArrayWrite[] = &#123;<span class="number">0x1234</span>, <span class="number">0x5678</span>&#125;;</span><br><span class="line"><span class="type">uint16_t</span> ArrayRead[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">Key_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;W:&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;R:&quot;</span>);</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line"></span><br><span class="line">PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">KeyNum = Key_GetNum();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (KeyNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ArrayWrite[<span class="number">0</span>] ++;</span><br><span class="line">ArrayWrite[<span class="number">1</span>] ++;</span><br><span class="line"></span><br><span class="line">BKP_WriteBackupRegister(BKP_DR1, ArrayWrite[<span class="number">0</span>]);</span><br><span class="line">BKP_WriteBackupRegister(BKP_DR2, ArrayWrite[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">3</span>, ArrayWrite[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, ArrayWrite[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayRead[<span class="number">0</span>] = BKP_ReadBackupRegister(BKP_DR1);</span><br><span class="line">ArrayRead[<span class="number">1</span>] = BKP_ReadBackupRegister(BKP_DR2);</span><br><span class="line"></span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">3</span>, ArrayRead[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowHexNum(<span class="number">2</span>, <span class="number">8</span>, ArrayRead[<span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RTC实时时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">MyRTC.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> MyRTC_Time[] = &#123;<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span><br><span class="line"></span><br><span class="line">PWR_BackupAccessCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BKP_ReadBackupRegister(BKP_DR1) != <span class="number">0xA5A5</span>)  <span class="comment">//随便写入一个数值当标志位</span></span><br><span class="line">&#123;</span><br><span class="line">RCC_LSEConfig(RCC_LSE_ON);</span><br><span class="line"><span class="keyword">while</span> (RCC_GetFlagStatus(RCC_FLAG_LSERDY) != SET);</span><br><span class="line"></span><br><span class="line">RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);</span><br><span class="line">RCC_RTCCLKCmd(ENABLE);</span><br><span class="line"></span><br><span class="line">RTC_WaitForSynchro();</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"></span><br><span class="line">RTC_SetPrescaler(<span class="number">32768</span> - <span class="number">1</span>);</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line"></span><br><span class="line">MyRTC_SetTime();</span><br><span class="line"></span><br><span class="line">BKP_WriteBackupRegister(BKP_DR1, <span class="number">0xA5A5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">RTC_WaitForSynchro();</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的板子用这个初始化没问题</span></span><br><span class="line"><span class="comment">//如果LSE无法起振导致程序卡死在初始化函数中</span></span><br><span class="line"><span class="comment">//可将初始化函数替换为下述代码，使用LSI当作RTCCLK</span></span><br><span class="line"><span class="comment">//LSI无法由备用电源供电，故主电源掉电时，RTC走时会暂停</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//void MyRTC_Init(void)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span></span><br><span class="line"><span class="comment">//RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP, ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//PWR_BackupAccessCmd(ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//RCC_LSICmd(ENABLE);</span></span><br><span class="line"><span class="comment">//while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span></span><br><span class="line"><span class="comment">//RCC_RTCCLKCmd(ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RTC_WaitForSynchro();</span></span><br><span class="line"><span class="comment">//RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RTC_SetPrescaler(40000 - 1);</span></span><br><span class="line"><span class="comment">//RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//MyRTC_SetTime();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//RCC_LSICmd(ENABLE);</span></span><br><span class="line"><span class="comment">//while (RCC_GetFlagStatus(RCC_FLAG_LSIRDY) != SET);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);</span></span><br><span class="line"><span class="comment">//RCC_RTCCLKCmd(ENABLE);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//RTC_WaitForSynchro();</span></span><br><span class="line"><span class="comment">//RTC_WaitForLastTask();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_SetTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"></span><br><span class="line">time_date.tm_year = MyRTC_Time[<span class="number">0</span>] - <span class="number">1900</span>;</span><br><span class="line">time_date.tm_mon = MyRTC_Time[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">time_date.tm_mday = MyRTC_Time[<span class="number">2</span>];</span><br><span class="line">time_date.tm_hour = MyRTC_Time[<span class="number">3</span>];</span><br><span class="line">time_date.tm_min = MyRTC_Time[<span class="number">4</span>];</span><br><span class="line">time_date.tm_sec = MyRTC_Time[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">time_cnt = mktime(&amp;time_date) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">RTC_SetCounter(time_cnt);</span><br><span class="line">RTC_WaitForLastTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyRTC_ReadTime</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">time_t</span> time_cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_date</span>;</span></span><br><span class="line"></span><br><span class="line">time_cnt = RTC_GetCounter() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">time_date = *localtime(&amp;time_cnt);</span><br><span class="line"></span><br><span class="line">MyRTC_Time[<span class="number">0</span>] = time_date.tm_year + <span class="number">1900</span>;</span><br><span class="line">MyRTC_Time[<span class="number">1</span>] = time_date.tm_mon + <span class="number">1</span>;</span><br><span class="line">MyRTC_Time[<span class="number">2</span>] = time_date.tm_mday;</span><br><span class="line">MyRTC_Time[<span class="number">3</span>] = time_date.tm_hour;</span><br><span class="line">MyRTC_Time[<span class="number">4</span>] = time_date.tm_min;</span><br><span class="line">MyRTC_Time[<span class="number">5</span>] = time_date.tm_sec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main.c</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">MyRTC_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Date:XXXX-XX-XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Time:XX:XX:XX&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;DIV :&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MyRTC_ReadTime();</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">0</span>], <span class="number">4</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">11</span>, MyRTC_Time[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">14</span>, MyRTC_Time[<span class="number">2</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, MyRTC_Time[<span class="number">3</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">9</span>, MyRTC_Time[<span class="number">4</span>], <span class="number">2</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">12</span>, MyRTC_Time[<span class="number">5</span>], <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">4</span>, <span class="number">6</span>, RTC_GetDivider(), <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里出来的效果有点bug，不太清楚是什么问题</p><p>我的板子用注释的那个初始化效果是没问题的，不用那个的话板子就会出问题</p><p>板子放平的时候自增一次需要5 6秒，要把板子拿起来放斜或者架起来效果才正常，就是板子的引脚不能碰到东西不然时间就会自增的很慢，接触不良</p><h3 id="PWR电源"><a href="#PWR电源" class="headerlink" title="PWR电源"></a>PWR电源</h3><h4 id="PWR简介"><a href="#PWR简介" class="headerlink" title="PWR简介"></a>PWR简介</h4><p>•PWR（Power Control）电源控制</p><p>•PWR负责管理STM32内部的电源供电部分，可以实现可编程电压监测器和低功耗模式的功能</p><p>•可编程电压监测器（PVD）可以监控VDD电源电压，当VDD下降到PVD阀值以下或上升到PVD阀值之上时，PVD会触发中断，用于执行紧急关闭任务</p><p>•低功耗模式包括睡眠模式（Sleep）、停机模式（Stop）和待机模式（Standby），可在系统空闲时，降低STM32的功耗，<strong>延长设备使用时间</strong></p><h4 id="框图-7"><a href="#框图-7" class="headerlink" title="框图"></a>框图</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918125052530.png" alt="image-20230918125052530"></p><p>上电复位和掉电复位</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918125140553.png" alt="image-20230918125140553"></p><p>可编程电压监测器</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918125244282.png" alt="image-20230918125244282"></p><h4 id="低功耗模式"><a href="#低功耗模式" class="headerlink" title="低功耗模式"></a>低功耗模式</h4><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918125328931.png" alt="image-20230918125328931"></p><h5 id="模式选择"><a href="#模式选择" class="headerlink" title="模式选择"></a>模式选择</h5><p>•执行WFI（Wait For Interrupt）或者WFE（Wait For Event）指令后，STM32进入低功耗模式</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918125402197.png" alt="image-20230918125402197"></p><h5 id="睡眠模式"><a href="#睡眠模式" class="headerlink" title="睡眠模式"></a>睡眠模式</h5><p>•执行完WFI/WFE指令后，STM32进入睡眠模式，程序暂停运行，唤醒后程序从暂停的地方继续运行</p><p>•SLEEPONEXIT位决定STM32执行完WFI或WFE后，是立刻进入睡眠，还是等STM32从最低优先级的中断处理程序中退出时进入睡眠</p><p>•在睡眠模式下，所有的I/O引脚都保持它们在运行模式时的状态</p><p>•WFI指令进入睡眠模式，可被任意一个NVIC响应的中断唤醒</p><p>•WFE指令进入睡眠模式，可被唤醒事件唤醒</p><h5 id="停止模式"><a href="#停止模式" class="headerlink" title="停止模式"></a>停止模式</h5><p>•执行完WFI/WFE指令后，STM32进入停止模式，程序暂停运行，唤醒后程序从暂停的地方继续运行</p><p>•1.8V供电区域的所有时钟都被停止，PLL、HSI和HSE被禁止，SRAM和寄存器内容被保留下来</p><p>•在停止模式下，所有的I/O引脚都保持它们在运行模式时的状态</p><p>•当一个中断或唤醒事件导致退出停止模式时，HSI被选为系统时钟</p><p>•当电压调节器处于低功耗模式下，系统从停止模式退出时，会有一段额外的启动延时</p><p>•WFI指令进入停止模式，可被任意一个EXTI中断唤醒</p><p>WFE指令进入停止模式，可被任意一个EXTI事件唤醒</p><h5 id="待机模式"><a href="#待机模式" class="headerlink" title="待机模式"></a>待机模式</h5><p>•执行完WFI/WFE指令后，STM32进入待机模式，唤醒后程序从头开始运行</p><p>•整个1.8V供电区域被断电，PLL、HSI和HSE也被断电，SRAM和寄存器内容丢失，只有备份的寄存器和待机电路维持供电</p><p>•在待机模式下，所有的I/O引脚变为高阻态（浮空输入）</p><p>•WKUP引脚的上升沿、RTC闹钟事件的上升沿、NRST引脚上外部复位、IWDG复位退出待机模式</p><h4 id="硬件电路-17"><a href="#硬件电路-17" class="headerlink" title="硬件电路"></a>硬件电路</h4><p> 修改主频</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918143136670.png" alt="image-20230918143136670"></p><p> 睡眠模式+串口发送+接收</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918143147203.png" alt="image-20230918143147203"></p><p> 停止模式+对射式红外传感器计次</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918143153915.png" alt="image-20230918143153915"></p><p>待机模式+实时时钟</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918143200038.png" alt="image-20230918143200038"></p><h4 id="软件代码-12"><a href="#软件代码-12" class="headerlink" title="软件代码"></a>软件代码</h4><p>注：在低功耗模式下载程序时，需按复位键下载，按着复位键点击下载，然后松开。</p><p> 修改主频</p><p>在system_stm32f10x.c，取消注释即可更换选择主频，需要注意更换主频后，有很多涉及计时的计算都要重新匹配，比如我用delay（1000)在72m主频下是一秒，但是改成36m就是两秒。</p><p>无特别需求，不建议随便修改主频</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918143502813.png" alt="image-20230918143502813"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;SYSCLK:&quot;</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">8</span>, SystemCoreClock, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 睡眠模式+串口发送+接收</p><p>其他代码参考串口发送+接受</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> RxData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;RxData:&quot;</span>);</span><br><span class="line"></span><br><span class="line">Serial_Init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Serial_GetRxFlag() == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">RxData = Serial_GetRxData();</span><br><span class="line">Serial_SendByte(RxData);</span><br><span class="line">OLED_ShowHexNum(<span class="number">1</span>, <span class="number">8</span>, RxData, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">__WFI(); <span class="comment">//低功耗待机模式，中断唤醒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 停止模式+对射式红外传感器计次</p><p>其他代码参考对射式红外传感器计次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CountSensor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">CountSensor_Init();</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Count:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">7</span>, CountSensor_Get(), <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">PWR_EnterSTOPMode(PWR_Regulator_ON, PWR_STOPEntry_WFI); <span class="comment">//进入停止模式</span></span><br><span class="line">SystemInit();  <span class="comment">//从停止模式唤醒后重新初始化系统，以保证正常运行</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>待机模式+实时时钟</p><p>其他代码参考实时时钟</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>                  <span class="comment">// Device header</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OLED.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyRTC.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">OLED_Init();</span><br><span class="line">MyRTC_Init();</span><br><span class="line"></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;CNT :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;ALR :&quot;</span>);</span><br><span class="line">OLED_ShowString(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;ALRF:&quot;</span>);</span><br><span class="line"></span><br><span class="line">PWR_WakeUpPinCmd(ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> Alarm = RTC_GetCounter() + <span class="number">10</span>;</span><br><span class="line">RTC_SetAlarm(Alarm);</span><br><span class="line">OLED_ShowNum(<span class="number">2</span>, <span class="number">6</span>, Alarm, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">OLED_ShowNum(<span class="number">1</span>, <span class="number">6</span>, RTC_GetCounter(), <span class="number">10</span>);</span><br><span class="line">OLED_ShowNum(<span class="number">3</span>, <span class="number">6</span>, RTC_GetFlagStatus(RTC_FLAG_ALR), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;Running&quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">1</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;STANDBY&quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">1000</span>);</span><br><span class="line">OLED_ShowString(<span class="number">4</span>, <span class="number">9</span>, <span class="string">&quot;       &quot;</span>);</span><br><span class="line">Delay_ms(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">OLED_Clear();</span><br><span class="line"></span><br><span class="line">PWR_EnterSTANDBYMode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="看门狗"><a href="#看门狗" class="headerlink" title="看门狗"></a>看门狗</h3><h4 id="WDG简介"><a href="#WDG简介" class="headerlink" title="WDG简介"></a>WDG简介</h4><p>•WDG（Watchdog）看门狗</p><p>•看门狗可以监控程序的运行状态，当程序因为设计漏洞、硬件故障、电磁干扰等原因，出现卡死或跑飞现象时，看门狗能及时复位程序，避免程序陷入长时间的罢工状态，保证系统的可靠性和安全性</p><p>•看门狗本质上是一个定时器，当指定时间范围内，程序没有执行喂狗（重置计数器）操作时，看门狗硬件电路就自动产生复位信号</p><p>•STM32内置两个看门狗</p><p> 独立看门狗（IWDG）：独立工作，对时间精度要求较低</p><p> 窗口看门狗（WWDG）：要求看门狗在精确计时窗口起作用</p><h4 id="IWDG"><a href="#IWDG" class="headerlink" title="IWDG"></a>IWDG</h4><p>框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918151013317.png" alt="image-20230918151013317"></p><p> IWDG键寄存器</p><p>•键寄存器本质上是控制寄存器，用于控制硬件电路的工作</p><p>•在可能存在干扰的情况下，一般通过在整个键寄存器写入特定值来代替控制寄存器写入一位的功能，以降低硬件电路受到干扰的概率</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>写入键寄存器的值</strong></th><th style="text-align:center"><strong>作用</strong></th></tr></thead><tbody><tr><td style="text-align:center">0xCCCC</td><td style="text-align:center">启用独立看门狗</td></tr><tr><td style="text-align:center">0xAAAA</td><td style="text-align:center">IWDG_RLR中的值重新加载到计数器（喂狗）</td></tr><tr><td style="text-align:center">0x5555</td><td style="text-align:center">解除IWDG_PR和IWDG_RLR的写保护</td></tr><tr><td style="text-align:center">0x5555之外的其他值</td><td style="text-align:center">启用IWDG_PR和IWDG_RLR的写保护</td></tr></tbody></table></div><p>IWDG超时时间</p><p>•超时时间：TIWDG = TLSI × PR预分频系数 × (RL + 1)</p><p>•其中：TLSI = 1 / FLSI</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918152932856.png" alt="image-20230918152932856"></p><h4 id="WWDG"><a href="#WWDG" class="headerlink" title="WWDG"></a>WWDG</h4><p>WWDG框图</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918153055739.png" alt="image-20230918153055739"></p><p>WWDG工作特性</p><p>•递减计数器T[6:0]的值小于0x40时，WWDG产生复位</p><p>•递减计数器T[6:0]在窗口W[6:0]外被重新装载时，WWDG产生复位</p><p>•递减计数器T[6:0]等于0x40时可以产生早期唤醒中断（EWI），用于重装载计数器以避免WWDG复位</p><p>定期写入WWDG_CR寄存器（喂狗）以避免WWDG复位</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918153204982.png" alt="image-20230918153204982"></p><p>WWDG超时时间</p><p>•超时时间：</p><p> TWWDG = TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] + 1)</p><p>•窗口时间：</p><p> TWIN = TPCLK1 × 4096 × WDGTB预分频系数 × (T[5:0] - W[5:0])</p><p>•其中：TPCLK1 = 1 / FPCLK1</p><p><img src="C:\Users\Y\AppData\Roaming\Typora\typora-user-images\image-20230918153233972.png" alt="image-20230918153233972"></p><h4 id="IWDG和WWDG对比"><a href="#IWDG和WWDG对比" class="headerlink" title="IWDG和WWDG对比"></a>IWDG和WWDG对比</h4><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">IWDG 独立看门狗</th><th style="text-align:center">WWDG 窗口看门狗</th></tr></thead><tbody><tr><td style="text-align:center">复位</td><td style="text-align:center">计数器减到0后</td><td style="text-align:center">计数器T[5:0]减到0后、过早重装计数器</td></tr><tr><td style="text-align:center">中断</td><td style="text-align:center">无</td><td style="text-align:center">早期唤醒中断</td></tr><tr><td style="text-align:center">时钟源</td><td style="text-align:center">LSI（40KHz）</td><td style="text-align:center">PCLK1（36MHz）</td></tr><tr><td style="text-align:center">预分频系数</td><td style="text-align:center">4、8、32、64、128、256</td><td style="text-align:center">1、2、4、8</td></tr><tr><td style="text-align:center">计数器</td><td style="text-align:center">12位</td><td style="text-align:center">6位（有效计数）</td></tr><tr><td style="text-align:center">超时时间</td><td style="text-align:center">0.1ms~26214.4ms</td><td style="text-align:center">113us~58.25ms</td></tr><tr><td style="text-align:center">喂狗方式</td><td style="text-align:center">写入键寄存器，重装固定值RLR</td><td style="text-align:center">直接写入计数器，写多少重装多少</td></tr><tr><td style="text-align:center">防误操作</td><td style="text-align:center">键寄存器和写保护</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">用途</td><td style="text-align:center">独立工作，对时间精度要求较低</td><td style="text-align:center">要求看门狗在精确计时窗口起作用</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 32单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录生活</title>
      <link href="/2023/01/01/%E7%94%9F%E6%B4%BB/"/>
      <url>/2023/01/01/%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="不要窥探我的生活！" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="6390787c541eb243eae6f679b94e7272b7193813a04d484dfb6a3810c42be7d6">56a054dc49fc7e673947b6052b05be34a7165fbb9b69f84d5c4315b2e8581480db5e607ae42cef9f1abe6ca4a4371e02be1b986cd94a94d155e5cc2e2edd2e348c27decf10a425bc49b218831e77134d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">记录生活，需要密码才可以看</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 我的生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 私人领域 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
